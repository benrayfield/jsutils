<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Opensource/MIT. BellSack - Single-Pass All GPU: Billboard Circles + Knobs + Raymarch</title>
	<style>
	body {
		margin: 0; padding: 0; background: #222;
		display: flex;
		justify-content: center;
		align-items: center;
		font-family: sans-serif;
	}
	canvas {
		background: black;
	}
	</style>
<script>
const Lamgl = window.Lamgl = (() => {
	/* LamGL is opensource MIT by Ben F Rayfield, a GPU API that runs in browsers.
	It comes after TinyGLSL, upgrades to do calculations in GPU memory without copying to CPU. Stores tensors
	in WebGLTexture's. Call GPU as a single function Lamgl({...})=>{...}.
	https://github.com/benrayfield/jsutils/blob/master/src/lamgl/LamglFromBellsack077.js
	https://github.com/benrayfield/jsutils/blob/master/src/lamgl/Lamgl_028.html
	LamGL.js is like GPU.js but without the overhead of copying back to CPU. You can have pointers into GPU memory like in tensorflow.js, but with the generality of GPU.js, and more low level as you type or generate the GLSL code.
	
	Bellsack and Lamgl are NOT under the OpenAI license because that license grants
	nonexclusive copyright: "We hereby assign to you all our right, title, and interest,
	if any, in and to Output." Nonexclusive "We may use Content to". I can opt out of Services section.
	https://github.com/benrayfield/jsutils/blob/master/src/bellsack/NotUnderOpenAILicenseBecause_2025-7-10.png


	Have bell_5. TODO bell_13 with radius replaced by a mat3 (3x3 rotation) or radius_and_quaternion, which is enuf to make skatepark shapes with.
	Make that one of the "species". A fractal can be a species too.

	
	if u call Lamgl with the same sh/shape, sv vertex shader code string, and sf fragment shader code string, it will call the already JIT compiled GPU stuff from the first call of it. Its returning sometimes as fast as 1/10000 second.
	
	maybe I should make it take an optional WebGL2 as a param Lamgl=MakeLamgl(...hand it a WebGL2 from an existing canvas...);
	

	Opensource MIT by Ben F Rayfield. LamGL, open browser console. TODO hook in VarTree.html/VarTree.jsp
	which code to call LamGL will be in the tree (.big fields). All this together will remake BellSack and
	scale it up to 30 species near each area and swapping in/out species as you move around the massively
	multiplayer 3d world. LOOK IN BROWSER CONSOLE FOR "test pass" or errors.

	Avoid these bugs in WebGL2 GLSL ES 300:
	-- If you texelFetch the same address twice in the same GPU thread, you'll get all 0s.
	[This is a known bug-like behavior (especially on certain GPUs and drivers, notably Intel and some mobile chipsets), and it boils down to this: In WebGL2 / GLSL ES 300, if you call texelFetch() multiple times with the same coordinates and sampler in the same shader invocation — even if in different scopes — you may get all 0.0s as the result on the second+ calls. This isn't defined behavior by the spec, but it's a real-world GPU driver optimization bug.]--GPT.
	-- Some GLSL optimizers are buggy so u have to make sure some code happens like this sometimes:
		//*1.0000001 avoid returning all 0s, force it to to do some calculation
		//thats not from the textures, cuz the glsl optimizer is buggy.
		dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.0000001

	2025-5-4 did this just reach 1 teraflop/sec when turned off observed_testMatmulAC4?
	testMatmulAC4 secs=0.10042023658752441 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=2.6731211269955195 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.047499895095825195 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.651285238808727 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.04397988319396973 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=6.103596383284764 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.05035996437072754 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.330334509847906 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.049179792404174805 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.4582470335359305 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00036025047302246094 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=745.1356100877723 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002598762512207031 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1032.9356943510313 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00028014183044433594 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=958.2126866745737 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002799034118652344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=959.0288814673117 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00024008750915527344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1118.073393090987 observed_testMatmulAC4.length=undefined
	...
	something dont seem right here. maybe its just that im not refilling the input matrixs so it doesnt have to move them around GPU memory as much, but its saying 21 teraflops when i raised to multiplying 2 1024x1024 matrixs: secs=0.00009989738464355469 gigaflopPerSec=21496.89559604
		
	2025-5-4-950aET about doBasicTests matmul tests only[[
	Are you recompiling the shader every call?
	no
	let program = vm.cache('program'+cacheKeySuffix, function(){...
	lazyevals it once

	 Are you recreating textures or frameBuffers every call?
	I was but i just fixed that (see .free() in finally block in new code im not giving u yet) and its a little faster but still taking 40ms.

	Are you doing gl.readPixels() after every run?
	yes.its for testing but i guess i shouldnt do that in the speed test

	Are you uploading data from CPU to GPU every time?
	no. it stays in the 2 input textures/tensors.

	 Are you allocating a new canvas or GL context?
	no

	Are you doing unnecessary conversions (e.g., CPU reshape / flatten)?
	no, not in the loop, only before it, and those tests in the loop are still slow. I expect the first 1 to be slow but not those after it.

	Are you launching too many threads or using poor loop structure?
	TinyGLSL is fast even with a million GPU threads. im only using 512*512/4=64k gpu threads which should be ok.
	]]

	The shit i gotta do for pointer-arithmetic to write a GPU memory address with a vec4 value (i do have random-access swarming many vec4 sized particles: gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
	i can read alot faster than i can write in GPU. i read as much as the 3d cube volume of matrix multiplying 2 2d squares or any 3 lengths of a 3d rectangle of compute returning a 2d matrix. they're all tensors.
	cuz i dont gotta do that affine transform shit to read. only to write. to read i just texelFetch an ivec2, which can be generated in simple easy to optimize ways or loaded at runtime and i can jump pointer arithmetic n levels deep at each point depending on reading shared GPU mem.
	im gonna turn this into something like codeblocks in a massively multiplayer way, and i'm not giving up GPU flops for it but i am giving up some IO bandwidth between CPU vs GPU cuz of browser layers etc. But imagine u can call pure-functions on eachother in an ocean of builders. (but not codeblocks specificly im optimizing for DAG which has immutable forest of childs, like in wikibinator203's tree drag and drop).
	float32 (even with the +1 in first shader and -1 in last shader, to fix an optimizer bug built into the drivers or browser or hardware etc) can exactly do int25 and uint24, if ur careful not to overflow it, so u might need to multiply 2 int12s or something like that.
	
	Params of the Lamgl javascript function such as (bellPositions, camPos, horizon, etc). Those are not built in. Whatever code string goes in sv and sf (shaders) has some var names,
	and you pass tensors or float32arrays or numbers in the Lamgl call.
	When you pass tensors into Lamgl, that were returned by earlier calls of Lamgl (all immutable), that is pointers into GPU memory. It doesnt copy it back to CPU unless you tell it to, so its nearly as fast as native GPU code in some cases.
	Lamgl can do a few thousand sequential calls per second on a good gaming computer, so maybe you get 50 of them per video frame to build whatever you want. You can keep them around to use less often in sparse combos too. dont forget to free them.
	if u wanna double buffer, u can do so with each buffer state being immutable, using only 2 actual WebGLTexture's (Lamgl handles that, u dont gotta touch that low level detail) as long as you free the oldest of the 2 tensors then make its tensor replacement. same ptr into GPU.
	You read tensors by texelFetch or texture which is the only place WebGL is letting me store memory between GPU calls. You just expect the texture to be there if you write a variable for it in the shader code and give it as a param in Lamgl({...glVarName: tensorVal etc}). can mat4
	You have random-access to read all params including	blocks of GPU memory up to at least 16mB (some GL's have more). You read a vec4 (4 floats) at a (x,y) or i can make a function to take an int. You write up to 8 vec4s but only at 1 int/(x,y), 1 per output tensor.
	that is, you write up to 8 vec4's per GPU thread / gl_VertexID. That could potentially be millions of threads since WebGL is designed to run 1 GPU thread per pixel normally, and it can also do voxels and thats how u can random-access write but only 1 address written per thread.
	Lamgl was designed to use headless GL, no canvas in the dom tree. Canvas was added later by tensor.copyTo(canvasDomNode). Lamgl matrix multiplied before it could display pixels on screen. Its normal use is off screen, and whenever u want, pick any tensor and tensor.display().
	
	Among GPU APIs, its recommended: If WebGL falls, retreat to OpenCL.
	If OpenCL falls retreat to WebGPU. Join OpenCL to Tomcat by 1 JSP or servlet and my https://github.com/benrayfield/LazyCL at gaming-low-lag.
	*/
	const vm = function(){}; //Proxy of this (Lamgl) can only be called as function if this is a function
	//VM = vm;
	
	const Todo = vm.Todo = str => { throw new Error(str || 'TODO'); };
	const Err = vm.Err = str => { throw new Error(str || '(Err with no message)'); };

	vm.jsType = x => (ArrayBuffer.isView(x) ? x.constructor.name : typeof(x));

	vm.call = (param,optionalSh)=>{
		//console.log('Lamgl called.');
		//if(typeof(param) == 'object'){
		if(param.sv || param.sf){
			return vm.callGPU(param);
		}else{
			return vm.wrap(param,optionalSh);
		}
	};
	
	vm.callGPU = map=>{
		let gl = vm.Gl();
		let sv = map.sv || '//FIXME no sv'; //vertex shader code
		let sf = map.sf || '//FIXME no sf'; //fragment shader code
		//If sc is true (or 1) then output to Lamgl.glCanv instead of a frameBuffer, by giving null frameBuffer.
		//There is only 1 canvas a WebGL2 instance can output to efficiently, and thats the canvas it was created from.
		//This is normally only used in Lamgl.Tensor.copyTo(Lamgl.glCanv) which is called by Lamgl.Tensor.display().
		let sc = !!map.sc;
		
		if(opt.logShaderCodeEveryTime){
			console.log('sv='+sv);
			console.log('sf='+sf);
			console.log('sc='+sc);
		}
		
		let sh = map.sh; //[height, width, 4] or maybe [zSize, height, width, 4] etc
		/*
		//TODO zSize for 3d pics?
		let h = map.h; //height, unless map.n is a [] list like [height width 4] or [zSize height width 4] etc.
		let w = map.w; //width, unless that
		let q = map.q || 4; //floats per GPU thread (or maybe per texture?)
		let sh = map.sh || [h, w, q]; //shape of tensor
		//in case there is zSize or what should it be called?
		if(!h) h = sh[n.length-3];
		if(!w) w = sh[n.length-2];
		if(!q) w = sh[n.length-1];
		*/
		
		let cacheKeySuffix = '_SV['+sv+']_SF['+sf+']_SH['+vm.Str(sh)+']';
		
		let glvars = vm.glvars(map);
		if(opt.logGlvars && !opt.logGlvarsDetail) console.log('glvars=[[['+glvars.join('\n')+']]]');
		if(opt.logGlvarsDetail) console.log(
			'<<<\nmap.sf='+map.sf+'\nglvars=[[['+glvars.map(x=>(x+' ('+map[x.shaderType].substring(x.charPtrFrom,x.charPtrTo)+')')).join('\n')+']]]\n>>>');
		
		// ── geometry auto-detect: if shader declares “in vec2 XY;” draw a quad
		//const hasXYAttr = glvars.some(v=>(v.memType==='in' && v.name==='XY' && v.glType.startsWith('vec2')));
		//
		//If hasXYAttr, then do 2 triangles to fill height x width, else only use gl_VertexID (tho can use both),
		//and it will come in the usual gl screen coordinates of x and y each range -1 to 1.
		const hasXYAttr = glvars.some(v=>(v.memType=='in' && v.name=='XY' && v.glType=='vec2'));
		const has_gl_VertexID = sv.includes('gl_VertexID'); //FIXME parse it better like what if its "int not_gl_VertexID".
		//No, cant do this, cuz gl_VertexID is with TRIANGLES not POINTS so theres too few of them: Allow this 2025-7-13+ cuz of using XY and VarGradientGL at same time.
		if(hasXYAttr && has_gl_VertexID){
			Err('hasXYAttr && has_gl_VertexID, but if you do that youll only get the corners of the 2 triangles forming a rectangle, not the every pixel in that rectangle you were expecting, sv['+sv+']');
		}
		if(!hasXYAttr && !has_gl_VertexID){
			console.log('Youre probably just testing simple stuff in 1 GPU thread. !hasXYAttr && !has_gl_VertexID. You normally do one or the other. Add "in vec2 XY;" for 2 triangles covering the rectangle heightXwidth, or use gl_VertexID (an int) in sv aka vertex shader code string. sv['+sv+']');
		}
		
		//If a memsIn's Tensor has fr/free of 1, then it uses an optimization of
		//its WebGLTexture being both in and out (in memsIn and memsOut)
		//since its, kind of in this higher level, garbage collected and reused at once,
		//based on that Tensor is immutable and Mem/WebGLTexture is mutable.
		//During this, mem.tensor should be null, and at end, create new Tensor(mem)
		//for each memsOut. Creating a tensor just wraps the Mem, doesnt copy contents,
		//and is still backed by GPU memory.
		let memsIn = []; //contains nulls where u dont use them
		let memsOut = []; //contains nulls where u dont use them
		//for each index in mems*, memsIn or memsOut or both have it.
		
		let uniformsIn = []; //undefined except at primitive uniforms
		
		let tensorsToDecrementFreeAtEnd = [];
		
		for(let i=0; i<glvars.length; i++){
			let glvar = glvars[i];
			let isIn = glvar.isIn(), isInTex = glvar.isInTex(), isOut = glvar.isOut();
			//console.log('glvars looping, glvars['+i+']='+glvar+' isIn='+isIn+' isInTex='+isInTex+' isOut='+isOut);
			let tensorIn = null;
			if(isIn){
				if(isOut) Err('Cant be both in and out: '+glvar);
				//console.log('START isIn, glvar='+glvar);
				if(isInTex){
					tensorIn = map[glvar.name];
					if(!tensorIn) Err('No tensorIn for '+glvar);
					tensorsToDecrementFreeAtEnd.push(tensorIn);
					memsIn[i] = tensorIn.mem; //read-only and immutable
					//console.log('END isIn, glvar='+glvar+', memsIn['+i+'] = '+tensorIn+' of name '+glvar.name+' texture='+ tensorIn.mem.mut);
				}else if(hasXYAttr && glvar.name=='XY'){
					//the var of hasXYAttr. Do nothing here, just log it. Set it later by 2 triangles.
					//console.log(`END isIn (vertex attr)	${glvar.name}	– no uniform upload cuz is an in.`);
				}else{ //uniformsIn
					let val = map[glvar.name];
					if(val === undefined){
						Err('No uniform value for '+glvar.name);
					}
					/* -----------------------------------------------------------------
						Promote plain JS lists → typed arrays exactly once, picking the
						right element type from the GLSL declaration.
						float / vec* / mat*	→ Float32Array
						int/ivec*		 → Int32Array
						uint/uvec*		→ Int32Array	 (WebGL has no Uint32Uniform)
						-----------------------------------------------------------------
					*/
					if(Array.isArray(val)){
						const t = glvar.glType;	 // e.g. "float", "vec3", "int", …
						if(t === 'float' || t.startsWith('vec') || t.startsWith('mat')){
							val = new Float32Array(val);
						}else if(t === 'int'	|| t.startsWith('ivec') ||
								t === 'uint' || t.startsWith('uvec')){
							val = new Int32Array(val);
						}else{
							Err('Don’t know how to promote list for '+t+' '+glvar.name);
						}
					}
					uniformsIn[i] = val; //remember for later
					//console.log('END isIn, primitive uniform glvar.name='+glvar.name+' jsType_val='+Lamgl.jsType(val)+' val='+val);
				}
			}else if(isOut){ //isOut
				//console.log('START isOut, glvar='+glvar);
				
				
				//Cant do it as "const canReuseTexture = firstStateTensor.fr === 1;" cuz requires checking if
				//firstStateTensor exists cuz its an optional param. for each output, it optionally is also a param
				//for the starting state of the output memory, which gl_Position can sparsely write on top of.
				let firstStateTensor = map[glvar.name]; //if this doesnt exist, start with an empty state.
				//the optimization this whole LamGL software is based on,
				//that allows it to be completely stateless/immutable Tensors
				//that share and reuse GPU memory without copying back to CPU
				//except as needed after 1 or many GPU calls.
				let doSharedTextureOptimization = false;
				//console.log('doSharedTextureOptimization='+doSharedTextureOptimization);
				if(firstStateTensor){
					//console.log('isOut: map.'+glvar.name+' exists so using it as the starting state (firstStateTensor) of that texture/GPUMemory. If its .fr/free is 1, will do the optimization to reuse that texture, else will copy it first.');
					doSharedTextureOptimization = firstStateTensor.fr==1;
					//TODO firstStateTensor.useFree() at end. cant free it yet.
				}
				
				/*if(firstStateTensor && doSharedTextureOptimization){ //use 1 texture as if it was 2
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else if(firstStateTensor){ //use 2 textures, copy-on-write
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					memsOut[i] = firstStateTensor.copy().mem;
				}else{ //no firstStateTensor, start with empty memory
					memsOut[i] = vm.gpuMalloc(map.sh); // assumes `map.sh` is the desired shape
				}*/
				
				if(firstStateTensor){
					if(doSharedTextureOptimization){
						//garbage collect immutable tensor so can reuse texture/mem
						firstStateTensor.tensor = null;
						memsOut[i] = firstStateTensor.mem;
						//console.log('yes firstStateTensor, doSharedTextureOptimization=TRUE, memsOut['+i+'] = '+firstStateTensor+' of name '+glvar.name);
					}else{
						//firstStateTensor.fr is big enuf its not garbage collected,
						//so this (after copy) is the last we use it in this call of callGPU.
						//Instead, we copy it to another texture/mem and use that as output,
						//including that its a mutable texture during writing it,
						//as it has its previous contents and wherever gl_Position
						//sparsely writes voxels over it.
						//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
						//depending on if its a 2d or 3d texture),
						//and write 1-8 vec4s there, 1 vec4 written to each output texture,
						//and gl has a limit of at most 8 output textures (normally just 1).
						//firstStateTensor.useFree(); //decrement firstStateTensor.fr
						tensorsToDecrementFreeAtEnd.push(firstStateTensor);
						//new GPU mem. starts with high .fr
						memsOut[i] = firstStateTensor.copy().mem;
						//console.log('yes firstStateTensor, doSharedTextureOptimization=FALSE, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					}
				}else{
					memsOut[i] = vm.gpuMallocMem(sh);
					//console.log('no firstStateTensor, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					if(memsOut[i].tensor) Err('gpuMallocMem gave Mem with a tensor');
				}
				
				/*
				Todo('there might be 3 cases, do optimization, dont do optimization, where there is .fr>1 so still gotta copy, and where there is .fr==1 so reuse it (the optimization). some combo of those');
				if(doSharedTextureOptimization){ //use 1 texture as if it was 2
					Todo('this might be wrong, check [there might be 3 cases]');
					//garbage collect immutable tensor so can reuse texture/mem
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else{ //use 2 textures, copy-on-write
					Todo('this might be wrong, check [there might be 3 cases]');
					//firstStateTensor.fr is big enuf its not garbage collected,
					//so this (after copy) is the last we use it in this call of callGPU.
					//Instead, we copy it to another texture/mem and use that as output,
					//including that its a mutable texture during writing it,
					//as it has its previous contents and wherever gl_Position
					//sparsely writes voxels over it.
					//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
					//depending on if its a 2d or 3d texture),
					//and write 1-8 vec4s there, 1 vec4 written to each output texture,
					//and gl has a limit of at most 8 output textures (normally just 1).
					//firstStateTensor.useFree(); //decrement firstStateTensor.fr
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					//new GPU mem. starts with high .fr
					memsOut[i] = firstStateTensor.copy().mem;
				}
				*/
				
				//console.log('END isOut, glvar='+glvar+', memsOut['+i+'] = Tensor '+glvar.name+', GPU texture ='+memsOut[i].mut);
			}else Err('Is not in or out: '+glvar+' FIXME what if its an input of fragment shader (sf) which comes after vertex shader (sv).');
		}
		//console.log('Got '+memsIn.filter(x=>!!x).length+' ins and '+memsOut.filter(x=>!!x).length+' outs, excluding nulls/undefineds in memsIn and memsOut lists.');
		//Todo();
		
		//todo remove this double loop. also, does doSharedTextureOptimization allow them to be both in and out in some cases?
		//console.log('--- Checking input/output GPU memory overlap ---');
		for (let i = 0; i < memsIn.length; i++) {
			const memIn = memsIn[i];
			if (!memIn) continue;
			for (let j = 0; j < memsOut.length; j++) {
				const memOut = memsOut[j];
				if (!memOut) continue;
				if (memIn.mut === memOut.mut) {
					console.warn(`ERR, ⚠️ memsIn[${i}] and memsOut[${j}] share the SAME WebGLTexture!`, memIn.mut);
				}else{
					//console.warn(`OK memsIn[${i}] and memsOut[${j}]`);
				}
			}
		}
		//console.log('--- End check ---');

		
		let program = vm.cache('program'+cacheKeySuffix, function(){
			let vertexShader = vm.cache('vertexShader'+cacheKeySuffix, function(){
				sv = vm.preprocessShaderString(sv); //add line numbers etc
				let v = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(v, sv);
				gl.compileShader(v);
				if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+sv);
				}
				return v;
			});
			console.log('vertexShader='+vertexShader);
			let fragmentShader = vm.cache('fragmentShader'+cacheKeySuffix, function(){
				sf = vm.preprocessShaderString(sf); //add line numbers etc
				const f = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(f, sf);
				gl.compileShader(f);
				if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(f)+'\n\nFRAGMENTSHADERCODE:\n'+sf);
				}
				return f;
			});
			console.log('fragmentShader='+fragmentShader);
			const p = gl.createProgram();
			gl.attachShader(p, vertexShader);
			gl.attachShader(p, fragmentShader);
			gl.linkProgram(p);
			console.log('skip_gl_getProgramParameter_LINK_STATUS='+vm.skip_gl_getProgramParameter_LINK_STATUS);
			if(!vm.skip_gl_getProgramParameter_LINK_STATUS && !gl.getProgramParameter(p, gl.LINK_STATUS)){
				Err(gl.getProgramInfoLog(p));
			}
			return p;
		});
		//console.log('program='+program);
		
	
		
		let ret = {};
		
		//nTextures are outputs, not inputs. 1-8 textures of float or vec4 per pixel each.
		
		/*if(nTextures.length > 1){
			//Specify the draw buffers for multiple render targets
			const attachments = nTextures.map((_, index) => gl.COLOR_ATTACHMENT0 + index);
			gl.drawBuffers(attachments);
		}*/
		let texturesOut = [];
		if(sc){
			//console.log('Skipping for(let mem of memsOut) if(mem) texturesOut.push(mem.mut); cuz sc aka output to the canvas that created this GL aka null frameBuffer');
		}else{
			for(let mem of memsOut) if(mem) texturesOut.push(mem.mut);
		}
		
		//vm.cacheFramebuffer = true;
		vm.cacheFramebuffer = false;
		//console.log('vm.cacheFramebuffer='+vm.cacheFramebuffer);
		
		let frameBuffer = null;
		if(!sc){
			let frameBufferMaker = function(){
				const f = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, f);
				for(let i=0; i<texturesOut.length; i++){
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, texturesOut[i], 0);
				}
				return f;
			};
			frameBuffer = vm.cacheFramebuffer ?
				vm.cache('frameBuffer'+cacheKeySuffix, frameBufferMaker)
				: frameBufferMaker();
		}
		
				
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer); //frameBuffer is null if sc
		//gl.clearColor(0, 0, 0, 0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		gl.viewport(0, 0, width, height);
		gl.useProgram(program);
		
		if(texturesOut.length){
			const attachments = texturesOut.map((_,i)=>(gl.COLOR_ATTACHMENT0+i));
			//console.log('Calling gl.drawBuffers');
			gl.drawBuffers(attachments); 
			//gl.drawBuffers(texturesOut);
		}
		
		
		// === Bind sampler2D uniforms ===
		let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;	// only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}


		// --- bind primitive uniforms ---------------------------------------
		for(let i=0; i<glvars.length; i++){ //added 2025-6-21
			let val = uniformsIn[i];
			if (val === undefined) continue;			 // not a uniform
			//console.log('uniformsIn doing gl.uniform* to set value, glvars['+i+']='+glvars[i]+', val='+val);
			//let loc = gl.getUniformLocation(program, glvars[i].name);
			// first try plain name, then the "[0]" form required for arrays
			let loc = gl.getUniformLocation(program, glvars[i].name) //normal
				|| gl.getUniformLocation(program, glvars[i].name+'[0]'); //GPT thought this [0] should be here. probably dont need it
			if(loc === null) continue; //may have been removed by removeGlvarsThatJustCopyFromSvToSf, or could just be missing?
			//Accept number, Array, or Float32Array
			if (typeof val === 'number'){
				gl.uniform1f(loc, val);
			}else if(val instanceof Float32Array || Array.isArray(val)){
				const buf = (val instanceof Float32Array) ? val : new Float32Array(val);
				switch (glvars[i].glType){
					case 'float': gl.uniform1fv(loc, buf); break;
					case 'vec2':	gl.uniform2fv(loc, buf); break;
					case 'vec3':	gl.uniform3fv(loc, buf); break;
					case 'vec4':	gl.uniform4fv(loc, buf); break;
					default:
						Err('Unsupported uniform type '+glvars[i].glType+' for '+glvars[i].name);
				}
				/*switch (val.length){
					case 1:
						gl.uniform1f(loc, val[0]);
					break;case 2:
						gl.uniform2fv(loc, val);
					break;case 3:
						gl.uniform3fv(loc, val);
					break;case 4:
						gl.uniform4fv(loc, val);
					break;default:
						Err('Unsupported uniform length for '+glvars[i].name+'. TODO arrays, but u will have a limit of about 4k total uniforms in vertex shader and 1k in fragment shader.');
				}*/
			}else{
				Err('Unsupported uniform type for '+glvars[i].name);
			}
		}

		
		
		if(hasXYAttr){ //2 triangles filling rectangle, use "in vec2 XY;"
			//console.log('Lamgl doing 2 triangles: in vec2 XY;');
			//lazy-create and cache a full-screen quad VBO (6 vertices)
			const quadBuf = vm.cache('lamgl_quadVBO', () => {
				const q = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, q);
				gl.bufferData(
					gl.ARRAY_BUFFER,
					new Float32Array([
						-1,-1,	 1,-1,	-1, 1,
						-1, 1,	 1,-1,	 1, 1,
					]),
					gl.STATIC_DRAW
				);
				return q;
			});
			//hook the XY attribute of *this* program to that VBO
			const locXY = gl.getAttribLocation(program, 'XY');
			if (locXY !== -1) {
				gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
				gl.enableVertexAttribArray(locXY);
				gl.vertexAttribPointer(locXY, 2, gl.FLOAT, false, 0, 0);
			}
			//rasterise the quad
			gl.drawArrays(gl.TRIANGLES, 0, 6);
			//leave no attribs enabled for later POINTS calls
			if (locXY !== -1) gl.disableVertexAttribArray(locXY);
		}else{ //gl_VertexID
			//console.log('Lamgl doing points as gl_VertexID.');
			//=== run shader for every pixel/voxel using gl_VertexID ===
			let numVerts = 1;
			for(let d = 0; d < sh.length - 1; d++){	 // multiply all dims except the last (==4)
				numVerts *= sh[d];
			}
			gl.drawArrays(gl.POINTS, 0, numVerts);	// no VBO needed – gl_VertexID drives the math
		}

		//=== wrap each output Mem in an immutable Tensor and expose it ===
		for(let i=0; i<glvars.length; i++){
			if(glvars[i].isOut() && memsOut[i]){
				let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);
				memsOut[i].tensor = t;			// back-link for texture pooling
				ret[glvars[i].name] = t;			// e.g. ret.result
			}
		}
		
		//unbind input textures that were binded in the loop
		//containing "if (!glvar.isInTex()) continue;	// only bind texture inputs"
		for (let i = 0; i < nextTextureUnit; i++){
			gl.activeTexture(gl.TEXTURE0 + i);
			gl.bindTexture(gl.TEXTURE_2D, null); //this was here 2025-6-21 for long time
			//gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0); //new 2025-6-21
		}
		if(frameBuffer){ //new 2025-6-21
			for(let i=0; i<texturesOut.length; i++){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, null, 0); //detach
			}
		}
		// === Unbind frameBuffer output ===
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		// === Optional: reset active texture to 0 for consistency ===
		gl.activeTexture(gl.TEXTURE0);
		gl.useProgram(null);
		gl.bindVertexArray(null); //even tho its not using a vertex array
		
		for(let tensor of tensorsToDecrementFreeAtEnd){
			//decrement tensor.fr and if its 0 return its texture/mem to pool
			tensor.useFree();
		}
		
		return ret;
	};
	
	vm.preprocessShaderString = code=>{
		return vm.addLineNumbers(code);
	};
	
	//This is for lines like "out vec4 result; //comment".
	//TODO? eltype is element type, like 'vec4' or 'float' or 'int',
	//regardless of its an array/texture vs one primitive.
	//sh is [] if not an array, or [arraySize] or [outerSize, innerSize], etc.
	vm.GLVar = function(memType, glType, sh, name, charPtrFrom, charPtrTo, shaderType){
		this.memType = memType;
		this.glType = glType;
		this.sh = sh;
		this.name = name;
		this.charPtrFrom = charPtrFrom; //inclusive, range of the shader code string
		this.charPtrTo = charPtrTo; //exclusive
		this.shaderType = shaderType;
	};
	
	vm.GLVar.prototype.isIn = function(){
		// Treat uniforms and varying inputs (from vertex shader) as inputs
		return this.memType === 'uniform' || this.memType === 'in';
	};

	vm.GLVar.prototype.isInTex = function(){
		// A sampler2D, samplerCube, etc., in a uniform is a texture input
		return this.memType === 'uniform' && this.glType.startsWith('sampler');
	};

	vm.GLVar.prototype.isOutTex = function(){
		// Fragment outputs (out vec4 ...) are the only texture outputs
		return this.memType === 'out';
	};

	vm.GLVar.prototype.isOut = function(){
		// Alias to isOutTex for now, but leaves room to generalize later
		return this.isOutTex();
	};

	
	vm.GLVar.prototype.toString = function(){
		return '[GLVar memType='+this.memType+' glType='+this.glType+' sh='+vm.Str(this.sh)+' name='+this.name+' charPtrFrom='+this.charPtrFrom+' charPtrTo='+this.charPtrTo+' shaderType='+this.shaderType+']';
	};
	
	//Returns a list of glvars excluding those that are out from sv and in to sf of the same name and type,
	//which are only used to copy between the 2 shaders and are not inputs/outputs of the Lamgl call.
	vm.removeGlvarsThatJustCopyFromSvToSf = function(glvars) {
		const buckets = {};
		const toRemove = new Set();

		for (let i = 0; i < glvars.length; i++) {
			const v = glvars[i];
			const key = v.name + '|' + v.glType;
			let bucket = buckets[key] || (buckets[key] = []);
			//bucket.push({ idx: i, v: v });
			bucket.push(v);
		}

		for (let key in buckets) {
			const list = buckets[key];
			if (list.length === 2) {
				const [a, b] = list;
				if (
					(a.memType === 'out' && a.shaderType === 'sv' &&
					 b.memType === 'in'	&& b.shaderType === 'sf') ||
					(b.memType === 'out' && b.shaderType === 'sv' &&
					 a.memType === 'in'	&& a.shaderType === 'sf')
				) {
					//toRemove.add(a.idx);
					//toRemove.add(b.idx);
					toRemove.add(a);
					toRemove.add(b);
				}
			}
		}

		//console.log('removeGlvarsThatJustCopyFromSvToSf removing '+toRemove.size+' glvars:\n'+[...toRemove].join('\n'));
		return glvars.filter(v=>!toRemove.has(v));
	};

	
	//returns [] list of GLVar's in the order they should be used in gl.
	//map.sv is string of vertex shader code, sf fragement shader,
	//(todo if one of those is not given use or generate some default?).
	/*vm.glvars = map=>{
		Todo();
	};*/
	vm.glvars = map=>{
		const glvars = [];

		/*const parseShaderVars = (shaderSrc, shaderType)=>{
			let charPtr = 0; //running offset
			//fixme what about "flat" keyword and other keywords?
			const lines = shaderSrc.split('\n');
			//for (let line of lines){
			for(let raw of lines){
				const line = raw.trim();
				//line = line.trim();

				// Ignore comments
				if (line.startsWith('//')) continue;

				let isIn = false;
				let memType = null, glType = null, name = null;

				// Handle uniform
				//let matchUniform = line.match(/^uniform\s+(\w+)\s+(\w+);/);
				// Handle uniform	─ (accept optional "[	N ]")
				//let matchUniform = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\s*\])?\s*;/);
				//Handle uniform ─ (capture optional "[ N ]")
				let matchUniform = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchUniform){
					const from = charPtr + raw.indexOf(matchUniform[0]);
					const to   = from + matchUniform[0].length;
					glType = matchUniform[1];
					name = matchUniform[2];
					/*GPT-o3 said, about "what do you expect to be in matchUniform[3] ?": matchUniform[3] is the optional numeric size that appears inside the square-brackets of an array uniform declaration:
					uniform float foo[ 128 ];   // ← “128” is captured as matchUniform[3]
					uniform vec3  bar[4];       // ← “4”
					uniform float baz;          // ← no “[ … ]”, so matchUniform[3] is undefined
					*
					let asz = matchUniform[3] ? parseInt(matchUniform[3]) : null;
					let sh = asz ? [asz] : [];
					memType = 'uniform';
					isIn = true;
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}

				// Handle in/out (varyings, fragment outputs, etc.)
				//let matchIO = line.match(/^(in|out)\s+(\w+)\s+(\w+);/);
				// Handle in/out (varyings, fragment outputs, etc.)
				//let matchIO = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\])?\s*;/);
				let matchIO = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchIO){
					const from = charPtr + raw.indexOf(matchIO[0]);
					const to   = from + matchIO[0].length;
					let qualifier = matchIO[1];
					glType = matchIO[2];
					name = matchIO[3];
					let asz = matchIO[4] ? parseInt(matchIO[4]) : null;
					memType = qualifier;
					let sh  = asz ? [asz] : [];
					isIn = (qualifier === 'in');
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}

				// Handle layout(...) out vec4 NAME;
				//let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+(\w+);/);
				// Handle layout(...) out vec4 NAME;
				//let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\])?\s*;/);
				let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchLayoutOut){
					const from = charPtr + raw.indexOf(matchLayoutOut[0]);
					const to   = from + matchLayoutOut[0].length;
					glType = matchLayoutOut[1];
					name = matchLayoutOut[2];
					let asz = matchLayoutOut[3] ? parseInt(matchLayoutOut[3]) : null;
					let sh  = asz ? [asz] : [];
					memType = 'out';
					isIn = false;
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}
				charPtr += raw.length+1; // +1 for '\n'. FIXME norm newlines
			}
		};*/
		
		const parseShaderVars = (shaderSrc, shaderType)=>{
			let charPtr = 0;                          // running offset into shaderSrc
			const lines  = shaderSrc.split('\n');

			for(const raw of lines){
				const lineStart = charPtr;            // ← position of this line in the full source
				const line      = raw.trim();

				// ----- skip comments ------------------------------------------------
				if(line.startsWith('//')){
					charPtr += raw.length + 1;        // still count the line + '\n'
					continue;
				}

				// ---------- uniform -------------------------------------------------
				let m = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to   = from      + m[0].length;

					const asz = m[3] ? parseInt(m[3], 10) : null;
					glvars.push(new vm.GLVar(
						'uniform', m[1], asz ? [asz] : [], m[2],
						from, to, shaderType
					));
					charPtr += raw.length + 1;        // ✅ advance before next loop
					continue;
				}

				// ---------- in / out -----------------------------------------------
				m = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to   = from      + m[0].length;

					const asz = m[4] ? parseInt(m[4], 10) : null;
					glvars.push(new vm.GLVar(
						m[1], m[2], asz ? [asz] : [], m[3],
						from, to, shaderType
					));
					charPtr += raw.length + 1;
					continue;
				}

				// ---------- layout(...) out ----------------------------------------
				m = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to   = from      + m[0].length;

					const asz = m[3] ? parseInt(m[3], 10) : null;
					glvars.push(new vm.GLVar(
						'out', m[1], asz ? [asz] : [], m[2],
						from, to, shaderType
					));
					charPtr += raw.length + 1;
					continue;
				}

				// ---------- no match on this line -----------------------------------
				charPtr += raw.length + 1;
			}
		};

		if (map.sv) parseShaderVars(map.sv, 'sv');
		if (map.sf) parseShaderVars(map.sf, 'sf');

		return vm.removeGlvarsThatJustCopyFromSvToSf(glvars);
	};

	
	//vm.Str = 
	
	//TODO make a way to call Lamgl({...}) that takes a string of js code that generates
	//the Float32Array or Mem/texture contents in CPU.
	//Maybe name it sj (j for javascript) like sv (vertex shader) and sf (fragment shader).
	//A tensor could be more general, in cpu mem or gpu mem.
	
	vm.wrap = (wrapMe,optionalSh)=>{
		if(wrapMe instanceof Float32Array){
			let sh = optionalSh || [wrapMe.length>>2, 4]; //FIXME what if its not a multiple of 4?
			let mem = vm.gpuMallocMem(sh);
			mem.set(wrapMe); //copy from CPU (Float32Array wrapMe) to GPU (WebGLTexture in mem.mut)
			return new vm.Tensor(mem);
		}else Err('wrapMe is a '+typeof(wrapMe));
	};
	
		//immutable, normally exists in a Mem. Is same shape as that mem.
	vm.Tensor = function(mem,optionalFr){
		this.mem = mem;
		this.sh = mem.sh;
		//countdown until garbcol. Each time its read in GPU,
		//this is decremented. When it reaches 0, vm.gpuFree(this)
		//is called to return that GPU memory to the pool.
		this.fr = optionalFr || vm.defaultFr;
		if(mem.tensor){
			Err('mem already has a tensor and its not this one, mem='+mem+', thisTensor='+this);
		}else{
			mem.tensor = this;
		}
	};
	
	vm.Tensor.prototype.toString = function(){
		return '[Tensor sh='+JSON.stringify(this.sh)+']';
	};
	
	//Fast. this.get().length but without calling this.get() cuz that would copy from GPU to CPU.
	vm.Tensor.prototype.size = function(){
		return this.mem.size();
	};
	
	//return a Float32Array copy of the WebGLTexture in the mem backing this Tensor
	vm.Tensor.prototype.get = function(){
		return this.mem.get();
	};
	
	//Returns this Tensor with fr set.
	//Like, vm.gpuMalloc([300,500,4]).free(1) is a Tensor that will free
	//its WebGLTexture (back to the vm.texPool) after the next GPU call.
	//if optionalFr is not given or is 0, frees now.
	//If its 1, frees on the next use (1 more GPU call),
	//fr decreases by 1 each GPU call.
	vm.Tensor.prototype.free = function(optionalFr){
		this.fr = optionalFr|0;
		if(!this.fr){
			vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
		}
		return this;
	};
	
	//use 1 more fr in the countdown, toward garbage collecting the WebGLTexture at this.fr==0,
	//but only back into the vm.texPool pool, not deleting it out of the GPU
	//(todo also that if its not used for a while and the GPU memory is needed).
	vm.Tensor.prototype.useFree = function(){
		if(this.fr){
			this.fr--;
			if(!this.fr){
				vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
			}
		}
	};
	
	//For if sh.length==2, not sure if we even have 1d textures in this version of webgl. Get flattened index.
	vm.Tensor.prototype.ii = function(x, w){
		return x*this.sh[0]+w;
	};

	//For if sh.length==3 like a 2d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iii = function(y, x, w){
		return (y*this.sh[0]+x)*this.sh[1]+w;
	};

	//For if sh.length==4 like a 3d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iiii = function(z, y, x, w){
		return z*this.sh[0]+(y*this.sh[1]+x)*this.sh[2]+w
	};
	
	//vm.texPool[vm.shKey(sh)] is a [] of unused vm.Mem instances of that sh/shape.
	//See vm.gpuMallocMem and vm.gpuFreeMem.
	vm.texPool = {};
	
	vm.verifyShEndsWithVec4 = sh=>{
		if(sh[sh.length-1] != 4) Err('Last dimension is not 4: '+Str(sh));
	};
	
	//returns a Tensor wrapping a Mem wrapping a WebGLTexture,
	//instead of that Mem. Tensor is immutable. Mem is mutable.
	//The Tensor contains whatever data was in WebGLTexture (malloc, not calloc).
	//The normal use of this, since Tensor is immutable, would be to remove the Tensor from the Mem,
	//modify the Mem, then add another Tensor to represent that new Mem state.
	vm.gpuMallocTensor = sh=>(new vm.Tensor(vm.gpuMallocMem(sh)));
	
	vm.gpuMallocMem_usesCache = true; //normal
	//vm.gpuMallocMem_usesCache = false; //test
	//console.log('vm.gpuMallocMem_usesCache='+vm.gpuMallocMem_usesCache);
	
	//Example: vm.gpuMallocMem([300,500,4]) returns a Mem.
	//allocate a texture of a chosen sh/shape from pool, in GPU mem.
	//Returns a Mem instance wrapping a WebGLTexture of 2d or 3d,
	//normally with 4 floats per pixel (vec4) as sh[sh.length-1] is normaly 4.
	//This is specificly a malloc, not calloc, as it doesnt clear the mem.
	//Only the first use of a WebGLTexture is cleared,
	//but after that it can be returned to the pool and reallocated without clearing,
	//but it should be written before read again.
	vm.gpuMallocMem = sh=>{
		vm.verifyShEndsWithVec4(sh);
		let k = vm.shKey(sh);
		//list of Mem's whose mem.sh contents equal.
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		if(vm.gpuMallocMem_usesCache && list.length){
			//console.log('gpuMallocMem returning from cache, sh='+vm.Str(sh));
			return list.pop();
		}else{
			let tex = null;
			if(sh.length==3 && sh[2]==4){
				//2d WebGLTexture with vec4 per pixel
				//console.log('gpuMallocMem makeGLTexture2dVec4, sh='+vm.Str(sh));
				tex = vm.makeGLTexture2dVec4(sh[0], sh[1]);
			}else if(sh.length==3 && sh[2]==4){
				Todo('new 3d WebGLTexture (vec4 per pixel) of that sh='+Str(sh));
			}else{
				Todo('new WebGLTexture of that sh='+Str(sh));
			}
			return new vm.Mem(tex, sh);
			//return new vm.Tensor(new vm.Mem(tex, sh));
		}
	};
	
	//Example:	mem is what a vm.gpuMalloc returned.
	//FIXME: Does not check if its already freed or if its already in texPool,
	//so only call once after each gpuMallocMem.
	vm.gpuFreeMem = mem=>{
		//console.log('gpuFreeMem this='+this);
		mem.tensor.mem = null; //breaks the tensor, cant use it anymore
		mem.tensor = null;
		let k = vm.shKey(mem.sh);
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		list.push(mem);
	};
	
	vm.shKey = sh=>sh.join('_');
	
	//mutable. wraps WebGLTexture and maybe Float32Array.
	//shape is [z,y,x,4] or [y,x,4] or [y,x,1] or [500] etc. As of 2025-5-6 only [height,width,4] is supported.
	vm.Mem = function(mutableMem, shape){
		this.mut = mutableMem;
		this.sh = shape;
		this.tensor = null; //this Mem is in the pool when this.tensor is null.
	};
	
	vm.mulAll = function(vec){
		let ret = 1;
		for(let num of vec) ret *= num;
		return ret;
	};
	
	vm.Mem.prototype.size = function(){
		return vm.mulAll(this.sh);
	};
	
	//copy gpu to cpu
	vm.Mem.prototype.get = function(optionalFloat32Array){
		let size = this.size();
		let ret = optionalFloat32Array || new Float32Array(size);
		vm.copyTextureToFloat32Array(this.mut,this.sh,ret); //GPU
		return ret;
	};
	
	/*vm.copyTextureToFloat32Array = (tex,floatsOut)=>{
		Todo();
	};*/
	vm.copyTextureToFloat32Array = (tex, sh, floatsOut) => {
		if(sh.length != 3) Todo('sh.length=='+sh.length);
		const gl = vm.Gl();
		let isTex = gl.isTexture(tex);
		if(!isTex){
			Err('NOT gl.isTexture(tex) at the start of copyTextureToFloat32Array, see bug in bellsack190_mostBallsMoveDiffDirectionsButAfter10SecondsGLCrashesSeeDetailsInFIXMETextInUI.html vs that bug does not happen in bellsack183.html, if you wait about [30 seconds or 2000 video frames].');
		}
		//console.log('copyTextureToFloat32Array, lamglLoopBody_count='+(lamglLoopBody_count)+', gl.isTexture(tex)='+isTex+', sh='+Lamgl.Str(sh)+' floatsOut.length='+floatsOut.length+' typeof(tex)='+typeof(tex));

		// Assume the texture is 2D and in RGBA32F format
		// Find the dimensions from floatsOut.length and assume vec4 per pixel
		let totalFloats = floatsOut.length;
		let height = sh[0];
		let width = sh[1];
		let pixels = totalFloats/sh[2];
		
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		//let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		
		/*let pixels = totalFloats / 4;
		let width = Math.ceil(Math.sqrt(pixels));
		let height = Math.ceil(pixels / width); //TODO choose width and height better
		*/

		// Create a temporary frameBuffer and attach the texture to it
		const frameBuffer = gl.createFramebuffer();
		console.log('copyTextureToFloat32Array, after gl.createFramebuffer gl.isTexture(tex)='+gl.isTexture(tex));
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
		console.log('copyTextureToFloat32Array, after gl.bindFramebuffer gl.isTexture(tex)='+gl.isTexture(tex));
		gl.viewport(0, 0, width, height);
		console.log('copyTextureToFloat32Array, after gl.viewport(0, 0, '+width+', '+height+') gl.isTexture(tex)='+gl.isTexture(tex));
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
		console.log('copyTextureToFloat32Array, after gl.framebufferTexture2D gl.isTexture(tex)='+gl.isTexture(tex));

		let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			// Clean up before erroring out
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.deleteFramebuffer(frameBuffer);
			Err('Framebuffer not complete: ' + status);
		}

		// Read pixels from the frameBuffer into the Float32Array
		gl.readPixels(
			0, 0, width, height,
			gl.RGBA, gl.FLOAT,
			floatsOut
		);

		// Clean up
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(frameBuffer);
	};
	
	//vm.skip_gl_getProgramParameter_LINK_STATUS = false; //2024-5-9-640pET defaulting this to false (dont skip) cuz of I turned SKLT=F (dont skip) by clicking the button and this neuralnet nnet_1715286589.548.dagball compiled in about .1 second when I changed {nodes 12} to {nodes 13}.
	//skip_gl_getProgramParameter_LINK_STATUS: true, //normal as of 2024-5-9 cuz it made compiling GLSL alot faster, probably some thread thing it didnt have to wait on, considering theres multiple off-screen canvases.
	//skip_gl_getProgramParameter_LINK_STATUS: false, //normal before 2024-5-9, but TODO experimentally trying skipping it cuz this line takes .1 to 20 seconds and is likely causing threads to wait on eachother
	//skip_gl_getProgramParameter_LINK_STATUS: true, //for testing, or maybe it will work out this way?
	vm.skip_gl_getProgramParameter_LINK_STATUS = true, //2025-7-19 changed this to true (was undefined) cuz page loading slow
	
	//copy cpu to gpu
	vm.Mem.prototype.set = function(float32Array){
		vm.copyFloat32ArrayToTexture(float32Array,this.mut,this.sh);
	};
	
	// --- CPU → GPU upload ----------------------------------------------
	vm.copyFloat32ArrayToTexture = (src, tex, sh) => {
		// sh is the tensor shape that texture represents, e.g. [h, w, 4]
		if (!sh || sh.length !== 3 || sh[2] !== 4) {
			Err('copyFloat32ArrayToTexture: shape must be [height,width,4]');
		}
		const gl	 = vm.Gl();
		const height = sh[0];
		const width	= sh[1];

		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,				 // level
			0, 0,				// x-offset, y-offset
			width, height,	 // size
			gl.RGBA,			 // format
			gl.FLOAT,			// type
			src				// the Float32Array with 4*width*height values
		);
	};

	
	vm.webglType = 'webgl2'; //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	vm.glslVersionString = '#version 300 es'; //WebGL2 GLSL ES 300
	
	//returns 'Uint8Array' or 'Float64Array' or 'object' or 'number' or 'string' for example.
	vm.jsType = x=>(ArrayBuffer.isView(x) ? x.constructor.name : typeof(x)),
	
	vm.gl = null; //the only GL instance, normally WebGL2 GLSL ES 300
	vm.glCanv = null;
	//vm.glCanvasHeight = 1; //1x1 canvas, cuz gonna use gl_VertexID instead of 2 triangles that form a rectangle covering the canvas
	//vm.glCanvasWidth = 1;
	//vm.glCanvasHeight = 300; //experiment avoid resizing canvas to see if it boots faster 2025-7-19
	//vm.glCanvasWidth = 400; //experiment avoid resizing canvas to see if it boots faster 2025-7-19
	vm.glCanvasHeight = 600;
	vm.glCanvasWidth = 800;
	vm.Gl = ()=>{
		if(!vm.gl){
			let c = document.createElement("canvas");
			c.setAttribute("height", ''+vm.glCanvasHeight);
			c.setAttribute("width", ''+vm.glCanvasWidth);
			c.addEventListener('webglcontextlost', function(event){
				//event.preventDefault();
				//activeContexts.delete(context);
				console.log('Lamgl says canvas event webglcontextlost, event='+event);
				/*console.log('TinyGLSL says canvas event webglcontextlost, event='+event);
				if(TinyGlsl.do_clearAllCache_whenWebglContextLost){
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost STARTING TinyGlsl.clearAllCache()...');
					TinyGlsl.clearAllCache();
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost DONE TinyGlsl.clearAllCache().');
				}*/
			}, false);
			vm.glCanv = c;
			
			let gl = vm.glCanv.getContext(vm.webglType);
			let glErr = gl.getError();
			if(glErr) Err('after canvas.getContext(TinyGlsl.webglType), gl.getError()='+glErr);
			if(!gl.getExtension('EXT_color_buffer_float')){ //this turns the extension on. its not just checking if it exists.
				Err('EXT_color_buffer_float not supported so cant return 1 or 4 floats per pixel instead of bytes');
			}
			let isContextLost = gl.isContextLost();
			console.log('creating gl context, gl.isContextLost()=='+isContextLost);
			if(isContextLost) Err('gl.isContextLost()=='+isContextLost+
				', see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/isContextLost');
			console.log('Returning new webgl context '+gl);
			vm.gl = gl;
		}
		return vm.gl;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.makeGLTexture2dVec4_count = 0;
	
	vm.makeGLTexture2dVec4 = (height, width, optionalFloat32Array)=>{
		vm.makeGLTexture2dVec4_count++;
		//console.log('makeGLTexture2dVec4, height='+height+' width='+width+' optionalFloat32Array_exists='+!!optionalFloat32Array+' makeGLTexture2dVec4_count='+vm.makeGLTexture2dVec4_count);
		let gl = vm.Gl();
		let t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		let floats = optionalFloat32Array || null;
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
		gl.texImage2D(
			gl.TEXTURE_2D,
			0,
			gl.RGBA32F,
			width,
			height,
			0,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		return t;
	};
	
	vm.defaultFr = 1<<30;
	
	vm.vm = vm; //so Lamgl.vm is vm. Lamgl is a Proxy
	
	vm.jsNumToGlslFloat = jsNum=>{
		let s = ''+jsNum;
		if(!s.includes('.') && !s.includes('e')) s += '.'; //Examples: '3.', '3.45', '5e-10', '-5e-10'
		return s;
	};

	let Str = vm.Str = value => {
		if (value === null) return 'null';
		if (value === undefined) return 'undefined';
		if(value instanceof Float32Array) return 'Float32Array.of('+value.join(', ')+')';
		if(value.length) return JSON.stringify(value);
		if (typeof value === 'symbol') return value.toString();
		if (typeof value === 'function') return '[Function]';
		if (value instanceof WebGLTexture) return 'WebGLTexture';
		if (value instanceof vm.Tensor) return value.toString();
		if (typeof value === 'object'){
			//if(value.length) return String(value);
			//else{
				let s = '{';
				for(let key in value){
					console.log('key='+key);
					if(s.length>1) s += ',';
					s += key+': '+Str(value[key]);
				}
				return s+'}';
			//}
		}
		if(value.toString){
			return value.toString();
		}
		try {
			return 'THING';
		} catch (e) {
			return Object.prototype.toString.call(value);
		}
	};
	
	vm.timeOffset_ = performance.timing.navigationStart;
	//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
	vm.time = ()=>((vm.timeOffset_+performance.now())*.001);

	const Lamgl = vm.Lamgl = new Proxy(vm, {
		apply: (target, thisArg, args) => {
			//console.log('Proxy.apply target=' + target + ' thisArg=' + thisArg + ' args=' + args);
			return target.call(...args);
		},
		get: (target, prop, receiver) => {
			//console.log('Proxy.get target=' + Str(target) + ' prop=' + Str(prop) + ' receiver=' + Str(receiver));
			if (typeof prop === "symbol") {
				// Directly pass through all symbol accesses
				return target[prop];
			}
			// Access properties like 'doBasicTests'
			if (prop in target) {
				return target[prop];
			}
			return Reflect.get(target, prop, receiver);
			//return Reflect.get(target, prop, receiver);
		}
	});
	
	vm.caches = {type: 'lamgl_caches'};
	
	//if this is nonnull (a {}), then TinyGlsl.cache(key,lazyVal) puts stats into it when lazyVal is called but does not store the output of lazyVal here.
	//TODO This could get big so it waits for it to be set to {} externally (by a button in dagball normally)
	//vm.cacheStats = null; //normal
	vm.cacheStats = {}; //test
	
	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	vm.cache = function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = Lamgl.caches[key];
		if(val === undefined){
			//putTid: put a .tid field that is dagball.timeId() so can be deleted in same order as created (or reverse order?) Or might help in choosing the order in some cases?
			let startTime;
			if(Lamgl.cacheStats){
				startTime = Lamgl.time();
			}
			//val = Lamgl.caches[key] = Lamgl.putTid(lazyVal());
			val = Lamgl.caches[key] = lazyVal();
			if(Lamgl.cacheStats){
				let now = Lamgl.time();
				let map = Lamgl.cacheStats[key] = Lamgl.cacheStats[key] || {};
				let duration = now-startTime;
				map.count = (map.count|0)+1;
				map.lastDurationEndTime = now;
				map.lastDuration = duration;
				if(!map.firstDuration){
					map.firstDuration = duration;
				}
			}
		}
		return val;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.float32ArrayTranspose = (matBC,sizeB,sizeC)=>{
		let matCB = new Float32Array(sizeC*sizeB);
		for(let b=0; b<sizeB; b++) for(let c=0; c<sizeC; c++){
			matCB[c*sizeB+b] = matBC[b*sizeC+c];
		}
		return matCB;
	};
	
	vm.countNonzeros = function(floats){
		let count = 0;
		for(let i=0; i<floats.length; i++) if(floats[i]) count++;
		return count;
	};
	
	vm.testNearEqualFloatArrays = (a,b,epsilon,comment)=>{
		if(a.length != b.length) Err('TEST FAIL Array lengths differ '+a.length+' '+b.length+', '+comment);
		for(let i=0; i<a.length; i++){
			let diff = Math.abs(a[i]-b[i]);
			if(diff > epsilon) Err('TEST FAIL at i='+i+' '+a[i]+' != '+b[i]+', diff='+diff+', epsilon='+epsilon+', '+comment);
		}
		console.log('Test pass, '+comment);
	};

	vm.doBasicTests = ()=>{
		console.log('START Lamgl.doBasicTests()');
		
		let testA = Lamgl({
			sh: [1, 1, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				void main(){
					gl_Position = vec4(0.,0.,0.,1.0);
					gl_PointSize = 1.0;
				}`,
			sf: `#version 300 es
				precision highp float;
				out vec4 result;
				void main(){
					result = vec4(2.,3.+4.,44.,55.);
				}`,
		});
		let correctA = Float32Array.of(2.,7.,44.,55.);
		let observedA = testA.result.get();
		//console.log('testA='+JSON.stringify(testA));
		console.log('testA='+Str(testA));
		console.log('correctA='+Str(correctA));
		console.log('observedA='+Str(observedA));
		vm.testNearEqualFloatArrays(observedA,correctA,0, 'one vec4');
		
		
		console.log('doBasicTests, Lamgl='+Lamgl);
		let arr = Lamgl(Float32Array.of(2,3,4,5.67,100,200,300,400),[1,2,4]);
		console.log('doBasicTests, arr='+arr);
		let testD = Lamgl({
			sh: [128, 128, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				flat out int vID;
				void main(){
					int idy = gl_VertexID>>7;
					int idx = gl_VertexID&127;
					//x and y go in range -1 to 1, +.5 so its in center of pixel and doesnt get dropped
					gl_Position = vec4((float(idx)+.5)/128.*2.-1., (float(idy)+.5)/128.*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					vID = gl_VertexID; //so sf can get it
				}`,
			sf: `#version 300 es
				precision highp float;
				layout(location = 0) out vec4 result;
				flat in int vID;
				uniform sampler2D someArray;
				//todo sampler2d or something called someArray
				void main(){
					//result = vec4(gl_VertexID, 0., 0., 1.);
					float f = texelFetch(someArray, ivec2(vID&1,0), 0).x;
					result = vec4(float(vID), 7., f, 1.);
				}`,
			someArray: arr,
		});
		let correctD = new Float32Array(128*128*4);
		for(let y=0; y<128; y++) for(let x=0; x<128; x++){
			let i = (y*128+x)*4;
			let gl_VectorID = i/4;
			correctD[i] = gl_VectorID;
			correctD[i+1] = 7;
			correctD[i+2] = x&1 ? 100 : 2; //from Float32Array.of(2,3,4,5.67,100,200,300,400)
			correctD[i+3] = 1;
		}
		let observedD = testD.result.get();
		console.log('testD='+Str(testD));
		console.log('correctD='+Str(correctD));
		console.log('observedD='+Str(observedD));
		vm.testNearEqualFloatArrays(correctD,observedD,0, 'testD');
		
		
		
		/** from TinyGLSL
		let tenThousandFloatsOut = TinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), null, 1000, 10);
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		*/
		
		let tenThousandFloatsOut = Lamgl({
			sh:[100, 25, 4],
			sv:`#version 300 es
				precision highp float;
				flat out vec4 tempColor;
				float outFunc(int i){
					return float(i)*float(i); //ret = float(id)*float(id); like in TinyGLSL
				}
				const int height = 100;
				const int width = 25;
				void main(){
					int idy = gl_VertexID/width;
					int idx = gl_VertexID%width;
					gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					int i = gl_VertexID<<2;
					tempColor = vec4(outFunc(i), outFunc(i+1), outFunc(i+2), outFunc(i+3));
				}`,
			sf:`#version 300 es
				precision highp float;
				flat in vec4 tempColor;
				layout(location = 0) out vec4 result;
				void main(){
					result = tempColor; //copy from sv
				}`
		}).result.get();
		console.log('tenThousandFloatsOut='+[...tenThousandFloatsOut].map((x,i)=>('['+i+']='+x)).join(', '));
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		
		
		console.log('START test testMatmulAC');
		let sizeA = 1024;
		let sizeB = 1024;
		let sizeC = 1024;
		let flopsPerMatmul = sizeA*sizeB*sizeC*2; //*2 cuz its add and multiply.
		
		/*let sizeA = 8;
		let sizeB = 8;
		let sizeC = 8;
		*/
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');
		let matABTensor = Lamgl(matAB,[sizeA,sizeB/4,4]);
		let matCBTensor = Lamgl(matCB,[sizeC,sizeB/4,4]);
		console.log('matABTensor='+matABTensor);
		console.log('matCBTensor='+matCBTensor);
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			let copyToCpuInMatmulTest = repeat_testMatmulAC4<5 || repeat_testMatmulAC4==9; //so we see its speed without that in later loops
			console.log('r='+repeat_testMatmulAC4+' copyToCpuInMatmulTest='+copyToCpuInMatmulTest);
			/*console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			console.log('matABTensor.get()[55]='+matABTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			console.log('matCBTensor.get()[55]='+matCBTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163 Lamgl_036.html:1212:12
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163
			so the data is still in them.
			*/
			let testMatmulAC4_timeStart = vm.time();
			let observed_testMatmulAC4 = null;
			let observed_testMatmulAC4_map = null;
			try{
				let testMatmulAC4_sh = [sizeA, sizeC/4, 4];
				observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						flat out vec4 tempColor;
						void main(){
							int idy = gl_VertexID / width; // row (A)
							int idx = gl_VertexID % width; // column block (C/4)
							/*tempColor = vec4(
								dotProd(idy, idx*4+0),
								dotProd(idy, idx*4+1),
								dotProd(idy, idx*4+2),
								dotProd(idy, idx*4+3)
							);*/
							vec4 sums = vec4(1.); //vec4 sums = vec4(0);
							for (int b=0; b<sizeBOver4; b++){
								vec4 mul = texelFetch(matAB,ivec2(b,idy),0);
								sums += vec4(
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+0),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+1),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+2),0)),
									//*1.0000001 avoid returning all 0s, force it to to do some calculation
									//thats not from the textures, cuz the glsl optimizer is buggy.
									//dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.000001
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))
								);
							}
							tempColor = sums;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1.,
								(float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							//gl_PointSize = 1.0;
							gl_PointSize = 1.;
							//float sum1 = 0.;
							//float sum2 = 0.;
							//float sum3 = 0.;
							/*for (int b1=0; b1<sizeBOver4; b1++){
								vec4 ba = texelFetch(matAB,ivec2(b1,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b1,idx*4+1),0);
								sum1 += dot(ba, bc);
							}
							float sum2 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+2),0);
								sum2 += dot(ba, bc);
							}
							float sum3 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+3),0);
								sum3 += dot(ba, bc);
							}*/
							//tempColor = vec4(sum0, sum1, sum2, sum3);
						}`,
					sf: `#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main() {
							//result = tempColor;
							//result = tempColor/1.000001; //undo *1.0000001 (glsl optimizer bug)
							result = tempColor-1.; //undo +1 (glsl optimizer bug)
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});

				
				console.log('observed_testMatmulAC4_map='+observed_testMatmulAC4_map);
				if(copyToCpuInMatmulTest){
					observed_testMatmulAC4 = observed_testMatmulAC4_map.result.get();
					//FIXME what kind of transpose-like op goes here? let observed_testMatmulAC = vm.float32ArrayTranspose(observed_testMatmulAC4,size
					/*let cor = [...correct_testMatmulAC];
					for(let i=0; i<1000; i++){
						let ind = cor.indexOf(observed_testMatmulAC[i]);
						console.log('i='+i+' ind='+ind);
					}*/
					let cor = [...correct_testMatmulAC];
					let obs4 = [...observed_testMatmulAC4];
					for(let i=0; i<Math.min(100,correct_testMatmulAC.length); i++){
						console.log('i='+i+' cor='+correct_testMatmulAC[i]+'@'+obs4.indexOf(correct_testMatmulAC[i])+' obs4='+observed_testMatmulAC4[i]+'@'+cor.indexOf(observed_testMatmulAC4[i]));
					}
					let epsilon = (.3*sizeB)**2; //FIXME?
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, epsilon, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
					/*
					console.log('testMatmulAC4 test code incompletely written. todo fix it.');
					for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
					let numNonzero_observed_testMatmulAC4 = 0;
					for(let i=0; i<observed_testMatmulAC4.length; i++) if(observed_testMatmulAC4[i]) numNonzero_observed_testMatmulAC4++;
					console.log('numNonzero_observed_testMatmulAC4='+numNonzero_observed_testMatmulAC4);
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					*/
				}
			}finally{
				let secs = vm.time()-testMatmulAC4_timeStart;
				let flopPerSec = flopsPerMatmul/secs;
				console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4+' testMatmulAC4 secs='+secs+' gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)='+(flopPerSec/1e9)+' observed_testMatmulAC4.length='+(observed_testMatmulAC4?observed_testMatmulAC4.length:'undefined'));
				if(observed_testMatmulAC4_map) for(let k in observed_testMatmulAC4_map){
					let val = observed_testMatmulAC4_map[k];
					if(val instanceof vm.Tensor){
						val.free(); //return WebGLTexture to pool
					}
				}
			}
		}
		
		/* ===========================================================
			 NEW TEST – geometry chosen implicitly via `in vec2 XY;`
			 Expectation: Lamgl must detect the attribute name, switch
			 to “two-triangle quad” geometry, fill a 40 × 30 tensor,
			 and give us	 value = 1000*y + x	 at each pixel.
			 ===========================================================*/
		{
			const H = 30, W = 40;				 // small so we can eyeball failures
			const quadTest = Lamgl({
				sh: [H, W, 4],
				sv: `#version 300 es
					 precision highp float;
					 in vec2 XY; //triggers quad/rectangle/twoTriangles geometry, dont use gl_ VertexID.
					 void main (){
						 gl_Position = vec4(XY, 0., 1.); //pass-through clip-space
					 }`,

				sf: `#version 300 es
					//fragment: encode 1000*y + x into .r
					 precision highp float;
					 layout(location=0) out vec4 result;
					 void main () {
						 int x = int(gl_FragCoord.x) - 0;	 // 0..W-1
						 int y = int(gl_FragCoord.y) - 0;	 // 0..H-1
						 result = vec4(float(1000*y + x), 0.0, 0.0, 1.0);
					 }`
			});
			//pull back to CPU and verify
			const data = quadTest.result.get(); //Float32Array
			let ok = true;
			for (let y = 0; y < H; ++y) {
				for (let x = 0; x < W; ++x) {
					const i = (y*W + x) * 4;
					const expected = 1000*y + x;
					if (data[i] !== expected) {
						console.error(`quadTest mismatch at (x=${x}, y=${y}): `
										+ `got ${data[i]}, expected ${expected}`);
						ok = false;
						break;
					}
				}
				if (!ok) break;
			}
			if (!ok) throw 'quadTest failed – Lamgl did not switch to QUAD geometry';
			console.log('quadTest passed – Lamgl QUAD geometry ok');
		}
		/*2025-6-25-546pET[
		Test pass, one vec4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testD
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1197 tenThousandFloatsOut test pass
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r0
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r1
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r2
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r3
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r9
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1406 quadTest passed – Lamgl QUAD geometry ok
		]*/

		
		//Lamgl.testDisplay(true,Lamgl.time()); //FIXME remove this cuz its UI stuff
		
		console.log('END Lamgl.doBasicTests()');
	};
	
	vm.Tensor.prototype.copyTo = function(canvas){
		if(canvas != vm.glCanv){
			Todo('also support copying (slower) to other canvases than vm.glCanv aka Lamgl.glCanv. Its built into WebGL2 that if you give null as FrameBuffer, it writes to the canvas that WebGL2 was made from. To copy to another canvas youd have to copy from that canvas to another one or on some other path.');
		}
		if(this.sh.length != 3){
			Err('this.sh.length='+this.sh.length+' but expected [height, width, 4]');
		}
		let [h, w, ch] = this.sh;
		vm.setCanvasSize(canvas, h, w);
		Lamgl({
			sh: this.sh,
			sv: `#version 300 es
				//sv tensor.copyTo for tensor.display() to canvas
				void main() {
					int id = gl_VertexID;
					int idx = id % ${w};
					int idy = id / ${w};
					float x = (float(idx) + 0.5) / float(${w});
					float y = (float(idy) + 0.5) / float(${h});
					gl_Position = vec4(x * 2.0 - 1.0, y * 2.0 - 1.0, 0.0, 1.0);
					gl_PointSize = 1.0;
				}
			`,
			sf: `#version 300 es
				//sf tensor.copyTo for tensor.display() to canvas
				precision highp float;
				uniform sampler2D tex;
				out vec4 outColor;
				void main() {
					ivec2 uv = ivec2(gl_FragCoord.xy);
					outColor = texelFetch(tex, uv, 0);
				}
			`,
			tex: this,
			sc: true, //output to Lamgl.glCanv aka vm.glCanv, the canvas that the WebGL2 was made from.
		});
	};
	
	vm.Tensor.prototype.display = function(){
		let canvas = vm.glCanv;
		vm.putCanvasInDomOnce(canvas);
		this.copyTo(canvas);
	};
	
	vm.putCanvasInDomOnce = function(canvas){ //does nothing if the canvas is already in the dom. Normally called on Lamgl.glCanv aka vm.glCanv
		if(!document.body.contains(canvas)){
			canvas.style.position = 'fixed';
			canvas.style.left = '0px';
			canvas.style.top = '0px';
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.zIndex = '-10'; // behind most content
			canvas.style.border = 'none';
			document.body.appendChild(canvas);
		}
		return canvas;
	};
	
	vm.setCanvasSize = function(canvas, h, w){
		if(canvas.width !== w || canvas.height !== h){
			canvas.width = w;
			canvas.height = h;
		}
	};
	
	vm.testDisplay = (isSparse, isDetailedLog, time)=>{
		console.log('Start testDisplay');
		let t = time || vm.time();
		const height = 400, width = 300;
		let tSmall = t%86400; //cuz float64 time cast to float32 loses the part of time that changes fast enuf to see
		let mapOut = Lamgl({
			sh: [height, width, 4],
			tSmall: tSmall,
			sv: `#version 300 es
				precision highp float;
				const int height = ${height};
				const int width = ${width};
				out vec2 uv;
				${isSparse ? '//sparsePoints' : 'in vec2 XY; //twoTriangles'}
				//const float tSmall = ${vm.jsNumToGlslFloat(tSmall)}; //TODO do this in uniform so Lamgl doesnt compile again every time
				void main(){
					${isSparse?
						`int idy = gl_VertexID / width;
						int idx = gl_VertexID % width;
						uv = vec2(float(idx)/float(width), float(idy)/float(height));
						gl_Position = vec4((float(idx)+.5)/float(width)*2. - 1.,
											(float(idy)+.5)/float(height)*2. - 1., 0., 1.);
						gl_PointSize = 1.0;`
						:
						`uv = XY * 0.5 + 0.5;
						gl_Position = vec4(XY, 0.0, 1.0);`
					}
				}`,
			sf: `#version 300 es
				precision highp float;
				uniform float tSmall;
				layout(location = 0) out vec4 outColor;
				in vec2 uv;
				void main(){
					float r = 0.5 + 0.5 * sin(sin(tSmall*.567) + uv.x * 20.0 + uv.y * 10.0);
					float g = 0.5 + 0.5 * cos(tSmall+cos(tSmall*1.876-uv.x*r) + uv.y * 30.0 - uv.x * 5.0);
					float b = 0.5 + 0.5 * sin(uv.x * 40.0 + uv.y * 40.0);
					//tempColor = vec4(1., .5, .4, 1.0);
					outColor = vec4(r, g, b, 1.0);
				}`,
		});
		
		let tensorOut = mapOut.outColor;
		if(!tensorOut){
			Err('No tensorOut');
		}
		console.log('tensorOut.sh='+JSON.stringify(tensorOut.sh));
		if(isDetailedLog){
			let floats = tensorOut.get();
			if(floats.length != height*width*4){
				Err('floats.length='+floats.length+' but expected height*width*4='+(height*width*4));
			}
			console.log('testDisplay contents: ');
			let countNonzeros = 0;
			for(let y=0; y<height; y++){
				let line = '';
				for(let x=0; x<width; x++){
					line += ' '
					for(let c=0; c<4; c++){
						if(c) line += ',';
						let f = floats[(y*width+x)*4+c];
						if(f) countNonzeros++;
						line += f;
					}
				}
				console.log(line);
			}
			if(!countNonzeros){
				Err('testDisplay, all '+floats.length+' floats from GPU are 0');
			}
		}
		//uses {sc:true} to output to canvas, that canvas being Lamgl.glCanv, and resizes if needed to match tensor size
		//and put thats canvas in dom tree if its not already.
		tensorOut.display();
	};

	return vm.Lamgl;
	//requestAnimationFrame(() => { Lamgl.doBasicTests(); });
})();
</script>
<script>
//V/Var class

//copied (then maybe modified) from VarTree_002.html 2025-7-5.
//Var class was copied 2025-4-16 from blobMonstersGame_2025-3-27.html then modified TODO...
//
//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn .mx and .poten
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt)
//so order of calling gob.brain(...vars) of many gobs and Vars, has no effect except float64 roundoff.
//Also dont modify prevP, epsilon, accelMul, or gp. Those are set externally.
//TODO over time, remove this.gob/optionalGob and use ONLY Var, and same for Game and other classes.
//They were made first, then redesigned as Var is their data format but its also a fast param like centerY.p.
//So far the tree is entirely organized by root.namespace.object.field, which is a Var tree 3 deep, as you see
//in the pic of json, but it can be any tree shape. Each var has a position, velocity, and 0 or more named childs.
//https://x.com/benrayfield/status/1877462454222958657 2025-1-9.
//
//To add new code, you move in a many dimensional space. Each possible code string is hashed to name
//it as a dimension. Position in that dimension means does the code exist or not. Child dimensions are its
//parameters, part of the high dimensional game state vector. It returns list or Int32Array of int voxels.
//You just write a javascript function of any parameters you want (Var instances which have
//position and velocity) and generate whatever pic you want based on that. The params will automatically
//change so the pics come to life.
//
const Var = function(optionalParentVar, optionalName, optionalBig, optionalGob){

	//fixme remove Var.brain cuz Var.getOb().brain would be that if ob is a Gob,
	//and remove Var.vars cuz thats now Var.pu aka the opposite spelling of Var.up.
	//this.brain = null; //where compiled (this.big || this.name) goes, normally a js func of Var's to list/array of int voxels.
	//this.vars = null;
	
	//If this.name is a hash id (or might be prefixed with something? todo), then its the hash of this.big which is probably a string of json (see Dagverse json norming, in dagball, TODO).
	//This must be verifiable. Dont just make up a name and make up a big that cant prove that its name is the hash of that.
	this.big = optionalBig || null;
	this.t = 0; //not used as of 2025-2-20 even though some code copies it, maybe later? TODO actual current time //TODO? this.t = utc time as float64 so has at least microsecond precision for 100+ more years.
	
	//TODO? this.ch = [] child vars list (gob.vars if this is gob.influence), if this is a .influence var
	//that is 1 for this thing exists and 0 for does not exist.
	//so there is 1 correct answer, or it should converge, to what .p and .v should a var be at time t
	//TODO? this.ns = string namespace, like game.ns.
	//TODO? this.pk = primaryKey of this Var. or should that be per scalar instead of per Var?
	//should pk depend on namespace? be concat to that? or what? pk certainly should not depend on t/time.
	this.name = optionalName || 'v'+(++generatedNameCounter);
	this.cache = {}; //holds constY and constX if this wraps a tile
	if(this.name.startsWith('tile')){
		if(isTileString(this.name)){
			let square = tileStringToSquare(this.name);
			this.cache.constY = SquareMidY(square);
			this.cache.constX = SquareMidX(square);
			//let yOfTopLeftCorner = SquareY(square);
			//let xOfTopLeftCorner = SquareX(square);
			//for Var.y() when Var.ob would be a QuadTile since it doesnt have Y and X Var childs cuz its in the square number instead
			//cant use this.constY cuz it will make a Var instance and put it in this.pu.constY
			//this.constY = yOfTopLeftCorner;
			//this.constX = xOfTopLeftCorner; //for Var.x()
			//this.cache.constY = yOfTopLeftCorner;
			//this.cache.constX = yOfTopLeftCorner;
		}
	}

	/*Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var.
	*/
	this.up = optionalParentVar || null;
	if(!this.up && this.name != 'V'){ //FIXME remove this. The V global var is root of all Vars, but someone might rename it something else, who knows. This is a test to find those not in the tree at all 2024-11-21.
		throw new Error('Var not in the tree: '+this.path());
	}
	//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
	//Gobs normally go at height 2. Gob fields height 3.
	this.h = this.up ? this.up.h+1 : 0;
	
	if(this.name=='Y' && this.h==2){
		throw new Error('Var named '+this.name+' as child in namespace. should be 1 deeper.');
	}
	
	//pu is opposite of up aka down.
	//TODO make a {} whose Object.getPrototypeOf is custom built so any field that doesnt exist automatically creates
	//a Var instance as that child with that name and this Var as its parent and its .p of 0 and .v of 0 and other defaults.
	this.pu = {}; //mape of childVar.name to childVar.//this.down = {}; //mape of childVar.name to childVar.
	
	//2025-2-6+ will probably keep Var.ob as it can be Gob or Game instance
	//(like V.testnet.game.getOb() is a Game and sets V.testnet.game.ob and returns from that on next call of getOb()),
	//maybe other types later too. If you just type V.someOtherNamespace567.game.getOb() that should also make a Game instance.
	//TODO this field Var.gob will be removed???, Var class replaces Gob class. parent is this.up. childs are in this.pu.
	//can put same fields in Var as long as they're deriveable by Var.p Var.v Var.name Var.big etc.
	//The root (V) Var, and a namespace Var (like V/blobMonstersGameDefaultNamespace), dont have a Gob.
	//Its 1 layer deeper (theGobVar itself instead of gob.instance), and inside that is gob.vars.
	this.ob = null; //Gob or Game instance, whose parent Var is the same such as V.testnet: this.gob = optionalGob || null;
	
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	//dv is this i think, dont need da: this.da = 0; //da accel. dv velocity. dp position. so dv += da*dt; then dp += dv*dt; so we dont need dt param to accelerate by game.gravY.p.
	this.gr = 0; //same as (negative) .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
	//use this.brain instead: this.evaled = null; //eval of this.big || this.name, a js lambda whose params are all Var objects, those in this.influence.vars or gob.vars
	
	/* A tighter security copy of this.p, that may differ from this.p like by game.sparseUpdate() or game.tryEval(string) etc.
	Decides if its evaled into local game state or removed. Should try to stay equal to this.p if this.y() this.x() is near enough to view.
	
	2025-2-18 mmMain:redesignDisorganizedBuggyTiles2025-2-18+ which led to the creation
	of Var.e and TODO Var.setE(number) or something like that TODO.
	
	Ive probably broken the loading of tiles again but ive got to mmMain:"fix why the tiles are appearing/disappearing approx like they should but at a few hundred pixels past where the gobs appear/disappear at the sparse distance (see sparseUpdate)"

	This whole tile thing is getting too complex. Its time for a small redesign, to get things straight in the design before writing more code. Its too many places things are being stored:
	Var.ob is a QuadTile, which has a square (uint53) and a Quad.
	game.wal is a BigTile containing Tile's.
	tile.dense is a 128x128 byte array.
	tile.sparse is a Quad.
	game.board is modified by a Quad in Tile.prototype.paintGame and it remembers that in tile.lastPaintedQuadOnGame (similar to gob.voxInGame int array but its a Quad instead).

	Theres also autoEval in Var.

	Theres Var.p NOT being used for create/delete at height 2 (V.testnet.objectName.p). State was supposed to be in the Var tree but some parts are not, and its causing an avalanche of cache errors that confusing me and getting way too much stuff tangled.
	Maybe I need a bit field in Var to say if its in the game or not, or a scalar field to say gradually how much, 0 to 1 in the simplest case.
	I recently changed Gob to not change its Var (gob.bo is a Var whose Var.ob is that Gob) when you edit the textarea. The var changes, but its a new Gob. Similarly, I dont want state stored in Tile thats not in Var, which might mean I have to redesign how you paint on BigTile to queue updates in some other structure and do them all at once (before next video frame).

	These redesigns wont be covered here[[[
	wikib upgrades.
	gob.m.isSelected etc put in the Var tree.
	redesign gob.brain funcs to not modify their param Vars and instead be a pure-function (except maybe the mouse gob that reads Controls.mouseY etc) but I dont know how to do that efficiently.
	]]]

	This might turn into a bigger redesign than I thought, but think thru it carefully. In general I think I want to make game.wal (which is a BigTile) be a backing wrapper of the V/Var tree instead of storing out of sync caches of it, and I likely want another upgrade to the Var class which is Var.pExistsInGame but find something smaller to write it as maybe p.e. Yes, lets call it p.e for amount of eval, thats supposed to usually be the same as .p but .e goes thru more security checks, while .p can be changed by merging V tree across internet, its only evaled (TODO) into game.board etc	if !!p.e where p.e is normally 0 or 1. Also, we dont share Var.e across internet cuz its about local views of the Var tree, such as viewing it in a specific game.board game.gobs game.wal etc.
	...
	And im gonna need events to update things whenever .e changes, so .setE func instead of setting .e directly?
	*/
	this.e = 0;
	
	//gp works. it makes the gobs voxels overlap eachother less and bounce better. keep it. now is 2025-1-16.
	//gp: Like -dt*gr (gradient) usually goes into velocity, this part goes into position. p += -dt*gp.
	//This is an experimental field of Var added 2024-11-13 to try to solve that gobs overlap too much, take too long to accel away from eachother,
	//so this should slightly make them instantly jump away from eachother too.
	//I just doubled constraint solving efficiency of Blob Monster Game in 2 lines of code, in Var class:
	//"this.gp = 1.5; //TODO this.gp = 0;" and "let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);".
	//Now they overlap less. https://pic.x.com/7OjEWfA9hC (2024_pic.x.comSLASH7OjEWfA9hC.png)
	//This might be useful as a neuralnet param, built on the loss function it solves toward lower. Ive already live trained a 22 node sigmoid RNN
	//whose output is to recurse 15 cycles then take one node's output as potentialEnergy. Bent it like neural playdough. Havent tried this on it 2024-11-13.
	//--https://x.com/benrayfield/status/1856780041985687963
	//this.gp = 2.3; //TODO this.gp = 0;
	this.gp = DefaultGp;
	if(this.up && this.up.pu[this.name]){
		throw new Error('Duplicate Var, same name, same parent Var');
	}
	//if(this.up) this.up.pu[this.name] = this;
	//tie the new Var into its parent in TWO places
	//** fast own-prop lookup	(thisParent.child)
	//** iteration / filtering (thisParent.pu.child)								 */
	if(this.up){
		this.up.pu[this.name] = this;	 // existing behavior 2025-7-4 and earlier.
		this.up[this.name]	= this;	 // new: direct, non-proxy hit, 2025-7-5+
	}
	
	/*doesnt work, need Proxy: this.get = function(fieldName){
		console.log('fieldName='+fieldName);
		return this[fieldName]!==undefined ? this[fieldName] : this.pU(fieldName); //creates fieldName
	};*/
	
	//has no effect if ps==0. position taRget, like in dagball.Ed having a target ave and strength as a parabola
	this.pr = 0;
	//strength of p toward pr, as pr and ps define a parabola of poten
	this.ps = 0;
	this.cv = 0; //base kv. its cv+kv, not just kv, but kv is set by code dynamicly, and cv is set in the Var.
};

var DefaultEpsilon = window.DefaultEpsilon = 2**-7; //FIXME which scripts (of the 3 in this html) use this?
//var DefaultEpsilon = 2**-12; //FIXME is this small enuf? is it for float32 or float64?

//This should be a little more than the common epsilon of 1 for pixel coordinates (1 pixel over)
//so it can jump a little past that. If its 1, it moves a little too slow. If 2 its noticably jumpy.
//var DefaultGp = 1.5; //normal
var DefaultGp = .2;
//var DefaultGp = 0; //experimental, trying setting this to 0 2024-11-25 to experiment with game.collideSqMul.
//var DefaultGp = 5.5;
//var DefaultGp = 15.5;

Var.prototype.touch = function(){
	this.t = TimeId(); //a unique time, increments by at least 1 ULP.
	return this; //for chaining calls
};

//delete me from the local V/Var tree
Var.prototype.del = function(){
	if(!this.up){
		Err('Already is root V/Var, cant del: '+this.path());
	}
	console.log('Deleting Var path='+this.path());
	delete this.up.pu[this.name];
	//FIXME this.up still exists, so if this.abc.def.ghi still exists then ghi.up.up... will still find this and parents.
};

//copy copyMe.p to this.p, copyMe.v to this.v, etc, but nothing in this.pu (childs) cuz thats not local.
//Its only the fields that count as longterm game state, not temp vars used DURING a physics cycle like this.gr.
//Does not copy .epsilon or .accelMul cuz those are set once in code in the varName/*p v e a*/ syntax,
//which I might change to include pr ps cv and maybe more, but i might leave that to the fieldEditor UI etc.
Var.prototype.copyLocalFrom = function(copyMe){
	this.p = copyMe.p;
	this.v = copyMe.v;
	this.pr = copyMe.pr;
	this.ps = copyMe.ps;
	this.cv = copyMe.cv;
};

Var.prototype.Mn = function(val){
	this.mn = Math.max(this.min,val);
};

Var.prototype.Mx = function(val){
	this.mx = Math.min(val, this.mx);
};

//does both Mn and Mx. Same as setting this.p (after this.nextState(dt)) but if others have set this.mn or this.mx
//and the value this sets it to is not in that allowed range, it does not get set at all. Thats to keep it independent
//of the order Var's are updated, which is less important in Blob Monsters Game than it was in dagball cuz Var is so
//far 2024-11-23 only used in 1 Gob/monster at a time, but in dagball they have EdJoint's. Might add EdJoints here later.
//Var.prototype.MnMx = function(val){
Var.prototype.set = function(val){
	this.mn = Math.max(this.mn,val);
	this.mx = Math.min(val, this.mx);
};

//get namespace
Var.prototype.ns = function(){
	if(this.h <= 1){
		if(this.h == 0) throw Error('This is root Var, which namespaces are childs of.');
		return this;
	}
	return this.up.ns();
};

//gets the Game (like V.testnet.game) of the namespace, even if this is like V.testnet.someGob555
Var.prototype.getGameVar = function(){
	return this.ns().game; //TODO multiple views, each a Game instance.
};

Var.prototype.getGame = function(){
	return this.getGameVar().getOb(); //Game instance
};

//added 2025-7-5, not tested
Var.prototype.z = function(){
	return this.cache.constZ!==undefined ? this.cache.constZ : (this.pu.Z || this.Z).p;
};

Var.prototype.y = function(){
	//Var.constY and .constX are created if isTileString(Var.name)
	//return (this.constY!==undefined) ? (this.constY) : ((this.pu.Y || this.Y).p);
	return this.cache.constY!==undefined ? this.cache.constY : (this.pu.Y || this.Y).p;
};

Var.prototype.x = function(){
	return this.cache.constX!==undefined ? this.cache.constX : (this.pu.X || this.X).p;
};

//used on Var.name or Var.big of a tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
//or the longer form that goes in .big or the shorter form thats a literal instead of a hash after the first $.
var isTileString = s=>/^tile\d{1,16}\$/.test(s);

var tileStringToQuadTile = s=>{ //returns a QuadTile containing all the info in the string. TODO merge some of the code from Tile.toVar() into this.
	/*let i = s.indexOf('$');
	let base64 = s.substring(i+1);
	let tileNum = parseFloat(s.substring('tile'.length, i)); //0 to (2**53)-1, an integer.
	let height = SquareH(tileNum);
	let quadBytes = base64ToBytes(base64);
	return new Quad(height, quadBytes);
	*/
	let square = tileStringToSquare(s);
	return new QuadTile(square, new Quad(SquareH(square), tileStringToBytes(s)));
};

//0 to (2**53)-1, an integer. Use with SquareY SquareX SquareH and Square(h,y,x)
var tileStringToSquare = s=>parseFloat(s.substring('tile'.length, s.indexOf('$')));

var tileStringToH = s=>SquareH(tileStringToSquare(s));

//top Y. 1<<height is y height and x width.
var tileStringToY = s=>SquareY(tileStringToSquare(s));

//left X. 1<<height is y height and x width.
var tileStringToX = s=>SquareX(tileStringToSquare(s));

//is either the sha256 of the .big form or is the bytes for a Quad, so check if its the Var.name vs Var.big.
var tileStringToBytes = s=>base64ToBytes(s.substring(s.indexOf('$')+1));


//lazy create ob (Gob or Game, depending on var path ends with .game or not, todo multiple views/games).
Var.prototype.getOb = function(){
	if(this.ob){
		return this.ob;
	}else{
		if(this.h == 2){
			//raise this.t which is a unique (in this browser tab, not across network) UTC time (TimeId())
			//When multiple QuadTiles are at the same square,
			//TODO uses touch time (QuadTile.bo.t) to keep newest and turn older ones off,
			//but across network (TODO its still just 1 computer as of 2025-2-23) it wont trust .t and syncs by .p mainly.
			//Locally we use .t in some cases to choose .p values, and .e tries (within security rules) to stay equal to .p
			//when near the Y X of the view area, so it should all fit together.
			this.touch();
			let text = this.text();
			if(text.startsWith('(') || text.startsWith('gob$')){
				let game = this.getGame(); //likely a sibling, and game.influence===this.getGameVar()
				//text is a js lambda (brain) whose params if evaled should be Var objects, returns list of int voxels
				//fails cuz text is not evaled, is still a string: return this.ob = new Gob(game, text);
				let jsLambdaAsGobBrain = game.tryEval(text);
				return this.ob = new Gob(game, jsLambdaAsGobBrain);
			}else if(text == 'game'){
				//like V.testnet.game is the default path of the game,
				//but todo multiple games/views at once of each namespace.
				return this.ob = new Game(this);
			}else if(isTileString(this.name)){
				let qt = tileStringToQuadTile(this.big || this.name);
				this.ob = qt;
				qt.bo = this; //QuadTile.bo is its Var. Only if created/loaded by Var will it have a .bo field.
				return qt;
			}else{
				throw new Error('Uknown object type: '+text);
			}
		}else{
			throw new Error('this.h/height is '+this.h+' but Gob and Game go at height 2 (right after namespace at height 1)');
		}
	}
};

//copies from map to Var recursively. Overwrites where existed.
//You can fork world state by loading the part just past the namespace into another namespace you make up,
//which you can do many times per second such as for harmony-search of game states to look for lower poten/potentialEnergy.
//a json map of the kind V.toMap() creates, or subset of it, like you might do V.testnet.load({..parts inside V.testnet..})
//or you might V.load({testnet:{...},otherNamespace5:{...}}). This only copies it into the Var system,
//doesnt eval it (TODO should it? Maybe it will later and this comment not be updated FIXME?).
//
//If optional_isAutoEval is false (or param not given) then it doesnt call Var.eval() after loading,
//so for example if you load a tile it will appear in the Var tree but not in game.board or on screen.
//If you instead use optional_isAutoEval of true, it will do that eval and appear on screen,
//but be careful in that it can lead to remote-code-injection cross-site-scripting etc as the code may have
//come from an untrusted source, a peer to peer network of whatever js code ppl and AIs write as game content.
//To limit the risk of that, it should use game.tryEval(string) but as of 2025-2-17 it just evals nearly everything.
//Another way to limit that risk is to use wikibinator203 instead of javascript as the model of gob.brain code
//which is likely to be a far future upgrade.
Var.prototype.loadMap = function(map, optional_isAutoEval){
	this.p = map.p || 0; //position
	this.v = map.v || 0; //velocity
	if(map.pu){ //childs of any names
		for(let id in map.pu){
			let childMap = map.pu[id];
			//let childVar = this[id]; //reuses if exist, else creates using varProxyHandler as Var is a js Proxy object.
			let childVar = this.pu[id];
			if(!childVar){
				let big = childMap.big || id;
				childVar = this[big];
				if(childVar.name != id){
					Err('Wrong hash. big did not generate expected id of '+id+', from big='+big);
					//you could just do this[id] but that wouldnt create this[id].big which id is derived from.
				}
			}
			childVar.loadMap(childMap, optional_isAutoEval);
		}
	}
	if(optional_isAutoEval){
		console.log('Var.eval() cuz optional_isAutoEval='+optional_isAutoEval+', '+this.path());
		this.eval();
	}
};

Var.prototype.loadJson = function(json, optional_isAutoEval){
	this.loadMap(JSON.parse(json), optional_isAutoEval);
};

Var.prototype.clear = function(map){
	this.nextState(0);
	this.pu = {}; //empty this.pu
};

Var.prototype.toJson = function(excludeBig){
	return JSON.stringify(this.toMap(excludeBig));
};

var Load = json=>{
	let isAutoEval = true;
	V.loadJson(json, isAutoEval);
};

var State = excludeBig=>V.toJson(excludeBig);

/*todo var Save = name=>{
	if(name === undefined){
		name = 'blobMonstersGame_'+time();
	}
	if(!name.includes('.')) name += '.vartree';
	let json = State();
	
};*/

var quicksave = function(name){
	console.log('quicksave '+name);
	localStorage.setItem('monst.'+name, State());
};

var quickload = function(name){
	console.log('quickload '+name);
	let json = localStorage.getItem('monst.'+name);
	if(json){
		Load(json);
	}
};

var saveFile = (fileName, contentType, text)=>{
	var blob = new Blob([text], {type: contentType});
	if(window.navigator.msSaveOrOpenBlob){
		window.navigator.msSaveBlob(blob, fileName);
	}else{
		var elem = window.document.createElement('a');
		elem.href = window.URL.createObjectURL(blob);
		elem.download = fileName;
		document.body.appendChild(elem);
		elem.click();
		document.body.removeChild(elem);
	}
};



//If this is a Tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF,
//then loads it into game.wal (BigTile) and game.board (64 megapixel array of nearest 8k x 8k square
//to game.Y.p game.X.p 2d coordinate where viewing, so careful not to load tile where it would wrap around that as its farther away.
//TODO also load gob if its that, aka its name starts with gob$ . Careful about remote code injection,
//check it for infinite loops, spam redirects of window.location, etc.
Var.prototype.eval = function(){
	if(this.name.startsWith('gob$')){
		//Todo();
		console.log('Ignoring Var.eval() for gob cuz gob puts itself in game.gobs list and has been working as of 2025-2-17, path='+this.path());
	}else if(isTileString(this.name)){
		let quadTile = this.getOb();
		game.wal.tile(quadTile.square).writeSparse(quadTile.quad); //idempotent and fast if that same quad is already there
	}else{
		console.warn('TODO how to load Var='+this.path());
	}
};

/*//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
//Gobs normally go at height 2. Gob fields height 3.
Var.prototype.h = function(){
	return this.up ? (this.up.pathHeight()+1) : 0;
};*/

Var.prototype.toMap = function(excludeBig){
	let ret = {
		p: this.p,
		v: this.v,
		//name: this.name,
		//pu: {},
	};
	if(this.t){
		ret.t = this.t; //UTC time updated. not all code will use this. but each Var is a time-series of 2 numbers: position and velocity.
	}
	if(this.pr){
		ret.pr = this.pr; //target position to spring toward
	}
	if(this.ps){
		ret.ps = this.ps; //spring strength of p toward pr
	}
	if(this.cv){
		ret.cv = this.cv; //base velocity decay, which kv is reset to in Var.nextState(dt)
	}
	if(this.big && !excludeBig){
		ret.big = this.big;
	}
	for(let childName in this.pu){
		let pu = ret.pu || (ret.pu = {});
		pu[childName] = this.pu[childName].toMap(excludeBig);
	}
	return ret;
};

Var.prototype.text = function(){
	return this.big || this.name;
};

const DefaultMaxResults = 2**16;
const DefaultRadiusResults = 2**12;

Var.prototype.allVars = function(optionalListToFill){
	let list = optionalListToFill || [];
	list.push(this);
	for(let childName in this.pu){
		this.pu[childName].allVars(list);
	}
	return list;
};

//returns a list of Var in descending (or is it ascending? is positive good or bad? choose one.) order of goal(theVar)
//which returns a number for how good a match it is. Also limit by exclude negatives (or positives?) from if score is too low?
//Theres an optimization that if optionalMaxResults==1 it doesnt sort an array but just keeps the best in a loop,
//but either way it calls goal on every Var reachable from here.
//TODO optimize more in that case to not even create the array of all Var.
Var.prototype.searchTree = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	let vars = this.allVars();
	if(maxResults == 1){ //n cost
		let bestScore = -Infinity; //FIXME is this reversed from how i vars.sort it?
		let bestVar = null;
		for(let v of vars){
			let score = goal(v);
			if(bestScore < score){
				score = bestScore;
				bestVar = v;
			}
		}
		return bestVar ? [bestVar] : [];
	}else{ //n*log(n) cost
		vars.sort((varA,varB)=>Math.sign(goal(varA)-goal(varB))); //FIXME is this reversed?
		while(vars.length > maxResults) vars.pop();
		return vars;
	}
};

//TODO rename search to searchChilds and have another func searchTree.
//goal(anyVar)->score (FIXME or should it be loss which is -score or someConstant-score?
//As goal, any positive number passes, and any 0 or negative number does not match.
//Sort by that descending, of those which pass.
Var.prototype.search = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	//if(maxResults === undefined) maxResults = DefaultMaxResults;
	let scores = new Map();
	let ret = [];
	for(let n in this.pu){
		let childVar = this.pu[n];
		let score = goal(childVar);
		if(score > 0){
			scores.set(childVar, score);
			ret.push(childVar);
		}
	}
	ret.sort((a,b)=>{
		let scoreA = scores.get(a), scoreB = scores.get(b);
		if(scoreA < scoreB) return -1;
		if(scoreA > scoreB) return 1;
		return 0;
	});
	while(ret.length > maxResults) ret.pop();
	//console.log('Var.search got '+ret.length+' results, goal='+goal);
	/*if(game.gobs.length > 0 && ret.length == 0){ //FIXME remove this
		lastGoalWhenEmpty = goal;
		lastGobsListWhenEmptying = [...(game.gobs)];
	}*/
	return ret;
};

//FIXME rename centerY and centerX in existing game content to Y and X, like game.Y and game.X TODO game.Y and game.X.
//if its on the line, is not included. Has to be less than r distance. This is cuz sorts by a relative distance, and 0 must not be included.
Var.prototype.searchZYXR = function(z, y, x, r, maxResults){
	if(r === undefined) r = DefaultRadiusResults;
	//const rr = r*r;
	return this.search(
		vr=>{
			//return rr - ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
			let distSq = (vr.z()-z)**2 + (vr.y()-y)**2 + (vr.x()-x)**2;
			let dist = Math.sqrt(distSq);
			return dist;
			
			
			
			
			
			
			
			
			
			
			
			
			
			//FIXME this isnt cutting it off (by being 0 or less) at r aka radius.
			
			
			
			
			
			
			
			
			
			
			
			//let d = rr - ((vr.z()-z)**2 + (vr.y()-y)**2 + (vr.x()-x)**2);
			//return d;
			//return -d;
		},
		maxResults);
};

//makes a new goal that also	requires it be within r distance of (y,x) (not on the line).
Var.prototype.searchYXRGoal = function(y, x, r, goal, maxResults){
	const rr = r*r;
	return this.search(vr=>{
		//let isNear = rr > ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		//in case [the Var whose Var.ob is a QuadTile] doesnt have Y and X child Vars,
		//since its implied by the first number in Var.big in that case (see SquareY and SquareX funcs and tileSize).
		//See Var.constY and Var.constX which Var.y() and Var.x() use if they exist.
		let isNear = rr > ((vr.y()-y)**2 + (vr.x()-x)**2);
		if(!isNear) return 0;
		return goal(vr);
	}, maxResults);
};

Var.prototype.if0 = function(newP){
	if(!this.p) this.p = newP;
	return this;
};

Var.prototype.setNow = function(newP, optionalNewV){
	this.p = newP;
	if(optionalNewV !== undefined) this.v = optionalNewV;
	return this;
};

//const hashIdLen = ('sha256$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
const hashIdLen = ('gob$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
//
//FIXME theres gob$hash and tile9007199254595405$hash and tile9007199254595405$literalIfSmall,
//so should hashIdLen be renamed to minHashIdLen?


//TODO what should this limit be?
//If its longer	than this, auto hashes it and uses the hash (prefixed by what, in case it starts with a digit etc?)
//as the Var.name and the content hashed as the Var.big.
//so u can know if its a hash or not by its length. or could check for any chars then $ like sha256$thehash.
const MaxLiteralNameLen = hashIdLen-1;

const isLowercase = c=>(c >= 'a' && c <= 'z');

//get or create child Var
Var.prototype.pU = function(nameOrBig){
	if(isLowercase(nameOrBig[0])){
		Err('Child Vars cant start with lowercase letter, such as toString p v or you gave: '+nameOrBig);
	}
	let ret;
	if(nameOrBig.length <= MaxLiteralNameLen && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(nameOrBig)){ //TODO make this condition be a func
		ret = this.pu[nameOrBig] || new Var(this, nameOrBig, null, this.ob||null); //auto puts it in this.pu[string]
	}else{
		//let hash = hashStringToHex(nameOrBig);
		let name = hashStringToBase64(nameOrBig); //todo dont hash if its small enuf to be a literal id (dont use .big)
		/*if(nameOrBig.startsWith('mutid$')){ //FIXME 2025-1-9 removed the mutid$ prefix of tiles, so am not using it for anything.
			let i = nameOrBig.indexOf('$','mutid$'.length);
			if(i!=-1){ //found next $ like in mutid$tile3534523423$...
				name = nameOrBig.substring(i+1)+name; //mutid$tile3534523423$234324hash345345
			}else Err('no second $ found in mutid$...');
		*/
		//TODO this is likely blobMonstersGame Gob code not relevant to bellsack:
		if(nameOrBig.startsWith('tile')){ //like tile1971583262467328$ then base64 of its Quad bytes, if small, else then base64 of hash of that.
			if(isValidVarName(nameOrBig) && nameOrBig.length < 64){
				//considering size of tile1971583262467328$ (size 21) and 43 digits of sha256 base64 (21+43==64),
				//if its smaller then use it directly, else hash it.
				//isValidVarName might let vars be bigger like 100, but i havent used it much and am experimenting. Might need those bigger vars.
				name = nameOrBig;
			}else{ //FIXME this isnt running for nontiles, like anyPrefixblahblah4325$stufftohash
				let i = nameOrBig.indexOf('$');
				if(i == -1) Err('No $ after tile in var name');
				let prefix = nameOrBig.substring(0,i+1); //like tile1971583262467328$
				name = prefix+name; //like tile1971583262467328$thenbase64ofsha256ofdotbig
				
				//example:
				//tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF is the name of big:	//tile1971585409951104$qjB$pzN$oUR$$$2GwV$$$Bo$$$28$$$$lF$$$3k$pUg$oz$$oUc$nRJ$$$0BIBJ$I3lBIBZ$lF$$$3k$I3k$oUAClF$$$3lBlF0B$3lBI3lB$CArnF28$$$$lF$$$3k$$3k$oUQ8I3n4I3k$I3lBmRJ$I$0BI$0BI$2HyF2Hx$2Gzk2GygZ$lJlB$3k$$3k$nRJ$I$0BI$24I3k$I$$$$$$$$$
			}
			//TODO generate this.Y.p and this.X.p to be derived from SquareY and SquareX of 1971585409951104 like in tile1971585409951104$,
			//but dont let them change and dont spend time computing what if they change during physics. Tiles are constants.
			
			//My 128x128 game tiles have hash ids like this. The first number tells a power
			//of 2x2 size, y, and x: tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
			//Then 43 base64 digits of sha256 of the quadtree compressed content, which is normally a few hundred bytes.
		}else{
			//name = 'sha256$'+name; //no special prefixing
			name = 'gob$'+name; //no special prefixing
		}
		//ret = this.pu[name] || new Var(this, name, nameOrBig, this.gob||null); //auto puts it in this.pu[string]
		ret = this.pu[name] || new Var(this, name, nameOrBig, this.ob||null); //auto puts it in this.pu[string]
	}
	//TODO this is likely blobMonstersGame Gob code not relevant to bellsack:
	if(ret.big && ret.big.startsWith('(')){ //likely a js function string
		let listOfLists = getParamNames(ret.big);
		if(listOfLists.length){
			ret.vars = []; //same order as in gob.vars, a list instead of the .pu {} of paramName to Var. Vars either way.
			for(let list of listOfLists){
				let paramName = list[0]; //TODO if theres more stuff in it, do whats normally done after getParamNames, fill in .p .v .epsilon andOr .accelMul etc.
				ret.vars.push(ret.pU(paramName));
			}
		}
	}
	return ret;
};

Var.prototype.think = function(){
	let brain = this.brain || (this.brain = eval(this.big || this.name));
	//no this is done in Gob.think: this.extraThink(); //do game.gravY.p etc.
	return brain(...(this.vars)); //list or Int32Array of int voxels. See YXC IY IX YXRGB etc funcs for int voxels.
};

const varProxyHandler = {
	/*get(target, prop, receiver){ //works 2025-7-4
		if(typeof(prop) === 'symbol'){
			return Reflect.get(target, prop, receiver);
		}
		return target[prop] || receiver.pU(prop);
	},*/
	//2025-7-5 moving varProxyHandler to be prototype of prototype of each Var instance, so .toString etc stay in its prototype.
	//If a childName is not found, creates it in thisVar.childName and in thisVar.pu.childName which point at the same Var,
	//so thisVar.pu.childName doesnt create it and theres some syntax thisVar.pu.?childName maybe, that can chain it get undefined at end.
	get(target, prop, receiver){
		if(typeof(prop) === 'symbol'){
			return Reflect.get(target, prop, receiver);
		}
		//return target[prop] || receiver.pU(prop);
		/*GPT-o3 says why change receiver.pU(prop) to target.pU.call(receiver, prop)
		-	 const child = target.Pu.call(receiver, prop);
		+	 const child = target.pU.call(receiver, prop);
			return child;
		}
		❓ Why not receiver.pU(prop)?
		When the instance (receiver) looks for pU, it doesn’t have an
		own-property, so the engine would walk up the prototype chain:
		VarPrototype → VarProxy → …
		That walk would re-enter the same proxy trap we’re executing right
		now, leading to an extra hop (and, in some cases, an infinite loop
		if guards were missing).

		By calling target.pU.call(receiver, …) we:

		grab the already-known method reference directly from the
		plain object that is the proxy’s target (VarPrototype),

		bind this to the real instance (receiver),

		avoid any second trip through the proxy machinery.

		This keeps the “first-touch” cost to one proxy invocation and guarantees
		that all subsequent property reads hit the freshly cached
		this[childName] own-property at plain-object speed.
		*/
		//return target[prop] || target.pU.call(receiver,prop);
		
		//Prototype-owned props (pU, path, toString, …)
		//if(prop in target){
		//	return target[prop];
		//}
		//Prototype-owned methods (pU, path, toString, …)
		//if(prop in Var.prototype){
		//	return Var.prototype[prop];
		//}
		
		
		/*//Already-materialised child (own-prop on the instance)
		const cached = Reflect.get(receiver, prop, receiver);
		if(cached !== undefined){
			return cached;
		}
		that caused infinite loop
		V.hello
		bellsack161.html:2384 Uncaught RangeError: Maximum call stack size exceeded
		at Reflect.get (<anonymous>)
		at Object.get (bellsack161.html:2384:26)
		at Reflect.get (<anonymous>)
		at Object.get (bellsack161.html:2384:26)
			Here’s the one-line fix that stops the infinite recursion.
		(Only the get trap is touched.)

		diff
		Copy
		Edit
		@@
		-		//Already-materialised child (own-prop on the instance)
		-		const cached = Reflect.get(receiver, prop, receiver);
		-		if(cached !== undefined){
		-			return cached;
		-		}
		+		//Already-materialised child (own-prop on the *instance*) – check without climbing the
		+		//prototype chain so we don’t re-enter this proxy trap.
		+		if (Object.prototype.hasOwnProperty.call(receiver, prop)) {
		+			return receiver[prop];
		+		}
		*/
		//Already-materialised child (own-prop on the *instance*) – check without climbing the
		//prototype chain so we don’t re-enter this proxy trap.
		if(Object.prototype.hasOwnProperty.call(receiver, prop)){
			return receiver[prop];
		}
		
		//First-touch child: create & cache via pU
		//return target.pU.call(receiver, prop);
		//First-touch child — use receiver.pU; the lookup
		//resolves on Var.prototype and never re-enters the proxy.
		return receiver.pU(prop);
	},
};

//Var.prototype = new Proxy(Var.prototype, varProxyHandler);
const VarProxy	 = new Proxy(Object.create(null), varProxyHandler);
Object.setPrototypeOf(Var.prototype, VarProxy); //2025-7-5 changing from Var being a Proxy to "instance → proto → proxy".


//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p is probably more efficient.
	return this.p;
};

Var.prototype.path = function(){
	return this.up ? this.up.path()+'.'+this.name : this.name;
};

Var.prototype.toString = function(){
	return this.path();//return this.up ? this.up.toString()+'.'+this.name : this.name;
	//return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

Var.prototype.nextState = function(dt){
	if(dt){
		//use someVar.nextState(0) to clear someVar.kv someVar.dp etc, without modifying someVar.p or .v etc.
		//For use during gradient of things that might happen but have not decided to make them happen.
		
		//this.v = 0; //FIXME
		//let nextP = this.p + dt*(this.v+this.dp);
		if(this.pr){
			//this.gr += TODO something about this.pr and this.ps as parabola.
			//let positionDiff = this.pr-this.p; //FIXME is this backward? accel negative gradient
			let positionDiff = this.p-this.pr; //FIXME is this backward? accel negative gradient
			let partOfGradientFromParabola = positionDiff*this.ps; //TODO divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ???
			//let partOfGradientFromParabola = positionDiff/2*this.ps; //TODO verify this /2 is correct (vs /4 or *2 or sqrt2, etc, or just leave it as is): divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ???
			this.gr += partOfGradientFromParabola;
			//this.poten += this.ps*positionDiff*positionDiff;
		}
		if(opt.oneBitPerDimGradient){ //FIXME this is outside the Var script, is part of Bellsack script, so shouldnt be here.
			if(this.gr < 0) this.gr = -opt.oneBitPerDimGradientVal;
			if(this.gr > 0) this.gr = opt.oneBitPerDimGradientVal;
			//3 possible values
		}
		let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);
		if(this.mn <= this.mx){
			nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
		}
		let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
		//let nextV = 0; //FIXME
		
		
		//let changePAmount = Math.abs(this.p-nextP);
		//if(changePAmount > 100 && this.ob==cShapedGob){ //FIXME remove this
		//	console.log('Var '+this.path()+' changePAmount='+changePAmount);
		//}
		
		this.p = nextP;
		this.v = nextV;
	}
	//this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.kv = this.cv; //cv is base kv. velocity decay per second continuously.
	this.dp = this.dv = this.poten = 0; //OLD: leave this.gr as is, since its not a sum, is just set all at once in one of the doPhysics funcs.
	this.prevGr = this.gr; //for debugging. has no effect on physics. previous gradient.
	this.gr = 0; //cuz in blobMonstersGame gr was set in doPhysicsA, but here we dont have that func.
	this.mn = -Infinity;
	this.mx = Infinity;
};

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = funcOrStr=>{
	const fnStr = funcOrStr.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
		.map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
	return params.map(match => {
		const [_, name, comment] = match;
		const numbers = comment ? comment.match(/\d+/g) : [];
		return [name, ...(numbers || []).map(Number)];
	});
};

Var.prototype.setOb = function(gobOrGame){
	this.ob = gobOrGame;
	return this;
};


//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

//this uses js digits. i prefer dvBase64Digits cuz they are all valid in js var names and are in ascending order.
//dagball.bytesToBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

//bytesToBase64 = bytes=>jsBase64ToDvBase64(btoa(String.fromCharCode.apply(null, bytes))); //returns string


//use this one cuz its sorted by utf8 and ascii except = padding
const dvBase64Digits = '$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz=';
//This is whats made by javascript atob and btoa funcs. This one is only used internally for atob and btoa
const jsBase64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var bytesToJsBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

var jsBase64ToBytes = base64=>{ //returns Uint8Array
	const binaryString = atob(base64);
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
};

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

//dvBase64Digits and Uint8Array
var base64ToBytes = function(base64){
	return jsBase64ToBytes(dvBase64ToJsBase64(base64));
};
	
//dvBase64Digits and Uint8Array
var bytesToBase64 = function(bytes){
	return jsBase64ToDvBase64(bytesToJsBase64(bytes));
};

var digitJsToDv = {}; //transforms between 2 sets of base64 digits
var digitDvToJs = {};
for(let i=0; i<65; i++){ //last digit is = for padding, but dv base64 doesnt use it. js base64 does.
	let jsDigit = jsBase64Digits[i];
	let dvDigit = dvBase64Digits[i];
	digitJsToDv[jsDigit] = dvDigit;
	digitDvToJs[dvDigit] = jsDigit;
}

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

var dvBase64ToJsBase64 = function(dvBase64){
	let s = ''; //TODO char array or something is faster?
	for(let i=0; i<dvBase64.length; i++){
		s += digitDvToJs[dvBase64[i]];
	}
	while(s.length&3){ //while not a multiple of 4
		s += '='; //pad
	}
	return s;
};

var testBase64ToFromBytes = ()=>{
	let listOfByteArrays = [Uint8Array.of(2,3,17,255,254,3,3,2,171,170,199),Uint8Array.of(10),Uint8Array.of(),Uint8Array.of(1,2,3,4),Uint8Array.of(1,2,3,4,5),Uint8Array.of(1,2,3,4,5,6),Uint8Array.of(1,2,3,4,5,6,7)];
	for(let testNum=0; testNum<listOfByteArrays.length; testNum++){
		let bytes = listOfByteArrays[testNum];
		let b64 = bytesToBase64(bytes);
		let bytesRebuilt = base64ToBytes(b64);
		if(bytes.length != bytesRebuilt.length) Err('bytesRebuilt different len');
		for(let i=0; i<bytes.length; i++) if(bytes[i] != bytesRebuilt[i]) Err('bytes[i] != bytesRebuilt[i] i='+i);
		console.log('testBase64ToFromBytes_'+testNum+' test pass, bytes='+[...bytes].join(',')+' base64='+b64);
	}
};
testBase64ToFromBytes();

//TODO rewrite these comments:
//return 192 <= bytes[offset];
//return QFORK <= bytes[offset]; //QFORK is just below the line, of things above fork and things below dont. its an opcode to fork without knowing the length yet.
var byteHasChilds = byt=>(QFORK <= byt);
//var hasChilds = (bytes, offset)=>byteHasChilds(bytes[offset]);

var hashStringToHex = function(str){
	return bytesToHex(sha256(stringToBytes(str)));
};
var hashStringToBase64 = function(str){
	//return dagball.bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
	return bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
};
var utf8TextEncoder = new TextEncoder('utf-8');
var utf8TextDecoder = new TextDecoder('utf-8');
var stringToBytes = function(s){ return utf8TextEncoder.encode(s); };
var bytesToString = function(bytes){ return utf8TextDecoder.decode(bytes); };
var hexDigits = '0123456789abcdef'.split('');
var mapOfHexDigitToInt = {}; //vals are 0 to 15. filled in boot.
var mapOfDoubleHexDigitsToInt = {}; //vals are 0 to 255. filled in boot.
var bytesToHex = function(bytes){ return bytesAndRangeToHex(bytes,0,bytes.length); };
var doubleHexDigits = [];
for(let i=0; i<16; i++){
	mapOfHexDigitToInt[hexDigits[i]] = i;
	for(let j=0; j<16; j++){
		let hh = hexDigits[i]+hexDigits[j];
		doubleHexDigits.push(hh);
		mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
	}
};
var bytesAndRangeToHex = function(bytes,from,toExcl){
	let s = '';
	for(let i=from; i<toExcl; i++) s += doubleHexDigits[bytes[i]];
	return s;
};

//Var class was copied 2025-4-16 from blobMonstersGame_2025-3-27.html then modified TODO...
//blobMonstersGame used V.testnet. BellSack/LamGL will use V.bellsack.room1 or V.bellsack.makeUpARoomName etc,
//and V.htmls to put the html in,
//like v.htmls.sha256$9dda0dee909c8e96c82caf183cd938a1e07c23c9c79c06d5b53e626b36b54efc.big = '<html>...</html>' will load in iframe here,
//but only whichever of them has nonzero (or highest?) v.htmls.someHtml24353245.p.
//
//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = window.V = new Var(null, 'V'); //var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob)

</script>
<script>
"use strict";

var Err = msg=>{ throw new Error(msg); };

/***************************************************************
 * 1) Config
 ***************************************************************/

const opt = {
	//horizon: 60.0,			// how far to search for surfaces
	horizon: 60.0,			// how far to search for surfaces
	isRaymarch: 1,		 // variable-step or fixed-step
	//isRaymarch: 0,
	//raytraceStep: .2,
	raytraceStep: .1,
	//raytraceStep: .03,
	//marchMaxSteps: 50,	 // maximum steps
	//marchMaxSteps: 200,	 // maximum steps
	//marchMaxSteps: 40,	 // maximum steps
	marchMaxSteps: 200,	 // maximum steps
	//marchMaxSteps: 100,	 // maximum steps
	closeEnufToZero: 0.001, // tolerance for crossing
	//closeEnufToZero: 0.00001, // tolerance for crossing
	//circleBandPx: 1.5,		// ring thickness in screen px
	//circleBandPx: 7, //fat
	circleBandPx: 4, //normal
	//circleBandPx: 2, //thin
	//circleBandPx: 1,
	//circleBandPx: 0, //dont display rings
	//circleBandPx: 0,
	knobAngleBand: 0.15,	// how wide an angle for each knob (approx)
	//TOTAL_BELLS: 100000,
	//TOTAL_BELLS: 10000,
	TOTAL_BELLS: 10000,
	//TOTAL_BALLS: 22000,
	TOTAL_BALLS: 2000,
	//TOTAL_BALLS: 80,
	//TOTAL_BALLS: 300,
	//TOTAL_BALLS: 30,
	//TOTAL_BALLS: 150,
	//TOTAL_BALLS: 80,
	//NEAR_TOTAL: 192,
	//NEAR_TOTAL: 100,
	//NEAR_TOTAL: 170,
	//NEAR_TOTAL: 10, //FIXME
	NEAR_TOTAL: 50, //each (simplest kind of) bell is 5 floats
	//NEAR_TOTAL: 100, //each (simplest kind of) bell is 5 floats
	//NEAR_BALLS_TOTAL: 150,
	NEAR_BALLS_TOTAL: 50, //each (simplest kind of) ball is 3 floats10
	//NEAR_BALLS_TOTAL: 300, //each (simplest kind of) ball is 3 floats
	//NEAR_BALLS_TOTAL: 30, //each (simplest kind of) ball is 3 floats
	//NEAR_BALLS_TOTAL: 10,
	KNOB_COUNT: 5,
	//displayCenterForwardOfCam: -4, //test
	displayCenterForwardOfCam: 0, //test
	//displayCenterForwardOfCam: 4, //normal
	displayTerrain: true, //normal
	//displayTerrain: false, //test
	color1: [1.0,0.2,0.2],
	color2: [0.2,1.0,0.2],
	color3: [0.2,0.2,1.0],
	doLamglLoopBody: true, //normal, tho havent got it to work as of 2025-6-29
	//doLamglLoopBody: false, //test
	//logGlvars: true, //test
	logGlvars: false, //normal
	//logGlvarsDetail: true, //test
	logGlvarsDetail: false, //normal
	//logShaderCodeEveryTime: true, //test
	logShaderCodeEveryTime: false, //normal
	doPhysics: true, //normal soon after 2025-7-12 cuz adding physics code...
	//doPhysics: false, //test
	//oneBitPerDimGradient: true, //test. should make balls ignore magnitude of gradient per dimension and use opt.oneBitPerDimGradientVal vs -opt.oneBitPerDimGradientVal instead
	oneBitPerDimGradient: false, //normal
	//oneBitPerDimGradientVal: 20,
	oneBitPerDimGradientVal: 1,
};

const bellsackStartLoadingTime = Lamgl.time();

// region to place random bellcurves
//const WORLD_SIZE = 70;
const WORLD_SIZE = 30;
//const WORLD_SIZE = 40;
//const WORLD_SIZE = 25;

//use this as x y and z position for things not to display or do physics on
//such as empty slots in "uniform vec3 ballXYZ[${opt.NEAR_BALLS_TOTAL}];".
const NULLXYZ = 1000000;

/***************************************************************
 * 2) Large set of bellcurves + a spatial grid
 ***************************************************************/

function pickRandomColor() {
	let r = Math.floor(128 + 128 * Math.random());
	let g = Math.floor(128 + 128 * Math.random());
	let b = Math.floor(128 + 128 * Math.random());
	return `rgb(${r},${g},${b})`;
}

class BellCurve {
	constructor(x, y, z, radius, strength, isSelected) {
	this.x = x;
	this.y = y;
	this.z = z;
	this.radius = radius;
	this.strength = strength;
	// We'll store an integer color in [0..255] x 3 for convenience
	// or store it as random floats in [0..1], or just store a string and parse it in JS.
	// We'll store as random floats 0..1 so we can pass them to GPU if we want.
	// But for big sets we might skip it. For demonstration, let's store them anyway:
	this.colorR = 0.5 + 0.5 * Math.random();
	this.colorG = 0.5 + 0.5 * Math.random();
	this.colorB = 0.5 + 0.5 * Math.random();
	this.isSelected = !!isSelected;
	}
}

var Dom = id=>document.getElementById(id);

var doTestDisplay = ()=>{
	const isSparse = document.getElementById('testDisplayIsSparseXY').checked;
	const bigLog = document.getElementById('testDisplayLogsBigTensor').checked;
	Lamgl.testDisplay(isSparse, bigLog, Lamgl.time());
	if(document.getElementById('continueTestDisplay').checked){
		requestAnimationFrame(doTestDisplay);
	}
};

class SpatialGrid {
	constructor(cellSize) {
	//this.cellSize = cellSize;
	//this.cells = new Map();
	this.bellList = []; //FIXME remove this when get SpatialGrid working
	}
	/*_cellKey(x,y,z) {
	let ix = Math.floor(x/this.cellSize);
	let iy = Math.floor(y/this.cellSize);
	let iz = Math.floor(z/this.cellSize);
	return `${ix},${iy},${iz}`;
	}*/
	insert(bc) {
	/*let k = this._cellKey(bc.x, bc.y, bc.z);
	if(!this.cells.has(k)) this.cells.set(k, []);
	this.cells.get(k).push(bc);
	*/
	this.bellList.push(bc);
	}
	queryNearby(cx,cy,cz, range){
	let ret = [];
	let rangeSq = range**2;
	for(let bell of this.bellList){
		if((bell.x-cx)**2 + (bell.y-cy)**2 + (bell.z-cz)**2 <= rangeSq){
			ret.push(bell);
		}
	}
	return ret;
	/*
	const minX = Math.floor((cx-range)/this.cellSize);
	const maxX = Math.floor((cx+range)/this.cellSize);
	const minY = Math.floor((cy-range)/this.cellSize);
	const maxY = Math.floor((cy+range)/this.cellSize);
	const minZ = Math.floor((cz-range)/this.cellSize);
	const maxZ = Math.floor((cz+range)/this.cellSize);
	let arr=[];
	for(let ix=minX; ix<=maxX; ix++){
		for(let iy=minY; iy<=maxY; iy++){
		for(let iz=minZ; iz<=maxZ; iz++){
			let key=`${ix},${iy},${iz}`;
			if(this.cells.has(key)){
			arr.push(...this.cells.get(key));
			}
		}
		}
	}
	return arr;
	*/
	}
}

let allBells=[];
let spatialGrid=null;

let NS = V.Bellsack.Room1; //FIXME make this a url param or something
let Balls = NS.Balls;

let nextBallNameSuffix = 1;

var newBallName = ()=>('B'+(nextBallNameSuffix++));

function buildWorld(){
	spatialGrid=new SpatialGrid(10);
	for(let i=0; i<opt.TOTAL_BELLS; i++){
		let x = (Math.random()-0.5)*WORLD_SIZE;
		let y = (Math.random()-0.5)*WORLD_SIZE;
		let z = (Math.random()-0.5)*WORLD_SIZE;
		let r = 0.2+ 0.3*Math.random();
		let s = Math.random()*2.0-1.0;
		let bc= new BellCurve(x,y,z,r,s,false);
		allBells.push(bc);
		spatialGrid.insert(bc);
	}
	console.log("Created", allBells.length, "bellcurves in", WORLD_SIZE, "^3 region");
	
	let ballSpread = WORLD_SIZE;
	ballSpread = 7; //FIXME
	for(let i=0; i<opt.TOTAL_BALLS; i++){
		let ball = Balls[newBallName()];
		ball.X.p = (Math.random()-0.5)*ballSpread;
		ball.Y.p = (Math.random()-0.5)*ballSpread;
		ball.Z.p = (Math.random()-0.5)*ballSpread;
		//ball.X.p = 0;
		//ball.Z.p = 0;
		
		/*let fract = i/opt.TOTAL_BALLS;
		ball.X.p = fract*ballSpread;
		ball.Y.p = fract*ballSpread;
		ball.Z.p = fract*ballSpread;
		*/
		//ball.R.p = (.5+.5*Math.random()); //red
		//ball.G.p = (.5+.5*Math.random()); //green
		//ball.B.p = (.5+.5*Math.random()); //blue
	}
}
buildWorld();

/***************************************************************
 * 3) WebGL Setup
 ***************************************************************/

/*let canvas = document.getElementById("glCanvas");
let gl = canvas.getContext("webgl2");
if(!gl){
	alert("WebGL2 not found!");
}*/

/***************************************************************
 * 4) compileShader & createProgram
 ***************************************************************/

/*function compileShader(gl, type, src){
	let s=gl.createShader(type);
	gl.shaderSource(s, src);
	gl.compileShader(s);
	if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
	console.error("Shader compile error:", gl.getShaderInfoLog(s));
	throw new Error("Shader compile fail");
	}
	return s;
}
function createProgram(gl, vsSrc, fsSrc){
	let vs= compileShader(gl, gl.VERTEX_SHADER, vsSrc);
	let fs= compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
	let p= gl.createProgram();
	gl.attachShader(p, vs);
	gl.attachShader(p, fs);
	gl.linkProgram(p);
	if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
	console.error("Program link error:", gl.getProgramInfoLog(p));
	throw new Error("Program link fail");
	}
	return p;
}*/

/***************************************************************
 * 5) Single-Pass FS: Raymarch + Billboard Circles + GPU knobs
 ***************************************************************/

const vsSource = `#version 300 es
in vec2 XY; //in vec2 position; If you call it "in vec2 XY;" then Lamgl does 2 triangles instead of gl_ VertexID.
//uniform int width;
out vec2 uv;
//out int ID;
void main(){
	//cant do this cuz its TRIANGLES instead of POINTS so theres too few vertexs, so use ID.x instead: ID = gl _VertexID; //so VarGradientGL generated sf/fragmentShader can use it
	uv = XY * 0.5 + 0.5;
	//ID = int(uv.x*float(width)); //range 0 to width-1
	gl_Position = vec4(XY, 0,1);
}`;

// We'll define NEAR_TOTAL = opt.NEAR_TOTAL
// We'll do a ring search for each bell & also a local tangent-plane transform
// to see if it's near 1 of the 5 knob angles, coloring them differently.
const fsSourceMaker = isPhysicsElseGraphics=>(`#version 300 es
precision highp float;
${isPhysicsElseGraphics?'//physics':'//graphics'}
in vec2 uv;
//in int ID; //int x from 0 to width-1, and since height=1 its pixel index
out vec4 outColor;

//uniform int width;
uniform float width; //FIXME make it int, but this might be crashing gl as int cuz Lamgl doesnt support uniform int vars yet?
//ID: range 0 to width-1. set in main(). Used by generated VarGradientGL.
//FIXME the generated VarGradientGL code goes at first line in main()
//which would be before ID is set in main(), so need to generate ID too
int ID; //FIXME this should be generated in perturbGlsl, not manually written here.

uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform float horizon;
uniform float isRaymarch;
uniform float closeEnuf;
uniform float circleBandPx;
uniform float knobAngleBand;	// how large an angle difference to consider a knob
uniform int selectedBellI; //-1 if none. 0 to NEAR_TOTAL-1 if selected.

uniform float mouseY;
uniform float mouseX;

uniform vec3 bellPositions[${opt.NEAR_TOTAL}];
uniform float bellRadii[${opt.NEAR_TOTAL}];
uniform float bellStrengths[${opt.NEAR_TOTAL}];

//VarGradientXYZ does not support vec3 uniforms, but its ok to have vec3s where
//we are not computing gradient. We compute it in ballXYZ (changing to ballX ballY ballZ)
//but not in "uniform vec3 color2;" etc.
//uniform vec3 ballXYZ[${opt.NEAR_BALLS_TOTAL}];
uniform float ballX[${opt.NEAR_BALLS_TOTAL}];
uniform float ballY[${opt.NEAR_BALLS_TOTAL}];
uniform float ballZ[${opt.NEAR_BALLS_TOTAL}];

// We'll do no per-bell color for now, just ring vs knob vs surface. 
// If you want each bell to have a random color, you'd need arrays for that.
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;

const int MARCH_MAX_STEPS = ${opt.marchMaxSteps};
const int NEAR_TOTAL = ${opt.NEAR_TOTAL};
const int KNOB_COUNT = ${opt.KNOB_COUNT};

//const float	BALL_R	 = 2.35;				 // TODO: make this a uniform array
//const float	BALL_R	 = .7;				 // TODO: make this a uniform array
const float	BALL_R	 = 0.135;				 // TODO: make this a uniform array
const float	BALL_R2	= BALL_R * BALL_R;		// radius², used in c term

const int NEAR_BALLS_TOTAL = ${opt.NEAR_BALLS_TOTAL};
uniform float numBalls; //at most NEAR_BALLS_TOTAL, ignore higher indexed balls, its padding

const float NULLXYZ = ${Lamgl.jsNumToGlslFloat(NULLXYZ)};

//#define EPSILON ${Lamgl.jsNumToGlslFloat(DefaultEpsilon)}
const float EPSILON = ${Lamgl.jsNumToGlslFloat(DefaultEpsilon)};

float sumOfBellcurves(in vec3 p){
	float val=0.0;
	for(int i=0;i<NEAR_TOTAL;i++){
	vec3 d = p - bellPositions[i];
	float dist2= dot(d,d);
	val += bellStrengths[i]* exp(-dist2/(2.0 * bellRadii[i]* bellRadii[i]));
	}
	return val;
}

//sum of all the species/codeTypes, including the 5 float 3d bellcurves.
float densityAtXYZ(in vec3 xyz){
	float density = sumOfBellcurves(xyz);
	//TODO add other species/codeTypes here.
	return density;
}

// Regular-tetrahedron directions (all pair-wise equidistant)
const vec3 v0 = vec3( 1.0,  1.0,  1.0);
const vec3 v1 = vec3(-1.0, -1.0,  1.0);
const vec3 v2 = vec3(-1.0,  1.0, -1.0);
const vec3 v3 = vec3( 1.0, -1.0, -1.0);

//∇density using ONE tetrahedron  ⇢ 4 texture reads instead of 6
vec3 gradientAtXYZ(in vec3 p){
    // Sample the scalar field at the four vertices
    float d0 = densityAtXYZ(p + EPSILON*v0);
    float d1 = densityAtXYZ(p + EPSILON*v1);
    float d2 = densityAtXYZ(p + EPSILON*v2);
    float d3 = densityAtXYZ(p + EPSILON*v3);

    // Re-combine to isolate each partial derivative
    return vec3(
        (d0 - d1 - d2 + d3),   // ∂/∂x*4
        (d0 - d1 + d2 - d3),   // ∂/∂y*4
        (d0 + d1 - d2 - d3)    // ∂/∂z*4
    )/(4.*EPSILON);
}

// Positive outside, negative inside.
float signedDistanceToBallsAtXYZExcludingBallIndex(in vec3 fromXYZ, in int excludeBallIndex){
	float minSignedDistance = NULLXYZ; //big positive
	for(int bi=0; bi<NEAR_BALLS_TOTAL; bi++){
		if(bi != excludeBallIndex){
			vec3 otherXYZ = vec3(ballX[bi],ballY[bi],ballZ[bi]);
			float centerToCenterDistance = length(fromXYZ-otherXYZ);
			//float signedDistance = centerToCenterDistance-2.*BALL_R; //TODO balls can have diff radius than eachother?
			float signedDistance = centerToCenterDistance-BALL_R; //only 1 ball. TODO balls can have diff radius than eachother?
			minSignedDistance = min(minSignedDistance, signedDistance);
		}
	}
	return minSignedDistance;
}

// Positive outside, negative inside.
float signedDistanceToIsosurfaceAtXYZ(in vec3 p0){
    vec3  p   = p0;
    float sd  = densityAtXYZ(p);           // initial guess
	float speed = .1;
    for(int i = 0; i < 32; ++i){            // 4 Newton steps ≈ 8-10 × faster
        vec3  g   = gradientAtXYZ(p);
        float gL  = length(g) + 1e-9;      // avoid /0
        float step= sd / gL;               // project onto iso-normal
        p       -= g * (step / gL) * speed;
        sd       = densityAtXYZ(p);
    }
	float distance = length(p0-p);
	return sign(sd)*distance;
    //return sd;
}

//balls and surface, excluding ballX[excludeBallIndex] ballY ballZ, which you can give -1 to not exclude any balls.
float signedDistanceAtXYZExcludingBallIndex(in vec3 fromXYZ, in int excludeBallIndex){
	return min(signedDistanceToIsosurfaceAtXYZ(fromXYZ),
		signedDistanceToBallsAtXYZExcludingBallIndex(fromXYZ,excludeBallIndex));
}

//min distance from surface of ball to every point inside the isosurface volume and every point inside other balls.
float signedDistanceOfBall(in int ballIndex){
	return signedDistanceAtXYZExcludingBallIndex(
		vec3(ballX[ballIndex],ballY[ballIndex],ballZ[ballIndex]),ballIndex)-BALL_R;
}

//balls and surface. does not exclude any balls, so is not the right signedDistance func for accelerating a ball
//cuz it will detect collision with itself.
float signedDistanceAtXYZ(in vec3 fromXYZ){
	return signedDistanceAtXYZExcludingBallIndex(fromXYZ,-1);
}

//Loss function for VarGradientGL
//High when balls are colliding with the isosurface volume,
//but for now its just densityAtXYZ directly without the more detailed collision detection.
float loss(){
	float loss = 0.;
	//vec3 inFrontOfCam = camPos+vec3(0.,0.,10.);
	vec3 posVisibleWhenCamStarts = vec3(0.,0.,10.);
	for(int bi=0; bi<NEAR_BALLS_TOTAL; bi++){
		//vec3 p = ballXYZ[bi];
		
		//vec3 p = vec3(ballX[bi],0.,0.);
		//vec3 p = vec3(ballX[bi],0.,0.);
		vec3 p = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		//vec3 p = vec3(ballX[bi],-ballY[bi],ballZ[bi]);
		//vec3 p = vec3(0.,ballY[bi],0.);
		
		//FIXME dont branch by continue. use ifTrue*chance+ifFalse*(1-chance),
		//for updating each branching float var as nonbranching, and you set ifTrue float and ifFalse float,
		//doesnt have to be named ifTrue or ifFalse. The webgl compiler might do that anyways in some cases.
		//
		//if(p.x >= (NULLXYZ/2.)) continue;          // unused slot. todo NONBRANCHING
		if(float(bi) >= (numBalls-.5)){
			continue; //padding, dont use this as ball, its vec3(NULLXYZ,NULLXYZ,NULLXYZ) or that differing by epsilon
		}
		
		/*
		//simple physics
		float d = densityAtXYZ(p);
		//d *= d;
		//d = -d; //flip accel direction. FIXME
		//d = 0.;
		
		d = max(0., d); //flat 0 in open areas, but solid volumes (inside isosurface) still repel.
		
		//l += d*d;                             // simple ‖distance‖² penalty
		loss += d; //FIXME do detailed collision detection and squared signedDistance of overlap
		*/
		
		
		//float sd = signedDistanceToIsosurfaceAtXYZ(p);
		//float sd = signedDistanceAtXYZExcludingBallIndex(p,bi);
		//float sdWithRadius = sd-BALL_R;
		//float sdWithRadius = signedDistanceAtXYZExcludingBallIndex(p,bi);
		float sdWithRadius = signedDistanceOfBall(bi);
		sdWithRadius = min(0.,sdWithRadius);
		loss += 5.3*sdWithRadius*sdWithRadius; //spring force for how far ball is inside isosurface volume
		//loss += .3*sdWithRadius; //spring force for how far ball is inside isosurface volume
		
		//loss += p.y*2.3; //gravity
		//float distanceToCam = length(p-camPos);
		//loss += .3*distanceToCam*distanceToCam;

		//all balls move toward (0,0,0) experiment
		//float distanceToOrigin = length(p);
		//loss += distanceToOrigin*distanceToOrigin*.001;
		
		
		//float distanceToInFrontOfCam = length(p-inFrontOfCam);
		//float distErr = length(p-posVisibleWhenCamStarts);
		//float targetDist = 2.;
		//float targetDist = 0.;
		//float distErr = (distanceToOrigin-targetDist);
		//loss += .01*distErr*distErr;
		//loss += .3*p.y*p.y; //attract to plane at p.y=0
		//loss += .003*abs(p.y); //attract to plane at p.y=0
		
		
		//loss += .1*p.y; //gravity
		loss += .3*p.y; //gravity
		
		
		//loss += .3*distErr*distErr;
		//loss += 2.1*distanceToOrigin*distanceToOrigin;
		//loss += 2.1*distanceToOrigin;
		//loss += .1*distErr*distErr;
		//loss += -1.4*p.z;
	}
	//TODO add ball ball collisions to loss like did in dagball
	return loss;
}

// step function
float stepFunction(float val, float lastVal){
	// if isRaymarch>0.5 => variable step
	float doVar= step(0.5, isRaymarch);
	float fixedSz = ${opt.raytraceStep}; //float fixedSz= 0.2;
	float raw= 2.0* abs(val);
	float minimal=0.001;
	float stDist= max(raw, minimal);
	return mix(fixedSz, stDist, doVar);
	
	//return abs(val);
	//return stDist;
	//return val; //FIXME
}

// find the implicit surface
float findSurface(in vec3 origin, in vec3 dir, out vec3 outPos){
	float t=0.0;
	float val=0.0, lastVal=0.0;
	bool found=false;
	for(int i=0;i<MARCH_MAX_STEPS;i++){
	if(t> horizon) break;
	vec3 p= origin + dir*t;
	val = densityAtXYZ(p); //val= sumOfBellcurves(p);
	if(i>0 && (sign(val)!=sign(lastVal) || abs(val)< closeEnuf)){
		found= true;
		// approximate crossing
		float dt= ( stepFunction(val,lastVal)*abs(lastVal) ) / ( abs(val)+ abs(lastVal)+ 1e-9 );
		t= t- stepFunction(val,lastVal)+ dt;
		outPos= origin + dir*t;
		break;
	}
	lastVal= val;
	float stSz= stepFunction(val,lastVal);
	t+= stSz;
	}
	if(!found) return 999999.0;
	return t;
}

// For billboard ring & knobs. 
// We'll store bestRingT, bestRingColor, etc.
struct RingResult {
	float t;
	vec3 color;
	int i; //index 0 to NEAR_TOTAL-1 of the ring
};

// ---------------------------------------------------------------------------
// BallResult – closest hit on any sphere of fixed radius BALL_R.
// colour is just a grey placeholder; replace it however you like.
// ---------------------------------------------------------------------------

//there might be more BallResult fields later even tho 2025-7-7 its float,vec3,int just like RingResult
//but the int means which ball instead of which angle slice aka knob in the ball.
struct BallResult {
	float t;		//distance along the ray
	vec3	pos;		//hit-point in world space	(handy for shading)
	int	 i;		//index of the sphere that was hit
};

RingResult findNearestBillboard(in vec3 origin, in vec3 dir){
	RingResult rr;
	rr.t= NULLXYZ;
	rr.color= vec3(0.0);
	rr.i = -2;

	// We'll define a stable planeRight, planeUp for the knob angles
	// We'll pick worldUp= (0,1,0) unless dot(worldUp, camForward)>0.9 => pick (1,0,0).
	vec3 worldUp= vec3(0,1,0);
	float d= abs(dot(worldUp, normalize(camForward)));
	if(d>0.9){
		worldUp= vec3(1,0,0);
	}
	
	/*FIXME? GPT-o3 says: If camForward happens to be parallel to worldUp the first cross
	is ≈ (0,0,0) ⇒ NaNs. You handled the almost-parallel case (d>0
	*/
	vec3 planeRight= normalize( cross(camForward, worldUp) );
	vec3 planeUp	 = normalize( cross(planeRight, camForward) );

	for(int i=0; i<NEAR_TOTAL; i++){
		// skip if it's dummy
		if(bellPositions[i].x>=NULLXYZ) continue;
		// plane intersection
		float denom= dot(dir, normalize(camForward));
		if(abs(denom)<1e-9) continue;
		float tC= dot( (bellPositions[i]-origin), normalize(camForward))/ denom;
		if(tC<0.01 || tC> horizon) continue;

		// dist3D from the plane point to bell center
		vec3 planePt= origin + dir* tC;
		float distCenter= distance(planePt, bellPositions[i]);

		// approximate how many px is "1 px" at distance tC
		float pxScale= 0.003 * tC;
		float band= circleBandPx * pxScale;

		// ring check
		float ringDiff= abs(distCenter - bellRadii[i]);
		if(ringDiff < band){
			// we have found a ring. Possibly a knob.
			// local 2D coords in plane: localX= dot(planeRight, (planePt-center)), localY= dot(planeUp, (planePt-center))
			vec3 localVec= planePt - bellPositions[i];
			float localX= dot(localVec, planeRight);
			float localY= dot(localVec, planeUp);
			float angle= atan(localY, localX); // in [-pi, pi]
			if(angle<0.0) angle += 6.2831853; // so [0..2pi)
			float knobAngle= 6.2831853 / float(KNOB_COUNT); // 2pi/5 => ~1.2566
			// find which knob index is closest:
			float kFloat= angle / knobAngle; // e.g. 2.2 => knob #2
			float kRound= floor( kFloat+0.5 );
			float angleDiff= abs( kFloat - kRound );
			// if angleDiff < knobAngleBand? We do a subband. e.g. 0.2 => yes
			float angleThresh= knobAngleBand; // e.g. 0.2 or 0.15
			if(angleDiff < angleThresh){
				// color the knob
				float knobIdx= mod( kRound, float(KNOB_COUNT) );
				// map 0->red,1->green,2->blue,3->white,4->black for example
				// We'll do a quick if-else or a small array. For brevity, do if else:
				vec3 knobColor;
				if(knobIdx<0.5) knobColor= vec3(1,0,0);
				else if(knobIdx<1.5) knobColor= vec3(0,1,0);
				else if(knobIdx<2.5) knobColor= vec3(0,0,1);
				else if(knobIdx<3.5) knobColor= vec3(1,1,1);
				else knobColor= vec3(0,0,0);
				// pick that
				if(tC< rr.t){
					rr.t= tC;
					rr.color= knobColor;
					rr.i = i;
				}
			} else {
				// it's ring but not a knob => e.g. gray
				if(tC< rr.t){
					rr.t= tC;
					rr.color= vec3(0.6,0.6,0.6);
					rr.i = i;
				}
			}
		}
	}
	return rr;
}

/*BallResult findNearestBall(in vec3 origin, in vec3 dir){
	float bestT	 = NULLXYZ; //no hit yet
	float bestIdx = -1.0;
	vec3 bestPos = vec3(0);
	const float R2 = BALL_R * BALL_R;
	for (int i = 0; i < NEAR_BALLS_TOTAL; ++i) {
		vec3 ballXYZ = vec3(ballX[i],ballY[i],ballZ[i]);
		vec3 oc = origin - ballXYZ;
		float b	= dot(oc, dir);
		float d	= b*b - (dot(oc, oc) - R2);

		float root = sqrt(max(d, 0.0));
		float tCand	= -b - root; //"near" root
		float validHit = step(0.0, d) * step(0.0, tCand);

		tCand = mix(NULLXYZ, tCand, validHit);

		//float closer = step(tCand, bestT);
		float closer = validHit*step(tCand, bestT);
		bestT	 = mix(bestT,	 tCand,	closer);
		bestIdx = mix(bestIdx, float(i), closer);
		bestPos = mix(bestPos, origin + tCand*dir, closer);
	}

	return BallResult(bestT, bestPos, int(bestIdx));
}*/
BallResult findNearestBall(in vec3 origin, in vec3 dir){
    float bestT   = NULLXYZ;       // none yet
    float bestIdx = -1.0;
    vec3  bestPos = vec3(0.0);

    const float R2 = BALL_R * BALL_R;

    for (int i = 0; i < NEAR_BALLS_TOTAL; ++i) {
        vec3  c   = vec3(ballX[i], ballY[i], ballZ[i]);
        vec3  oc  = origin - c;

        float b   = dot(oc, dir);
        float d   = b*b - (dot(oc, oc) - R2);          // discriminant
        float okD = step(0.0, d);                      // 1 if d ≥ 0

        float root = sqrt(max(d, 0.0));

        float t0   = -b - root;                        // enter
        float t1   = -b + root;                        // exit
        // choose the first positive root (t0 if it’s ≥0, else t1)
        float tCand = mix(t1, t0, step(0.0, t0));
        float hit   = okD * step(0.0, tCand);          // 1 if real & in front

        // keep nearest valid hit so far
        float closer = hit * step(tCand, bestT);
        bestT   = mix(bestT,   tCand,           closer);
        bestIdx = mix(bestIdx, float(i),        closer);
        bestPos = mix(bestPos, origin + tCand*dir, closer);
    }

    return BallResult(bestT, bestPos, int(bestIdx));
}

// shading the surface
vec3 shadeSurface(in vec3 p){
	float eps= 0.001;
	//float base= sumOfBellcurves(p);
	float base = densityAtXYZ(p);
	vec3 grad= vec3(0);
	for(int k=0;k<3;k++){
	vec3 offset= vec3(0);
	offset[k]= eps;
	//float val2= sumOfBellcurves(p+ offset);
	float val2 = densityAtXYZ(p+offset);
	grad[k]= (val2 - base)/ eps;
	}
	vec3 N= normalize(grad);
	vec3 L= normalize(vec3(1,1,1));
	float bright= 1.8/(1.0+ exp(-2.5* dot(N,L)));
	float weirdBright = .5+.5*sin(bright*10.);
	float wx= dot(N,vec3(1,0,0))*0.5 +0.5;
	float wy= dot(N,vec3(0,1,0))*0.5 +0.5;
	float wz= dot(N,vec3(0,0,1))*0.5 +0.5;
	float sumw= wx+wy+wz +1e-9;
	vec3 angleColor= (color1*wx + color2*wy + color3*wz)/ sumw;
	//return angleColor* bright;
	//return bright;
	//return angleColor;
	//return vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	//float smul = 8.;
	float smul = 2.5;
	vec3 stable3dColor = vec3(.5+.5*sin(p[0]*smul),.5+.5*sin(p[1]*smul),.5+.5*sin(p[2]*smul));
	vec3 abc = vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	return abc*.03+stable3dColor*.7+bright*-.3;
}

float sigmoid(float x){ return 1./(1.+exp(-x)); }

${isPhysicsElseGraphics ?
`void main(){ //physics
	//gradient code will be auto inserted here by VarGradientGL for numVars+1 gpuThreads/pixels,
	//which will perturb loss() based on at most 1 of the uniform floats being changed per thread.
	outColor = vec4(loss(), 0., 0., 0.);
}` :
`
vec3 gridColor(vec3 position){
	return vec3(
		max(0.,mod(position.x,0.1)-.09)*100.,
		max(0.,mod(position.y,0.1)-.09)*100.,
		max(0.,mod(position.z,0.1)-.09)*100.
	);
}

void main(){ //graphics
	//generate instead in perturbGlsl: ID = int(uv.x*float(width)); //range 0 to width-1
	// build a ray from pixel
	vec2 st= uv*2.0-1.0;
	vec3 dir= normalize( camForward + st.x*camRight + st.y*camUp );

	// 1) find ring
	RingResult rRing= findNearestBillboard( camPos, dir );
	float ringDistance = rRing.t;
	
	BallResult ball = findNearestBall(camPos, dir);
	float ballDistance = ball.t;

	// 2) find surface
	vec3 surfPos= vec3(0);
	float surfaceDistance = ${opt.displayTerrain ? 'findSurface( camPos, dir, surfPos )' : 'NULLXYZ'};
	//surfaceDistance = -10000.;
	
	// pick whichever is near
	
	/*if(ball.i != -1){ //ball found in this ray direction. FIXME theres a few things to compare here for distance, like what if a ring or terrain is in front of it
		//outColor = vec4(ball.color,1.0);
		outColor = vec4(.2,.5,.9,1.0); //FIXME constant blue color of ball just to see if it displays balls
	}else if(${opt.displayTerrain?'':'true ||'} rRing.t < surfaceDistance){
		vec3 color = rRing.color;
		//if((rRing.i&1)==0){ //test
		//if(rRing.i == selectedBellI){
		//	//color = mix(color, vec3(0.), .7);
		//	//color = (color-.3)*12.;
		//	//color = vec3(surfaceDistance*.1);
		//	color = 1.-color;
		//}
		outColor= vec4(color,1.0);
	}else if(surfaceDistance< 999999.0){
		vec3 c= shadeSurface(surfPos);
		outColor= vec4(c,1.0);
	}else{
		outColor= vec4(0.5,0.5,0.5,1.0);
	}*/
	/*float minDistance = min(surfaceDistance, min(ringDistance, ballDistance));
	if(minDistance < 999999.0){
		//if(surfaceDistance == minDistance){ //surface
		if(surfaceDistance<ringDistance && surfaceDistance<ballDistance){ //surface
			vec3 c = shadeSurface(surfPos);
			outColor = vec4(c,1.0);
		}else if(ballDistance == minDistance){ //ball
			outColor = vec4(.2,.5,.9,1.0); //FIXME constant blue color of ball just to see if it displays balls
		}else{ //ring
			outColor = vec4(rRing.color,1.0);
		}
	}else{
		outColor= vec4(0.5,0.5,0.5,1.0);
	}*/
	float minDistance = min(surfaceDistance, min(ringDistance, ballDistance));
	if(minDistance < NULLXYZ){
		if(surfaceDistance<=ringDistance && surfaceDistance<=ballDistance){ //surface
			vec3 c = shadeSurface(surfPos);
			if(densityAtXYZ(camPos)>0.){ //camera is in solid volume (not open area).
				c = c*.4; //darken color
			}
			outColor = vec4(c+gridColor(surfPos),1.0);
		}else if(ballDistance<=ringDistance && ballDistance<=surfaceDistance){ //ball
			float bright = 1.-sigmoid(ballDistance*.1-1.5);
			float mulA = mod(ballDistance,2.3)/2.3;
			//outColor = vec4(.2*bright,.5*bright*mulA,.9*bright,1.0); //FIXME constant blue color of ball just to see if it displays balls
			//float signedDistance = signedDistanceAtXYZ(ball.pos);
			float signedDistance = signedDistanceAtXYZExcludingBallIndex(ball.pos,ball.i);
			//float debugRedBrightness = sigmoid(signedDistance);
			//float debugRedBrightness = signedDistance > 0. ? 1. : 0.;
			//float debugRedBrightness = .5+.5*sin(signedDistance*14.1)
			//float debugRedBrightness = mod(signedDistance,.1)*10.;
			//float debugRedBrightness = sigmoid(signedDistance*4.);
			//float debugRedBrightness = 1.-max(0.,abs(signedDistance*5.));
			//float debugRedBrightness = 1.-max(0.,abs(signedDistance*5.));
			float debugRedBrightness = 0.;
			//float debugBlueBrightness = signedDistance > 0. ? 1. : 0.;
			//float debugBlueBrightness = 0.;
			//float debugBlueBrightness = .7;
			//float debugBlueBrightness = .05 + .08/(abs(signedDistance)+.00001);
			float debugBlueBrightness = signedDistance*5.;
			//outColor = vec4(debugRedBrightness,.1*bright*mulA,.3*bright,1.0); //FIXME constant blue color of ball just to see if it displays balls
			//float blue = max(0.,mod(ball.pos.x,0.1)-.09)*100.;
			//outColor = vec4(debugRedBrightness*5.,0.,blue,1.0); //FIXME constant blue color of ball just to see if it displays balls
			float gridBright = .2;
			outColor = vec4(debugRedBrightness,0.,debugBlueBrightness,1.)+vec4(gridColor(ball.pos)*gridBright,0.);
		}else{ //ring
			outColor = vec4(rRing.color,1.0);
		}
	}else{
		outColor= vec4(0.5,0.5,0.5,1.0);
	}
	
	//if(mod(uv.x,.02) < .01){
	//	outColor = vec4(.1, .5, .9, 1.); //FIXME, display vertical blue lines for testing
	//}
	float bifractionY = uv.y*2.-1.; //range -1 to 1
	float bifractionX = uv.x*2.-1.;
	float distanceToMouse = length(vec2(mouseY-bifractionY, mouseX-bifractionX));
	if(distanceToMouse < .02){
		outColor = vec4(.1, .8, .3, 1.); //display circle around mouse
	}
}` //end graphics
} //end isPhysicsElseGraphics ?:
`);

const fsSourcePhysics = fsSourceMaker(true);
const fsSourceGraphics = fsSourceMaker(false);

/***************************************************************
 * 6) Create & link
 ***************************************************************/

/*let vs=compileShader(gl,gl.VERTEX_SHADER,vsSource);
let fs=compileShader(gl,gl.FRAGMENT_SHADER,fsSource);
let program= gl.createProgram();
gl.attachShader(program,vs);
gl.attachShader(program,fs);
gl.linkProgram(program);
if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
	console.error("link err:",gl.getProgramInfoLog(program));
	throw new Error("link fail");
}
gl.useProgram(program);

// uniform locs
let loc_bellPos = gl.getUniformLocation(program,"bellPositions");
let loc_bellRad = gl.getUniformLocation(program,"bellRadii");
let loc_bellStr = gl.getUniformLocation(program,"bellStrengths");

let loc_camPos	 = gl.getUniformLocation(program,"camPos");
let loc_camFwd	 = gl.getUniformLocation(program,"camForward");
let loc_camRight = gl.getUniformLocation(program,"camRight");
let loc_camUp	= gl.getUniformLocation(program,"camUp");

let loc_horizon	= gl.getUniformLocation(program,"horizon");
let loc_isRay	= gl.getUniformLocation(program,"isRaymarch");
let loc_closeE	 = gl.getUniformLocation(program,"closeEnuf");
let loc_circPx	 = gl.getUniformLocation(program,"circleBandPx");
let loc_knobAng	= gl.getUniformLocation(program,"knobAngleBand");
let loc_selectedBellI	 = gl.getUniformLocation(program,"selectedBellI");

let loc_col1	 = gl.getUniformLocation(program,"color1");
let loc_col2	 = gl.getUniformLocation(program,"color2");
let loc_col3	 = gl.getUniformLocation(program,"color3");

// VAO
let quadVBO= gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,quadVBO);
let quadData= new Float32Array([
	-1,-1, 1,-1, -1,1,
	-1,1, 1,-1, 1,1
]);
gl.bufferData(gl.ARRAY_BUFFER,quadData,gl.STATIC_DRAW);

let vao= gl.createVertexArray();
gl.bindVertexArray(vao);
//let posLoc= gl.getAttribLocation(program,"position");
let posLoc= gl.getAttribLocation(program,"XY"); //renamed position to XY for Lamgl compatibility	
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
gl.bindVertexArray(null);
*/

/***************************************************************
 * 7) Searching up to NEAR_TOTAL
 ***************************************************************/

let nearBells=[];
let selectedBellI = -1; //index in nearBells, copied into GPU for display
let gpuPos= new Float32Array(opt.NEAR_TOTAL*3);
let gpuRad= new Float32Array(opt.NEAR_TOTAL);
let gpuStr= new Float32Array(opt.NEAR_TOTAL);

function updateNearBells(){
	let rng= 200;
	let cpx= camPos[0], cpy= camPos[1], cpz= camPos[2];
	if(opt.displayCenterForwardOfCam){
	let fwd = calculateForwardVector(camQ);
	cpx += fwd[0]*opt.displayCenterForwardOfCam
	cpy += fwd[1]*opt.displayCenterForwardOfCam;
	cpz += fwd[2]*opt.displayCenterForwardOfCam;
	}
	let cands= spatialGrid.queryNearby(cpx,cpy,cpz, rng);
	//FIXME 2025-3-27 this is returning all 100k bells cuz cell size is 10.
	cands.sort((a,b)=>{
	let da=(a.x-cpx)**2+(a.y-cpy)**2+(a.z-cpz)**2;
	let db=(b.x-cpx)**2+(b.y-cpy)**2+(b.z-cpz)**2;
	return da-db;
	});
	nearBells= cands.slice(0,opt.NEAR_TOTAL);
	//let prev_selectedBellI = selectedBellI;
	selectedBellI = -1; //none
	for(let i=0;i<nearBells.length; i++){
	gpuPos[i*3+0]= nearBells[i].x;
	gpuPos[i*3+1]= nearBells[i].y;
	gpuPos[i*3+2]= nearBells[i].z;
	gpuRad[i]	= nearBells[i].radius;
	gpuStr[i]	= nearBells[i].strength;
	if(nearBells[i].isSelected){
		if(selectedBellI != -1){
			throw new Error('Found second selected bell. max 1.');
		}
		selectedBellI = i;
	}
	}
	//if(prev_selectedBellI != selectedBellI) console.log('selectedBellI='+selectedBellI);
	//console.log('selectedBellI='+selectedBellI);
	/*for(let i=nearBells.length; i<opt.NEAR_TOTAL; i++){ //FIXME remove this?
	gpuPos[i*3+0]= 9999;
	gpuPos[i*3+1]= 9999;
	gpuPos[i*3+2]= 9999;
	gpuRad[i]= 0.01;
	gpuStr[i]= 0.0;
	nearBells[i].isSelected = false;
	}*/
}

/***************************************************************
 * 8) Camera + Gamepad
 ***************************************************************/

//let camPos=[0,0,5];
let camPos=[0,0,-5];
//let camPos=[0,0,0];
//let camPos=[0,0,-12]; //far back so can see balls 2025-7-17
let camQ	=[0,0,0,1];

function updateFromGamepad(dt){
	let gps= navigator.getGamepads();
	if(!gps) return;
	let gp= gps[0];
	if(!gp) return;
	let lx= gp.axes[0], ly= gp.axes[1];
	let rx= gp.axes[2], ry= gp.axes[3];
	const dead= 0.06;
	//const dead= 0; //FIXME
	let lLen= Math.hypot(lx,ly);
	if(lLen>dead){
	let leftover= lLen- dead;
	lx*= leftover/lLen;
	ly*= leftover/lLen;
	} else { lx=0; ly=0; }
	let rLen= Math.hypot(rx,ry);
	if(rLen>dead){
	let leftover2= rLen- dead;
	rx*= leftover2/rLen;
	ry*= leftover2/rLen;
	} else { rx=0; ry=0; }
	ry*=-1;
	let turnSpd = 2;
	//let turnSpd = .8;
	//let turnSpd = .6;
	rx *= turnSpd;
	ry *= turnSpd;
	rotateCamera(rx,ry,dt);

	let fwdVal= gp.buttons[7]?.value - gp.buttons[6]?.value;
	let upDown= -ly;
	let leftRight= lx;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));
	let moveSpd=2.0;
	//let moveSpd=.8;
	camPos[0]+= (fwd[0]*fwdVal + upv[0]*upDown + rig[0]*leftRight)* moveSpd* dt;
	camPos[1]+= (fwd[1]*fwdVal + upv[1]*upDown + rig[1]*leftRight)* moveSpd* dt;
	camPos[2]+= (fwd[2]*fwdVal + upv[2]*upDown + rig[2]*leftRight)* moveSpd* dt;
}

function rotateCamera(rx, ry, dt){
	const threshold= 0.001;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));

	let combined=[0,0,0,1];
	if(Math.abs(rx)> threshold){
	let yawAngle= -rx*2.0* dt;
	let yawQ= createQuaternion(upv,yawAngle);
	combined= multiplyQuaternions(yawQ,combined);
	}
	if(Math.abs(ry)> threshold){
	let pitchAngle= -ry*2.0* dt;
	let pitchQ= createQuaternion(rig,pitchAngle);
	combined= multiplyQuaternions(combined,pitchQ);
	}
	camQ= multiplyQuaternions(combined, camQ);
	camQ= normalizeQuaternion(camQ);
}

/***************************************************************
 * 9) CPU overlay of ring+knobs is removed. 
 *	But user wants to “click + drag” to update the 5 numbers per bell?
 *	That now means we have no 2D or “visible overlay.” 
 *	We'll do a trivial approach:
 *	If user clicks => we do a “nearest billboard ring.” 
 *	Then if it’s near a knob => store which bell & knob. 
 *	Drag changes that param.	But we cannot see them, 
 *	because we removed the CPU overlay.
 ***************************************************************/

// For demonstration, we'll still handle mouse so user can drag (like a big invisible UI).
// We'll do the same findKnobAt approach in JS, but that means we replicate the plane intersection logic in JS 
// or we do readPixels but that’s more complicated. 
// We'll replicate the plane logic + local tangent-plane transform here. 
// If you truly want *perfect* matching, you'd do a readback from a picking buffer or do an extra pass, but that’s advanced.

// We'll do a minimal approach, scanning the same nearBells.	
// If found ring & knob => we set dragState. Then as user drags => we adjust radius, or strength, or x,y,z, etc.

let dragState=null;

let Controls = {mouseY: 0, mouseX: 0};

let did_bootLamglDomEvents = false;
let bootLamglDomEvents = ()=>{
	console.log('START bootLamglDomEvents, Lamgl.glCanv='+Lamgl.glCanv);
	//Lamgl.Gl(); //create Lamgl.glCanv if not already exist.
	let mousedown = e=>{
		let rect= Lamgl.glCanv.getBoundingClientRect();
		let mx= e.clientX- rect.left;
		//FIXME findKnobAt is flipped in y, +y is up. let my= e.clientY- rect.top;
		//let my= rect.y-e.clientY; //cuz flipped. FIXME
		let my= e.clientY- rect.top;
		my = rect.height-1-my; //cuz flipped. FIXME.
		let k= findKnobAt(mx,my);
		if(k){
		for(let bc of allBells) bc.isSelected = false; //unselect all
		//if(dragState) dragState.bc.isSelected = false; //unselect prev selection
		dragState={
			bc: k.bc,
			knobIndex: k.knobIndex,
			startY: my,
			startVal: getParamVal(k.bc,k.knobIndex)
		};
		dragState.bc.isSelected = true; //select next
		}
	};
	Lamgl.glCanv.addEventListener("mousedown", mousedown);
	Lamgl.glCanv.addEventListener("mousemove", e=>{
		//mousedown(e); //FIXME
		let rect= Lamgl.glCanv.getBoundingClientRect();
		let my= e.clientY-rect.top; //FIXME
		my = rect.height-1-my; //FIXME cuz flipped y between cpu and gpu
		let mx= e.clientX- rect.left;
		Controls.mouseY = my;
		Controls.mouseX = mx;
		//console.log('mousemove y'+my+' x'+mx);
		if(!dragState) return;
		let dy= my- dragState.startY;
		let newVal= dragState.startVal+ (-dy*0.02);
		setParamVal(dragState.bc, dragState.knobIndex, newVal);
	});
	Lamgl.glCanv.addEventListener("mouseup", e=>{
		for(let bc of allBells) bc.isSelected = false; //unselect all
	});
	Lamgl.glCanv.addEventListener("mouseup", e=>{
		dragState=null;
	});
	console.log('END bootLamglDomEvents, Lamgl.glCanv='+Lamgl.glCanv);
}

var selectedKnob = null;

// We replicate the plane logic for ring & knob detection in JS. 
// See the approach used in the fragment code, but we do it once for every bell. 
// Then we pick whichever is closest in tC. If ringDiff < band => we also do knob angle check.
function findKnobAt(mx,my){
	console.log('findKnobAt mx='+mx+' my='+my);
	let camForward = calculateForwardVector(camQ); //FIXME this was added 2025-3-27 dont know if its the correct camForward
	let camUp= calculateUpVector(camQ); //FIXME
	let camRight= cross(camForward, camUp); //FIXME
	camRight= normalize(camRight); //FIXME
	console.log('camForward='+camForward);

	// transform pixel -> st => [-1..1], st => build ray
	//let width = Lamgl.glCanv.width, height = Lamgl.glCanv.height;
	const rectCanvas = Lamgl.glCanv.getBoundingClientRect(); //cuz canvas stretches
	const width	= rectCanvas.width; //pixels on screen, not in canvas coordinates
	const height = rectCanvas.height;
	//let stx= (mx/(float(width))) *2.0 -1.0; 
	let stx= (mx/width) *2.0 -1.0; 
	//let sty= (my/(float(height)))*2.0 -1.0;
	let sty= (my/height)*2.0 -1.0;
	// but we are in JS, so do
	let stxF= (mx/width)*2 -1;
	let styF= (my/height)*2-1;
	let dir= normalize( vecAdd( camForward, vecAdd( scale(camRight,stxF), scale(camUp,styF) ) ) );

	// define plane normal= camForward
	let n= normalize(camForward);
	let bestT= 999999;
	let bestBell=null;
	let bestKnob=-1;

	// define stable planeRight, planeUp
	let wUp= [0,1,0];
	let d= Math.abs(dot(wUp, n));
	if(d>0.9){
	wUp= [1,0,0];
	}
	let pRight= normalize( cross(n, wUp) );
	let pUp	 = normalize( cross(pRight, n) );

	for(let i=0; i< nearBells.length; i++){
	let bc= nearBells[i];
	if(bc.x>9000) continue;
	let denom= dot(dir, n);
	if(Math.abs(denom)<1e-9) continue;
	let c= [bc.x, bc.y, bc.z];
	let diff= vecSub(c, camPos);
	let tC= dot(diff,n)/ denom;
	
	
	
	
	//if(tC<0.01 || tC> opt.horizon) continue; //commentedout 2025-3-28 for testing
	if(tC<0.01 || tC> opt.horizon) continue;
	
	
	
	
	// planePt
	let planePt= vecAdd( camPos, scale(dir, tC) );
	let distC= length( vecSub(planePt, c) );
	// ring diff
	let pxScale= 0.003* tC;
	let band= opt.circleBandPx* pxScale;
	let ringDiff= Math.abs(distC- bc.radius);
	if(ringDiff < band){
		// might be a knob
		// local2D
		let localVec= vecSub(planePt, c);
		let localX= dot(localVec, pRight);
		let localY= dot(localVec, pUp);
		let angle= Math.atan2(localY, localX);
		if(angle<0) angle+= 2*Math.PI;
		let knobAng= 2*Math.PI/ opt.KNOB_COUNT; 
		let kFloat= angle/ knobAng;
		let kRound= Math.floor(kFloat+0.5);
		let angleDiff= Math.abs( kFloat- kRound );
		if(angleDiff < opt.knobAngleBand){
		// it's a knob
		if(tC< bestT){
			bestT= tC;
			bestBell= bc;
			bestKnob= kRound % opt.KNOB_COUNT;
		}
		} else {
		// ring
		// maybe store a separate best ring, but user only wants to drag knobs.
		// so if it’s ring only => no knob => no drag
		// skip
		}
	}
	}
	if(!bestBell) return null;
	selectedKnob={bc: bestBell, knobIndex: bestKnob};
	console.log('selectedKnob='+JSON.stringify(selectedKnob));
	setParamVal(selectedKnob.bc, selectedKnob.knobIndex,
	getParamVal(selectedKnob.bc, selectedKnob.knobIndex)+.001);
	return selectedKnob;
}

// minimal vector utilities in JS:
function vecAdd(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];}
function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];}
function dot(a,b){ return a[0]*b[0]+ a[1]*b[1]+ a[2]*b[2];}
function cross(a,b){
	return [
	a[1]*b[2]- a[2]*b[1],
	a[2]*b[0]- a[0]*b[2],
	a[0]*b[1]- a[1]*b[0]
	];
}
function scale(a,s){return [a[0]*s, a[1]*s, a[2]*s];}
function length(a){ return Math.hypot(a[0],a[1],a[2]);}
function normalize(a){
	let L= length(a);
	if(L<1e-9) return [0,0,0];
	return [a[0]/L, a[1]/L, a[2]/L];
}

/***************************************************************
 * 11) Editing the 5 knobs means x,y,z,radius,str
 ***************************************************************/

function getParamVal(bc,k){
	switch(k){
	case 0: return bc.x;
	case 1: return bc.y;
	case 2: return bc.z;
	case 3: return bc.radius;
	case 4: return bc.strength;
	}
}
function setParamVal(bc,k,v){
	//console.log('setParamVal k='+k+' v='+v+' bc='+bc);
	switch(k){
	case 0: bc.x= v; break;
	case 1: bc.y= v; break;
	case 2: bc.z= v; break;
	case 3: bc.radius= Math.max(0.01,v); break;
	case 4: bc.strength= v; break;
	}
}

/***************************************************************
 * 12) Render/Physics loop
 ***************************************************************/
 
var lamglLoopBody_count = 0;
 
var lamglLoopBody = ()=>{
	let pause = Dom('pauseBellsack');
	if(!pause || pause.checked){
		console.log('PAUSE, lamglLoopBody ending cuz pauseBellsack');
		return;
	}
	//console.log('lamglLoopBody_count='+(++lamglLoopBody_count));
	let dt = 1/60; //FIXME compute and clamp this by Lamgl.time()
	//console.log('lamglLoopBody');
	//let tSmall = Lamgl.time() % 1000.0;
	let tSmall = Lamgl.time() % 86400;
	let camFwd = calculateForwardVector(camQ);
	let camUp = calculateUpVector(camQ);
	let camRight = cross(camFwd, camUp);
	camRight = normalize(camRight);
	//let camPos = camera.position;
	//let camFwd = camera.forward;
	//let camRight = camera.right;
	//let camUp = camera.up;

	//let height = 400, width = 300;
	let height = Lamgl.glCanvasHeight, width = Lamgl.glCanvasWidth;
	//let height = 800, width = 600; //TODO switch to height 600 width 800.
	//let height = 600, width = 800;
	//let height = 2000, width = 1500;
	let rect = Lamgl.glCanv ? Lamgl.glCanv.getBoundingClientRect() : {height,width}; //that height and width stretched to full screen canvas. first time glCanv wont exist.
	
	//console.log('gpuRad.length: '+gpuRad.length);			// 192	– good
	//console.log('gpuRad: '+Lamgl.vm.Str(gpuRad));	 // Float32Array.of(...)
	
	//let ballRadius = .3; //FIXME
	//let ballRadius = 1.3; //FIXME
	let balls = Balls.searchZYXR(camPos[2], camPos[1], camPos[0], 10000000, opt.NEAR_BALLS_TOTAL); //FIXME is this param order backward for camPos?
	//let balls = Balls.searchZYXR(camPos[2], camPos[1], camPos[0], 30, opt.NEAR_BALLS_TOTAL); //FIXME is this param order backward for camPos?
	//console.log('lamglLoopBody balls.length='+balls.length);
	//let floatsPerBall = 3;
	//let ballXYZ = new Float32Array(opt.NEAR_BALLS_TOTAL*floatsPerBall);
	let ballX = new Float32Array(opt.NEAR_BALLS_TOTAL);
	let ballY = new Float32Array(opt.NEAR_BALLS_TOTAL);
	let ballZ = new Float32Array(opt.NEAR_BALLS_TOTAL);
	//let ballXYZVars = [];
	let ballXVars = [];
	let ballYVars = [];
	let ballZVars = [];
	//balls.length (nearest opt.NEAR_BALLS_TOTAL balls or less if theres not that many balls) <=
	// opt.NEAR_BALLS_TOTAL (max balls to display at once, even if theres more farther away).
	/*for(let i=0; i<opt.NEAR_BALLS_TOTAL; i++){
		//let ptr = i*floatsPerBall;
		let exists = i<balls.length;
		//ballXYZ[ptr] = exists ? balls[i].X.p : NULLXYZ; //FIXME x y z vs z y x?
		//ballXYZ[ptr+1] = exists ? balls[i].Y.p : NULLXYZ;
		//ballXYZ[ptr+2] = exists ? balls[i].Z.p : NULLXYZ;
		ballX[i] = exists ? balls[i].X.p : NULLXYZ;
		ballY[i] = exists ? balls[i].Y.p : NULLXYZ;
		ballZ[i] = exists ? balls[i].Z.p : NULLXYZ;
	}*/
	/*for(let i=0; i<balls.length; i++){
		//let ptr = i*floatsPerBall;
		//let exists = i<balls.length;
		//ballXYZVars.push(balls[i].X, balls[i].Y, balls[i].Z); //FIXME x y z vs z y x?
		ballXVars.push(balls[i].X);
		ballYVars.push(balls[i].Y);
		ballZVars.push(balls[i].Z);
	}*/
	
	for(let i = 0; i < opt.NEAR_BALLS_TOTAL; i++){
		if(i < balls.length){
			ballXVars.push(balls[i].X);
			ballYVars.push(balls[i].Y);
			ballZVars.push(balls[i].Z);
		}else{
			ballXVars.push(V.Const['IgnoreX'+i].setNow(NULLXYZ,0));
			ballYVars.push(V.Const['IgnoreY'+i].setNow(NULLXYZ,0));
			ballZVars.push(V.Const['IgnoreZ'+i].setNow(NULLXYZ,0));
		}
	}
	
	let ballXYZVars = ballXVars.concat(ballYVars).concat(ballZVars);
	//for(let vr of ballXYZVars){
	for(let i=0; i<balls.length; i++){
		for(let vr of [ballXVars[i],ballYVars[i],ballZVars[i]]){
			//base velocityDecay, otherwise it wont stop moving or would
			//have equal chance to slow down vs speed up by slight float32 roundoff
			vr.cv = 1.3; //base velocity decay
			//vr.cv = .3; //base velocity decay
			//vr.cv = 3.3; //base velocity decay
			//vr.cv = 13.3; //base velocity decay
			//vr.cv = 0.;
			//vr.cv = 30.;
			//FIXME Var.accelMul should be 1, but this is for testing...
			//vr.accelMul = .1;
			vr.accelMul = 10;
			//vr.accelMul = 0; //velocity changes by negative gradient
			//vr.gp = 11.1; //position changes by negative gradient
		}
	}
	V.Const.NULLXYZ.setNow(NULLXYZ,0);
	/*while(ballXVars.length < opt.NEAR_BALLS_TOTAL){
		//ignore these, but need it to be longer so not recompile GL shader
		//ballXYZVars.push(V.Const['Ignore'+ballXYZVars.length].setNow(NULLXYZ,0));
		ballXVars.push(V.Const['Ignore'+ballXYZVars.length].setNow(NULLXYZ,0));
		ballYVars.push(V.Const['Ignore'+ballXYZVars.length].setNow(NULLXYZ,0));
		ballZVars.push(V.Const['Ignore'+ballXYZVars.length].setNow(NULLXYZ,0));
	}*/
	//FIXME in physics it will use both NULLXYZ and NULLXYZ+epsilon during gradient
	//despite those extras are supposed to be ignored,
	//and the signal to ignore them is equalling NULLXYZ. so maybe should check >=NULLXYZ instead.
	/*for(let i=0; i<ballXYZ.length; i++){
		ballXYZ[i] = ballXYZVars[i].p; //copy position from the physics list to graphics list
	}*/
	for(let i=0; i<ballX.length; i++){
		//ballXYZ[i] = ballXYZVars[i].p; //copy position from the physics list to graphics list
		ballX[i] = ballXVars[i].p; //copy position from the physics list to graphics list
		ballY[i] = ballYVars[i].p;
		ballZ[i] = ballZVars[i].p;
	}

	for(let whichLamglCall=0; whichLamglCall<2; whichLamglCall++){
		let isPhysicsElseGraphics = !whichLamglCall; //physics first
		if(isPhysicsElseGraphics && !opt.doPhysics){
			continue;
		}
		let lamglOrVargradientglParam = {
			//sh: isPhysicsElseGraphics ? [1, ] : [height, width, 4],
			sv: vsSource, //very small
			sf: isPhysicsElseGraphics ? fsSourcePhysics : fsSourceGraphics, //the main work
			//241 was hardcoded for an experiment. width is added automatically in VarGradientGL: width: isPhysicsElseGraphics ? 241 : width, //FIXME //width: width,
			tSmall: tSmall,
			bellPositions: gpuPos,
			bellRadii: gpuRad,
			bellStrengths: gpuStr,
			//ballXYZ: isPhysicsElseGraphics ? ballXYZVars : ballXYZ, //Var's for gradient else floats
			ballX: isPhysicsElseGraphics ? ballXVars : ballX, //Var's for gradient else floats
			ballY: isPhysicsElseGraphics ? ballYVars : ballY,
			ballZ: isPhysicsElseGraphics ? ballZVars : ballZ,
			numBalls: balls.length,
			camPos: camPos,
			camForward: camFwd,
			camRight: camRight,
			camUp: camUp,
			horizon: opt.horizon,
			isRaymarch: opt.isRaymarch,
			closeEnuf: opt.closeEnufToZero,
			circleBandPx: opt.circleBandPx,
			knobAngleBand: opt.knobAngleBand,
			selectedBellI: selectedBellI,
			color1: opt.color1,
			color2: opt.color2,
			color3: opt.color3,
			mouseY: Controls.mouseY/rect.height*2-1, //range -1 to 1
			mouseX: Controls.mouseX/rect.width*2-1,
		};
		if(!isPhysicsElseGraphics){
			lamglOrVargradientglParam.sh = [height, width, 4];
			lamglOrVargradientglParam.width = width; //instead of VarGradientGL generates it
		}//else VarGradientGL computes it from the js [] lists of Var, that many plus one.
		if(isPhysicsElseGraphics){ //physics
			let jsMap = VarGradientGL(lamglOrVargradientglParam); //js Map of Var to addToGradient
			for(let [vr, addToGradient] of jsMap){
				let max = 1000; //truncate into plus/minus this. todo scaledTanh? easeInOut? etc?
				vr.gr += Math.max(-max, Math.min(addToGradient, max)); //gr is gradient
			}
			ballXYZVars.map(vr=>{
				vr.nextState(dt); //update vr.p and vr.v based on vr.gr etc. moves the balls.
			})
		}else{ //graphics
			let map = Lamgl(lamglOrVargradientglParam);
			map.outColor.display(); //to canvas Lamgl.glCanv which it puts on screen if not already in the dom tree
			//fixes bug bellsack190_mostBallsMoveDiffDirectionsButAfter10SecondsGLCrashesSeeDetailsInFIXMETextInUI.html
			map.outColor.free(); //return to Lamgl.texPool pool of WebGLTexture (outcolor.mem)
			//FIXME todo map.outColor.free() when where? See Lamgl free.
			/*
			//test contents of map.outColor. todo remove this for efficiency cuz copying to CPU is expensive...
			let outColorFloats = map.outColor.get();
			let s = 'outColorFloats... ';
			for(let i=0; i<30; i++) s += ' ['+i+']='+outColorFloats[i];
			console.log('lamglLoopBody, '+s);
			*/
		}
	}
	let live = Dom('liveDisplay');
	if(live){
		live.innerHTML = ('camPos=,'+camPos).replaceAll(',','<br>');
	}
	if(!did_bootLamglDomEvents){ //after first tensor.display()
		did_bootLamglDomEvents = true;
		bootLamglDomEvents();
		let bootDuration = Lamgl.time()-bellsackStartLoadingTime;
		console.log('Object.values(Lamgl.cacheStats)='+JSON.stringify(Object.values(Lamgl.cacheStats)));
		console.log('Bellsack booted in '+bootDuration+' seconds.');
	}
};

var isVar = v=>(v instanceof Var);

var isVarList = list=>{
	return list.length!==undefined && isVar(list[0]);
};

var varListToPositions = list=>{
	let ret = new Float32Array(list.length);
	for(let i=0; i<list.length; i++) ret[i] = list[i].p;
	return ret;
};

//Wrapper of Lamgl for physics, using nearly the same params
//as for calling Lamgl directly for physics.
//Returns a js Map (not {}) of Var to number that should be
//added by caller into eachVar.gr (gradient).
//wraps Lamgl, takes same params as Lamgl, but some values in the param {} can be
//list of Var instance, like [V.Bellsack.Room1.Balls.B3.X, V.Bellsack.Room1.Balls.B3.Y,
//for multiple balls and X Y Z of them all, but just the positions someVar.p],
//and for the set of all Var's given, which may occur in multiple parts of the {} map
//as {varNameA:[Var, Var, Var, Var...], varNameB:[...], otherLamglParams...},
//which is d Var's in total, it calls GPU (thru Lamgl) with d+1 GPU threads,
//by using "uniform vec2 XY;" which gets auto filled in by the two triangles
//way of filling a rectangle. Just give it height of 1 and X from 0 to width (inclusive),
//and 0 to width-1 each has epsilon added, and width is the last one with someVar.p as is.
//So it computes float[d] gradient that way (vec4 per pixel out, just uses 1 float each),
//and puts that in a Map of Var to number, and returns that Map, without changing the param.
//VarGradientGL has to work for ANY code string that Lamgl works for, by just
//substituting any of the Float32Array's (in the {} param of Lamgl/VarGradientGL)
//with js [] list of Var.
/*part of a conversation with GPT-o3 2025-7-10[[
bellsack174.html File
focus on changing sv and sf. they can NOT stay the same cuz caller does not include
the mutable versions of the Var arrays in the code. Caller includes code for them being
uniform float arrays. Those arrays need to be changed to mutable, and add a mutable
array of concat(sameName,'_const') and rename the params in Lamgl to concat(sameName,'_const')
which receive the Float32Array form of it, and add into the code, 1 loop per such array
concat(sameName,'_const')/sameName, to copy from concat(sameName,'_const')[i] to sameName[i]
the value or the value plus epsilon depending if its the dimension to be perturbed. Use
gl_VertexID and int gradientOffset = 0; [gradientOffset++] to loop over them. The highest
gl_VertexID will not have epsilon added to any dim cuz its index is not any of those indexs
in the arrays, its the last one for neutralSample. Use Lamgl.glvars(map) of the map param
of VarGradientGL(map) which will look in map.sv (vertex shader code string) and map.sf
(fragment shader code string) and return a list of Lamgl.GLVar instances that includes
all inputs and outputs but not those passing from vertex shader to fragment shader as thats
not relevant to caller of Lamgl. So when you call VarGradientGL on the param you would have
called Lamgl on except som of the values in the map/{} param are js [] list of Var, it runs
numVars+1 GPU threads and gets numVars+1 vec4s (4x as many floats) back from GPU, and
computes gradient of numVars dimensions, subtracting neutralSample then dividing by epsilon,
and returns a Map of Var to gradient, without modifying the param map.
]]
<<<<Example GLVars:
let glvars = vm.glvars(map);
		if(opt.logGlvars) console.log('glvars=[[['+glvars.join('\n')+']]]');
glvars=[[[[GLVar memType=in glType=vec2 name=XY shaderType=sv]
[GLVar memType=out glType=vec4 name=outColor shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camPos shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camForward shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camRight shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camUp shaderType=sf]
[GLVar memType=uniform glType=float name=horizon shaderType=sf]
[GLVar memType=uniform glType=float name=isRaymarch shaderType=sf]
[GLVar memType=uniform glType=float name=closeEnuf shaderType=sf]
[GLVar memType=uniform glType=float name=circleBandPx shaderType=sf]
[GLVar memType=uniform glType=float name=knobAngleBand shaderType=sf]
[GLVar memType=uniform glType=int name=selectedBellI shaderType=sf]
[GLVar memType=uniform glType=float name=mouseY shaderType=sf]
[GLVar memType=uniform glType=float name=mouseX shaderType=sf]
[GLVar memType=uniform glType=vec3 name=bellPositions shaderType=sf]
[GLVar memType=uniform glType=float name=bellRadii shaderType=sf]
[GLVar memType=uniform glType=float name=bellStrengths shaderType=sf]
[GLVar memType=uniform glType=vec3 name=ballXYZ shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color1 shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color2 shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color3 shaderType=sf]]]]
>>>>
*/
/*var VarGradientGL = map=>{
	console.log('VarGradientGL');
	let lamglParam = {}; //VarGradientGL takes mostly same params as Lamgl
	let numVars = 0;
	let epsilon = DefaultEpsilon;
	for(let key in map){
		let val = map[key];
		if(isVarList(val)){
			lamglParam[key] = varListToPositions(val);
			numVars += val.length;
		}else{
			lamglParam[key] = val;
		}
	}
	let gpuThreads = numVars+1; //measure gradient in numVars dimensions by numVars+1 samples
	let correctSh = [1, gpuThreads, 4]; //[height,width,4]
	if(map.sh){
		//throw if its not that same size
		if(!Lamgl.testNearEqualFloatArrays(map.sh, correctSh, 'VarGradientGL sh'));
	}else{
		//derive sh from number of var's
		lamglParam.sh = correctSh;
	}
	let lamglReturn = Lamgl(lamglParam);
	let lamglReturnedArray = Object.values(lamglReturn);
	if(lamglReturnedArray.length != gpuThreads){
		Err('lamglReturnedArray.length ('+lamglReturnedArray.length+') != gpuThreads ('+gpuThreads+')');
	}
	let neutralSample = lamglReturnedArray[numVars];
	//for(let v=0; v<neutralSample.
	let ret = new Map();
	//TODO fill ret with key of Var and val of
	//[todo should it be the literal values in lamglReturnedArray, with V (Var tree root) being neutralSample,
	//or should it be the gradient directly? Cuz ]
	
	

	


	//FIXME can this be done without changing map.sv and map.sf?

	//call Lamgl
	
	//return Map of Var to number.
	
	//TODO https://chatgpt.com/c/686ba7cf-f7d8-800a-ac0a-8649383cc06c
	
	Err('TODO whatever first float (of vec4) map.sf code returns, use that as loss. Do not give sh. Derive it from the number of Var in [] in the {} param, PLUS ONE. d+1 for gradient calculation. Then it returns Map of Var to addToGradient aka add to eachVar.gr . This will require the sf code string be slightly modified by caller differently than the graphics code which calls Lamgl directly.');
	
};*/
//Err('TODO VarGradientGL');
// Wrapper of Lamgl that evaluates a scalar loss at (d+1) nearby
// points and returns \partial loss / \partial p for every Var.
// Usage is identical to Lamgl(map) except that any param value may
// be a list of Var objects; their .p is packed into uniforms and the
// gradient for each Var is returned.

const VarGradientGL = map => {
    const epsilon = (typeof DefaultEpsilon === "number" ? DefaultEpsilon : 1e-3);

    /* ── 1.  Collect Vars, build flat Float32Arrays ─────────────────── */
    const lamglParam = {};
    const varLists   = [];   // [[Var,Var,…] in the order we encounter]

    for (const k in map) {
        const v = map[k];
        if (Array.isArray(v) && v.length && v[0] instanceof Var) {
            const arr = new Float32Array(v.length);
            for (let i = 0; i < v.length; ++i) arr[i] = v[i].p;
            //lamglParam[k] = arr;
			//varname_const is uniform float array. varname is mutable float array its copied
			//and maybe perturbed into. Caller of VarGradientGL should not write _const.
			//Thats generated. Use uniform float varname[size];gl_VertexID
			lamglParam[k+'_const'] = arr;
            varLists.push({ name: k, vars: v });
        } else {
            lamglParam[k] = v;
        }
    }

    const d = varLists.reduce((n, o) => n + o.vars.length, 0);
    const gpuThreads = d + 1;                 // +1 neutral sample

    /* ── 2.  Patch the fragment shader to apply ε on a per‑thread basis */
    const glvars   = Lamgl.glvars(map);
	lamglParam.sh = [1, gpuThreads, 4];       // 1×(d+1) vec4   (loss in .r)
	//map.sh should not exist since it will be generated. Give it in graphics call but not physics call.
	if(lamglParam.width !== undefined){
		Err('Param {} of VarGradientGL already had width but width must be generated.');
	}
	lamglParam.width = gpuThreads;
    const perturbed = perturbGlsl(
        map.sf,
        glvars.filter(gv => varLists.some(o => o.name === gv.name)),
        d,
        epsilon,
    );

    lamglParam.sf = perturbed;

    /* ── 3.  Run GPU pass ───────────────────────────────────────────── */
    const out = Lamgl(lamglParam);
    const firstOut = out[Object.keys(out)[0]];   // assume single out tex
	//console.log('firstOut='+firstOut);
    const floats = firstOut.get();               // Float32Array length 4*(d+1)
	//const floats = new Float32Array(firstOut.size()); //FIXME this ignores GPU output, for a test 2025-7-16
	//console.log('VarGradientGL, firstOut, floats.length='+floats.length);
    firstOut.free();

    const neutral = floats[(d) * 4];             // .r of last texel

    /* ── 4.  Map back to individual Vars ────────────────────────────── */
    const ret = new Map();
    let idx = 0;
    for (const block of varLists) {
        for (const v of block.vars) {
            const grad = (floats[idx * 4] - neutral) / epsilon;
            ret.set(v, grad);
            ++idx;
        }
    }

    return ret;
};

var reversedList = list=>{
	let ret = [...list];
	ret.reverse();
	return ret;
};

/* --------------------------------------------------------------------
   Helper – inlines ε‑perturbation into the original fragment shader.
   We rely on GLVar.charPtrFrom / charPtrTo to replace each uniform
   declaration with two pieces:   uniform TYPE name_const[…];
                                   TYPE   name[…];
   Then at the top of main() we apply a concise loop per uniform array
   using a shared EPSILON constant, rather than unrolling manually.
   ----------------------------------------------------------------- */
var perturbGlsl = (src, glvars, d, eps)=>{
    // Only perturb uniform arrays
    glvars = glvars.filter(g => g.memType === 'uniform' && g.sh.length > 0);
    // Sort descending so earlier replacements don't shift later indices
    glvars.sort((a, b) => b.charPtrFrom - a.charPtrFrom);

    let patched = src;

    // Inject shared EPSILON right after version line
    //const epsStr = Lamgl.jsNumToGlslFloat(eps);
    //patched = patched.replace(/(#version .*)/, `$1#define EPSILON ${epsStr} // auto-generated perturbation scale
//`);

    // Duplicate each uniform array declaration
    for (const g of glvars) {
        const decl = patched.slice(g.charPtrFrom, g.charPtrTo);
        const arraySuffix = g.sh.length ? `[${g.sh[0]}]` : "";
        //const replacement =
        //    `uniform ${g.glType} ${g.name}_const${arraySuffix};
//` +
//            `${g.glType} ${g.name}${arraySuffix};`;
		const replacement =
			`uniform ${g.glType} ${g.name}_const${arraySuffix};\n` +
			`${g.glType} ${g.name}${arraySuffix};\n`;   // ← add newline to keep declarations separate
        patched = patched.slice(0, g.charPtrFrom)
                + replacement
                + patched.slice(g.charPtrTo);
    }

    // Inject compact loops at top of main()
    const mainIdx = patched.indexOf("void main()");
    const braceIdx = patched.indexOf("{", mainIdx);
    if (mainIdx < 0 || braceIdx < 0) {
        throw new Error("perturbGlsl: couldn't locate main() to inject loops");
    }
    const setupLines = [];
	setupLines.push('ID = int(uv.x*float(width)); //range 0 to width-1');
    let offset = 0;
	let glvarsReversed = reversedList(glvars);
    //for (const g of glvars){ //ballsZ ballsY ballsX loops generated in in main()
	for (const g of glvarsReversed){ //ballsX ballsY ballsZ
        //const size = g.sh[0];
        //setupLines.push(`// perturb ${g.name}`);
        //setupLines.push(`for(int i=0;i<${size};++i){`);
        //setupLines.push(`  ${g.name}[i] = ${g.name}_const[i] + float(gl_VertexID == ${offset} + i) * EPSILON;`);
        //setupLines.push(`}`);
		const size = g.sh[0];
		setupLines.push(
			`for(int i=0;i<${size};++i){ ${g.name}[i] = ` +
			`${g.name}_const[i] + float(ID == ${offset} + i) * EPSILON; }`
		);
        offset += size;
    }
	
    // Merge injection into single line for clarity
    //patched = patched.slice(0, braceIdx + 1) + "\n" + setupLines.join("\n") + "\n" + patched.slice(braceIdx + 1);
	patched = patched.slice(0, braceIdx + 1) + "\n" + setupLines.join("\n") + "\n" + patched.slice(braceIdx + 1);
	/* now that we’ve finished position-sensitive replacements,
	inject the shared EPSILON define (this won’t disturb charPtr
	offsets used above) */
	if(!src.includes('EPSILON')){
		const epsStr = Lamgl.jsNumToGlslFloat(eps);
		patched = patched.replace(/(#version .*)\n/, `$1\n#define EPSILON ${epsStr} // auto-generated perturbation scale\n`);
	}

    return patched;
};

function renderLoop(t){
	let dt= 0.016; // approximate
	updateFromGamepad(dt);
	updateNearBells();

	// camera basis
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));
	
	
	if(opt.doLamglLoopBody){
		lamglLoopBody();
	}
	
	/*
	// set uniforms
	gl.viewport(0,0, canvas.width, canvas.height);
	gl.clearColor(0,0,0,1);
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.useProgram(program);

	gl.uniform3fv(loc_bellPos, gpuPos);
	gl.uniform1fv(loc_bellRad, gpuRad);
	gl.uniform1fv(loc_bellStr, gpuStr);

	gl.uniform3f(loc_camPos, camPos[0], camPos[1], camPos[2]);
	gl.uniform3f(loc_camFwd, fwd[0], fwd[1], fwd[2]);
	gl.uniform3f(loc_camRight, rig[0], rig[1], rig[2]);
	gl.uniform3f(loc_camUp, upv[0], upv[1], upv[2]);

	gl.uniform1f(loc_horizon, opt.horizon);
	gl.uniform1f(loc_isRay, (opt.isRaymarch?1.0:0.0));
	gl.uniform1f(loc_closeE, opt.closeEnufToZero);
	gl.uniform1f(loc_circPx, opt.circleBandPx);
	gl.uniform1f(loc_knobAng, opt.knobAngleBand);
	gl.uniform1i(loc_selectedBellI, selectedBellI);

	gl.uniform3fv(loc_col1, opt.color1);
	gl.uniform3fv(loc_col2, opt.color2);
	gl.uniform3fv(loc_col3, opt.color3);

	gl.bindVertexArray(vao);
	gl.drawArrays(gl.TRIANGLES,0,6);
	gl.bindVertexArray(null);
	*/

	requestAnimationFrame(renderLoop);
}
//requestAnimationFrame(renderLoop);

window.startBellsack = ()=>{
	console.log('startBellsack');
	requestAnimationFrame(renderLoop);
};

/***************************************************************
 * 13) Quicksave / Quickload
 ***************************************************************/

function doQuicksave(slot){
	let c= { pos:[...camPos], quat:[...camQ] };
	let arr=[];
	for(let b of allBells){
	arr.push([b.x,b.y,b.z,b.radius,b.strength]);
	}
	let obj={ camera:c, bellcurves:arr };
	let s= JSON.stringify(obj);
	localStorage.setItem("bellsack_qs_"+slot, s);
	alert("Saved slot "+slot+", len="+s.length);
}
function doQuickload(slot){
	let s= localStorage.getItem("bellsack_qs_"+slot);
	if(!s){
	alert("No data in slot "+slot);
	return;
	}
	let obj= JSON.parse(s);
	camPos[0]= obj.camera.pos[0];
	camPos[1]= obj.camera.pos[1];
	camPos[2]= obj.camera.pos[2];
	camQ[0]	= obj.camera.quat[0];
	camQ[1]	= obj.camera.quat[1];
	camQ[2]	= obj.camera.quat[2];
	camQ[3]	= obj.camera.quat[3];

	allBells=[];
	spatialGrid= new SpatialGrid(10);
	for(let row of obj.bellcurves){
	let bc= new BellCurve(row[0],row[1],row[2],row[3],row[4],false);
	allBells.push(bc);
	spatialGrid.insert(bc);
	}
	alert("Loaded slot "+slot+", got "+allBells.length+" bells");
}

/***************************************************************
 * 14) Quaternions & small vector ops
 ***************************************************************/

function calculateForwardVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*(x*z+ w*y);
	const yy= 2.0*(y*z- w*x);
	const zz= 1.0- 2.0*(x*x+ y*y);
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,0,1];
	return [xx/ln, yy/ln, zz/ln];
}
function calculateUpVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*( x*y- w*z );
	const yy= 1.0- 2.0*( x*x+ z*z );
	const zz= 2.0*( y*z+ w*x );
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,1,0];
	return [xx/ln, yy/ln, zz/ln];
}
function cross(a,b){
	return [
	a[1]*b[2]-a[2]*b[1],
	a[2]*b[0]-a[0]*b[2],
	a[0]*b[1]-a[1]*b[0]
	];
}
function normalize(v){
	const ln= Math.hypot(v[0],v[1],v[2]);
	if(ln<1e-9) return [0,0,0];
	return [v[0]/ln, v[1]/ln, v[2]/ln];
}
function multiplyQuaternions(q1,q2){
	const[x1,y1,z1,w1]=q1;
	const[x2,y2,z2,w2]=q2;
	return [
	w1*x2 + x1*w2 + y1*z2 - z1*y2,
	w1*y2 - x1*z2 + y1*w2 + z1*x2,
	w1*z2 + x1*y2 - y1*x2 + z1*w2,
	w1*w2 - x1*x2 - y1*y2 - z1*z2
	];
}
function createQuaternion(axis,angle){
	const ha= angle*0.5;
	const s = Math.sin(ha);
	return [ axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(ha)];
}
function normalizeQuaternion(q){
	const ln= Math.hypot(q[0],q[1],q[2],q[3]);
	if(ln<1e-9) return [0,0,0,1];
	return [q[0]/ln, q[1]/ln, q[2]/ln, q[3]/ln];
}




//window.onload = startBellsack;
window.addEventListener('DOMContentLoaded', startBellsack, { once:true });
</script>
</head><body>

<table><tr><td style="color:#cccccc">
	Play BellSack. MOVE: left joystick and 2 triggers. TURN: right joystick. <input type=button value="Privacy" onclick="alert('Privacy: If u want privacy dont share stuff. If u do share it, it might get around to anyone anywhere. But my tools do not suprise you by you think its running local but actually spying on u. Ur in control of all data streams in and out locally.');"><br>
	EDIT TERRAIN: mouse drag the 5 colored knobs per circle/bell. Save/load: TODO V/Var tree.<br>
	Bellsack183 has moving balls by VarGradientGL physics, not doing the more<br> detailed collisions yet, not tuned well yet, but at least its moving.<br>
	Bellack is now running on Lamgl, an javascript function that calls GPU statelessly with immutable tensors.<br>
	TODO implement <a href=https://github.com/benrayfield/jsutils/blob/master/src/bellsack/BellsackDesignDocument.txt>https://github.com/benrayfield/jsutils/blob/master/src/bellsack/BellsackDesignDocument.txt</a><br>
	Terrain is randomly generated. Reload it if you dont see the game world.
	<input type=button onclick="Lamgl.doBasicTests();" value="Lamgl.doBasicTests()">
	<input type=button onclick="doTestDisplay();" value="Lamgl.testDisplay">
	<br>
	<input type="checkbox" id="testDisplayIsSparseXY" checked><label for="testDisplayIsSparseXY" title="sparse points by gl_VertexID in vertex shader code string, else dense points by 2 triangles that fill the display rectangle using 'in vec2 XY;'.">testDisplayIsSparseXY</label>
	<input type=checkbox checked id=continueTestDisplay><label for=continueTestDisplay title="video test else 1 pic">continueTestDisplay</label>
	<input type=checkbox id=testDisplayLogsBigTensor><label for=testDisplayLogsBigTensor title="only works if you choose this before starting testDisplay, FIXME">testDisplayLogsBigTensor</label>
	<input type=checkbox id=pauseBellsack><label for=pauseBellsack onchange="if(this.checked){ console.log('Unpause pauseBellsack, calling lamglLoopBody(); FIXME what if it was already scheduled and u get 2 of them running at once?'); lamglLoopBody(); }">pauseBellsack</label><br>
	<label id=liveDisplay></label>
</td></tr></table>

</body>
</html>
