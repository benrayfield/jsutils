<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BellSack - Single-Pass All GPU: Billboard Circles + Knobs + Raymarch</title>
  <style>
    body {
      margin: 0; padding: 0; background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: sans-serif;
    }
    canvas {
      background: black;
    }
  </style>
</head>
<script>
const Lamgl = window.Lamgl = (() => {
	/* LamGL is opensource MIT by Ben F Rayfield, a GPU API that runs in browsers.
	It comes after TinyGLSL, upgrades to do calculations in GPU memory without copying to CPU. Stores tensors
	in WebGLTexture's. Call GPU as a single function Lamgl({...})=>{...}.
	https://github.com/benrayfield/jsutils/blob/master/src/lamgl/LamglFromBellsack077.js
	https://github.com/benrayfield/jsutils/blob/master/src/lamgl/Lamgl_028.html
	LamGL.js is like GPU.js but without the overhead of copying back to CPU. You can have pointers into GPU memory like in tensorflow.js, but with the generality of GPU.js, and more low level as you type or generate the GLSL code.
	
	if u call Lamgl with the same sh/shape, sv vertex shader code string, and sf fragment shader code string, it will call the already JIT compiled GPU stuff from the first call of it. Its returning sometimes as fast as 1/10000 second.
	
	maybe I should make it take an optional WebGL2 as a param Lamgl=MakeLamgl(...hand it a WebGL2 from an existing canvas...);
	

	Opensource MIT by Ben F Rayfield. LamGL, open browser console. TODO hook in VarTree.html/VarTree.jsp
	which code to call LamGL will be in the tree (.big fields). All this together will remake BellSack and
	scale it up to 30 species near each area and swapping in/out species as you move around the massively
	multiplayer 3d world. LOOK IN BROWSER CONSOLE FOR "test pass" or errors.

	Avoid these bugs in WebGL2 GLSL ES 300:
	-- If you texelFetch the same address twice in the same GPU thread, you'll get all 0s.
	[This is a known bug-like behavior (especially on certain GPUs and drivers, notably Intel and some mobile chipsets), and it boils down to this: In WebGL2 / GLSL ES 300, if you call texelFetch() multiple times with the same coordinates and sampler in the same shader invocation — even if in different scopes — you may get all 0.0s as the result on the second+ calls. This isn't defined behavior by the spec, but it's a real-world GPU driver optimization bug.]--GPT.
	-- Some GLSL optimizers are buggy so u have to make sure some code happens like this sometimes:
		//*1.0000001 avoid returning all 0s, force it to to do some calculation
		//thats not from the textures, cuz the glsl optimizer is buggy.
		dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.0000001

	2025-5-4 did this just reach 1 teraflop/sec when turned off observed_testMatmulAC4?
	testMatmulAC4 secs=0.10042023658752441 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=2.6731211269955195 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.047499895095825195 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.651285238808727 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.04397988319396973 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=6.103596383284764 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.05035996437072754 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.330334509847906 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.049179792404174805 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.4582470335359305 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00036025047302246094 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=745.1356100877723 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002598762512207031 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1032.9356943510313 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00028014183044433594 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=958.2126866745737 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002799034118652344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=959.0288814673117 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00024008750915527344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1118.073393090987 observed_testMatmulAC4.length=undefined
	...
	something dont seem right here. maybe its just that im not refilling the input matrixs so it doesnt have to move them around GPU memory as much, but its saying 21 teraflops when i raised to multiplying 2 1024x1024 matrixs: secs=0.00009989738464355469 gigaflopPerSec=21496.89559604
		
	2025-5-4-950aET about doBasicTests matmul tests only[[
	Are you recompiling the shader every call?
	no
	let program = vm.cache('program'+cacheKeySuffix, function(){...
	lazyevals it once

	 Are you recreating textures or frameBuffers every call?
	I was but i just fixed that (see .free() in finally block in new code im not giving u yet) and its a little faster but still taking 40ms.

	Are you doing gl.readPixels() after every run?
	yes.its for testing but i guess i shouldnt do that in the speed test

	Are you uploading data from CPU to GPU every time?
	no. it stays in the 2 input textures/tensors.

	 Are you allocating a new canvas or GL context?
	no

	Are you doing unnecessary conversions (e.g., CPU reshape / flatten)?
	no, not in the loop, only before it, and those tests in the loop are still slow. I expect the first 1 to be slow but not those after it.

	Are you launching too many threads or using poor loop structure?
	TinyGLSL is fast even with a million GPU threads. im only using 512*512/4=64k gpu threads which should be ok.
	]]

	The shit i gotta do for pointer-arithmetic to write a GPU memory address with a vec4 value (i do have random-access swarming many vec4 sized particles: gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
	i can read alot faster than i can write in GPU. i read as much as the 3d cube volume of matrix multiplying 2 2d squares or any 3 lengths of a 3d rectangle of compute returning a 2d matrix. they're all tensors.
	cuz i dont gotta do that affine transform shit to read. only to write. to read i just texelFetch an ivec2, which can be generated in simple easy to optimize ways or loaded at runtime and i can jump pointer arithmetic n levels deep at each point depending on reading shared GPU mem.
	im gonna turn this into something like codeblocks in a massively multiplayer way, and i'm not giving up GPU flops for it but i am giving up some IO bandwidth between CPU vs GPU cuz of browser layers etc. But imagine u can call pure-functions on eachother in an ocean of builders. (but not codeblocks specificly im optimizing for DAG which has immutable forest of childs, like in wikibinator203's tree drag and drop).
	float32 (even with the +1 in first shader and -1 in last shader, to fix an optimizer bug built into the drivers or browser or hardware etc) can exactly do int25 and uint24, if ur careful not to overflow it, so u might need to multiply 2 int12s or something like that.
	*/
    const vm = function(){}; //Proxy of this (Lamgl) can only be called as function if this is a function
	//VM = vm;
	
	const Todo = vm.Todo = str => { throw new Error(str || 'TODO'); };
	const Err = vm.Err = str => { throw new Error(str || '(Err with no message)'); };

    vm.jsType = x => (ArrayBuffer.isView(x) ? x.constructor.name : typeof(x));

    vm.call = (param,optionalSh)=>{
		//if(typeof(param) == 'object'){
		if(param.sv || param.sf){
			return vm.callGPU(param);
		}else{
			return vm.wrap(param,optionalSh);
		}
    };
	
	vm.callGPU = map=>{
		let gl = vm.Gl();
		let sv = map.sv || '//FIXME no sv'; //vertex shader code
		let sf = map.sf || '//FIXME no sf'; //fragment shader code
		//If sc is true (or 1) then output to Lamgl.glCanv instead of a frameBuffer, by giving null frameBuffer.
		//There is only 1 canvas a WebGL2 instance can output to efficiently, and thats the canvas it was created from.
		//This is normally only used in Lamgl.Tensor.copyTo(Lamgl.glCanv) which is called by Lamgl.Tensor.display().
		let sc = !!map.sc;
		
		console.log('sv='+sv);
		console.log('sf='+sf);
		console.log('sc='+sc);
		
		let sh = map.sh; //[height, width, 4] or maybe [zSize, height, width, 4] etc
		/*
		//TODO zSize for 3d pics?
		let h = map.h; //height, unless map.n is a [] list like [height width 4] or [zSize height width 4] etc.
		let w = map.w; //width, unless that
		let q = map.q || 4; //floats per GPU thread (or maybe per texture?)
		let sh = map.sh || [h, w, q]; //shape of tensor
		//in case there is zSize or what should it be called?
		if(!h) h = sh[n.length-3];
		if(!w) w = sh[n.length-2];
		if(!q) w = sh[n.length-1];
		*/
		
		let cacheKeySuffix = '_SV['+sv+']_SF['+sf+']_SH['+vm.Str(sh)+']';
		
		let glvars = vm.glvars(map);
		console.log('glvars=[[['+glvars.join('\n')+']]]');
		
		// ── geometry auto-detect: if shader declares “in vec2 XY;” draw a quad
		//const hasXYAttr = glvars.some(v=>(v.memType==='in' && v.name==='XY' && v.glType.startsWith('vec2')));
		//
		//If hasXYAttr, then do 2 triangles to fill height x width, else only use gl_VertexID (tho can use both),
		//and it will come in the usual gl screen coordinates of x and y each range -1 to 1.
		const hasXYAttr = glvars.some(v=>(v.memType=='in' && v.name=='XY' && v.glType=='vec2'));
		const has_gl_VertexID = sv.includes('gl_VertexID'); //FIXME parse it better like what if its "int not_gl_VertexID".
		if(hasXYAttr && has_gl_VertexID){
			Err('hasXYAttr && has_gl_VertexID, but if you do that youll only get the corners of the 2 triangles forming a rectangle, not the every pixel in that rectangle you were expecting, sv['+sv+']');
		}
		if(!hasXYAttr && !has_gl_VertexID){
			console.log('Youre probably just testing simple stuff in 1 GPU thread. !hasXYAttr && !has_gl_VertexID. You normally do one or the other. Add "in vec2 XY;" for 2 triangles covering the rectangle heightXwidth, or use gl_VertexID (an int) in sv aka vertex shader code string. sv['+sv+']');
		}
		
		//If a memsIn's Tensor has fr/free of 1, then it uses an optimization of
		//its WebGLTexture being both in and out (in memsIn and memsOut)
		//since its, kind of in this higher level, garbage collected and reused at once,
		//based on that Tensor is immutable and Mem/WebGLTexture is mutable.
		//During this, mem.tensor should be null, and at end, create new Tensor(mem)
		//for each memsOut. Creating a tensor just wraps the Mem, doesnt copy contents,
		//and is still backed by GPU memory.
		let memsIn = []; //contains nulls where u dont use them
		let memsOut = []; //contains nulls where u dont use them
		//for each index in mems*, memsIn or memsOut or both have it.
		
		let uniformsIn = []; //undefined except at primitive uniforms
		
		let tensorsToDecrementFreeAtEnd = [];
		
		for(let i=0; i<glvars.length; i++){
			let glvar = glvars[i];
			let isIn = glvar.isIn(), isInTex = glvar.isInTex(), isOut = glvar.isOut();
			console.log('glvars looping, glvars['+i+']='+glvar+' isIn='+isIn+' isInTex='+isInTex+' isOut='+isOut);
			let tensorIn = null;
			if(isIn){
				if(isOut) Err('Cant be both in and out: '+glvar);
				console.log('START isIn, glvar='+glvar);
				if(isInTex){
					tensorIn = map[glvar.name];
					if(!tensorIn) Err('No tensorIn for '+glvar);
					tensorsToDecrementFreeAtEnd.push(tensorIn);
					memsIn[i] = tensorIn.mem; //read-only and immutable
					console.log('END isIn, glvar='+glvar+', memsIn['+i+'] = '+tensorIn+' of name '+glvar.name+' texture='+ tensorIn.mem.mut);
				}else if(hasXYAttr && glvar.name=='XY'){
					//the var of hasXYAttr. Do nothing here, just log it. Set it later by 2 triangles.
					console.log(`END isIn (vertex attr)  ${glvar.name}  – no uniform upload cuz is an in.`);
				}else{ //uniformsIn
					const val = map[glvar.name];
					if(val === undefined){
						Err('No uniform value for '+glvar.name);
					}
					uniformsIn[i] = val; //remember for later
					console.log('END isIn, primitive uniform glvar.name='+glvar.name+' val='+val);
				}
			}else if(isOut){ //isOut
				console.log('START isOut, glvar='+glvar);
				
				
				//Cant do it as "const canReuseTexture = firstStateTensor.fr === 1;" cuz requires checking if
				//firstStateTensor exists cuz its an optional param. for each output, it optionally is also a param
				//for the starting state of the output memory, which gl_Position can sparsely write on top of.
				let firstStateTensor = map[glvar.name]; //if this doesnt exist, start with an empty state.
				//the optimization this whole LamGL software is based on,
				//that allows it to be completely stateless/immutable Tensors
				//that share and reuse GPU memory without copying back to CPU
				//except as needed after 1 or many GPU calls.
				let doSharedTextureOptimization = false;
				console.log('doSharedTextureOptimization='+doSharedTextureOptimization);
				if(firstStateTensor){
					console.log('isOut: map.'+glvar.name+' exists so using it as the starting state (firstStateTensor) of that texture/GPUMemory. If its .fr/free is 1, will do the optimization to reuse that texture, else will copy it first.');
					doSharedTextureOptimization = firstStateTensor.fr==1;
					//TODO firstStateTensor.useFree() at end. cant free it yet.
				}
				
				/*if(firstStateTensor && doSharedTextureOptimization){ //use 1 texture as if it was 2
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else if(firstStateTensor){ //use 2 textures, copy-on-write
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					memsOut[i] = firstStateTensor.copy().mem;
				}else{ //no firstStateTensor, start with empty memory
					memsOut[i] = vm.gpuMalloc(map.sh); // assumes `map.sh` is the desired shape
				}*/
				
				if(firstStateTensor){
					if(doSharedTextureOptimization){
						//garbage collect immutable tensor so can reuse texture/mem
						firstStateTensor.tensor = null;
						memsOut[i] = firstStateTensor.mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=TRUE, memsOut['+i+'] = '+firstStateTensor+' of name '+glvar.name);
					}else{
						//firstStateTensor.fr is big enuf its not garbage collected,
						//so this (after copy) is the last we use it in this call of callGPU.
						//Instead, we copy it to another texture/mem and use that as output,
						//including that its a mutable texture during writing it,
						//as it has its previous contents and wherever gl_Position
						//sparsely writes voxels over it.
						//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
						//depending on if its a 2d or 3d texture),
						//and write 1-8 vec4s there, 1 vec4 written to each output texture,
						//and gl has a limit of at most 8 output textures (normally just 1).
						//firstStateTensor.useFree(); //decrement firstStateTensor.fr
						tensorsToDecrementFreeAtEnd.push(firstStateTensor);
						//new GPU mem. starts with high .fr
						memsOut[i] = firstStateTensor.copy().mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=FALSE, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					}
				}else{
					memsOut[i] = vm.gpuMallocMem(sh);
					console.log('no firstStateTensor, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					if(memsOut[i].tensor) Err('gpuMallocMem gave Mem with a tensor');
				}
				
				/*
				Todo('there might be 3 cases, do optimization, dont do optimization, where there is .fr>1 so still gotta copy, and where there is .fr==1 so reuse it (the optimization). some combo of those');
				if(doSharedTextureOptimization){ //use 1 texture as if it was 2
					Todo('this might be wrong, check [there might be 3 cases]');
					//garbage collect immutable tensor so can reuse texture/mem
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else{ //use 2 textures, copy-on-write
					Todo('this might be wrong, check [there might be 3 cases]');
					//firstStateTensor.fr is big enuf its not garbage collected,
					//so this (after copy) is the last we use it in this call of callGPU.
					//Instead, we copy it to another texture/mem and use that as output,
					//including that its a mutable texture during writing it,
					//as it has its previous contents and wherever gl_Position
					//sparsely writes voxels over it.
					//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
					//depending on if its a 2d or 3d texture),
					//and write 1-8 vec4s there, 1 vec4 written to each output texture,
					//and gl has a limit of at most 8 output textures (normally just 1).
					//firstStateTensor.useFree(); //decrement firstStateTensor.fr
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					//new GPU mem. starts with high .fr
					memsOut[i] = firstStateTensor.copy().mem;
				}
				*/
				
				console.log('END isOut, glvar='+glvar+', memsOut['+i+'] = Tensor '+glvar.name+', GPU texture ='+memsOut[i].mut);
			}else Err('Is not in or out: '+glvar+' FIXME what if its an input of fragment shader (sf) which comes after vertex shader (sv).');
		}
		console.log('Got '+memsIn.filter(x=>!!x).length+' ins and '+memsOut.filter(x=>!!x).length+' outs, excluding nulls/undefineds in memsIn and memsOut lists.');
		//Todo();
		
		//todo remove this double loop. also, does doSharedTextureOptimization allow them to be both in and out in some cases?
		console.log('--- Checking input/output GPU memory overlap ---');
		for (let i = 0; i < memsIn.length; i++) {
			const memIn = memsIn[i];
			if (!memIn) continue;
			for (let j = 0; j < memsOut.length; j++) {
				const memOut = memsOut[j];
				if (!memOut) continue;
				if (memIn.mut === memOut.mut) {
					console.warn(`ERR, ⚠️ memsIn[${i}] and memsOut[${j}] share the SAME WebGLTexture!`, memIn.mut);
				}else{
					console.warn(`OK memsIn[${i}] and memsOut[${j}]`);
				}
			}
		}
		console.log('--- End check ---');

		
		let program = vm.cache('program'+cacheKeySuffix, function(){
			let vertexShader = vm.cache('vertexShader'+cacheKeySuffix, function(){
				sv = vm.preprocessShaderString(sv); //add line numbers etc
				let v = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(v, sv);
				gl.compileShader(v);
				if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+sv);
				}
				return v;
			});
			console.log('vertexShader='+vertexShader);
			let fragmentShader = vm.cache('fragmentShader'+cacheKeySuffix, function(){
				sf = vm.preprocessShaderString(sf); //add line numbers etc
				const f = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(f, sf);
				gl.compileShader(f);
				if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(f)+'\n\nFRAGMENTSHADERCODE:\n'+sf);
				}
				return f;
			});
			console.log('fragmentShader='+fragmentShader);
			const p = gl.createProgram();
			gl.attachShader(p, vertexShader);
			gl.attachShader(p, fragmentShader);
			gl.linkProgram(p);
			if(!vm.skip_gl_getProgramParameter_LINK_STATUS && !gl.getProgramParameter(p, gl.LINK_STATUS)){
				Err(gl.getProgramInfoLog(p));
			}
			return p;
		});
		console.log('program='+program);
		
	
		
		let ret = {};
		
		//nTextures are outputs, not inputs. 1-8 textures of float or vec4 per pixel each.
		
		/*if(nTextures.length > 1){
			//Specify the draw buffers for multiple render targets
			const attachments = nTextures.map((_, index) => gl.COLOR_ATTACHMENT0 + index);
			gl.drawBuffers(attachments);
		}*/
		let texturesOut = [];
		if(sc){
			console.log('Skipping for(let mem of memsOut) if(mem) texturesOut.push(mem.mut); cuz sc aka output to the canvas that created this GL aka null frameBuffer');
		}else{
			for(let mem of memsOut) if(mem) texturesOut.push(mem.mut);
		}
		
		//vm.cacheFramebuffer = true;
		vm.cacheFramebuffer = false;
		console.log('vm.cacheFramebuffer='+vm.cacheFramebuffer);
		
		let frameBuffer = null;
		if(!sc){
			let frameBufferMaker = function(){
				const f = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, f);
				for(let i=0; i<texturesOut.length; i++){
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, texturesOut[i], 0);
				}
				return f;
			};
			frameBuffer = vm.cacheFramebuffer ?
				vm.cache('frameBuffer'+cacheKeySuffix, frameBufferMaker)
				: frameBufferMaker();
		}
		
				
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer); //frameBuffer is null if sc
		//gl.clearColor(0, 0, 0, 0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		gl.viewport(0, 0, width, height);
		gl.useProgram(program);
		
		if(texturesOut.length){
			const attachments = texturesOut.map((_,i)=>(gl.COLOR_ATTACHMENT0+i));
			console.log('Calling gl.drawBuffers');
			gl.drawBuffers(attachments); 
			//gl.drawBuffers(texturesOut);
		}
		
		
		// === Bind sampler2D uniforms ===
		let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;    // only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}


		// --- bind primitive uniforms ---------------------------------------
		for(let i=0; i<glvars.length; i++){ //added 2025-6-21
			let val = uniformsIn[i];
			if (val === undefined) continue;           // not a uniform
			console.log('uniformsIn doing gl.uniform* to set value, glvars['+i+']='+glvars[i]+', val='+val);
			let loc = gl.getUniformLocation(program, glvars[i].name);
			if (loc === null) continue;                // optimiser removed it
			//Accept number, Array, or Float32Array
			if (typeof val === 'number'){
				gl.uniform1f(loc, val);
			}else if(val instanceof Float32Array || Array.isArray(val)){
				switch (val.length){
					case 1:
						gl.uniform1f(loc, val[0]);
					break;case 2:
						gl.uniform2fv(loc, val);
					break;case 3:
						gl.uniform3fv(loc, val);
					break;case 4:
						gl.uniform4fv(loc, val);
					break;default:
						Err('Unsupported uniform length for '+glvars[i].name+'. TODO arrays, but u will have a limit of about 4k total uniforms in vertex shader and 1k in fragment shader.');
				}
			}else{
				Err('Unsupported uniform type for '+glvars[i].name);
			}
		}

		
		
		if(hasXYAttr){ //2 triangles filling rectangle, use "in vec2 XY;"
			console.log('Lamgl doing 2 triangles: in vec2 XY;');
			//lazy-create and cache a full-screen quad VBO (6 vertices)
			const quadBuf = vm.cache('lamgl_quadVBO', () => {
				const q = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, q);
				gl.bufferData(
					gl.ARRAY_BUFFER,
					new Float32Array([
						-1,-1,   1,-1,  -1, 1,
						-1, 1,   1,-1,   1, 1,
					]),
					gl.STATIC_DRAW
				);
				return q;
			});
			//hook the XY attribute of *this* program to that VBO
			const locXY = gl.getAttribLocation(program, 'XY');
			if (locXY !== -1) {
				gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
				gl.enableVertexAttribArray(locXY);
				gl.vertexAttribPointer(locXY, 2, gl.FLOAT, false, 0, 0);
			}
			//rasterise the quad
			gl.drawArrays(gl.TRIANGLES, 0, 6);
			//leave no attribs enabled for later POINTS calls
			if (locXY !== -1) gl.disableVertexAttribArray(locXY);
		}else{ //gl_VertexID
			console.log('Lamgl doing points as gl_VertexID.');
			//=== run shader for every pixel/voxel using gl_VertexID ===
			let numVerts = 1;
			for(let d = 0; d < sh.length - 1; d++){   // multiply all dims except the last (==4)
				numVerts *= sh[d];
			}
			gl.drawArrays(gl.POINTS, 0, numVerts);    // no VBO needed – gl_VertexID drives the math
		}

		//=== wrap each output Mem in an immutable Tensor and expose it ===
		for(let i=0; i<glvars.length; i++){
			if(glvars[i].isOut() && memsOut[i]){
				let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);
				memsOut[i].tensor = t;            // back-link for texture pooling
				ret[glvars[i].name] = t;          // e.g. ret.result
			}
		}
		
		//unbind input textures that were binded in the loop
		//containing "if (!glvar.isInTex()) continue;    // only bind texture inputs"
		for (let i = 0; i < nextTextureUnit; i++){
			gl.activeTexture(gl.TEXTURE0 + i);
			gl.bindTexture(gl.TEXTURE_2D, null); //this was here 2025-6-21 for long time
			//gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0); //new 2025-6-21
		}
		if(frameBuffer){ //new 2025-6-21
			for(let i=0; i<texturesOut.length; i++){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, null, 0); //detach
			}
		}
		// === Unbind frameBuffer output ===
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		// === Optional: reset active texture to 0 for consistency ===
		gl.activeTexture(gl.TEXTURE0);
		gl.useProgram(null);
		gl.bindVertexArray(null); //even tho its not using a vertex array
		
		for(let tensor of tensorsToDecrementFreeAtEnd){
			//decrement tensor.fr and if its 0 return its texture/mem to pool
			tensor.useFree();
		}
		
		return ret;
	};
	
	vm.preprocessShaderString = code=>{
		return vm.addLineNumbers(code);
	};
	
	//This is for lines like "out vec4 result; //comment".
	//TODO? eltype is element type, like 'vec4' or 'float' or 'int',
	//regardless of its an array/texture vs one primitive.
	vm.GLVar = function(memType, glType, name){
		this.memType = memType;
		this.glType = glType;
		this.name = name;
	};
	
	vm.GLVar.prototype.isIn = function(){
		// Treat uniforms and varying inputs (from vertex shader) as inputs
		return this.memType === 'uniform' || this.memType === 'in';
	};

	vm.GLVar.prototype.isInTex = function(){
		// A sampler2D, samplerCube, etc., in a uniform is a texture input
		return this.memType === 'uniform' && this.glType.startsWith('sampler');
	};

	vm.GLVar.prototype.isOutTex = function(){
		// Fragment outputs (out vec4 ...) are the only texture outputs
		return this.memType === 'out';
	};

	vm.GLVar.prototype.isOut = function(){
		// Alias to isOutTex for now, but leaves room to generalize later
		return this.isOutTex();
	};

	
	vm.GLVar.prototype.toString = function(){
		return '[GLVar memType='+this.memType+' glType='+this.glType+' name='+this.name+']';
	};
	
	//returns [] list of GLVar's in the order they should be used in gl.
	//map.sv is string of vertex shader code, sf fragement shader,
	//(todo if one of those is not given use or generate some default?).
	/*vm.glvars = map=>{
		Todo();
	};*/
	vm.glvars = map => {
		const glvars = [];

		const parseShaderVars = (shaderSrc, isVertexShader) => {
			//fixme what about "flat" keyboard and other keywords?
			const lines = shaderSrc.split('\n');
			for (let line of lines) {
				line = line.trim();

				// Ignore comments
				if (line.startsWith('//')) continue;

				let isIn = false;
				let memType = null, glType = null, name = null;

				// Handle uniform
				let matchUniform = line.match(/^uniform\s+(\w+)\s+(\w+);/);
				if (matchUniform) {
					glType = matchUniform[1];
					name = matchUniform[2];
					memType = 'uniform';
					isIn = true;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle in/out (varyings, fragment outputs, etc.)
				let matchIO = line.match(/^(in|out)\s+(\w+)\s+(\w+);/);
				if (matchIO) {
					let qualifier = matchIO[1];
					glType = matchIO[2];
					name = matchIO[3];
					memType = qualifier;
					isIn = (qualifier === 'in');
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle layout(...) out vec4 NAME;
				let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+(\w+);/);
				if (matchLayoutOut) {
					glType = matchLayoutOut[1];
					name = matchLayoutOut[2];
					memType = 'out';
					isIn = false;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}
			}
		};

		if (map.sv) parseShaderVars(map.sv, true);
		if (map.sf) parseShaderVars(map.sf, false);

		return glvars;
	};
	
	//vm.Str = 
	
	//TODO make a way to call Lamgl({...}) that takes a string of js code that generates
	//the Float32Array or Mem/texture contents in CPU.
	//Maybe name it sj (j for javascript) like sv (vertex shader) and sf (fragment shader).
	//A tensor could be more general, in cpu mem or gpu mem.
	
	vm.wrap = (wrapMe,optionalSh)=>{
		if(wrapMe instanceof Float32Array){
			let sh = optionalSh || [wrapMe.length>>2, 4]; //FIXME what if its not a multiple of 4?
			let mem = vm.gpuMallocMem(sh);
			mem.set(wrapMe); //copy from CPU (Float32Array wrapMe) to GPU (WebGLTexture in mem.mut)
			return new vm.Tensor(mem);
		}else Err('wrapMe is a '+typeof(wrapMe));
	};
	
		//immutable, normally exists in a Mem. Is same shape as that mem.
	vm.Tensor = function(mem,optionalFr){
		this.mem = mem;
		this.sh = mem.sh;
		//countdown until garbcol. Each time its read in GPU,
		//this is decremented. When it reaches 0, vm.gpuFree(this)
		//is called to return that GPU memory to the pool.
		this.fr = optionalFr || vm.defaultFr;
		if(mem.tensor){
			Err('mem already has a tensor and its not this one, mem='+mem+', thisTensor='+this);
		}else{
			mem.tensor = this;
		}
	};
	
	vm.Tensor.prototype.toString = function(){
		return '[Tensor sh='+JSON.stringify(this.sh)+']';
	};
	
	//return a Float32Array copy of the WebGLTexture in the mem backing this Tensor
	vm.Tensor.prototype.get = function(){
		return this.mem.get();
	};
	
	//Returns this Tensor with fr set.
	//Like, vm.gpuMalloc([300,500,4]).free(1) is a Tensor that will free
	//its WebGLTexture (back to the vm.texPool) after the next GPU call.
	//if optionalFr is not given or is 0, frees now.
	//If its 1, frees on the next use (1 more GPU call),
	//fr decreases by 1 each GPU call.
	vm.Tensor.prototype.free = function(optionalFr){
		this.fr = optionalFr|0;
		if(!this.fr){
			vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
		}
		return this;
	};
	
	//use 1 more fr in the countdown, toward garbage collecting the WebGLTexture at this.fr==0,
	//but only back into the vm.texPool pool, not deleting it out of the GPU
	//(todo also that if its not used for a while and the GPU memory is needed).
	vm.Tensor.prototype.useFree = function(){
		if(this.fr){
			this.fr--;
			if(!this.fr){
				vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
			}
		}
	};
	
	//For if sh.length==2, not sure if we even have 1d textures in this version of webgl. Get flattened index.
	vm.Tensor.prototype.ii = function(x, w){
		return x*this.sh[0]+w;
	};

	//For if sh.length==3 like a 2d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iii = function(y, x, w){
		return (y*this.sh[0]+x)*this.sh[1]+w;
	};

	//For if sh.length==4 like a 3d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iiii = function(z, y, x, w){
		return z*this.sh[0]+(y*this.sh[1]+x)*this.sh[2]+w
	};
	
	//vm.texPool[vm.shKey(sh)] is a [] of unused vm.Mem instances of that sh/shape.
	//See vm.gpuMallocMem and vm.gpuFreeMem.
	vm.texPool = {};
	
	vm.verifyShEndsWithVec4 = sh=>{
		if(sh[sh.length-1] != 4) Err('Last dimension is not 4: '+Str(sh));
	};
	
	//returns a Tensor wrapping a Mem wrapping a WebGLTexture,
	//instead of that Mem. Tensor is immutable. Mem is mutable.
	//The Tensor contains whatever data was in WebGLTexture (malloc, not calloc).
	//The normal use of this, since Tensor is immutable, would be to remove the Tensor from the Mem,
	//modify the Mem, then add another Tensor to represent that new Mem state.
	vm.gpuMallocTensor = sh=>(new vm.Tensor(vm.gpuMallocMem(sh)));
	
	vm.gpuMallocMem_usesCache = true; //normal
	//vm.gpuMallocMem_usesCache = false; //test
	console.log('vm.gpuMallocMem_usesCache='+vm.gpuMallocMem_usesCache);
	
	//Example: vm.gpuMallocMem([300,500,4]) returns a Mem.
	//allocate a texture of a chosen sh/shape from pool, in GPU mem.
	//Returns a Mem instance wrapping a WebGLTexture of 2d or 3d,
	//normally with 4 floats per pixel (vec4) as sh[sh.length-1] is normaly 4.
	//This is specificly a malloc, not calloc, as it doesnt clear the mem.
	//Only the first use of a WebGLTexture is cleared,
	//but after that it can be returned to the pool and reallocated without clearing,
	//but it should be written before read again.
	vm.gpuMallocMem = sh=>{
		vm.verifyShEndsWithVec4(sh);
		let k = vm.shKey(sh);
		//list of Mem's whose mem.sh contents equal.
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		if(vm.gpuMallocMem_usesCache && list.length){
			console.log('gpuMallocMem returning from cache, sh='+vm.Str(sh));
			return list.pop();
		}else{
			let tex = null;
			if(sh.length==3 && sh[2]==4){
				//2d WebGLTexture with vec4 per pixel
				console.log('gpuMallocMem makeGLTexture2dVec4, sh='+vm.Str(sh));
				tex = vm.makeGLTexture2dVec4(sh[0], sh[1]);
			}else if(sh.length==3 && sh[2]==4){
				Todo('new 3d WebGLTexture (vec4 per pixel) of that sh='+Str(sh));
			}else{
				Todo('new WebGLTexture of that sh='+Str(sh));
			}
			return new vm.Mem(tex, sh);
			//return new vm.Tensor(new vm.Mem(tex, sh));
		}
	};
	
	//Example:  mem is what a vm.gpuMalloc returned.
	//FIXME: Does not check if its already freed or if its already in texPool,
	//so only call once after each gpuMallocMem.
	vm.gpuFreeMem = mem=>{
		console.log('gpuFreeMem this='+this);
		mem.tensor.mem = null; //breaks the tensor, cant use it anymore
		mem.tensor = null;
		let k = vm.shKey(mem.sh);
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		list.push(mem);
	};
	
	vm.shKey = sh=>sh.join('_');
	
	//mutable. wraps WebGLTexture and maybe Float32Array.
	//shape is [z,y,x,4] or [y,x,4] or [y,x,1] or [500] etc. As of 2025-5-6 only [height,width,4] is supported.
	vm.Mem = function(mutableMem, shape){
		this.mut = mutableMem;
		this.sh = shape;
		this.tensor = null; //this Mem is in the pool when this.tensor is null.
	};
	
	vm.mulAll = function(vec){
		let ret = 1;
		for(let num of vec) ret *= num;
		return ret;
	};
	
	vm.Mem.prototype.size = function(){
		return vm.mulAll(this.sh);
	};
	
	//copy gpu to cpu
	vm.Mem.prototype.get = function(optionalFloat32Array){
		let size = this.size();
		let ret = optionalFloat32Array || new Float32Array(size);
		vm.copyTextureToFloat32Array(this.mut,this.sh,ret); //GPU
		return ret;
	};
	
	/*vm.copyTextureToFloat32Array = (tex,floatsOut)=>{
		Todo();
	};*/
	vm.copyTextureToFloat32Array = (tex, sh, floatsOut) => {
		if(sh.length != 3) Todo('sh.length=='+sh.length);
		const gl = vm.Gl();

		// Assume the texture is 2D and in RGBA32F format
		// Find the dimensions from floatsOut.length and assume vec4 per pixel
		let totalFloats = floatsOut.length;
		let height = sh[0];
		let width = sh[1];
		let pixels = totalFloats/sh[2];
		
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		//let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		
		/*let pixels = totalFloats / 4;
		let width = Math.ceil(Math.sqrt(pixels));
		let height = Math.ceil(pixels / width); //TODO choose width and height better
		*/

		// Create a temporary frameBuffer and attach the texture to it
		const frameBuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
		gl.viewport(0, 0, width, height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

		let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			// Clean up before erroring out
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.deleteFramebuffer(frameBuffer);
			Err('Framebuffer not complete: ' + status);
		}

		// Read pixels from the frameBuffer into the Float32Array
		gl.readPixels(
			0, 0, width, height,
			gl.RGBA, gl.FLOAT,
			floatsOut
		);

		// Clean up
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(frameBuffer);
	};
	
	//vm.skip_gl_getProgramParameter_LINK_STATUS = false; //2024-5-9-640pET defaulting this to false (dont skip) cuz of I turned SKLT=F (dont skip) by clicking the button and this neuralnet nnet_1715286589.548.dagball compiled in about .1 second when I changed {nodes 12} to {nodes 13}.
	//skip_gl_getProgramParameter_LINK_STATUS: true, //normal as of 2024-5-9 cuz it made compiling GLSL alot faster, probably some thread thing it didnt have to wait on, considering theres multiple off-screen canvases.
	//skip_gl_getProgramParameter_LINK_STATUS: false, //normal before 2024-5-9, but TODO experimentally trying skipping it cuz this line takes .1 to 20 seconds and is likely causing threads to wait on eachother
	//skip_gl_getProgramParameter_LINK_STATUS: true, //for testing, or maybe it will work out this way?
	
	//copy cpu to gpu
	vm.Mem.prototype.set = function(float32Array){
		vm.copyFloat32ArrayToTexture(float32Array,this.mut,this.sh);
	};
	
	// --- CPU → GPU upload ----------------------------------------------
	vm.copyFloat32ArrayToTexture = (src, tex, sh) => {
		// sh is the tensor shape that texture represents, e.g. [h, w, 4]
		if (!sh || sh.length !== 3 || sh[2] !== 4) {
			Err('copyFloat32ArrayToTexture: shape must be [height,width,4]');
		}
		const gl     = vm.Gl();
		const height = sh[0];
		const width  = sh[1];

		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,                 // level
			0, 0,              // x-offset, y-offset
			width, height,     // size
			gl.RGBA,           // format
			gl.FLOAT,          // type
			src                // the Float32Array with 4*width*height values
		);
	};

	
	vm.webglType = 'webgl2'; //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	vm.glslVersionString = '#version 300 es'; //WebGL2 GLSL ES 300
	
	vm.gl = null; //the only GL instance, normally WebGL2 GLSL ES 300
	vm.glCanv = null;
	vm.glCanvasHeight = 1; //1x1 canvas, cuz gonna use gl_VertexID instead of 2 triangles that form a rectangle covering the canvas
	vm.glCanvasWidth = 1;
	vm.Gl = ()=>{
		if(!vm.gl){
			let c = document.createElement("canvas");
			c.setAttribute("height", ''+vm.glCanvasHeight);
			c.setAttribute("width", ''+vm.glCanvasWidth);
			c.addEventListener('webglcontextlost', function(event){
				//event.preventDefault();
				//activeContexts.delete(context);
				console.log('TinyGLSL says canvas event webglcontextlost, event='+event);
				if(TinyGlsl.do_clearAllCache_whenWebglContextLost){
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost STARTING TinyGlsl.clearAllCache()...');
					TinyGlsl.clearAllCache();
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost DONE TinyGlsl.clearAllCache().');
				}
			}, false);
			vm.glCanv = c;
			
			let gl = vm.glCanv.getContext(vm.webglType);
			let glErr = gl.getError();
			if(glErr) Err('after canvas.getContext(TinyGlsl.webglType), gl.getError()='+glErr);
			if(!gl.getExtension('EXT_color_buffer_float')){ //this turns the extension on. its not just checking if it exists.
				Err('EXT_color_buffer_float not supported so cant return 1 or 4 floats per pixel instead of bytes');
			}
			let isContextLost = gl.isContextLost();
			console.log('creating gl context, gl.isContextLost()=='+isContextLost);
			if(isContextLost) Err('gl.isContextLost()=='+isContextLost+
				', see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/isContextLost');
			console.log('Returning new webgl context '+gl);
			vm.gl = gl;
		}
		return vm.gl;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.makeGLTexture2dVec4 = (height, width, optionalFloat32Array)=>{
		let gl = vm.Gl();
		let t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		let floats = optionalFloat32Array || null;
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
		gl.texImage2D(
			gl.TEXTURE_2D,
			0,
			gl.RGBA32F,
			width,
			height,
			0,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		return t;
	};
	
	vm.defaultFr = 1<<30;
	
	vm.vm = vm; //so Lamgl.vm is vm. Lamgl is a Proxy
	
	vm.jsNumToGlslFloat = jsNum=>{
		let s = ''+jsNum;
		if(!s.includes('.') && !s.includes('e')) s += '.'; //Examples: '3.', '3.45', '5e-10', '-5e-10'
		return s;
	};

    let Str = vm.Str = value => {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';
		if(value instanceof Float32Array) return 'Float32Array.of('+value.join(', ')+')';
		if(value.length) return JSON.stringify(value);
        if (typeof value === 'symbol') return value.toString();
        if (typeof value === 'function') return '[Function]';
		if (value instanceof WebGLTexture) return 'WebGLTexture';
		if (value instanceof vm.Tensor) return value.toString();
        if (typeof value === 'object'){
			//if(value.length) return String(value);
			//else{
				let s = '{';
				for(let key in value){
					console.log('key='+key);
					if(s.length>1) s += ',';
					s += key+': '+Str(value[key]);
				}
				return s+'}';
			//}
		}
		if(value.toString){
			return value.toString();
		}
        try {
            return 'THING';
        } catch (e) {
            return Object.prototype.toString.call(value);
        }
    };
	
	vm.timeOffset_ = performance.timing.navigationStart;
	//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
	vm.time = ()=>((vm.timeOffset_+performance.now())*.001);

    const Lamgl = vm.Lamgl = new Proxy(vm, {
        apply: (target, thisArg, args) => {
            //console.log('Proxy.apply target=' + target + ' thisArg=' + thisArg + ' args=' + args);
            return target.call(...args);
        },
        get: (target, prop, receiver) => {
            //console.log('Proxy.get target=' + Str(target) + ' prop=' + Str(prop) + ' receiver=' + Str(receiver));
			if (typeof prop === "symbol") {
                // Directly pass through all symbol accesses
                return target[prop];
            }
			// Access properties like 'doBasicTests'
            if (prop in target) {
                return target[prop];
            }
            return Reflect.get(target, prop, receiver);
            //return Reflect.get(target, prop, receiver);
        }
    });
	
	vm.caches = {type: 'lamgl_caches'};
	
	//if this is nonnull (a {}), then TinyGlsl.cache(key,lazyVal) puts stats into it when lazyVal is called but does not store the output of lazyVal here.
	//TODO This could get big so it waits for it to be set to {} externally (by a button in dagball normally)
	vm.cacheStats = null;
	
	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	vm.cache = function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = Lamgl.caches[key];
		if(val === undefined){
			//putTid: put a .tid field that is dagball.timeId() so can be deleted in same order as created (or reverse order?) Or might help in choosing the order in some cases?
			let startTime;
			if(Lamgl.cacheStats){
				startTime = Lamgl.time();
			}
			//val = Lamgl.caches[key] = Lamgl.putTid(lazyVal());
			val = Lamgl.caches[key] = lazyVal();
			if(Lamgl.cacheStats){
				let now = Lamgl.time();
				Lamgl.cacheStats[key] = Lamgl.cacheStats[key] || {};
				let duration = now-startTime;
				Lamgl.cacheStats[key].count = (Lamgl.cacheStats[key].count|0)+1;
				Lamgl.cacheStats[key].lastDurationEndTime = now;
				Lamgl.cacheStats[key].lastDuration = duration;
			}
		}
		return val;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.float32ArrayTranspose = (matBC,sizeB,sizeC)=>{
		let matCB = new Float32Array(sizeC*sizeB);
		for(let b=0; b<sizeB; b++) for(let c=0; c<sizeC; c++){
			matCB[c*sizeB+b] = matBC[b*sizeC+c];
		}
		return matCB;
	};
	
	vm.countNonzeros = function(floats){
		let count = 0;
		for(let i=0; i<floats.length; i++) if(floats[i]) count++;
		return count;
	};
	
	vm.testNearEqualFloatArrays = (a,b,epsilon,comment)=>{
		if(a.length != b.length) Err('TEST FAIL Array lengths differ '+a.length+' '+b.length+', '+comment);
		for(let i=0; i<a.length; i++){
			let diff = Math.abs(a[i]-b[i]);
			if(diff > epsilon) Err('TEST FAIL at i='+i+' '+a[i]+' != '+b[i]+', diff='+diff+', epsilon='+epsilon+', '+comment);
		}
		console.log('Test pass, '+comment);
	};

    vm.doBasicTests = ()=>{
        console.log('START Lamgl.doBasicTests()');
		
		let testA = Lamgl({
			sh: [1, 1, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				void main(){
					gl_Position = vec4(0.,0.,0.,1.0);
					gl_PointSize = 1.0;
				}`,
            sf: `#version 300 es
				precision highp float;
				out vec4 result;
                void main(){
					result = vec4(2.,3.+4.,44.,55.);
                }`,
        });
		let correctA = Float32Array.of(2.,7.,44.,55.);
		let observedA = testA.result.get();
		//console.log('testA='+JSON.stringify(testA));
		console.log('testA='+Str(testA));
		console.log('correctA='+Str(correctA));
		console.log('observedA='+Str(observedA));
		vm.testNearEqualFloatArrays(observedA,correctA,0, 'one vec4');
		
		
		console.log('doBasicTests, Lamgl='+Lamgl);
		let arr = Lamgl(Float32Array.of(2,3,4,5.67,100,200,300,400),[1,2,4]);
		console.log('doBasicTests, arr='+arr);
        let testD = Lamgl({
			sh: [128, 128, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				flat out int vID;
				void main(){
					int idy = gl_VertexID>>7;
					int idx = gl_VertexID&127;
					//x and y go in range -1 to 1, +.5 so its in center of pixel and doesnt get dropped
					gl_Position = vec4((float(idx)+.5)/128.*2.-1., (float(idy)+.5)/128.*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					vID = gl_VertexID; //so sf can get it
				}`,
            sf: `#version 300 es
                precision highp float;
                layout(location = 0) out vec4 result;
				flat in int vID;
				uniform sampler2D someArray;
				//todo sampler2d or something called someArray
                void main(){
                    //result = vec4(gl_VertexID, 0., 0., 1.);
					float f = texelFetch(someArray, ivec2(vID&1,0), 0).x;
					result = vec4(float(vID), 7., f, 1.);
                }`,
			someArray: arr,
        });
		let correctD = new Float32Array(128*128*4);
		for(let y=0; y<128; y++) for(let x=0; x<128; x++){
			let i = (y*128+x)*4;
			let gl_VectorID = i/4;
			correctD[i] = gl_VectorID;
			correctD[i+1] = 7;
			correctD[i+2] = x&1 ? 100 : 2; //from Float32Array.of(2,3,4,5.67,100,200,300,400)
			correctD[i+3] = 1;
		}
		let observedD = testD.result.get();
		console.log('testD='+Str(testD));
		console.log('correctD='+Str(correctD));
		console.log('observedD='+Str(observedD));
		vm.testNearEqualFloatArrays(correctD,observedD,0, 'testD');
        
		
		
		/** from TinyGLSL
		let tenThousandFloatsOut = TinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), null, 1000, 10);
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		*/
		
		let tenThousandFloatsOut = Lamgl({
			sh:[100, 25, 4],
			sv:`#version 300 es
				precision highp float;
				flat out vec4 tempColor;
				float outFunc(int i){
					return float(i)*float(i); //ret = float(id)*float(id); like in TinyGLSL
				}
				const int height = 100;
				const int width = 25;
				void main(){
					int idy = gl_VertexID/width;
					int idx = gl_VertexID%width;
					gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					int i = gl_VertexID<<2;
					tempColor = vec4(outFunc(i), outFunc(i+1), outFunc(i+2), outFunc(i+3));
				}`,
			sf:`#version 300 es
                precision highp float;
				flat in vec4 tempColor;
				layout(location = 0) out vec4 result;
				void main(){
					result = tempColor; //copy from sv
				}`
		}).result.get();
		console.log('tenThousandFloatsOut='+[...tenThousandFloatsOut].map((x,i)=>('['+i+']='+x)).join(', '));
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		
		
		console.log('START test testMatmulAC');
		let sizeA = 1024;
		let sizeB = 1024;
		let sizeC = 1024;
		let flopsPerMatmul = sizeA*sizeB*sizeC*2; //*2 cuz its add and multiply.
		
		/*let sizeA = 8;
		let sizeB = 8;
		let sizeC = 8;
		*/
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');
		let matABTensor = Lamgl(matAB,[sizeA,sizeB/4,4]);
		let matCBTensor = Lamgl(matCB,[sizeC,sizeB/4,4]);
		console.log('matABTensor='+matABTensor);
		console.log('matCBTensor='+matCBTensor);
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			let copyToCpuInMatmulTest = repeat_testMatmulAC4<5 || repeat_testMatmulAC4==9; //so we see its speed without that in later loops
			console.log('r='+repeat_testMatmulAC4+' copyToCpuInMatmulTest='+copyToCpuInMatmulTest);
			/*console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			console.log('matABTensor.get()[55]='+matABTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			console.log('matCBTensor.get()[55]='+matCBTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163 Lamgl_036.html:1212:12
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163
			so the data is still in them.
			*/
			let testMatmulAC4_timeStart = vm.time();
			let observed_testMatmulAC4 = null;
			let observed_testMatmulAC4_map = null;
			try{
				let testMatmulAC4_sh = [sizeA, sizeC/4, 4];
				observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						flat out vec4 tempColor;
						void main(){
							int idy = gl_VertexID / width; // row (A)
							int idx = gl_VertexID % width; // column block (C/4)
							/*tempColor = vec4(
								dotProd(idy, idx*4+0),
								dotProd(idy, idx*4+1),
								dotProd(idy, idx*4+2),
								dotProd(idy, idx*4+3)
							);*/
							vec4 sums = vec4(1.); //vec4 sums = vec4(0);
							for (int b=0; b<sizeBOver4; b++){
								vec4 mul = texelFetch(matAB,ivec2(b,idy),0);
								sums += vec4(
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+0),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+1),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+2),0)),
									//*1.0000001 avoid returning all 0s, force it to to do some calculation
									//thats not from the textures, cuz the glsl optimizer is buggy.
									//dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.000001
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))
								);
							}
							tempColor = sums;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1.,
								(float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							//gl_PointSize = 1.0;
							gl_PointSize = 1.;
							//float sum1 = 0.;
							//float sum2 = 0.;
							//float sum3 = 0.;
							/*for (int b1=0; b1<sizeBOver4; b1++){
								vec4 ba = texelFetch(matAB,ivec2(b1,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b1,idx*4+1),0);
								sum1 += dot(ba, bc);
							}
							float sum2 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+2),0);
								sum2 += dot(ba, bc);
							}
							float sum3 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+3),0);
								sum3 += dot(ba, bc);
							}*/
							//tempColor = vec4(sum0, sum1, sum2, sum3);
						}`,
					sf: `#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main() {
							//result = tempColor;
							//result = tempColor/1.000001; //undo *1.0000001 (glsl optimizer bug)
							result = tempColor-1.; //undo +1 (glsl optimizer bug)
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});

				
				console.log('observed_testMatmulAC4_map='+observed_testMatmulAC4_map);
				if(copyToCpuInMatmulTest){
					observed_testMatmulAC4 = observed_testMatmulAC4_map.result.get();
					//FIXME what kind of transpose-like op goes here? let observed_testMatmulAC = vm.float32ArrayTranspose(observed_testMatmulAC4,size
					/*let cor = [...correct_testMatmulAC];
					for(let i=0; i<1000; i++){
						let ind = cor.indexOf(observed_testMatmulAC[i]);
						console.log('i='+i+' ind='+ind);
					}*/
					let cor = [...correct_testMatmulAC];
					let obs4 = [...observed_testMatmulAC4];
					for(let i=0; i<Math.min(100,correct_testMatmulAC.length); i++){
						console.log('i='+i+' cor='+correct_testMatmulAC[i]+'@'+obs4.indexOf(correct_testMatmulAC[i])+' obs4='+observed_testMatmulAC4[i]+'@'+cor.indexOf(observed_testMatmulAC4[i]));
					}
					let epsilon = (.3*sizeB)**2; //FIXME?
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, epsilon, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
					/*
					console.log('testMatmulAC4 test code incompletely written. todo fix it.');
					for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
					let numNonzero_observed_testMatmulAC4 = 0;
					for(let i=0; i<observed_testMatmulAC4.length; i++) if(observed_testMatmulAC4[i]) numNonzero_observed_testMatmulAC4++;
					console.log('numNonzero_observed_testMatmulAC4='+numNonzero_observed_testMatmulAC4);
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					*/
				}
			}finally{
				let secs = vm.time()-testMatmulAC4_timeStart;
				let flopPerSec = flopsPerMatmul/secs;
				console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4+' testMatmulAC4 secs='+secs+' gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)='+(flopPerSec/1e9)+' observed_testMatmulAC4.length='+(observed_testMatmulAC4?observed_testMatmulAC4.length:'undefined'));
				if(observed_testMatmulAC4_map) for(let k in observed_testMatmulAC4_map){
					let val = observed_testMatmulAC4_map[k];
					if(val instanceof vm.Tensor){
						val.free(); //return WebGLTexture to pool
					}
				}
			}
		}
		
		/* ===========================================================
		   NEW TEST – geometry chosen implicitly via `in vec2 XY;`
		   Expectation: Lamgl must detect the attribute name, switch
		   to “two-triangle quad” geometry, fill a 40 × 30 tensor,
		   and give us   value = 1000*y + x   at each pixel.
		   ===========================================================*/
		{
			const H = 30, W = 40;                 // small so we can eyeball failures
			const quadTest = Lamgl({
				sh: [H, W, 4],
				sv: `#version 300 es
					 precision highp float;
					 in vec2 XY; //triggers quad/rectangle/twoTriangles geometry, dont use gl_ VertexID.
					 void main (){
						 gl_Position = vec4(XY, 0., 1.); //pass-through clip-space
					 }`,

				sf: `#version 300 es
					//fragment: encode 1000*y + x into .r
					 precision highp float;
					 layout(location=0) out vec4 result;
					 void main () {
						 int x = int(gl_FragCoord.x) - 0;   // 0..W-1
						 int y = int(gl_FragCoord.y) - 0;   // 0..H-1
						 result = vec4(float(1000*y + x), 0.0, 0.0, 1.0);
					 }`
			});
			//pull back to CPU and verify
			const data = quadTest.result.get(); //Float32Array
			let ok = true;
			for (let y = 0; y < H; ++y) {
				for (let x = 0; x < W; ++x) {
					const i = (y*W + x) * 4;
					const expected = 1000*y + x;
					if (data[i] !== expected) {
						console.error(`quadTest mismatch at (x=${x}, y=${y}): `
									  + `got ${data[i]}, expected ${expected}`);
						ok = false;
						break;
					}
				}
				if (!ok) break;
			}
			if (!ok) throw 'quadTest failed – Lamgl did not switch to QUAD geometry';
			console.log('quadTest passed – Lamgl QUAD geometry ok');
		}
		/*2025-6-25-546pET[
		Test pass, one vec4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testD
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1197 tenThousandFloatsOut test pass
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r0
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r1
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r2
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r3
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r9
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1406 quadTest passed – Lamgl QUAD geometry ok
		]*/

		
		//Lamgl.testDisplay(true,Lamgl.time()); //FIXME remove this cuz its UI stuff
		
        console.log('END Lamgl.doBasicTests()');
    };
	
	vm.Tensor.prototype.copyTo = function(canvas){
		if(canvas != vm.glCanv){
			Todo('also support copying (slower) to other canvases than vm.glCanv aka Lamgl.glCanv. Its built into WebGL2 that if you give null as FrameBuffer, it writes to the canvas that WebGL2 was made from. To copy to another canvas youd have to copy from that canvas to another one or on some other path.');
		}
		if(this.sh.length != 3){
			Err('this.sh.length='+this.sh.length+' but expected [height, width, 4]');
		}
		let [h, w, ch] = this.sh;
		vm.setCanvasSize(canvas, h, w);
		Lamgl({
			sh: this.sh,
			sv: `#version 300 es
				void main() {
					int id = gl_VertexID;
					int idx = id % ${w};
					int idy = id / ${w};
					float x = (float(idx) + 0.5) / float(${w});
					float y = (float(idy) + 0.5) / float(${h});
					gl_Position = vec4(x * 2.0 - 1.0, y * 2.0 - 1.0, 0.0, 1.0);
					gl_PointSize = 1.0;
				}
			`,
			sf: `#version 300 es
				precision highp float;
				uniform sampler2D tex;
				out vec4 outColor;
				void main() {
					ivec2 uv = ivec2(gl_FragCoord.xy);
					outColor = texelFetch(tex, uv, 0);
				}
			`,
			tex: this,
			sc: true, //output to Lamgl.glCanv aka vm.glCanv, the canvas that the WebGL2 was made from.
		});
	};
	
	vm.Tensor.prototype.display = function(){
		let canvas = vm.glCanv;
		vm.putCanvasInDomOnce(canvas);
		this.copyTo(canvas);
	};
	
	vm.putCanvasInDomOnce = function(canvas){ //does nothing if the canvas is already in the dom. Normally called on Lamgl.glCanv aka vm.glCanv
		if(!document.body.contains(canvas)){
			canvas.style.position = 'fixed';
			canvas.style.left = '0px';
			canvas.style.top = '0px';
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.zIndex = '-10'; // behind most content
			canvas.style.border = 'none';
			document.body.appendChild(canvas);
		}
		return canvas;
	};
	
	vm.setCanvasSize = function(canvas, h, w){
		if(canvas.width !== w || canvas.height !== h){
			canvas.width = w;
			canvas.height = h;
		}
	};
	
	vm.testDisplay = (isSparse, isDetailedLog, time)=>{
		console.log('Start testDisplay');
		let t = time || vm.time();
		const height = 400, width = 300;
		let tSmall = t%86400; //cuz float64 time cast to float32 loses the part of time that changes fast enuf to see
		let mapOut = Lamgl({
			sh: [height, width, 4],
			tSmall: tSmall,
			sv: `#version 300 es
			precision highp float;
			const int height = ${height};
			const int width = ${width};
			${isSparse ? '//sparsePoints' : 'in vec2 XY; //twoTriangles'}
			uniform float tSmall;
			//const float tSmall = ${vm.jsNumToGlslFloat(tSmall)}; //TODO do this in uniform so Lamgl doesnt compile again every time
			flat out vec4 tempColor;
			void main() {
				${isSparse?
					`int idy = gl_VertexID / width;
					int idx = gl_VertexID % width;
					vec2 uv = vec2(float(idx)/float(width), float(idy)/float(height));
					gl_Position = vec4((float(idx)+.5)/float(width)*2. - 1.,
										(float(idy)+.5)/float(height)*2. - 1., 0., 1.);
					gl_PointSize = 1.0;`
					:
					`vec2 uv = XY * 0.5 + 0.5;
					gl_Position = vec4(XY, 0.0, 1.0);`
				}
				float r = 0.5 + 0.5 * sin(sin(tSmall*.567) + uv.x * 20.0 + uv.y * 10.0);
				float g = 0.5 + 0.5 * cos(tSmall+cos(tSmall*1.876-uv.x*r) + uv.y * 30.0 - uv.x * 5.0);
				float b = 0.5 + 0.5 * sin(uv.x * 40.0 + uv.y * 40.0);
				//tempColor = vec4(1., .5, .4, 1.0);
				tempColor = vec4(r, g, b, 1.0);
			}
			`,
			sf: `#version 300 es
			precision highp float;
			layout(location = 0) out vec4 outColor;
			flat in vec4 tempColor;
			void main(){
				outColor = tempColor;
			}`,
		});
		
		let tensorOut = mapOut.outColor;
		if(!tensorOut){
			Err('No tensorOut');
		}
		console.log('tensorOut.sh='+JSON.stringify(tensorOut.sh));
		if(isDetailedLog){
			let floats = tensorOut.get();
			if(floats.length != height*width*4){
				Err('floats.length='+floats.length+' but expected height*width*4='+(height*width*4));
			}
			console.log('testDisplay contents: ');
			let countNonzeros = 0;
			for(let y=0; y<height; y++){
				let line = '';
				for(let x=0; x<width; x++){
					line += ' '
					for(let c=0; c<4; c++){
						if(c) line += ',';
						let f = floats[(y*width+x)*4+c];
						if(f) countNonzeros++;
						line += f;
					}
				}
				console.log(line);
			}
			if(!countNonzeros){
				Err('testDisplay, all '+floats.length+' floats from GPU are 0');
			}
		}
		//uses {sc:true} to output to canvas, that canvas being Lamgl.glCanv, and resizes if needed to match tensor size
		//and put thats canvas in dom tree if its not already.
		tensorOut.display();
	};

    return vm.Lamgl;
	//requestAnimationFrame(() => { Lamgl.doBasicTests(); });
})();
</script>
<body>

<table><tr><td style="color:#cccccc">
	Play BellSack. MOVE: left joystick and 2 triggers. TURN: right joystick.<br>
	EDIT TERRAIN: mouse drag the 5 colored knobs per circle/bell. Save/load: TODO V/Var tree.<br>
	<input type=button onclick="Lamgl.doBasicTests();" value="Lamgl.doBasicTests()">
	<input type=button onclick="doTestDisplay();" value="Lamgl.testDisplay">
	<br>
	<input type="checkbox" id="testDisplayIsSparseXY" checked><label for="testDisplayIsSparseXY" title="sparse points by gl_VertexID in vertex shader code string, else dense points by 2 triangles that fill the display rectangle using 'in vec2 XY;'.">testDisplayIsSparseXY</label>
	<input type=checkbox checked id=continueTestDisplay><label for=continueTestDisplay title="video test else 1 pic">continueTestDisplay</label>
	<input type=checkbox id=testDisplayLogsBigTensor><label for=testDisplayLogsBigTensor title="only works if you choose this before starting testDisplay, FIXME">testDisplayLogsBigTensor</label>
</td></tr><tr><td>
	<canvas id="glCanvas" width="640" height="480"></canvas>
</td></tr></table>

<script>
"use strict";

/***************************************************************
 * 1) Config
 ***************************************************************/

const opt = {
  //horizon: 60.0,          // how far to search for surfaces
  horizon: 60.0,          // how far to search for surfaces
  ////isRaymarch: true,       // variable-step or fixed-step
  isRaymarch: false,
  //raytraceStep: .2,
  raytraceStep: .1,
  //marchMaxSteps: 50,     // maximum steps
  //marchMaxSteps: 200,     // maximum steps
  //marchMaxSteps: 40,     // maximum steps
  marchMaxSteps: 100,     // maximum steps
  closeEnufToZero: 0.01, // tolerance for crossing
  //closeEnufToZero: 0.00001, // tolerance for crossing
  //circleBandPx: 1.5,      // ring thickness in screen px
  //circleBandPx: 7,
  circleBandPx: 4,
  //circleBandPx: 0,
  knobAngleBand: 0.15,    // how wide an angle for each knob (approx)
  //TOTAL_BELLS: 100000,
  TOTAL_BELLS: 10000,
  NEAR_TOTAL: 192,
  KNOB_COUNT: 5,
  //displayCenterForwardOfCam: 0,
  displayCenterForwardOfCam: 4,
  displayTerrain: true, //normal
  //displayTerrain: false, //test
};

// region to place random bellcurves
//const WORLD_SIZE = 70;
const WORLD_SIZE = 30;
//const WORLD_SIZE = 40;
//const WORLD_SIZE = 25;

/***************************************************************
 * 2) Large set of bellcurves + a spatial grid
 ***************************************************************/

function pickRandomColor() {
  let r = Math.floor(128 + 128 * Math.random());
  let g = Math.floor(128 + 128 * Math.random());
  let b = Math.floor(128 + 128 * Math.random());
  return `rgb(${r},${g},${b})`;
}

class BellCurve {
  constructor(x, y, z, radius, strength, isSelected) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.radius = radius;
    this.strength = strength;
    // We'll store an integer color in [0..255] x 3 for convenience
    // or store it as random floats in [0..1], or just store a string and parse it in JS.
    // We'll store as random floats 0..1 so we can pass them to GPU if we want.
    // But for big sets we might skip it. For demonstration, let's store them anyway:
    this.colorR = 0.5 + 0.5 * Math.random();
    this.colorG = 0.5 + 0.5 * Math.random();
    this.colorB = 0.5 + 0.5 * Math.random();
	this.isSelected = !!isSelected;
  }
}

var doTestDisplay = ()=>{
	const isSparse = document.getElementById('testDisplayIsSparseXY').checked;
    const bigLog = document.getElementById('testDisplayLogsBigTensor').checked;
	Lamgl.testDisplay(isSparse, bigLog, Lamgl.time());
	if(document.getElementById('continueTestDisplay').checked){
		requestAnimationFrame(doTestDisplay);
	}
};

class SpatialGrid {
  constructor(cellSize) {
    //this.cellSize = cellSize;
    //this.cells = new Map();
	this.bellList = []; //FIXME remove this when get SpatialGrid working
  }
  /*_cellKey(x,y,z) {
    let ix = Math.floor(x/this.cellSize);
    let iy = Math.floor(y/this.cellSize);
    let iz = Math.floor(z/this.cellSize);
    return `${ix},${iy},${iz}`;
  }*/
  insert(bc) {
    /*let k = this._cellKey(bc.x, bc.y, bc.z);
    if(!this.cells.has(k)) this.cells.set(k, []);
    this.cells.get(k).push(bc);
	*/
	this.bellList.push(bc);
  }
  queryNearby(cx,cy,cz, range){
	let ret = [];
	let rangeSq = range**2;
	for(let bell of this.bellList){
		if((bell.x-cx)**2 + (bell.y-cy)**2 + (bell.z-cz)**2 <= rangeSq){
			ret.push(bell);
		}
	}
	return ret;
	/*
    const minX = Math.floor((cx-range)/this.cellSize);
    const maxX = Math.floor((cx+range)/this.cellSize);
    const minY = Math.floor((cy-range)/this.cellSize);
    const maxY = Math.floor((cy+range)/this.cellSize);
    const minZ = Math.floor((cz-range)/this.cellSize);
    const maxZ = Math.floor((cz+range)/this.cellSize);
    let arr=[];
    for(let ix=minX; ix<=maxX; ix++){
      for(let iy=minY; iy<=maxY; iy++){
        for(let iz=minZ; iz<=maxZ; iz++){
          let key=`${ix},${iy},${iz}`;
          if(this.cells.has(key)){
            arr.push(...this.cells.get(key));
          }
        }
      }
    }
    return arr;
	*/
  }
}

let allBells=[];
let spatialGrid=null;

function buildWorld(){
  spatialGrid=new SpatialGrid(10);
  for(let i=0; i<opt.TOTAL_BELLS; i++){
    let x= (Math.random()-0.5)*WORLD_SIZE;
    let y= (Math.random()-0.5)*WORLD_SIZE;
    let z= (Math.random()-0.5)*WORLD_SIZE;
    let r= 0.2+ 0.3*Math.random();
    let s= Math.random()*2.0-1.0;
    let bc= new BellCurve(x,y,z,r,s,false);
    allBells.push(bc);
    spatialGrid.insert(bc);
  }
  console.log("Created", allBells.length, "bellcurves in", WORLD_SIZE, "^3 region");
}
buildWorld();

/***************************************************************
 * 3) WebGL Setup
 ***************************************************************/

let canvas = document.getElementById("glCanvas");
let gl = canvas.getContext("webgl2");
if(!gl){
  alert("WebGL2 not found!");
}

/***************************************************************
 * 4) compileShader & createProgram
 ***************************************************************/

function compileShader(gl, type, src){
  let s=gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error("Shader compile error:", gl.getShaderInfoLog(s));
    throw new Error("Shader compile fail");
  }
  return s;
}
function createProgram(gl, vsSrc, fsSrc){
  let vs= compileShader(gl, gl.VERTEX_SHADER, vsSrc);
  let fs= compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  let p= gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error("Program link error:", gl.getProgramInfoLog(p));
    throw new Error("Program link fail");
  }
  return p;
}

/***************************************************************
 * 5) Single-Pass FS: Raymarch + Billboard Circles + GPU knobs
 ***************************************************************/

const vsSource=`#version 300 es
in vec2 position;
out vec2 uv;
void main(){
  uv = position * 0.5 + 0.5;
  gl_Position = vec4(position, 0,1);
}
`;

// We'll define NEAR_TOTAL = opt.NEAR_TOTAL
// We'll do a ring search for each bell & also a local tangent-plane transform
// to see if it's near 1 of the 5 knob angles, coloring them differently.
const fsSource=`#version 300 es
precision highp float;

in vec2 uv;
out vec4 outColor;

uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform float horizon;
uniform float isRaymarch;
uniform float closeEnuf;
uniform float circleBandPx;
uniform float knobAngleBand;  // how large an angle difference to consider a knob
uniform int selectedBellI; //-1 if none. 0 to NEAR_TOTAL-1 if selected.

uniform vec3 bellPositions[${opt.NEAR_TOTAL}];
uniform float bellRadii[${opt.NEAR_TOTAL}];
uniform float bellStrengths[${opt.NEAR_TOTAL}];

// We'll do no per-bell color for now, just ring vs knob vs surface. 
// If you want each bell to have a random color, you'd need arrays for that.
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;

const int MARCH_MAX_STEPS = ${opt.marchMaxSteps};
const int NEAR_TOTAL = ${opt.NEAR_TOTAL};
const int KNOB_COUNT = ${opt.KNOB_COUNT};

float sumOfBellcurves(in vec3 p){
  float val=0.0;
  for(int i=0;i<NEAR_TOTAL;i++){
    vec3 d = p - bellPositions[i];
    float dist2= dot(d,d);
    val += bellStrengths[i]* exp(-dist2/(2.0 * bellRadii[i]* bellRadii[i]));
  }
  return val;
}

// step function
float stepFunction(float val, float lastVal){
  // if isRaymarch>0.5 => variable step
  float doVar= step(0.5, isRaymarch);
  float fixedSz = ${opt.raytraceStep}; //float fixedSz= 0.2;
  float raw= 2.0* abs(val);
  float minimal=0.001;
  float stDist= max(raw, minimal);
  return mix(fixedSz, stDist, doVar);
  
  //return abs(val);
  //return stDist;
  //return val; //FIXME
}

// find the implicit surface
float findSurface(in vec3 origin, in vec3 dir, out vec3 outPos){
  float t=0.0;
  float val=0.0, lastVal=0.0;
  bool found=false;
  for(int i=0;i<MARCH_MAX_STEPS;i++){
    if(t> horizon) break;
    vec3 p= origin + dir*t;
    val= sumOfBellcurves(p);
    if(i>0 && (sign(val)!=sign(lastVal) || abs(val)< closeEnuf)){
      found= true;
      // approximate crossing
      float dt= ( stepFunction(val,lastVal)*abs(lastVal) ) / ( abs(val)+ abs(lastVal)+ 1e-9 );
      t= t- stepFunction(val,lastVal)+ dt;
      outPos= origin + dir*t;
      break;
    }
    lastVal= val;
    float stSz= stepFunction(val,lastVal);
    t+= stSz;
  }
  if(!found) return 999999.0;
  return t;
}

// For billboard ring & knobs. 
// We'll store bestRingT, bestRingColor, etc.
struct RingResult {
  float t;
  vec3 color;
  int i; //index 0 to NEAR_TOTAL-1 of the ring
};

RingResult findNearestBillboard(in vec3 origin, in vec3 dir){
  RingResult rr;
  rr.t= 999999.0;
  rr.color= vec3(0.0);
  rr.i = -2;

  // We'll define a stable planeRight, planeUp for the knob angles
  // We'll pick worldUp= (0,1,0) unless dot(worldUp, camForward)>0.9 => pick (1,0,0).
  vec3 worldUp= vec3(0,1,0);
  float d= abs(dot(worldUp, normalize(camForward)));
  if(d>0.9){
    worldUp= vec3(1,0,0);
  }
  vec3 planeRight= normalize( cross(camForward, worldUp) );
  vec3 planeUp   = normalize( cross(planeRight, camForward) );

  for(int i=0; i<NEAR_TOTAL; i++){
    // skip if it's dummy
    if(bellPositions[i].x>9000.0) continue;
    // plane intersection
    float denom= dot(dir, normalize(camForward));
    if(abs(denom)<1e-9) continue;
    float tC= dot( (bellPositions[i]-origin), normalize(camForward))/ denom;
    if(tC<0.01 || tC> horizon) continue;

    // dist3D from the plane point to bell center
    vec3 planePt= origin + dir* tC;
    float distCenter= distance(planePt, bellPositions[i]);

    // approximate how many px is "1 px" at distance tC
    float pxScale= 0.003 * tC;
    float band= circleBandPx * pxScale;

    // ring check
    float ringDiff= abs(distCenter - bellRadii[i]);
    if(ringDiff < band){
      // we have found a ring. Possibly a knob.
      // local 2D coords in plane: localX= dot(planeRight, (planePt-center)), localY= dot(planeUp, (planePt-center))
      vec3 localVec= planePt - bellPositions[i];
      float localX= dot(localVec, planeRight);
      float localY= dot(localVec, planeUp);
      float angle= atan(localY, localX); // in [-pi, pi]
      if(angle<0.0) angle += 6.2831853; // so [0..2pi)
      float knobAngle= 6.2831853 / float(KNOB_COUNT); // 2pi/5 => ~1.2566
      // find which knob index is closest:
      float kFloat= angle / knobAngle; // e.g. 2.2 => knob #2
      float kRound= floor( kFloat+0.5 );
      float angleDiff= abs( kFloat - kRound );
      // if angleDiff < knobAngleBand? We do a subband. e.g. 0.2 => yes
      float angleThresh= knobAngleBand; // e.g. 0.2 or 0.15
      if(angleDiff < angleThresh){
        // color the knob
        float knobIdx= mod( kRound, float(KNOB_COUNT) );
        // map 0->red,1->green,2->blue,3->white,4->black for example
        // We'll do a quick if-else or a small array. For brevity, do if else:
        vec3 knobColor;
        if(knobIdx<0.5) knobColor= vec3(1,0,0);
        else if(knobIdx<1.5) knobColor= vec3(0,1,0);
        else if(knobIdx<2.5) knobColor= vec3(0,0,1);
        else if(knobIdx<3.5) knobColor= vec3(1,1,1);
        else knobColor= vec3(0,0,0);
        // pick that
        if(tC< rr.t){
          rr.t= tC;
          rr.color= knobColor;
		  rr.i = i;
        }
      } else {
        // it's ring but not a knob => e.g. gray
        if(tC< rr.t){
          rr.t= tC;
		  rr.color= vec3(0.6,0.6,0.6);
		  rr.i = i;
        }
      }
    }
  }
  return rr;
}

// shading the surface
vec3 shadeSurface(in vec3 p){
  float eps= 0.001;
  float base= sumOfBellcurves(p);
  vec3 grad= vec3(0);
  for(int k=0;k<3;k++){
    vec3 offset= vec3(0);
    offset[k]= eps;
    float val2= sumOfBellcurves(p+ offset);
    grad[k]= (val2 - base)/ eps;
  }
  vec3 N= normalize(grad);
  vec3 L= normalize(vec3(1,1,1));
  float bright= 1.8/(1.0+ exp(-2.5* dot(N,L)));
  float weirdBright = .5+.5*sin(bright*10.);
  float wx= dot(N,vec3(1,0,0))*0.5 +0.5;
  float wy= dot(N,vec3(0,1,0))*0.5 +0.5;
  float wz= dot(N,vec3(0,0,1))*0.5 +0.5;
  float sumw= wx+wy+wz +1e-9;
  vec3 angleColor= (color1*wx + color2*wy + color3*wz)/ sumw;
  //return angleColor* bright;
  //return bright;
  //return angleColor;
  //return vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
  //float smul = 8.;
  float smul = 2.5;
  vec3 stable3dColor = vec3(.5+.5*sin(p[0]*smul),.5+.5*sin(p[1]*smul),.5+.5*sin(p[2]*smul));
  vec3 abc = vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
  return abc*.03+stable3dColor*.7+bright*-.3;
}

void main(){
  // build a ray from pixel
  vec2 st= uv*2.0-1.0;
  vec3 dir= normalize( camForward + st.x*camRight + st.y*camUp );

  // 1) find ring
  RingResult rRing= findNearestBillboard( camPos, dir );

  // 2) find surface
  vec3 surfPos= vec3(0);
  float tSurf= findSurface( camPos, dir, surfPos );

  // pick whichever is near
  if(${opt.displayTerrain?'':'true ||'} rRing.t < tSurf){
    vec3 color = rRing.color;
	//if((rRing.i&1)==0){ //test
	/*if(rRing.i == selectedBellI){
		//color = mix(color, vec3(0.), .7);
		//color = (color-.3)*12.;
		//color = vec3(tSurf*.1);
		color = 1.-color;
	}*/
    outColor= vec4(color,1.0);
  } else if(tSurf< 999999.0){
    vec3 c= shadeSurface(surfPos);
    outColor= vec4(c,1.0);
  } else {
    outColor= vec4(0.5,0.5,0.5,1.0);
  }
}
`;

/***************************************************************
 * 6) Create & link
 ***************************************************************/

let vs=compileShader(gl,gl.VERTEX_SHADER,vsSource);
let fs=compileShader(gl,gl.FRAGMENT_SHADER,fsSource);
let program= gl.createProgram();
gl.attachShader(program,vs);
gl.attachShader(program,fs);
gl.linkProgram(program);
if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
  console.error("link err:",gl.getProgramInfoLog(program));
  throw new Error("link fail");
}
gl.useProgram(program);

// uniform locs
let loc_bellPos = gl.getUniformLocation(program,"bellPositions");
let loc_bellRad = gl.getUniformLocation(program,"bellRadii");
let loc_bellStr = gl.getUniformLocation(program,"bellStrengths");

let loc_camPos   = gl.getUniformLocation(program,"camPos");
let loc_camFwd   = gl.getUniformLocation(program,"camForward");
let loc_camRight = gl.getUniformLocation(program,"camRight");
let loc_camUp    = gl.getUniformLocation(program,"camUp");

let loc_horizon  = gl.getUniformLocation(program,"horizon");
let loc_isRay    = gl.getUniformLocation(program,"isRaymarch");
let loc_closeE   = gl.getUniformLocation(program,"closeEnuf");
let loc_circPx   = gl.getUniformLocation(program,"circleBandPx");
let loc_knobAng  = gl.getUniformLocation(program,"knobAngleBand");
let loc_selectedBellI   = gl.getUniformLocation(program,"selectedBellI");

let loc_col1     = gl.getUniformLocation(program,"color1");
let loc_col2     = gl.getUniformLocation(program,"color2");
let loc_col3     = gl.getUniformLocation(program,"color3");

// VAO
let quadVBO= gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,quadVBO);
let quadData= new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1, 1,-1, 1,1
]);
gl.bufferData(gl.ARRAY_BUFFER,quadData,gl.STATIC_DRAW);

let vao= gl.createVertexArray();
gl.bindVertexArray(vao);
let posLoc= gl.getAttribLocation(program,"position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
gl.bindVertexArray(null);

/***************************************************************
 * 7) Searching up to NEAR_TOTAL
 ***************************************************************/

let nearBells=[];
let selectedBellI = -1; //index in nearBells, copied into GPU for display
let gpuPos= new Float32Array(opt.NEAR_TOTAL*3);
let gpuRad= new Float32Array(opt.NEAR_TOTAL);
let gpuStr= new Float32Array(opt.NEAR_TOTAL);

function updateNearBells(){
  let rng= 200;
  let cpx= camPos[0], cpy= camPos[1], cpz= camPos[2];
  if(opt.displayCenterForwardOfCam){
	let fwd = calculateForwardVector(camQ);
	cpx += fwd[0]*opt.displayCenterForwardOfCam
	cpy += fwd[1]*opt.displayCenterForwardOfCam;
	cpz += fwd[2]*opt.displayCenterForwardOfCam;
  }
  let cands= spatialGrid.queryNearby(cpx,cpy,cpz, rng);
  //FIXME 2025-3-27 this is returning all 100k bells cuz cell size is 10.
  cands.sort((a,b)=>{
    let da=(a.x-cpx)**2+(a.y-cpy)**2+(a.z-cpz)**2;
    let db=(b.x-cpx)**2+(b.y-cpy)**2+(b.z-cpz)**2;
    return da-db;
  });
  nearBells= cands.slice(0,opt.NEAR_TOTAL);
  //let prev_selectedBellI = selectedBellI;
  selectedBellI = -1; //none
  for(let i=0;i<nearBells.length; i++){
    gpuPos[i*3+0]= nearBells[i].x;
    gpuPos[i*3+1]= nearBells[i].y;
    gpuPos[i*3+2]= nearBells[i].z;
    gpuRad[i]    = nearBells[i].radius;
    gpuStr[i]    = nearBells[i].strength;
	if(nearBells[i].isSelected){
		if(selectedBellI != -1){
			throw new Error('Found second selected bell. max 1.');
		}
		selectedBellI = i;
	}
  }
  //if(prev_selectedBellI != selectedBellI) console.log('selectedBellI='+selectedBellI);
  console.log('selectedBellI='+selectedBellI);
  /*for(let i=nearBells.length; i<opt.NEAR_TOTAL; i++){ //FIXME remove this?
    gpuPos[i*3+0]= 9999;
    gpuPos[i*3+1]= 9999;
    gpuPos[i*3+2]= 9999;
    gpuRad[i]= 0.01;
    gpuStr[i]= 0.0;
	nearBells[i].isSelected = false;
  }*/
}

/***************************************************************
 * 8) Camera + Gamepad
 ***************************************************************/

let camPos=[0,0,5];
let camQ  =[0,0,0,1];

function updateFromGamepad(dt){
  let gps= navigator.getGamepads();
  if(!gps) return;
  let gp= gps[0];
  if(!gp) return;
  let lx= gp.axes[0], ly= gp.axes[1];
  let rx= gp.axes[2], ry= gp.axes[3];
  const dead= 0.06;
  //const dead= 0; //FIXME
  let lLen= Math.hypot(lx,ly);
  if(lLen>dead){
    let leftover= lLen- dead;
    lx*= leftover/lLen;
    ly*= leftover/lLen;
  } else { lx=0; ly=0; }
  let rLen= Math.hypot(rx,ry);
  if(rLen>dead){
    let leftover2= rLen- dead;
    rx*= leftover2/rLen;
    ry*= leftover2/rLen;
  } else { rx=0; ry=0; }
  ry*=-1;
  let turnSpd = 2;
  rx *= turnSpd;
  ry *= turnSpd;
  rotateCamera(rx,ry,dt);

  let fwdVal= gp.buttons[7]?.value - gp.buttons[6]?.value;
  let upDown= -ly;
  let leftRight= lx;
  let fwd= calculateForwardVector(camQ);
  let upv= calculateUpVector(camQ);
  let rig= cross(fwd, upv); rig= normalize(rig);
  upv= normalize(cross(rig, fwd));
  //let moveSpd=2.0;
  let moveSpd=2.0;
  camPos[0]+= (fwd[0]*fwdVal + upv[0]*upDown + rig[0]*leftRight)* moveSpd* dt;
  camPos[1]+= (fwd[1]*fwdVal + upv[1]*upDown + rig[1]*leftRight)* moveSpd* dt;
  camPos[2]+= (fwd[2]*fwdVal + upv[2]*upDown + rig[2]*leftRight)* moveSpd* dt;
}

function rotateCamera(rx, ry, dt){
  const threshold= 0.001;
  let fwd= calculateForwardVector(camQ);
  let upv= calculateUpVector(camQ);
  let rig= cross(fwd, upv); rig= normalize(rig);
  upv= normalize(cross(rig, fwd));

  let combined=[0,0,0,1];
  if(Math.abs(rx)> threshold){
    let yawAngle= -rx*2.0* dt;
    let yawQ= createQuaternion(upv,yawAngle);
    combined= multiplyQuaternions(yawQ,combined);
  }
  if(Math.abs(ry)> threshold){
    let pitchAngle= -ry*2.0* dt;
    let pitchQ= createQuaternion(rig,pitchAngle);
    combined= multiplyQuaternions(combined,pitchQ);
  }
  camQ= multiplyQuaternions(combined, camQ);
  camQ= normalizeQuaternion(camQ);
}

/***************************************************************
 * 9) CPU overlay of ring+knobs is removed. 
 *    But user wants to “click + drag” to update the 5 numbers per bell?
 *    That now means we have no 2D or “visible overlay.” 
 *    We'll do a trivial approach:
 *    If user clicks => we do a “nearest billboard ring.” 
 *    Then if it’s near a knob => store which bell & knob. 
 *    Drag changes that param.  But we cannot see them, 
 *    because we removed the CPU overlay.
 ***************************************************************/

// For demonstration, we'll still handle mouse so user can drag (like a big invisible UI).
// We'll do the same findKnobAt approach in JS, but that means we replicate the plane intersection logic in JS 
// or we do readPixels but that’s more complicated. 
// We'll replicate the plane logic + local tangent-plane transform here. 
// If you truly want *perfect* matching, you'd do a readback from a picking buffer or do an extra pass, but that’s advanced.

// We'll do a minimal approach, scanning the same nearBells.  
// If found ring & knob => we set dragState. Then as user drags => we adjust radius, or strength, or x,y,z, etc.

let dragState=null;
let mousedown = e=>{
  let rect= canvas.getBoundingClientRect();
  let mx= e.clientX- rect.left;
  //FIXME findKnobAt is flipped in y, +y is up. let my= e.clientY- rect.top;
  //let my= rect.y-e.clientY; //cuz flipped. FIXME
  let my= e.clientY- rect.top;
  my = rect.height-1-my; //cuz flipped. FIXME.
  let k= findKnobAt(mx,my);
  if(k){
	for(let bc of allBells) bc.isSelected = false; //unselect all
    //if(dragState) dragState.bc.isSelected = false; //unselect prev selection
    dragState={
      bc: k.bc,
      knobIndex: k.knobIndex,
      startY: my,
      startVal: getParamVal(k.bc,k.knobIndex)
    };
	dragState.bc.isSelected = true; //select next
  }
};
canvas.addEventListener("mousedown", mousedown);
canvas.addEventListener("mousemove", e=>{
  //mousedown(e); //FIXME
  if(!dragState) return;
  let rect= canvas.getBoundingClientRect();
  let my= e.clientY-rect.top; //FIXME
  my = rect.height-1-my; //FIXME cuz flipped y between cpu and gpu
  let dy= my- dragState.startY;
  let newVal= dragState.startVal+ (-dy*0.02);
  setParamVal(dragState.bc, dragState.knobIndex, newVal);
});
canvas.addEventListener("mouseup", e=>{
	for(let bc of allBells) bc.isSelected = false; //unselect all
});
canvas.addEventListener("mouseup", e=>{
  dragState=null;
});

var selectedKnob = null;

// We replicate the plane logic for ring & knob detection in JS. 
// See the approach used in the fragment code, but we do it once for every bell. 
// Then we pick whichever is closest in tC. If ringDiff < band => we also do knob angle check.
function findKnobAt(mx,my){
	console.log('findKnobAt mx='+mx+' my='+my);
	let camForward = calculateForwardVector(camQ); //FIXME this was added 2025-3-27 dont know if its the correct camForward
	let camUp= calculateUpVector(camQ); //FIXME
	let camRight= cross(camForward, camUp); //FIXME
	camRight= normalize(camRight); //FIXME
	console.log('camForward='+camForward);

  // transform pixel -> st => [-1..1], st => build ray
  let width= canvas.width, height= canvas.height;
  //let stx= (mx/(float(width))) *2.0 -1.0; 
  let stx= (mx/width) *2.0 -1.0; 
  //let sty= (my/(float(height)))*2.0 -1.0;
  let sty= (my/height)*2.0 -1.0;
  // but we are in JS, so do
  let stxF= (mx/width)*2 -1;
  let styF= (my/height)*2-1;
  let dir= normalize( vecAdd( camForward, vecAdd( scale(camRight,stxF), scale(camUp,styF) ) ) );

  // define plane normal= camForward
  let n= normalize(camForward);
  let bestT= 999999;
  let bestBell=null;
  let bestKnob=-1;

  // define stable planeRight, planeUp
  let wUp= [0,1,0];
  let d= Math.abs(dot(wUp, n));
  if(d>0.9){
    wUp= [1,0,0];
  }
  let pRight= normalize( cross(n, wUp) );
  let pUp   = normalize( cross(pRight, n) );

  for(let i=0; i< nearBells.length; i++){
    let bc= nearBells[i];
    if(bc.x>9000) continue;
    let denom= dot(dir, n);
    if(Math.abs(denom)<1e-9) continue;
    let c= [bc.x, bc.y, bc.z];
    let diff= vecSub(c, camPos);
    let tC= dot(diff,n)/ denom;
    
	
	
	
	//if(tC<0.01 || tC> opt.horizon) continue; //commentedout 2025-3-28 for testing
	if(tC<0.01 || tC> opt.horizon) continue;
	
	
	
	
    // planePt
    let planePt= vecAdd( camPos, scale(dir, tC) );
    let distC= length( vecSub(planePt, c) );
    // ring diff
    let pxScale= 0.003* tC;
    let band= opt.circleBandPx* pxScale;
    let ringDiff= Math.abs(distC- bc.radius);
    if(ringDiff < band){
      // might be a knob
      // local2D
      let localVec= vecSub(planePt, c);
      let localX= dot(localVec, pRight);
      let localY= dot(localVec, pUp);
      let angle= Math.atan2(localY, localX);
      if(angle<0) angle+= 2*Math.PI;
      let knobAng= 2*Math.PI/ opt.KNOB_COUNT; 
      let kFloat= angle/ knobAng;
      let kRound= Math.floor(kFloat+0.5);
      let angleDiff= Math.abs( kFloat- kRound );
      if(angleDiff < opt.knobAngleBand){
        // it's a knob
        if(tC< bestT){
          bestT= tC;
          bestBell= bc;
          bestKnob= kRound % opt.KNOB_COUNT;
        }
      } else {
        // ring
        // maybe store a separate best ring, but user only wants to drag knobs.
        // so if it’s ring only => no knob => no drag
        // skip
      }
    }
  }
  if(!bestBell) return null;
  selectedKnob={bc: bestBell, knobIndex: bestKnob};
  console.log('selectedKnob='+JSON.stringify(selectedKnob));
  setParamVal(selectedKnob.bc, selectedKnob.knobIndex,
	getParamVal(selectedKnob.bc, selectedKnob.knobIndex)+.001);
  return selectedKnob;
}

// minimal vector utilities in JS:
function vecAdd(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];}
function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];}
function dot(a,b){ return a[0]*b[0]+ a[1]*b[1]+ a[2]*b[2];}
function cross(a,b){
  return [
    a[1]*b[2]- a[2]*b[1],
    a[2]*b[0]- a[0]*b[2],
    a[0]*b[1]- a[1]*b[0]
  ];
}
function scale(a,s){return [a[0]*s, a[1]*s, a[2]*s];}
function length(a){ return Math.hypot(a[0],a[1],a[2]);}
function normalize(a){
  let L= length(a);
  if(L<1e-9) return [0,0,0];
  return [a[0]/L, a[1]/L, a[2]/L];
}

/***************************************************************
 * 11) Editing the 5 knobs means x,y,z,radius,str
 ***************************************************************/

function getParamVal(bc,k){
  switch(k){
    case 0: return bc.x;
    case 1: return bc.y;
    case 2: return bc.z;
    case 3: return bc.radius;
    case 4: return bc.strength;
  }
}
function setParamVal(bc,k,v){
  console.log('setParamVal k='+k+' v='+v+' bc='+bc);
  switch(k){
    case 0: bc.x= v; break;
    case 1: bc.y= v; break;
    case 2: bc.z= v; break;
    case 3: bc.radius= Math.max(0.01,v); break;
    case 4: bc.strength= v; break;
  }
}

/***************************************************************
 * 12) Render loop
 ***************************************************************/

function renderLoop(t){
  let dt= 0.016; // approximate
  updateFromGamepad(dt);
  updateNearBells();

  // camera basis
  let fwd= calculateForwardVector(camQ);
  let upv= calculateUpVector(camQ);
  let rig= cross(fwd, upv); rig= normalize(rig);
  upv= normalize(cross(rig, fwd));

  // set uniforms
  gl.viewport(0,0, canvas.width, canvas.height);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);

  gl.uniform3fv(loc_bellPos, gpuPos);
  gl.uniform1fv(loc_bellRad, gpuRad);
  gl.uniform1fv(loc_bellStr, gpuStr);

  gl.uniform3f(loc_camPos, camPos[0], camPos[1], camPos[2]);
  gl.uniform3f(loc_camFwd, fwd[0], fwd[1], fwd[2]);
  gl.uniform3f(loc_camRight, rig[0], rig[1], rig[2]);
  gl.uniform3f(loc_camUp, upv[0], upv[1], upv[2]);

  gl.uniform1f(loc_horizon, opt.horizon);
  gl.uniform1f(loc_isRay, (opt.isRaymarch?1.0:0.0));
  gl.uniform1f(loc_closeE, opt.closeEnufToZero);
  gl.uniform1f(loc_circPx, opt.circleBandPx);
  gl.uniform1f(loc_knobAng, opt.knobAngleBand);
  gl.uniform1i(loc_selectedBellI, selectedBellI);

  gl.uniform3fv(loc_col1, [1.0,0.2,0.2]);
  gl.uniform3fv(loc_col2, [0.2,1.0,0.2]);
  gl.uniform3fv(loc_col3, [0.2,0.2,1.0]);

  gl.bindVertexArray(vao);
  gl.drawArrays(gl.TRIANGLES,0,6);
  gl.bindVertexArray(null);

  requestAnimationFrame(renderLoop);
}
requestAnimationFrame(renderLoop);

/***************************************************************
 * 13) Quicksave / Quickload
 ***************************************************************/

function doQuicksave(slot){
  let c= { pos:[...camPos], quat:[...camQ] };
  let arr=[];
  for(let b of allBells){
    arr.push([b.x,b.y,b.z,b.radius,b.strength]);
  }
  let obj={ camera:c, bellcurves:arr };
  let s= JSON.stringify(obj);
  localStorage.setItem("bellsack_qs_"+slot, s);
  alert("Saved slot "+slot+", len="+s.length);
}
function doQuickload(slot){
  let s= localStorage.getItem("bellsack_qs_"+slot);
  if(!s){
    alert("No data in slot "+slot);
    return;
  }
  let obj= JSON.parse(s);
  camPos[0]= obj.camera.pos[0];
  camPos[1]= obj.camera.pos[1];
  camPos[2]= obj.camera.pos[2];
  camQ[0]  = obj.camera.quat[0];
  camQ[1]  = obj.camera.quat[1];
  camQ[2]  = obj.camera.quat[2];
  camQ[3]  = obj.camera.quat[3];

  allBells=[];
  spatialGrid= new SpatialGrid(10);
  for(let row of obj.bellcurves){
    let bc= new BellCurve(row[0],row[1],row[2],row[3],row[4],false);
    allBells.push(bc);
    spatialGrid.insert(bc);
  }
  alert("Loaded slot "+slot+", got "+allBells.length+" bells");
}

/***************************************************************
 * 14) Quaternions & small vector ops
 ***************************************************************/

function calculateForwardVector(q){
  const[x,y,z,w]=q;
  const xx= 2.0*(x*z+ w*y);
  const yy= 2.0*(y*z- w*x);
  const zz= 1.0- 2.0*(x*x+ y*y);
  const ln= Math.hypot(xx,yy,zz);
  if(ln<1e-9) return [0,0,1];
  return [xx/ln, yy/ln, zz/ln];
}
function calculateUpVector(q){
  const[x,y,z,w]=q;
  const xx= 2.0*( x*y- w*z );
  const yy= 1.0- 2.0*( x*x+ z*z );
  const zz= 2.0*( y*z+ w*x );
  const ln= Math.hypot(xx,yy,zz);
  if(ln<1e-9) return [0,1,0];
  return [xx/ln, yy/ln, zz/ln];
}
function cross(a,b){
  return [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ];
}
function normalize(v){
  const ln= Math.hypot(v[0],v[1],v[2]);
  if(ln<1e-9) return [0,0,0];
  return [v[0]/ln, v[1]/ln, v[2]/ln];
}
function multiplyQuaternions(q1,q2){
  const[x1,y1,z1,w1]=q1;
  const[x2,y2,z2,w2]=q2;
  return [
    w1*x2 + x1*w2 + y1*z2 - z1*y2,
    w1*y2 - x1*z2 + y1*w2 + z1*x2,
    w1*z2 + x1*y2 - y1*x2 + z1*w2,
    w1*w2 - x1*x2 - y1*y2 - z1*z2
  ];
}
function createQuaternion(axis,angle){
  const ha= angle*0.5;
  const s = Math.sin(ha);
  return [ axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(ha)];
}
function normalizeQuaternion(q){
  const ln= Math.hypot(q[0],q[1],q[2],q[3]);
  if(ln<1e-9) return [0,0,0,1];
  return [q[0]/ln, q[1]/ln, q[2]/ln, q[3]/ln];
}
</script>

</body>
</html>
