<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Bellsack</title>
	<style>
	body {
		margin: 0; padding: 0; background: #222;
		display: flex;
		justify-content: center;
		align-items: center;
		font-family: sans-serif;
	}
	canvas {
		background: black;
	}
	</style>
	<meta name="description" content="Bellsack game engine is opensource/Apache2 (starting at version 256, 2025-8-3) by Ben F Rayfield, including the Lamgl*.js and Var*.js which you can use as script tags here or separate files. Source code is all in this html, divided into 4 script tags and a little dom nodes: Lamgl (my 10 teraflop GPU API that runs in browsers), Var (high dimensional vector tree), Sak (incomplete programming language based on Var and Lamgl merging javascript with GLSL/GPU), and Bellsack (isosurface and balls). See https://github.com/benrayfield/jsutils/blob/master/src/bellsack/Bellsack255_firstMultilicense_Apache2_MIT_todoApacheOnlyGoingForward.html for where MIT vs Apache2 split. --- Bellsack technical stuff: It computes signed-distance by newton-loop of solving differential equation that relates 3d gradient of the scalar field to the scalar field itself. Sums 2 loss terms, 1 the density itself at 3d point, and the other, samples 4 times prefers gradient parallel to direction to ball. BellsackUpdate2025-12-16[[[[I'm close to the balls being fun to bounce around on the 3d curves. Has been physics bugs preventing it, that make balls sometimes bounce on invisible things that shouldnt exist in mid air (are density field localmins) and sometimes go thru walls. Once I get nearestPointOnIsosurfaceFromXYZ(vec3, ...params to tune experimental algorithms...)=>vec3 working more reliably, u wont be able to tell the difference between it and any other frictionless hardbody sim, except its hard bodies can have hundreds of dimensions (are a float[n]=>float scalar field defined by glsl code each). If u throw a ball at the ground, the ground will bend only in certain ways. These ways can generally solve any simple combo of a bunch of different algebra equations by least squares.]]]].">
<script>
//Lamgl*.js, opensource/Apache2 (versions before Bellsack256/2025-8-3 are MIT) by Ben F Rayfield.
//
//Lamgl copied from LamglNBody_333_50kParticles.html 2025-10-13-435pET which was
//copied from Bellsack330.html 2025-10-13-125pET then modified to fix some Lamgl bugs.
const Lamgl = window.Lamgl = (() => {
/*
	Ive fit up to 7gB in GPU memory of a browser in a bunch of 16mB 1024x1024x4xFloat32 GL textures.

	Bellsack 300 uses 3 fragment shaders (sfSourceMaker(funcName)), 1 for graphics and 2 for physics.
	The first physics shader estimates the nearest 3d point on isosurface to each ball (ballCacheVec4).
	The second physics shader uses ballCacheVec4 to compute high dimensional gradient of loss function
	called on nearby part of game state. The graphics shader does raytracing or raymarching.
	Look up opt {}.

	Bellsack (238) lets u shoot balls using LB/RB gamepad buttons, loads faster (fixed by using GL uniforms instead of constants, to prevent loop-unrolling optimization). See video of the balls reshaping terrain. Next I need to make it run faster. Play at https://html-preview.github.io/?url=https://github.com/benrayfield/jsutils/blob/master/src/bellsack/bellsack236_moreStableTerrainReshapingCuzBallsAndTerrainHeldNearStartingPositionsBySprings.html

	My GPU API LamglFromBellsack238.js, this time I tested it as a js script src= import and it works. This competes with tensorflow.js and GPU.js and is pure immutable tensors of shape [height,width,4], made for games but can do neuralnets, fractals, etc. https://github.com/benrayfield/jsutils/blob/master/src/lamgl/LamglFromBellsack238.js

	Have bell_5. TODO bell_13 with radius replaced by a mat3 (3x3 rotation) or radius_and_quaternion, which is enuf to make skatepark shapes with.
	Make that one of the "species". A fractal can be a species too.

	
	if u call Lamgl with the same sh/shape, sv vertex shader code string, and sf fragment shader code string, it will call the already JIT compiled GPU stuff from the first call of it. Its returning sometimes as fast as 1/10000 second.
	
	maybe I should make it take an optional WebGL2 as a param Lamgl=MakeLamgl(...hand it a WebGL2 from an existing canvas...);
	
	My game engine is weird cuz the objects are just an infinite set of points, but those points arent moving. Nothing moves. It pops out of existence one place and some other places pop into existence. It doesnt even have to be the same volume. So I cant tell is it moving along its surface, only if that surface is expanding outward or shrinking inward.
	
	2025-12-3 redesigns for multiprobe[[
		Three physics execution paths in Bellsack 380 / 384
		Case	Toggles	GPU passes	What each pass does
		1 · Legacy single-pass	chkIsBallCacheOptimization == OFF (cache disabled)	1 shader physicsSimple	For every perturb dimension and every ball it directly calls
		nearestPointOnIsosurfaceFromXYZ → signed-distance → gradient. No intermediate cache.
		2 · Two-pass cache (1 probe/ball)	chkIsBallCacheOptimization == ON
		multiprobe == OFF (offsetsPerBall = 1)	A physicsCacheNearestVec4PerBall
		B physicsUseNearestVec4PerBall	A: one Newton solve per ball → writes ballCacheVec4 [numBalls, 1, 4].
		B: VarGradientGL reads that single vec4, computes loss gradient for all Vars.
		3 · Three-pass cache (17 probe/ball)	chkIsBallCacheOptimization == ON
		multiprobe == ON (offsetsPerBall ≈ 17)	A0 physicsCacheNearestVec4PerBall (17× threads)
		A1 merge shader (SMERGE)
		B physicsUseNearestVec4PerBall	A0: launches ~17 Newton solves per ball (one per offset) → [numBalls, 17, 4].
		A1: for each row pick the lowest sortVal, drop column-dim → [numBalls, 1, 4].
		B: same as in case 2, now using the merged cache.

		Extra knobs that don’t change the pass count

		cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache – when ON, pass B reruns a Newton refine for every perturb sample, but it is still a single shader.

		debugGraphicsOnBallThatUsesSignedDistancePerPixel – lives only in the graphics fragment shader; re-enters a Newton solve per pixel but doesn’t add another physics pass.

		So:

		1 pass if cache optimisation is off.

		2 passes with cache on & single-probe.

		3 passes with cache on & multi-probe (17-sample) upgrade.

		You said:
		2025-12-3-1214pET bellsackCoding2025-12-2+[[[
		YES multiprobe
		YES debugGraphicsOnBallThatUsesSignedDistancePerPixel
		YES cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
		YES chkIsBallCacheOptimization
		]]]

		I probably want to put a few more checkboxes to vary multiprobe_physics multiprobe_graphicsThingABC etc. for each of those, i can vary them separately, and if i do it in debugGraphicsOnBallThatUsesSignedDistancePerPixel or cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache or the unchecked of chkIsBallCacheOptimization then it does a loop of numOffsetsPerBall in 1 GPU thread, not the fastest way but ok for infrequently used debug options. Proceed, a little more talking to GPT but i think we got this mostly solved...
	]]
	

	TODO hook in VarTree.html/VarTree.jsp
	which code to call LamGL will be in the tree (.big fields). All this together will remake BellSack and
	scale it up to 30 species near each area and swapping in/out species as you move around the massively
	multiplayer 3d world. LOOK IN BROWSER CONSOLE FOR "test pass" or errors.
	
	2025-9-21[[
		START Lamgl.doBasicTests()
		LamglFromBellsack327.js:177 Youre probably just testing simple stuff in 1 GPU thread. !hasXYAttr && !has_gl_VertexID. You normally do one or the other. Add "in vec2 XY;" for 2 triangles covering the rectangle heightXwidth, or use gl_VertexID (an int) in sv aka vertex shader code string. sv[#version 300 es
						precision highp float;
						void main(){
							gl_Position = vec4(0.,0.,0.,1.0);
							gl_PointSize = 1.0;
						}]
		LamglFromBellsack327.js:1364 testA={result: [Tensor sh=[1,1,4]]}
		LamglFromBellsack327.js:1340 Test pass, one vec4
		LamglFromBellsack327.js:1370 doBasicTests, Lamgl=function () { [native code] }
		LamglFromBellsack327.js:1372 doBasicTests, arr=[Tensor sh=[1,2,4]]
		LamglFromBellsack327.js:1409 testD={result: [Tensor sh=[128,128,4]]}
		LamglFromBellsack327.js:1340 Test pass, testD
		LamglFromBellsack327.js:1458 tenThousandFloatsOut test pass
		LamglFromBellsack327.js:1461 START test testMatmulAC
		LamglFromBellsack327.js:1486 testMatmulAC matAB and matBC created
		LamglFromBellsack327.js:1524 r=0 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r0
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=0 testMatmulAC4 secs=0.30049991607666016 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=7.146370208809503 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1524 r=1 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r1
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=1 testMatmulAC4 secs=0.3219001293182373 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=6.671273020449619 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1524 r=2 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r2
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=2 testMatmulAC4 secs=0.25119996070861816 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=8.548901209785596 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1524 r=3 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r3
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=3 testMatmulAC4 secs=0.27810001373291016 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=7.721983250466372 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1524 r=4 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r4
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=4 testMatmulAC4 secs=0.2867000102996826 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=7.490350787763391 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1524 r=5 copyToCpuInMatmulTest=false
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=5 testMatmulAC4 secs=0.00020003318786621094 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=10735.636775615008 observed_testMatmulAC4.length=undefined
		LamglFromBellsack327.js:1524 r=6 copyToCpuInMatmulTest=false
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=6 testMatmulAC4 secs=0.00010013580322265625 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=21445.71251128808 observed_testMatmulAC4.length=undefined
		LamglFromBellsack327.js:1524 r=7 copyToCpuInMatmulTest=false
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=7 testMatmulAC4 secs=0.00009989738464355469 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=21496.895596040555 observed_testMatmulAC4.length=undefined
		LamglFromBellsack327.js:1524 r=8 copyToCpuInMatmulTest=false
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=8 testMatmulAC4 secs=0 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=Infinity observed_testMatmulAC4.length=undefined
		LamglFromBellsack327.js:1524 r=9 copyToCpuInMatmulTest=true
		LamglFromBellsack327.js:1586 observed_testMatmulAC4_map=[object Object]
		LamglFromBellsack327.js:1340 Test pass, testMatmulAC_r9
		LamglFromBellsack327.js:1616 repeat_testMatmulAC4=9 testMatmulAC4 secs=0.2894001007080078 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=7.420466139252378 observed_testMatmulAC4.length=1048576
		LamglFromBellsack327.js:1670 quadTest passed â€“ Lamgl QUAD geometry ok
		LamglFromBellsack327.js:1688 END Lamgl.doBasicTests()
		LamglFromBellsack327_test.html:5 [Violation] 'click' handler took 8941ms
	]]

	Avoid these bugs in WebGL2 GLSL ES 300:
	-- If you texelFetch the same address twice in the same GPU thread, you'll get all 0s.
	[This is a known bug-like behavior (especially on certain GPUs and drivers, notably Intel and some mobile chipsets), and it boils down to this: In WebGL2 / GLSL ES 300, if you call texelFetch() multiple times with the same coordinates and sampler in the same shader invocation — even if in different scopes — you may get all 0.0s as the result on the second+ calls. This isn't defined behavior by the spec, but it's a real-world GPU driver optimization bug.]--GPT.
	-- Some GLSL optimizers are buggy so u have to make sure some code happens like this sometimes:
		//*1.0000001 avoid returning all 0s, force it to to do some calculation
		//thats not from the textures, cuz the glsl optimizer is buggy.
		dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.0000001
		I ended up doing just +1 in one shader and -1 in another shader, which is better than * then / of 1.0000001 .

	2025-5-4 did this just reach 1 teraflop/sec when turned off observed_testMatmulAC4?
	testMatmulAC4 secs=0.10042023658752441 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=2.6731211269955195 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.047499895095825195 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.651285238808727 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.04397988319396973 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=6.103596383284764 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.05035996437072754 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.330334509847906 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.049179792404174805 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.4582470335359305 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00036025047302246094 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=745.1356100877723 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002598762512207031 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1032.9356943510313 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00028014183044433594 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=958.2126866745737 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002799034118652344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=959.0288814673117 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00024008750915527344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1118.073393090987 observed_testMatmulAC4.length=undefined
	...
	something dont seem right here. maybe its just that im not refilling the input matrixs so it doesnt have to move them around GPU memory as much, but its saying 21 teraflops when i raised to multiplying 2 1024x1024 matrixs: secs=0.00009989738464355469 gigaflopPerSec=21496.89559604
		
	2025-5-4-950aET about doBasicTests matmul tests only[[
	Are you recompiling the shader every call?
	no
	let program = vm.cache('program'+cacheKeySuffix, function(){...
	lazyevals it once

	 Are you recreating textures or frameBuffers every call?
	I was but i just fixed that (see .free() in finally block in new code im not giving u yet) and its a little faster but still taking 40ms.

	Are you doing gl.readPixels() after every run?
	yes.its for testing but i guess i shouldnt do that in the speed test

	Are you uploading data from CPU to GPU every time?
	no. it stays in the 2 input textures/tensors.

	 Are you allocating a new canvas or GL context?
	no

	Are you doing unnecessary conversions (e.g., CPU reshape / flatten)?
	no, not in the loop, only before it, and those tests in the loop are still slow. I expect the first 1 to be slow but not those after it.

	Are you launching too many threads or using poor loop structure?
	TinyGLSL is fast even with a million GPU threads. im only using 512*512/4=64k gpu threads which should be ok.
	]]

	The shit i gotta do for pointer-arithmetic to write a GPU memory address with a vec4 value (i do have random-access swarming many vec4 sized particles: gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
	i can read alot faster than i can write in GPU. i read as much as the 3d cube volume of matrix multiplying 2 2d squares or any 3 lengths of a 3d rectangle of compute returning a 2d matrix. they're all tensors.
	cuz i dont gotta do that affine transform shit to read. only to write. to read i just texelFetch an ivec2, which can be generated in simple easy to optimize ways or loaded at runtime and i can jump pointer arithmetic n levels deep at each point depending on reading shared GPU mem.
	im gonna turn this into something like codeblocks in a massively multiplayer way, and i'm not giving up GPU flops for it but i am giving up some IO bandwidth between CPU vs GPU cuz of browser layers etc. But imagine u can call pure-functions on eachother in an ocean of builders. (but not codeblocks specificly im optimizing for DAG which has immutable forest of childs, like in wikibinator203's tree drag and drop).
	float32 (even with the +1 in first shader and -1 in last shader, to fix an optimizer bug built into the drivers or browser or hardware etc) can exactly do int25 and uint24, if ur careful not to overflow it, so u might need to multiply 2 int12s or something like that.
	
	Params of the Lamgl javascript function such as (bellPositions, camPos, horizon, etc). Those are not built in. Whatever code string goes in sv and sf (shaders) has some var names,
	and you pass tensors or float32arrays or numbers in the Lamgl call.
	When you pass tensors into Lamgl, that were returned by earlier calls of Lamgl (all immutable), that is pointers into GPU memory. It doesnt copy it back to CPU unless you tell it to, so its nearly as fast as native GPU code in some cases.
	Lamgl can do a few thousand sequential calls per second on a good gaming computer, so maybe you get 50 of them per video frame to build whatever you want. You can keep them around to use less often in sparse combos too. dont forget to free them.
	if u wanna double buffer, u can do so with each buffer state being immutable, using only 2 actual WebGLTexture's (Lamgl handles that, u dont gotta touch that low level detail) as long as you free the oldest of the 2 tensors then make its tensor replacement. same ptr into GPU.
	You read tensors by texelFetch or texture which is the only place WebGL is letting me store memory between GPU calls. You just expect the texture to be there if you write a variable for it in the shader code and give it as a param in Lamgl({...glVarName: tensorVal etc}). can mat4
	You have random-access to read all params including	blocks of GPU memory up to at least 16mB (some GL's have more). You read a vec4 (4 floats) at a (x,y) or i can make a function to take an int. You write up to 8 vec4s but only at 1 int/(x,y), 1 per output tensor.
	that is, you write up to 8 vec4's per GPU thread / gl_VertexID. That could potentially be millions of threads since WebGL is designed to run 1 GPU thread per pixel normally, and it can also do voxels and thats how u can random-access write but only 1 address written per thread.
	Lamgl was designed to use headless GL, no canvas in the dom tree. Canvas was added later by tensor.copyTo(canvasDomNode). Lamgl matrix multiplied before it could display pixels on screen. Its normal use is off screen, and whenever u want, pick any tensor and tensor.display().
	
	Among GPU APIs, its recommended: If WebGL falls, retreat to OpenCL.
	If OpenCL falls retreat to WebGPU. Join OpenCL to Tomcat by 1 JSP or servlet and my https://github.com/benrayfield/LazyCL at gaming-low-lag.
	The reason is WebGPU bans the http protocol except on localhost/file, which they use as a kill-switch by https cert revoke.
	If you just want to run a tomcat server real quick you dont need https, but WebGPU will be disabled in browsers who click into that tomcat.
	*/
	const vm = function(){}; //Proxy of this (Lamgl) can only be called as function if this is a function
	//VM = vm;
	
	const Todo = vm.Todo = str => { throw new Error(str || 'TODO'); };
	const Err = vm.Err = str => { throw new Error(str || '(Err with no message)'); };
	
	vm.opt = {
		//logGlvars: true, //test
		logGlvars: false, //normal
		//logGlvarsDetail: true, //test
		logGlvarsDetail: false, //normal
		//logShaderCodeEveryTime: true, //test
		logShaderCodeEveryTime: false, //normal
	};

	vm.jsType = x => (ArrayBuffer.isView(x) ? x.constructor.name : typeof(x));

	vm.call = (param,optionalSh)=>{
		//console.log('Lamgl called.');
		//if(typeof(param) == 'object'){
		let ret = null;
		if(param.sv || param.sf){
			ret = vm.callGPU(param);
		}else{
			ret = vm.wrap(param,optionalSh);
		}
		if(vm.forceGlFinishAtEndOfEachLamglCall){
			vm.Gl().finish();
		}
		return ret;
	};
	
	//default vertex shader if you dont give sv and just give sf etc.
	vm.defaultSv =
`#version 300 es
precision highp float;
in vec2 XY; //in Lamgl, triggers quad/rectangle/twoTriangles geometry, if you use this instead of gl_ VertexID.
void main(){
	gl_Position = vec4(XY, 0.0, 1.0);
}`;

	vm.addVersionEtcIfNeeded = glsl=>{
		if(!glsl.includes('#version ')){ //if you dont specify GLSL version (in sv andOr sf) it adds that
			//FIXME move this to add after version if u specify version but not precision
			if(!glsl.includes('precision')){ //if you dont specify precision it adds that
				glsl = 'precision highp float;\n'+glsl;
			}
			glsl = '#version 300 es\n'+glsl;
		}
		return glsl;
	};
	
	vm.callGPU = map=>{
		let gl = vm.Gl();
		let sv = map.sv || vm.defaultSv; //vertex shader code
		let sf = map.sf || '//FIXME no sf'; //fragment shader code
		sv = vm.addVersionEtcIfNeeded(sv);
		sf = vm.addVersionEtcIfNeeded(sf);
		if(sv != map.sv || sf != map.sf){
			map = {...map}; //dont modify param map
			map.sv = sv;
			map.sf = sf;
		}
		//If sc is true (or 1) then output to Lamgl.glCanv instead of a frameBuffer, by giving null frameBuffer.
		//There is only 1 canvas a WebGL2 instance can output to efficiently, and thats the canvas it was created from.
		//This is normally only used in Lamgl.Tensor.copyTo(Lamgl.glCanv) which is called by Lamgl.Tensor.display().
		let sc = !!map.sc;
		
		if(vm.opt.logShaderCodeEveryTime){
			console.log('sv='+sv);
			console.log('sf='+sf);
			console.log('sc='+sc);
		}
		
		let sh = map.sh; //[height, width, 4] or maybe [zSize, height, width, 4] etc
		/*
		//TODO zSize for 3d pics?
		let h = map.h; //height, unless map.n is a [] list like [height width 4] or [zSize height width 4] etc.
		let w = map.w; //width, unless that
		let q = map.q || 4; //floats per GPU thread (or maybe per texture?)
		let sh = map.sh || [h, w, q]; //shape of tensor
		//in case there is zSize or what should it be called?
		if(!h) h = sh[n.length-3];
		if(!w) w = sh[n.length-2];
		if(!q) w = sh[n.length-1];
		*/
		
		let cacheKeySuffix = '_SV['+sv+']_SF['+sf+']_SH['+vm.Str(sh)+']';
		
		let glvars = vm.glvars(map);
		if(vm.opt.logGlvars && !opt.logGlvarsDetail) console.log('glvars=[[['+glvars.join('\n')+']]]');
		if(vm.opt.logGlvarsDetail) console.log(
			'<<<\nmap.sf='+map.sf+'\nglvars=[[['+glvars.map(x=>(x+' ('+map[x.shaderType].substring(x.charPtrFrom,x.charPtrTo)+')')).join('\n')+']]]\n>>>');
		
		// ── geometry auto-detect: if shader declares “in vec2 XY;” draw a quad
		//const hasXYAttr = glvars.some(v=>(v.memType==='in' && v.name==='XY' && v.glType.startsWith('vec2')));
		//
		//If hasXYAttr, then do 2 triangles to fill height x width, else only use gl_VertexID (tho can use both),
		//and it will come in the usual gl screen coordinates of x and y each range -1 to 1.
		const hasXYAttr = glvars.some(v=>(v.memType=='in' && v.name=='XY' && v.glType=='vec2'));
		const has_gl_VertexID = sv.includes('gl_VertexID'); //FIXME parse it better like what if its "int not_gl_VertexID".
		//No, cant do this, cuz gl_VertexID is with TRIANGLES not POINTS so theres too few of them: Allow this 2025-7-13+ cuz of using XY and VarGradientGL at same time.
		if(hasXYAttr && has_gl_VertexID){
			Err('hasXYAttr && has_gl_VertexID, but if you do that youll only get the corners of the 2 triangles forming a rectangle, not the every pixel in that rectangle you were expecting, sv['+sv+']');
		}
		if(!hasXYAttr && !has_gl_VertexID){
			console.log('Youre probably just testing simple stuff in 1 GPU thread. !hasXYAttr && !has_gl_VertexID. You normally do one or the other. Add "in vec2 XY;" for 2 triangles covering the rectangle heightXwidth, or use gl_VertexID (an int) in sv aka vertex shader code string. sv['+sv+']');
		}
		
		//If a memsIn's Tensor has fr/free of 1, then it uses an optimization of
		//its WebGLTexture being both in and out (in memsIn and memsOut)
		//since its, kind of in this higher level, garbage collected and reused at once,
		//based on that Tensor is immutable and Mem/WebGLTexture is mutable.
		//During this, mem.tensor should be null, and at end, create new Tensor(mem)
		//for each memsOut. Creating a tensor just wraps the Mem, doesnt copy contents,
		//and is still backed by GPU memory.
		let memsIn = []; //contains nulls where u dont use them
		let memsOut = []; //contains nulls where u dont use them
		//for each index in mems*, memsIn or memsOut or both have it.
		
		let uniformsIn = []; //undefined except at primitive uniforms
		
		let tensorsToDecrementFreeAtEnd = [];
		
		//let pendingRewrap = [];	//{mem, outIndex}. Only used for doSharedTextureOptimization.
		
		for(let i=0; i<glvars.length; i++){
			let glvar = glvars[i];
			let isIn = glvar.isIn(), isInTex = glvar.isInTex(), isOut = glvar.isOut();
			//console.log('glvars looping, glvars['+i+']='+glvar+' isIn='+isIn+' isInTex='+isInTex+' isOut='+isOut);
			let tensorIn = null;
			if(isIn){
				if(isOut) Err('Cant be both in and out: '+glvar);
				//console.log('START isIn, glvar='+glvar);
				if(isInTex){
					tensorIn = map[glvar.name];
					if(!tensorIn) Err('No tensorIn for '+glvar);
					tensorsToDecrementFreeAtEnd.push(tensorIn);
					memsIn[i] = tensorIn.mem; //read-only and immutable
					//console.log('END isIn, glvar='+glvar+', memsIn['+i+'] = '+tensorIn+' of name '+glvar.name+' texture='+ tensorIn.mem.mut);
				}else if(hasXYAttr && glvar.name=='XY'){
					//the var of hasXYAttr. Do nothing here, just log it. Set it later by 2 triangles.
					//console.log(`END isIn (vertex attr)	${glvar.name}	– no uniform upload cuz is an in.`);
				}else{ //uniformsIn
					let val = map[glvar.name];
					if(val === undefined){
						Err('No uniform value for '+glvar.name);
					}
					/* -----------------------------------------------------------------
						Promote plain JS lists → typed arrays exactly once, picking the
						right element type from the GLSL declaration.
						float / vec* / mat*	→ Float32Array
						int/ivec*		 → Int32Array
						uint/uvec*		→ Int32Array	 (WebGL has no Uint32Uniform)
						-----------------------------------------------------------------
					*/
					if(Array.isArray(val)){
						const t = glvar.glType;	 // e.g. "float", "vec3", "int", …
						if(t === 'float' || t.startsWith('vec') || t.startsWith('mat')){
							val = new Float32Array(val);
						}else if(t === 'int'	|| t.startsWith('ivec') ||
								t === 'uint' || t.startsWith('uvec')){
							val = new Int32Array(val);
						}else{
							Err('Don’t know how to promote list for '+t+' '+glvar.name);
						}
					}
					uniformsIn[i] = val; //remember for later
					//console.log('END isIn, primitive uniform glvar.name='+glvar.name+' jsType_val='+Lamgl.jsType(val)+' val='+val);
				}
			}else if(isOut){ //isOut
				//console.log('START isOut, glvar='+glvar);
				
				
				//Cant do it as "const canReuseTexture = firstStateTensor.fr === 1;" cuz requires checking if
				//firstStateTensor exists cuz its an optional param. for each output, it optionally is also a param
				//for the starting state of the output memory, which gl_Position can sparsely write on top of.
				let firstStateTensor = map[glvar.name]; //if this doesnt exist, start with an empty state.
				//the optimization this whole LamGL software is based on,
				//that allows it to be completely stateless/immutable Tensors
				//that share and reuse GPU memory without copying back to CPU
				//except as needed after 1 or many GPU calls.
				let doSharedTextureOptimization = false;
				//console.log('doSharedTextureOptimization='+doSharedTextureOptimization);
				if(firstStateTensor){
					//console.log('isOut: map.'+glvar.name+' exists so using it as the starting state (firstStateTensor) of that texture/GPUMemory. If its .fr/free is 1, will do the optimization to reuse that texture, else will copy it first.');
					doSharedTextureOptimization = firstStateTensor.fr==1;
					//TODO firstStateTensor.useFree() at end. cant free it yet.
				}
				
				/*if(firstStateTensor && doSharedTextureOptimization){ //use 1 texture as if it was 2
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else if(firstStateTensor){ //use 2 textures, copy-on-write
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					memsOut[i] = firstStateTensor.copy().mem;
				}else{ //no firstStateTensor, start with empty memory
					memsOut[i] = vm.gpuMalloc(map.sh); // assumes `map.sh` is the desired shape
				}*/
				
				if(firstStateTensor){
					if(doSharedTextureOptimization){
						//garbage collect immutable tensor so can reuse texture/mem
						//firstStateTensor.tensor = null;
						//memsOut[i] = firstStateTensor.mem;
						//console.log('yes firstStateTensor, doSharedTextureOptimization=TRUE, memsOut['+i+'] = '+firstStateTensor+' of name '+glvar.name);
						
						//Detach the old tensor from its Mem
						let mem = firstStateTensor.mem;
						//Since tensor is (used as) immutable, remove tensor now and
						//create another one wrapping this same Mem at end of callGPU.
						//Mem is never modified while mem.tensor is nonnull.
						mem.tensor = null;
						firstStateTensor.mem = null;
						firstStateTensor.fr = 0; //This is the only place we dont garbcol it back to the pool, cuz mem is being used here still.
					
						//Remember we must re-wrap this Mem later
						//dont need this cuz as an output texture it will happen: pendingRewrap.push({mem, outIndex: i});
						
						//FBO attachment uses the raw Mem
						memsOut[i] = mem;
					}else{
						Err('This never worked, TODO');
						//TODO 2025-10-13 theres no tensor.copy() func so this never worked, always used doSharedTextureOptimization
						//until now (broke when tried to use it recently in LamglNBody.html).
					
						//firstStateTensor.fr is big enuf its not garbage collected,
						//so this (after copy) is the last we use it in this call of callGPU.
						//Instead, we copy it to another texture/mem and use that as output,
						//including that its a mutable texture during writing it,
						//as it has its previous contents and wherever gl_Position
						//sparsely writes voxels over it.
						//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
						//depending on if its a 2d or 3d texture),
						//and write 1-8 vec4s there, 1 vec4 written to each output texture,
						//and gl has a limit of at most 8 output textures (normally just 1).
						//firstStateTensor.useFree(); //decrement firstStateTensor.fr
						tensorsToDecrementFreeAtEnd.push(firstStateTensor);
						//new GPU mem. starts with high .fr
						memsOut[i] = firstStateTensor.copy().mem;
						//console.log('yes firstStateTensor, doSharedTextureOptimization=FALSE, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					}
				}else{
					memsOut[i] = vm.gpuMallocMem(sh);
					//console.log('no firstStateTensor, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					if(memsOut[i].tensor) Err('gpuMallocMem gave Mem with a tensor');
				}
				
				/*
				Todo('there might be 3 cases, do optimization, dont do optimization, where there is .fr>1 so still gotta copy, and where there is .fr==1 so reuse it (the optimization). some combo of those');
				if(doSharedTextureOptimization){ //use 1 texture as if it was 2
					Todo('this might be wrong, check [there might be 3 cases]');
					//garbage collect immutable tensor so can reuse texture/mem
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else{ //use 2 textures, copy-on-write
					Todo('this might be wrong, check [there might be 3 cases]');
					//firstStateTensor.fr is big enuf its not garbage collected,
					//so this (after copy) is the last we use it in this call of callGPU.
					//Instead, we copy it to another texture/mem and use that as output,
					//including that its a mutable texture during writing it,
					//as it has its previous contents and wherever gl_Position
					//sparsely writes voxels over it.
					//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
					//depending on if its a 2d or 3d texture),
					//and write 1-8 vec4s there, 1 vec4 written to each output texture,
					//and gl has a limit of at most 8 output textures (normally just 1).
					//firstStateTensor.useFree(); //decrement firstStateTensor.fr
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					//new GPU mem. starts with high .fr
					memsOut[i] = firstStateTensor.copy().mem;
				}
				*/
				
				//console.log('END isOut, glvar='+glvar+', memsOut['+i+'] = Tensor '+glvar.name+', GPU texture ='+memsOut[i].mut);
			}else Err('Is not in or out: '+glvar+' FIXME what if its an input of fragment shader (sf) which comes after vertex shader (sv).');
		}
		//console.log('Got '+memsIn.filter(x=>!!x).length+' ins and '+memsOut.filter(x=>!!x).length+' outs, excluding nulls/undefineds in memsIn and memsOut lists.');
		//Todo();
		
		//todo remove this double loop. also, does doSharedTextureOptimization allow them to be both in and out in some cases?
		//console.log('--- Checking input/output GPU memory overlap ---');
		for (let i = 0; i < memsIn.length; i++) {
			const memIn = memsIn[i];
			if (!memIn) continue;
			for (let j = 0; j < memsOut.length; j++) {
				const memOut = memsOut[j];
				if (!memOut) continue;
				if (memIn.mut === memOut.mut) {
					console.warn(`ERR, ⚠️ memsIn[${i}] and memsOut[${j}] share the SAME WebGLTexture!`, memIn.mut);
				}else{
					//console.warn(`OK memsIn[${i}] and memsOut[${j}]`);
				}
			}
		}
		//console.log('--- End check ---');

		
		let program = vm.cache('program'+cacheKeySuffix, function(){
			let vertexShader = vm.cache('vertexShader'+cacheKeySuffix, function(){
				sv = vm.preprocessShaderString(sv); //add line numbers etc
				let v = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(v, sv);
				gl.compileShader(v);
				if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+sv);
				}
				return v;
			});
			console.log('vertexShader='+vertexShader);
			let fragmentShader = vm.cache('fragmentShader'+cacheKeySuffix, function(){
				sf = vm.preprocessShaderString(sf); //add line numbers etc
				const f = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(f, sf);
				gl.compileShader(f);
				if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
					let s = 'FRAGMENTSHADERCODE:\n'+sf;
					console.log(s);
					let sShort = (s.length > 2000) ? (s.substring(0,2000)+'... (see FRAGMENTSHADERCODE above for whole thing)') : s;
					throw new Error(gl.getShaderInfoLog(f)+'\n\n'+sShort);
				}
				return f;
			});
			console.log('fragmentShader='+fragmentShader);
			console.log('sf/fragmentShader='+sf);
			const p = gl.createProgram();
			gl.attachShader(p, vertexShader);
			gl.attachShader(p, fragmentShader);
			gl.linkProgram(p);
			console.log('skip_gl_getProgramParameter_LINK_STATUS='+vm.skip_gl_getProgramParameter_LINK_STATUS);
			if(!vm.skip_gl_getProgramParameter_LINK_STATUS && !gl.getProgramParameter(p, gl.LINK_STATUS)){
				Err(gl.getProgramInfoLog(p));
			}
			return p;
		});
		//console.log('program='+program);
		
	
		
		let ret = {};
		
		//nTextures are outputs, not inputs. 1-8 textures of float or vec4 per pixel each.
		
		/*if(nTextures.length > 1){
			//Specify the draw buffers for multiple render targets
			const attachments = nTextures.map((_, index) => gl.COLOR_ATTACHMENT0 + index);
			gl.drawBuffers(attachments);
		}*/
		let texturesOut = [];
		if(sc){
			//console.log('Skipping for(let mem of memsOut) if(mem) texturesOut.push(mem.mut); cuz sc aka output to the canvas that created this GL aka null frameBuffer');
		}else{
			for(let mem of memsOut) if(mem) texturesOut.push(mem.mut);
		}
		
		//vm.cacheFramebuffer = true;
		vm.cacheFramebuffer = false;
		//console.log('vm.cacheFramebuffer='+vm.cacheFramebuffer);
		
		let frameBuffer = null;
		if(!sc){
			let frameBufferMaker = function(){
				const f = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, f);
				for(let i=0; i<texturesOut.length; i++){
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, texturesOut[i], 0);
				}
				return f;
			};
			frameBuffer = vm.cacheFramebuffer ?
				vm.cache('frameBuffer'+cacheKeySuffix, frameBufferMaker)
				: frameBufferMaker();
		}
		
				
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer); //frameBuffer is null if sc
		//gl.clearColor(0, 0, 0, 0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		gl.viewport(0, 0, width, height);
		gl.useProgram(program);
		
		if(texturesOut.length){
			const attachments = texturesOut.map((_,i)=>(gl.COLOR_ATTACHMENT0+i));
			//console.log('Calling gl.drawBuffers');
			gl.drawBuffers(attachments); 
			//gl.drawBuffers(texturesOut);
		}
		
		
		// === Bind sampler2D uniforms ===
		let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;	// only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}


		// --- bind primitive uniforms ---------------------------------------
		for(let i=0; i<glvars.length; i++){ //added 2025-6-21
			let val = uniformsIn[i];
			if (val === undefined) continue;			 // not a uniform
			//console.log('uniformsIn doing gl.uniform* to set value, glvars['+i+']='+glvars[i]+', val='+val);
			//let loc = gl.getUniformLocation(program, glvars[i].name);
			// first try plain name, then the "[0]" form required for arrays
			let loc = gl.getUniformLocation(program, glvars[i].name) //normal
				|| gl.getUniformLocation(program, glvars[i].name+'[0]'); //GPT thought this [0] should be here. probably dont need it
			if(loc === null) continue; //may have been removed by removeGlvarsThatJustCopyFromSvToSf, or could just be missing?
			//Accept number, Array, or Float32Array
			if (typeof val === 'number'){
				//gl.uniform1f(loc, val);
				let glType = glvars[i].glType;
				if(glType == 'float'){
					gl.uniform1f(loc, val);
				}else if(glType == 'int'){
					gl.uniform1i(loc, val);
				}else Err('Expected float or int but got glType='+glType);
			}else if(val instanceof Float32Array || Array.isArray(val)){
				const buf = (val instanceof Float32Array) ? val : new Float32Array(val);
				switch (glvars[i].glType){
					case 'float': gl.uniform1fv(loc, buf); break;
					case 'vec2':	gl.uniform2fv(loc, buf); break;
					case 'vec3':	gl.uniform3fv(loc, buf); break;
					case 'vec4':	gl.uniform4fv(loc, buf); break;
					default:
						Err('Unsupported uniform type '+glvars[i].glType+' for '+glvars[i].name);
				}
				/*switch (val.length){
					case 1:
						gl.uniform1f(loc, val[0]);
					break;case 2:
						gl.uniform2fv(loc, val);
					break;case 3:
						gl.uniform3fv(loc, val);
					break;case 4:
						gl.uniform4fv(loc, val);
					break;default:
						Err('Unsupported uniform length for '+glvars[i].name+'. TODO arrays, but u will have a limit of about 4k total uniforms in vertex shader and 1k in fragment shader.');
				}*/
			}else if(val instanceof vm.Tensor){
				Err('Cant give a Lamgl.Tensor for value of a gl uniform. Use tensor.get() to get Float32Array from it if its floats or vec4s for example. The reason this does not automatically call .get() is you should not accidentally copy from GPU to CPU cuz its slow. val='+val);
			}else{ //TODO ivec2 ivec3 ivec4
				Err('Unsupported uniform type['+Lamgl.jsType(val)+'] for '+glvars[i].name);
			}
		}

		
		
		if(hasXYAttr){ //2 triangles filling rectangle, use "in vec2 XY;"
			//console.log('Lamgl doing 2 triangles: in vec2 XY;');
			//lazy-create and cache a full-screen quad VBO (6 vertices)
			const quadBuf = vm.cache('lamgl_quadVBO', () => {
				const q = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, q);
				gl.bufferData(
					gl.ARRAY_BUFFER,
					new Float32Array([
						-1,-1,	 1,-1,	-1, 1,
						-1, 1,	 1,-1,	 1, 1,
					]),
					gl.STATIC_DRAW
				);
				return q;
			});
			//hook the XY attribute of *this* program to that VBO
			const locXY = gl.getAttribLocation(program, 'XY');
			if (locXY !== -1) {
				gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
				gl.enableVertexAttribArray(locXY);
				gl.vertexAttribPointer(locXY, 2, gl.FLOAT, false, 0, 0);
			}
			//rasterise the quad
			gl.drawArrays(gl.TRIANGLES, 0, 6);
			//leave no attribs enabled for later POINTS calls
			if (locXY !== -1) gl.disableVertexAttribArray(locXY);
		}else{ //gl_VertexID
			//console.log('Lamgl doing points as gl_VertexID.');
			//=== run shader for every pixel/voxel using gl_VertexID ===
			/*let numVerts = 1;
			for(let d = 0; d < sh.length - 1; d++){	 // multiply all dims except the last (==4)
				numVerts *= sh[d];
			}
			gl.drawArrays(gl.POINTS, 0, numVerts);	// no VBO needed – gl_VertexID drives the math
			*/
			let numVerts = Lamgl.mapToNumVerts(map); //this should fix bug bellsackBugSparsePointsDoesSameNumberOfGpuThreadsAsXYDense 2025-12-15+ in theory.
			console.log('gl_VertexID sparse (not "in vec2 XY;" dense) numVerts='+numVerts);
			gl.drawArrays(gl.POINTS, 0, numVerts);	// no VBO needed – gl_VertexID drives the math
		}

		//=== wrap each output Mem in an immutable Tensor and expose it ===
		for(let i=0; i<glvars.length; i++){
			if(glvars[i].isOut() && memsOut[i]){
				let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);
				memsOut[i].tensor = t;			// back-link for texture pooling
				ret[glvars[i].name] = t;			// e.g. ret.result
			}
		}
		
		//unbind input textures that were binded in the loop
		//containing "if (!glvar.isInTex()) continue;	// only bind texture inputs"
		for (let i = 0; i < nextTextureUnit; i++){
			gl.activeTexture(gl.TEXTURE0 + i);
			gl.bindTexture(gl.TEXTURE_2D, null); //this was here 2025-6-21 for long time
			//gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0); //new 2025-6-21
		}
		if(frameBuffer){ //new 2025-6-21
			for(let i=0; i<texturesOut.length; i++){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, null, 0); //detach
			}
		}
		// === Unbind frameBuffer output ===
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		// === Optional: reset active texture to 0 for consistency ===
		gl.activeTexture(gl.TEXTURE0);
		gl.useProgram(null);
		gl.bindVertexArray(null); //even tho its not using a vertex array
		
		/*Dont need this cuz "let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);" already does it cuz its an output mem.
		//create another tensor wrapping the modified Mem from doSharedTextureOptimization,
		//for every tensor/Mem that is both an input/param and output/return at once,
		//without having put that Mem back into the pool.
		for(let item of pendingRewrap){
			memsOut[item.outIndex] = new vm.Tensor(item.mem); //tensor.fr is defaultFr which is big
		}*/
		
		for(let tensor of tensorsToDecrementFreeAtEnd){
			//decrement tensor.fr and if its 0 return its texture/mem to pool
			tensor.useFree();
		}
		
		return ret;
	};
	
	vm.preprocessShaderString = code=>{
		return vm.addLineNumbers(code);
	};
	
	//This is for lines like "out vec4 result; //comment".
	//TODO? eltype (glType? todo look in debugger) is element type, like 'vec4' or 'float' or 'int',
	//regardless of its an array/texture vs one primitive.
	//sh is [] if not an array, or [arraySize] or [outerSize, innerSize], etc.
	vm.GLVar = function(memType, glType, sh, name, charPtrFrom, charPtrTo, shaderType){
		this.memType = memType;
		this.glType = glType;
		this.sh = sh;
		this.name = name;
		this.charPtrFrom = charPtrFrom; //inclusive, range of the shader code string
		this.charPtrTo = charPtrTo; //exclusive
		this.shaderType = shaderType;
	};
	
	vm.GLVar.prototype.isIn = function(){
		// Treat uniforms and varying inputs (from vertex shader) as inputs
		return this.memType === 'uniform' || this.memType === 'in';
	};

	vm.GLVar.prototype.isInTex = function(){
		// A sampler2D, samplerCube, etc., in a uniform is a texture input
		return this.memType === 'uniform' && this.glType.startsWith('sampler');
	};

	vm.GLVar.prototype.isOutTex = function(){
		// Fragment outputs (out vec4 ...) are the only texture outputs
		return this.memType === 'out';
	};

	vm.GLVar.prototype.isOut = function(){
		// Alias to isOutTex for now, but leaves room to generalize later
		return this.isOutTex();
	};

	
	vm.GLVar.prototype.toString = function(){
		return '[GLVar memType='+this.memType+' glType='+this.glType+' sh='+vm.Str(this.sh)+' name='+this.name+' charPtrFrom='+this.charPtrFrom+' charPtrTo='+this.charPtrTo+' shaderType='+this.shaderType+']';
	};
	
	//Returns a list of glvars excluding those that are out from sv and in to sf of the same name and type,
	//which are only used to copy between the 2 shaders and are not inputs/outputs of the Lamgl call.
	vm.removeGlvarsThatJustCopyFromSvToSf = function(glvars) {
		const buckets = {};
		const toRemove = new Set();

		for (let i = 0; i < glvars.length; i++) {
			const v = glvars[i];
			const key = v.name + '|' + v.glType;
			let bucket = buckets[key] || (buckets[key] = []);
			//bucket.push({ idx: i, v: v });
			bucket.push(v);
		}

		for (let key in buckets) {
			const list = buckets[key];
			if (list.length === 2) {
				const [a, b] = list;
				if (
					(a.memType === 'out' && a.shaderType === 'sv' &&
					 b.memType === 'in'	&& b.shaderType === 'sf') ||
					(b.memType === 'out' && b.shaderType === 'sv' &&
					 a.memType === 'in'	&& a.shaderType === 'sf')
				) {
					//toRemove.add(a.idx);
					//toRemove.add(b.idx);
					toRemove.add(a);
					toRemove.add(b);
				}
			}
		}

		//console.log('removeGlvarsThatJustCopyFromSvToSf removing '+toRemove.size+' glvars:\n'+[...toRemove].join('\n'));
		return glvars.filter(v=>!toRemove.has(v));
	};

	
	//returns [] list of GLVar's in the order they should be used in gl.
	//map.sv is string of vertex shader code, sf fragement shader,
	//(todo if one of those is not given use or generate some default? (update: there is a default sv, what var name?)).
	/*vm.glvars = map=>{
		Todo();
	};*/
	vm.glvars = map=>{
		const glvars = [];

		/*const parseShaderVars = (shaderSrc, shaderType)=>{
			let charPtr = 0; //running offset
			//fixme what about "flat" keyword and other keywords?
			const lines = shaderSrc.split('\n');
			//for (let line of lines){
			for(let raw of lines){
				const line = raw.trim();
				//line = line.trim();

				// Ignore comments
				if (line.startsWith('//')) continue;

				let isIn = false;
				let memType = null, glType = null, name = null;

				// Handle uniform
				//let matchUniform = line.match(/^uniform\s+(\w+)\s+(\w+);/);
				// Handle uniform	─ (accept optional "[	N ]")
				//let matchUniform = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\s*\])?\s*;/);
				//Handle uniform ─ (capture optional "[ N ]")
				let matchUniform = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchUniform){
					const from = charPtr + raw.indexOf(matchUniform[0]);
					const to	 = from + matchUniform[0].length;
					glType = matchUniform[1];
					name = matchUniform[2];
					/*GPT-o3 said, about "what do you expect to be in matchUniform[3] ?": matchUniform[3] is the optional numeric size that appears inside the square-brackets of an array uniform declaration:
					uniform float foo[ 128 ];	 // ← “128” is captured as matchUniform[3]
					uniform vec3	bar[4];		 // ← “4”
					uniform float baz;			// ← no “[ … ]”, so matchUniform[3] is undefined
					*
					let asz = matchUniform[3] ? parseInt(matchUniform[3]) : null;
					let sh = asz ? [asz] : [];
					memType = 'uniform';
					isIn = true;
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}

				// Handle in/out (varyings, fragment outputs, etc.)
				//let matchIO = line.match(/^(in|out)\s+(\w+)\s+(\w+);/);
				// Handle in/out (varyings, fragment outputs, etc.)
				//let matchIO = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\])?\s*;/);
				let matchIO = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchIO){
					const from = charPtr + raw.indexOf(matchIO[0]);
					const to	 = from + matchIO[0].length;
					let qualifier = matchIO[1];
					glType = matchIO[2];
					name = matchIO[3];
					let asz = matchIO[4] ? parseInt(matchIO[4]) : null;
					memType = qualifier;
					let sh	= asz ? [asz] : [];
					isIn = (qualifier === 'in');
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}

				// Handle layout(...) out vec4 NAME;
				//let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+(\w+);/);
				// Handle layout(...) out vec4 NAME;
				//let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*\d*\])?\s*;/);
				let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if(matchLayoutOut){
					const from = charPtr + raw.indexOf(matchLayoutOut[0]);
					const to	 = from + matchLayoutOut[0].length;
					glType = matchLayoutOut[1];
					name = matchLayoutOut[2];
					let asz = matchLayoutOut[3] ? parseInt(matchLayoutOut[3]) : null;
					let sh	= asz ? [asz] : [];
					memType = 'out';
					isIn = false;
					//glvars.push(new vm.GLVar(memType, glType, name, shaderType));
					//glvars.push(new vm.GLVar(memType, glType, sh, name, shaderType));
					glvars.push(new vm.GLVar(memType, glType, sh, name, from, to, shaderType));
					continue;
				}
				charPtr += raw.length+1; // +1 for '\n'. FIXME norm newlines
			}
		};*/
		
		const parseShaderVars = (shaderSrc, shaderType)=>{
			let charPtr = 0;							// running offset into shaderSrc
			const lines	= shaderSrc.split('\n');

			for(const raw of lines){
				const lineStart = charPtr;			// ← position of this line in the full source
				const line		= raw.trim();

				// ----- skip comments ------------------------------------------------
				if(line.startsWith('//')){
					charPtr += raw.length + 1;		// still count the line + '\n'
					continue;
				}

				// ---------- uniform -------------------------------------------------
				let m = line.match(/^uniform\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to	 = from		+ m[0].length;

					const asz = m[3] ? parseInt(m[3], 10) : null;
					glvars.push(new vm.GLVar(
						'uniform', m[1], asz ? [asz] : [], m[2],
						from, to, shaderType
					));
					charPtr += raw.length + 1;		// ✅ advance before next loop
					continue;
				}

				// ---------- in / out -----------------------------------------------
				m = line.match(/^(in|out)\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to	 = from		+ m[0].length;

					const asz = m[4] ? parseInt(m[4], 10) : null;
					glvars.push(new vm.GLVar(
						m[1], m[2], asz ? [asz] : [], m[3],
						from, to, shaderType
					));
					charPtr += raw.length + 1;
					continue;
				}

				// ---------- layout(...) out ----------------------------------------
				m = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+([A-Za-z_]\w*)\s*(?:\[\s*(\d*)\s*\])?\s*;/);
				if (m) {
					const from = lineStart + raw.indexOf(m[0]);
					const to	 = from		+ m[0].length;

					const asz = m[3] ? parseInt(m[3], 10) : null;
					glvars.push(new vm.GLVar(
						'out', m[1], asz ? [asz] : [], m[2],
						from, to, shaderType
					));
					charPtr += raw.length + 1;
					continue;
				}

				// ---------- no match on this line -----------------------------------
				charPtr += raw.length + 1;
			}
		};

		if (map.sv) parseShaderVars(map.sv, 'sv');
		if (map.sf) parseShaderVars(map.sf, 'sf');

		return vm.removeGlvarsThatJustCopyFromSvToSf(glvars);
	};

	
	//vm.Str = 
	
	//TODO make a way to call Lamgl({...}) that takes a string of js code that generates
	//the Float32Array or Mem/texture contents in CPU.
	//Maybe name it sj (j for javascript) like sv (vertex shader) and sf (fragment shader).
	//A tensor could be more general, in cpu mem or gpu mem.
	
	vm.wrap = (wrapMe,optionalSh)=>{
		if(wrapMe instanceof Float32Array){
			let sh = optionalSh || [wrapMe.length>>2, 4]; //FIXME what if its not a multiple of 4?
			let mem = vm.gpuMallocMem(sh);
			mem.set(wrapMe); //copy from CPU (Float32Array wrapMe) to GPU (WebGLTexture in mem.mut)
			return new vm.Tensor(mem);
		}else Err('wrapMe is a '+typeof(wrapMe));
	};
	
	vm.nextId_ = 1;
	vm.nextId = ()=>(++vm.nextId_); //for debugging, not used as of 2025-10-13
	
	//immutable, normally exists in a Mem. Is same shape as that mem.
	vm.Tensor = function(mem,optionalFr){
		this.mem = mem;
		this.sh = mem.sh;
		//countdown until garbcol. Each time its read in GPU,
		//this is decremented. When it reaches 0, vm.gpuFree(this)
		//is called to return that GPU memory to the pool.
		this.fr = optionalFr || vm.defaultFr;
		if(mem.tensor){
			//Err('mem already has a tensor and its not this one, mem='+mem+', thisTensor='+this);
			Err('mem already has a tensor and (TODO why did i assume this:) its not this one, mem='+mem+', thisTensor='+this);
		}else{
			mem.tensor = this;
		}
		this.id = vm.nextId(); //for debugging, not used as of 2025-10-13
	};
	
	vm.Tensor.prototype.toString = function(){
		return '[Tensor sh='+JSON.stringify(this.sh)+']';
	};
	
	//Fast. this.get().length but without calling this.get() cuz that would copy from GPU to CPU.
	vm.Tensor.prototype.size = function(){
		return this.mem.size();
	};
	
	//return a Float32Array copy of the WebGLTexture in the mem backing this Tensor
	vm.Tensor.prototype.get = function(){
		return this.mem.get();
	};
	
	//Returns this Tensor with fr set.
	//Like, vm.gpuMalloc([300,500,4]).free(1) is a Tensor that will free
	//its WebGLTexture (back to the vm.texPool) after the next GPU call.
	//if optionalFr is not given or is 0, frees now.
	//If its 1, frees on the next use (1 more GPU call),
	//fr decreases by 1 each GPU call.
	vm.Tensor.prototype.free = function(optionalFr){
		if(!this.fr){
			Err('Tensor was already freed');
		}
		this.fr = optionalFr|0;
		if(!this.fr){
			vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
		}
		return this;
	};
	
	//use 1 more fr in the countdown, toward garbage collecting the WebGLTexture at this.fr==0,
	//but only back into the vm.texPool pool, not deleting it out of the GPU
	//(todo also that if its not used for a while and the GPU memory is needed).
	vm.Tensor.prototype.useFree = function(){
		if(this.fr){
			this.fr--;
			if(!this.fr){
				vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
			}
		}
	};
	
	//For if sh.length==2, not sure if we even have 1d textures in this version of webgl. Get flattened index.
	vm.Tensor.prototype.ii = function(x, w){
		return x*this.sh[0]+w;
	};

	//For if sh.length==3 like a 2d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iii = function(y, x, w){
		return (y*this.sh[0]+x)*this.sh[1]+w;
	};

	//For if sh.length==4 like a 3d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iiii = function(z, y, x, w){
		return z*this.sh[0]+(y*this.sh[1]+x)*this.sh[2]+w
	};
	
	//vm.texPool[vm.shKey(sh)] is a [] of unused vm.Mem instances of that sh/shape.
	//See vm.gpuMallocMem and vm.gpuFreeMem.
	vm.texPool = {};
	
	vm.verifyShEndsWithVec4 = sh=>{
		if(sh[sh.length-1] != 4) Err('Last dimension is not 4: '+Str(sh));
	};
	
	//returns a Tensor wrapping a Mem wrapping a WebGLTexture,
	//instead of that Mem. Tensor is immutable. Mem is mutable.
	//The Tensor contains whatever data was in WebGLTexture (malloc, not calloc).
	//The normal use of this, since Tensor is immutable, would be to remove the Tensor from the Mem,
	//modify the Mem, then add another Tensor to represent that new Mem state.
	vm.gpuMallocTensor = sh=>(new vm.Tensor(vm.gpuMallocMem(sh)));
	
	vm.gpuMallocMem_usesCache = true; //normal
	//vm.gpuMallocMem_usesCache = false; //test
	//console.log('vm.gpuMallocMem_usesCache='+vm.gpuMallocMem_usesCache);
	
	//Example: vm.gpuMallocMem([300,500,4]) returns a Mem.
	//allocate a texture of a chosen sh/shape from pool, in GPU mem.
	//Returns a Mem instance wrapping a WebGLTexture of 2d or 3d,
	//normally with 4 floats per pixel (vec4) as sh[sh.length-1] is normaly 4.
	//This is specificly a malloc, not calloc, as it doesnt clear the mem.
	//Only the first use of a WebGLTexture is cleared,
	//but after that it can be returned to the pool and reallocated without clearing,
	//but it should be written before read again.
	vm.gpuMallocMem = sh=>{
		vm.verifyShEndsWithVec4(sh);
		let k = vm.shKey(sh);
		//list of Mem's whose mem.sh contents equal.
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		if(vm.gpuMallocMem_usesCache && list.length){
			//console.log('gpuMallocMem returning from cache, sh='+vm.Str(sh));
			return list.pop();
		}else{
			let tex = null;
			if(sh.length==3 && sh[2]==4){
				//2d WebGLTexture with vec4 per pixel
				//console.log('gpuMallocMem makeGLTexture2dVec4, sh='+vm.Str(sh));
				tex = vm.makeGLTexture2dVec4(sh[0], sh[1]);
			}else if(sh.length==3 && sh[2]==4){
				Todo('new 3d WebGLTexture (vec4 per pixel) of that sh='+Str(sh));
			}else{
				Todo('new WebGLTexture of that sh='+Str(sh));
			}
			return new vm.Mem(tex, sh);
			//return new vm.Tensor(new vm.Mem(tex, sh));
		}
	};
	
	//Example:	mem is what a vm.gpuMalloc returned.
	//FIXME: Does not check if its already freed or if its already in texPool,
	//so only call once after each gpuMallocMem.
	vm.gpuFreeMem = mem=>{
		if(!mem){
			Err('No mem param');
		}
		if(!mem.tensor){
			Err('No mem.tensor, so was already freed');
		}
		//console.log('gpuFreeMem this='+this);
		mem.tensor.mem = null; //breaks the tensor, cant use it anymore
		mem.tensor = null;
		let k = vm.shKey(mem.sh);
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		list.push(mem);
	};
	
	vm.shKey = sh=>sh.join('_');
	
	//mutable. wraps WebGLTexture and maybe Float32Array.
	//shape is [z,y,x,4] or [y,x,4] or [y,x,1] or [500] etc. As of 2025-5-6 only [height,width,4] is supported.
	vm.Mem = function(mutableMem, shape){
		this.mut = mutableMem;
		this.sh = shape;
		this.tensor = null; //this Mem is in the pool when this.tensor is null.
		this.id = vm.nextId(); //for debugging, not used as of 2025-10-13
	};
	
	vm.mulAll = function(vec){
		let ret = 1;
		for(let num of vec) ret *= num;
		return ret;
	};
	
	vm.Mem.prototype.size = function(){
		return vm.mulAll(this.sh);
	};
	
	//copy gpu to cpu
	vm.Mem.prototype.get = function(optionalFloat32Array){
		let size = this.size();
		let ret = optionalFloat32Array || new Float32Array(size);
		vm.copyTextureToFloat32Array(this.mut,this.sh,ret); //GPU
		return ret;
	};
	
	//vm.log_copyTextureToFloat32Array = true; //test
	vm.log_copyTextureToFloat32Array = false; //normal
	
	/*2025-8-11 Bellsack278.html gl.finish() only slows it down by about another 7%. its in Lamgl.forceGlFinishAtEndOfEachLamglCall (true or false).
	im keeping it cuz it makes my browser performance tools get (closer to, some may be way off cuz this is buggy as in delayed calculations in GPU returning early and unfinished async despite Lamgl always syncronously does CPU->GPU->CPU or GPU->GPU (the fastest) or CPU->GPU or GPU->CPU) correct measurements.
	*/
	vm.forceGlFinishAtEndOfEachLamglCall = true; //in theory this will make browser profiler tools show actual time cost per Lamgl call.
	//vm.forceGlFinishAtEndOfEachLamglCall = false; //was false before 2025-7-22.
	
	/*vm.copyTextureToFloat32Array = (tex,floatsOut)=>{
		Todo();
	};*/
	vm.copyTextureToFloat32Array = (tex, sh, floatsOut) => {
		if(sh.length != 3) Todo('sh.length=='+sh.length);
		const gl = vm.Gl();
		let isTex = null;
		if(vm.log_copyTextureToFloat32Array){
			gl.isTexture(tex);
			if(!isTex){
				Err('NOT gl.isTexture(tex) at the start of copyTextureToFloat32Array, see bug in bellsack190_mostBallsMoveDiffDirectionsButAfter10SecondsGLCrashesSeeDetailsInFIXMETextInUI.html vs that bug does not happen in bellsack183.html, if you wait about [30 seconds or 2000 video frames].');
			}
		}
		//console.log('copyTextureToFloat32Array, lamglLoopBody_count='+(lamglLoopBody_count)+', gl.isTexture(tex)='+isTex+', sh='+Lamgl.Str(sh)+' floatsOut.length='+floatsOut.length+' typeof(tex)='+typeof(tex));

		// Assume the texture is 2D and in RGBA32F format
		// Find the dimensions from floatsOut.length and assume vec4 per pixel
		let totalFloats = floatsOut.length;
		let height = sh[0];
		let width = sh[1];
		let pixels = totalFloats/sh[2];
		
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		//let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		
		/*let pixels = totalFloats / 4;
		let width = Math.ceil(Math.sqrt(pixels));
		let height = Math.ceil(pixels / width); //TODO choose width and height better
		*/

		// Create a temporary frameBuffer and attach the texture to it
		const frameBuffer = gl.createFramebuffer();
		if(vm.log_copyTextureToFloat32Array) console.log('copyTextureToFloat32Array, after gl.createFramebuffer gl.isTexture(tex)='+gl.isTexture(tex));
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
		if(vm.log_copyTextureToFloat32Array) console.log('copyTextureToFloat32Array, after gl.bindFramebuffer gl.isTexture(tex)='+gl.isTexture(tex));
		gl.viewport(0, 0, width, height);
		if(vm.log_copyTextureToFloat32Array) console.log('copyTextureToFloat32Array, after gl.viewport(0, 0, '+width+', '+height+') gl.isTexture(tex)='+gl.isTexture(tex));
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
		if(vm.log_copyTextureToFloat32Array) console.log('copyTextureToFloat32Array, after gl.framebufferTexture2D gl.isTexture(tex)='+gl.isTexture(tex));

		let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			// Clean up before erroring out
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.deleteFramebuffer(frameBuffer);
			Err('Framebuffer not complete: ' + status);
		}

		// Read pixels from the frameBuffer into the Float32Array
		gl.readPixels(
			0, 0, width, height,
			gl.RGBA, gl.FLOAT,
			floatsOut
		);

		// Clean up
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(frameBuffer);
	};
	
	vm.skip_gl_getProgramParameter_LINK_STATUS = false; //2024-5-9-640pET defaulting this to false (dont skip) cuz of I turned SKLT=F (dont skip) by clicking the button and this neuralnet nnet_1715286589.548.dagball compiled in about .1 second when I changed {nodes 12} to {nodes 13}.
	//skip_gl_getProgramParameter_LINK_STATUS: true, //normal as of 2024-5-9 cuz it made compiling GLSL alot faster, probably some thread thing it didnt have to wait on, considering theres multiple off-screen canvases.
	//skip_gl_getProgramParameter_LINK_STATUS: false, //normal before 2024-5-9, but TODO experimentally trying skipping it cuz this line takes .1 to 20 seconds and is likely causing threads to wait on eachother
	//skip_gl_getProgramParameter_LINK_STATUS: true, //for testing, or maybe it will work out this way?
	//vm.skip_gl_getProgramParameter_LINK_STATUS = true, //2025-7-19 changed this to true (was undefined) cuz page loading slow
	
	//copy cpu to gpu
	vm.Mem.prototype.set = function(float32Array){
		vm.copyFloat32ArrayToTexture(float32Array,this.mut,this.sh);
	};
	
	// --- CPU → GPU upload ----------------------------------------------
	vm.copyFloat32ArrayToTexture = (src, tex, sh) => {
		// sh is the tensor shape that texture represents, e.g. [h, w, 4]
		if (!sh || sh.length !== 3 || sh[2] !== 4) {
			Err('copyFloat32ArrayToTexture: shape must be [height,width,4]');
		}
		const gl	 = vm.Gl();
		const height = sh[0];
		const width	= sh[1];

		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,				 // level
			0, 0,				// x-offset, y-offset
			width, height,	 // size
			gl.RGBA,			 // format
			gl.FLOAT,			// type
			src				// the Float32Array with 4*width*height values
		);
	};

	
	vm.webglType = 'webgl2'; //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	vm.glslVersionString = '#version 300 es'; //WebGL2 GLSL ES 300
	
	//returns 'Uint8Array' or 'Float64Array' or 'object' or 'number' or 'string' for example.
	vm.jsType = x=>(ArrayBuffer.isView(x) ? x.constructor.name : typeof(x)),
	
	vm.gl = null; //the only GL instance, normally WebGL2 GLSL ES 300
	vm.glCanv = null;
	//vm.glCanvasHeight = 1; //1x1 canvas, cuz gonna use gl_VertexID instead of 2 triangles that form a rectangle covering the canvas
	//vm.glCanvasWidth = 1;
	
	
	vm.glCanvasHeight = 300; //normal 2025-11-22. experiment avoid resizing canvas to see if it boots faster 2025-7-19
	vm.glCanvasWidth = 400; //normal 2025-11-22. experiment avoid resizing canvas to see if it boots faster 2025-7-19
	
	//vm.glCanvasHeight = 600;
	//vm.glCanvasWidth = 800;
	//vm.glCanvasHeight = 150;
	//vm.glCanvasWidth = 200;
	//vm.glCanvasHeight = 75; //low res
	//vm.glCanvasWidth = 100; //low res
	vm.setBootOptionsInGl = gl=>{
		//so it ignores .w in vec4(red,green,blue,depth), doesnt use it as transparency, in graphicsMain
		//and graphicsDebug (changing that to ns.Opt.IsGraphicsDebug.p) and todo graphicsOverlay.
		gl.disable(gl.BLEND);
	};
	vm.Gl = ()=>{
		if(!vm.gl){
			let c = document.createElement("canvas");
			c.setAttribute("height", ''+vm.glCanvasHeight);
			c.setAttribute("width", ''+vm.glCanvasWidth);
			c.addEventListener('webglcontextlost', function(event){
				//event.preventDefault();
				//activeContexts.delete(context);
				console.log('Lamgl says canvas event webglcontextlost, event='+event);
				/*console.log('TinyGLSL says canvas event webglcontextlost, event='+event);
				if(TinyGlsl.do_clearAllCache_whenWebglContextLost){
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost STARTING TinyGlsl.clearAllCache()...');
					TinyGlsl.clearAllCache();
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost DONE TinyGlsl.clearAllCache().');
				}*/
			}, false);
			vm.glCanv = c;
			
			let gl = vm.glCanv.getContext(vm.webglType);
			let glErr = gl.getError();
			if(glErr) Err('after canvas.getContext(TinyGlsl.webglType), gl.getError()='+glErr);
			if(!gl.getExtension('EXT_color_buffer_float')){ //this turns the extension on. its not just checking if it exists.
				Err('EXT_color_buffer_float not supported so cant return 1 or 4 floats per pixel instead of bytes');
			}
			vm.setBootOptionsInGl(gl);
			let isContextLost = gl.isContextLost();
			console.log('creating gl context, gl.isContextLost()=='+isContextLost);
			if(isContextLost) Err('gl.isContextLost()=='+isContextLost+
				', see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/isContextLost');
			console.log('Returning new webgl context '+gl);
			vm.gl = gl;
		}
		return vm.gl;
	};
	
	//string to [] list of string lines
	vm.lines = code=>code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
	
	//Return the vertex count that Lamgl.callGPU should pass to gl.drawArrays.
	//Priority: 1) map.verts  2) product of map.sh dimensions (ignoring the last channel slot).
	//This is meant to fix bug bellsackBugSparsePointsDoesSameNumberOfGpuThreadsAsXYDense 2025-12-15+.
	/*
			sf: `out vec4 inOutColor;							// writing directly back
			void main(){ inOutColor = vec4(1.0, 0.85, 0.1, 1.0); }	// solid debug yellow. FIXME put color in .w of pts and get it out of there`,
			pts: pts,
			ptsW, totalPts,
			camPos, camRight, camUp, camFwd,
			tanHalfFovY: Math.tan(opt.fovY_deg * Math.PI / 360),
			aspect: scrW / scrH,

			// draw *into* the existing texture
			inOutColor: prevPic_rgbd
		}).inOutColor;										// same tensor, now with dots
	};
	sh in lamgl means the output size [height,width,4]. It does not have an input size, cuz it just runs 1 thread per output pixel. This seems incompletely designed and works by accident or by chance that the number of sparse points is less than the number of dense pixels. I think we need verts field. value is an integer that goes in gl.drawArrays(gl.POINTS, 0, numVerts); instead of multiplying numVerts *= sh[d]; but if u dont give verts it will compute it that same way. Lamgl({verts: numVerts, sh:[output size...]) }else{ //gl_VertexID //console.log('Lamgl doing points as gl_VertexID.'); //=== run shader for every pixel/voxel using gl_VertexID === let numVerts = 1; for(let d = 0; d < sh.length - 1; d++){ // multiply all dims except the last (==4) numVerts *= sh[d]; } gl.drawArrays(gl.POINTS, 0, numVerts); // no VBO needed – gl_VertexID drives the math }
	*/
	vm.mapToNumVerts = map=>{
		if(map.verts !== undefined){
			return map.verts;
		}else{
			let n = 1;
			for(let i = 0; i<map.sh.length-1; i++){
				n *= map.sh[i]; //usually this is just height*width.
			}
			return n;
		}
	};

	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = vm.lines(code);
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.makeGLTexture2dVec4_count = 0;
	
	vm.makeGLTexture2dVec4 = (height, width, optionalFloat32Array)=>{
		vm.makeGLTexture2dVec4_count++;
		//console.log('makeGLTexture2dVec4, height='+height+' width='+width+' optionalFloat32Array_exists='+!!optionalFloat32Array+' makeGLTexture2dVec4_count='+vm.makeGLTexture2dVec4_count);
		let gl = vm.Gl();
		let t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		let floats = optionalFloat32Array || null;
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
		gl.texImage2D(
			gl.TEXTURE_2D,
			0,
			gl.RGBA32F,
			width,
			height,
			0,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		return t;
	};
	
	vm.defaultFr = 1<<30;
	
	vm.vm = vm; //so Lamgl.vm is vm. Lamgl is a Proxy
	
	vm.jsNumToGlslFloat = jsNum=>{
		let s = ''+jsNum;
		if(!s.includes('.') && !s.includes('e')) s += '.'; //Examples: '3.', '3.45', '5e-10', '-5e-10'
		return s;
	};

	let Str = vm.Str = value => {
		if (value === null) return 'null';
		if (value === undefined) return 'undefined';
		if(value instanceof Float32Array) return 'Float32Array.of('+value.join(', ')+')';
		if(value.length) return JSON.stringify(value);
		if (typeof value === 'symbol') return value.toString();
		if (typeof value === 'function') return '[Function]';
		if (value instanceof WebGLTexture) return 'WebGLTexture';
		if (value instanceof vm.Tensor) return value.toString();
		if (typeof value === 'object'){
			//if(value.length) return String(value);
			//else{
				let s = '{';
				for(let key in value){
					console.log('key='+key);
					if(s.length>1) s += ',';
					s += key+': '+Str(value[key]);
				}
				return s+'}';
			//}
		}
		if(value.toString){
			return value.toString();
		}
		try {
			return 'THING';
		} catch (e) {
			return Object.prototype.toString.call(value);
		}
	};
	
	vm.timeOffset_ = performance.timing.navigationStart;
	//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
	vm.time = ()=>((vm.timeOffset_+performance.now())*.001);

	const Lamgl = vm.Lamgl = new Proxy(vm, {
		apply: (target, thisArg, args) => {
			//console.log('Proxy.apply target=' + target + ' thisArg=' + thisArg + ' args=' + args);
			return target.call(...args); //seems pointless compared to Lamgl being a function from the start, but it makes Lamgl(thing) call some function... TODO track this proxy stuff down but i know theres a Lamgl.callGPU in there. Its probably just Lamgl.call. Comments need organizing. U cant both use js .prototype class-like/object-oriented stuff AND be a function. I fixed it so u can, and I do, and it cost the use of Proxy for every Lamgl call but thats not the bottleneck. Lamgl.doBasicTests() for example. But also Lamgl({...details of GPU call...})=>mapOfTensors and Lamgl(someFloat32Array,[height,width,4])=>tensor.
		},
		get: (target, prop, receiver) => {
			//console.log('Proxy.get target=' + Str(target) + ' prop=' + Str(prop) + ' receiver=' + Str(receiver));
			if (typeof prop === "symbol") {
				// Directly pass through all symbol accesses
				return target[prop];
			}
			// Access properties like 'doBasicTests'
			if (prop in target) {
				return target[prop];
			}
			return Reflect.get(target, prop, receiver);
			//return Reflect.get(target, prop, receiver);
		}
	});
	
	vm.caches = {type: 'lamgl_caches'};
	
	//if this is nonnull (a {}), then TinyGlsl.cache(key,lazyVal) puts stats into it when lazyVal is called but does not store the output of lazyVal here.
	//TODO This could get big so it waits for it to be set to {} externally (by a button in dagball normally)
	//vm.cacheStats = null; //normal
	vm.cacheStats = {}; //test
	
	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	vm.cache = function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = Lamgl.caches[key];
		if(val === undefined){
			//putTid: put a .tid field that is dagball.timeId() so can be deleted in same order as created (or reverse order?) Or might help in choosing the order in some cases?
			let startTime;
			if(Lamgl.cacheStats){
				startTime = Lamgl.time();
			}
			//val = Lamgl.caches[key] = Lamgl.putTid(lazyVal());
			val = Lamgl.caches[key] = lazyVal();
			if(Lamgl.cacheStats){
				let now = Lamgl.time();
				let map = Lamgl.cacheStats[key] = Lamgl.cacheStats[key] || {};
				let duration = now-startTime;
				map.count = (map.count|0)+1;
				map.lastDurationEndTime = now;
				map.lastDuration = duration; //FIXME this isnt running again during second third... GPU calls, only the first per shader/etc, cuz if(val === undefined) is not the right place for it. This is a compile stat.
				if(!map.firstDuration){
					map.firstDuration = duration;
				}
			}
		}
		return val;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		//FIXME this "?: starts a noncapturing group, so it doesnt include those in the returned list,
		//just whats between" stuff sounds like it could have bugs. test it with variety of line endings
		//and unexpected combos of them with other text.
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.float32ArrayTranspose = (matBC,sizeB,sizeC)=>{
		let matCB = new Float32Array(sizeC*sizeB);
		for(let b=0; b<sizeB; b++) for(let c=0; c<sizeC; c++){
			matCB[c*sizeB+b] = matBC[b*sizeC+c];
		}
		return matCB;
	};
	
	vm.countNonzeros = function(floats){
		let count = 0;
		for(let i=0; i<floats.length; i++) if(floats[i]) count++;
		return count;
	};
	
	vm.testNearEqualFloatArrays = (a,b,epsilon,comment)=>{
		if(a.length != b.length) Err('TEST FAIL Array lengths differ '+a.length+' '+b.length+', '+comment);
		for(let i=0; i<a.length; i++){
			let diff = Math.abs(a[i]-b[i]);
			if(diff > epsilon) Err('TEST FAIL at i='+i+' '+a[i]+' != '+b[i]+', diff='+diff+', epsilon='+epsilon+', '+comment);
		}
		console.log('Test pass, '+comment);
	};

	vm.doBasicTests = ()=>{
		console.log('START Lamgl.doBasicTests()');
		
		let testA = Lamgl({
			sh: [1, 1, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				void main(){
					gl_Position = vec4(0.,0.,0.,1.0);
					gl_PointSize = 1.0;
				}`,
			sf: `#version 300 es
				precision highp float;
				out vec4 result;
				void main(){
					result = vec4(2.,3.+4.,44.,55.);
				}`,
		});
		let correctA = Float32Array.of(2.,7.,44.,55.);
		let observedA = testA.result.get();
		//console.log('testA='+JSON.stringify(testA));
		console.log('testA='+Str(testA));
		console.log('correctA='+Str(correctA));
		console.log('observedA='+Str(observedA));
		vm.testNearEqualFloatArrays(observedA,correctA,0, 'one vec4');
		
		
		console.log('doBasicTests, Lamgl='+Lamgl);
		let arr = Lamgl(Float32Array.of(2,3,4,5.67,100,200,300,400),[1,2,4]);
		console.log('doBasicTests, arr='+arr);
		let testD = Lamgl({
			sh: [128, 128, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				flat out int vID;
				void main(){
					int idy = gl_VertexID>>7;
					int idx = gl_VertexID&127;
					//x and y go in range -1 to 1, +.5 so its in center of pixel and doesnt get dropped
					gl_Position = vec4((float(idx)+.5)/128.*2.-1., (float(idy)+.5)/128.*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					vID = gl_VertexID; //so sf can get it
				}`,
			sf: `#version 300 es
				precision highp float;
				layout(location = 0) out vec4 result;
				flat in int vID;
				uniform sampler2D someArray;
				//todo sampler2d or something called someArray
				void main(){
					//result = vec4(gl_VertexID, 0., 0., 1.);
					float f = texelFetch(someArray, ivec2(vID&1,0), 0).x;
					result = vec4(float(vID), 7., f, 1.);
				}`,
			someArray: arr,
		});
		let correctD = new Float32Array(128*128*4);
		for(let y=0; y<128; y++) for(let x=0; x<128; x++){
			let i = (y*128+x)*4;
			let gl_VertexID = i/4;
			correctD[i] = gl_VertexID;
			correctD[i+1] = 7;
			correctD[i+2] = x&1 ? 100 : 2; //from Float32Array.of(2,3,4,5.67,100,200,300,400)
			correctD[i+3] = 1;
		}
		let observedD = testD.result.get();
		console.log('testD='+Str(testD));
		console.log('correctD='+Str(correctD));
		console.log('observedD='+Str(observedD));
		vm.testNearEqualFloatArrays(correctD,observedD,0, 'testD');
		
		
		
		/** from TinyGLSL
		let tenThousandFloatsOut = TinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), null, 1000, 10);
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		*/
		
		let tenThousandFloatsOut = Lamgl({
			sh:[100, 25, 4],
			sv:`#version 300 es
				precision highp float;
				flat out vec4 tempColor;
				float outFunc(int i){
					return float(i)*float(i); //ret = float(id)*float(id); like in TinyGLSL
				}
				const int height = 100;
				const int width = 25;
				void main(){
					int idy = gl_VertexID/width;
					int idx = gl_VertexID%width;
					gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					int i = gl_VertexID<<2;
					tempColor = vec4(outFunc(i), outFunc(i+1), outFunc(i+2), outFunc(i+3));
				}`,
			sf:`#version 300 es
				precision highp float;
				flat in vec4 tempColor;
				layout(location = 0) out vec4 result;
				void main(){
					result = tempColor; //copy from sv
				}`
		}).result.get();
		console.log('tenThousandFloatsOut='+[...tenThousandFloatsOut].map((x,i)=>('['+i+']='+x)).join(', '));
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		
		
		console.log('START test testMatmulAC');
		let sizeA = 1024;
		let sizeB = 1024;
		let sizeC = 1024;
		let flopsPerMatmul = sizeA*sizeB*sizeC*2; //*2 cuz its add and multiply.
		
		/*let sizeA = 8;
		let sizeB = 8;
		let sizeC = 8;
		*/
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');
		let matABTensor = Lamgl(matAB,[sizeA,sizeB/4,4]);
		let matCBTensor = Lamgl(matCB,[sizeC,sizeB/4,4]);
		console.log('matABTensor='+matABTensor);
		console.log('matCBTensor='+matCBTensor);
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		//TODO use "in vec2 XY; //triggers quad/rectangle/twoTriangles geometry, dont use gl_ VertexID."
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			let copyToCpuInMatmulTest = repeat_testMatmulAC4<5 || repeat_testMatmulAC4==9; //so we see its speed without that in later loops
			console.log('r='+repeat_testMatmulAC4+' copyToCpuInMatmulTest='+copyToCpuInMatmulTest);
			/*console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			console.log('matABTensor.get()[55]='+matABTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			console.log('matCBTensor.get()[55]='+matCBTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163 Lamgl_036.html:1212:12
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163
			so the data is still in them.
			*/
			let testMatmulAC4_timeStart = vm.time();
			let observed_testMatmulAC4 = null;
			let observed_testMatmulAC4_map = null;
			try{
				let testMatmulAC4_sh = [sizeA, sizeC/4, 4];
				observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						flat out vec4 tempColor;
						void main(){
							int idy = gl_VertexID / width; // row (A)
							int idx = gl_VertexID % width; // column block (C/4)
							vec4 sums = vec4(1.); //vec4 sums = vec4(0);
							for (int b=0; b<sizeBOver4; b++){
								vec4 mul = texelFetch(matAB,ivec2(b,idy),0);
								sums += vec4(
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+0),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+1),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+2),0)),
									//Did "vec4 sums = vec4(1.);" then "result = tempColor-1.;" instead of:
									//*1.0000001 avoid returning all 0s, force it to to do some calculation
									//thats not from the textures, cuz the glsl optimizer is buggy.
									//dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.000001
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))
								);
							}
							tempColor = sums;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1.,
								(float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							gl_PointSize = 1.;
						}`,
					sf: `#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main() {
							//result = tempColor;
							//result = tempColor/1.000001; //undo *1.0000001 (glsl optimizer bug)
							result = tempColor-1.; //undo +1 (glsl optimizer bug)
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});

				console.log('observed_testMatmulAC4_map='+observed_testMatmulAC4_map);
				if(copyToCpuInMatmulTest){
					observed_testMatmulAC4 = observed_testMatmulAC4_map.result.get();
					//FIXME what kind of transpose-like op goes here? let observed_testMatmulAC = vm.float32ArrayTranspose(observed_testMatmulAC4,size
					/*let cor = [...correct_testMatmulAC];
					for(let i=0; i<1000; i++){
						let ind = cor.indexOf(observed_testMatmulAC[i]);
						console.log('i='+i+' ind='+ind);
					}*/
					let cor = [...correct_testMatmulAC];
					let obs4 = [...observed_testMatmulAC4];
					for(let i=0; i<Math.min(100,correct_testMatmulAC.length); i++){
						console.log('i='+i+' cor='+correct_testMatmulAC[i]+'@'+obs4.indexOf(correct_testMatmulAC[i])+' obs4='+observed_testMatmulAC4[i]+'@'+cor.indexOf(observed_testMatmulAC4[i]));
					}
					let epsilon = (.3*sizeB)**2; //FIXME?
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, epsilon, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
					/*
					console.log('testMatmulAC4 test code incompletely written. todo fix it.');
					for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
					let numNonzero_observed_testMatmulAC4 = 0;
					for(let i=0; i<observed_testMatmulAC4.length; i++) if(observed_testMatmulAC4[i]) numNonzero_observed_testMatmulAC4++;
					console.log('numNonzero_observed_testMatmulAC4='+numNonzero_observed_testMatmulAC4);
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					*/
				}
			}finally{
				let secs = vm.time()-testMatmulAC4_timeStart;
				let flopPerSec = flopsPerMatmul/secs;
				console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4+' testMatmulAC4 secs='+secs+' gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)='+(flopPerSec/1e9)+' observed_testMatmulAC4.length='+(observed_testMatmulAC4?observed_testMatmulAC4.length:'undefined'));
				if(observed_testMatmulAC4_map) for(let k in observed_testMatmulAC4_map){
					let val = observed_testMatmulAC4_map[k];
					if(val instanceof vm.Tensor){
						val.free(); //return WebGLTexture to pool
					}
				}
			}
		}
		
		/* ===========================================================
			 NEW TEST – geometry chosen implicitly via `in vec2 XY;`
			 Expectation: Lamgl must detect the attribute name, switch
			 to “two-triangle quad” geometry, fill a 40 × 30 tensor,
			 and give us	 value = 1000*y + x	 at each pixel.
			 ===========================================================*/
		{
			const H = 30, W = 40;				 // small so we can eyeball failures
			const quadTest1 = Lamgl({
				sh: [H, W, 4],
				sv: `#version 300 es
					 precision highp float;
					 in vec2 XY; //triggers quad/rectangle/twoTriangles geometry, dont use gl_ VertexID.
					 void main (){
						 gl_Position = vec4(XY, 0., 1.); //pass-through clip-space
					 }`,

				sf: `#version 300 es
					//fragment: encode 1000*y + x into .r
					 precision highp float;
					 layout(location=0) out vec4 result;
					 void main () {
						 int x = int(gl_FragCoord.x) - 0;	 // 0..W-1
						 int y = int(gl_FragCoord.y) - 0;	 // 0..H-1
						 result = vec4(float(1000*y + x), 0.0, 0.0, 1.0);
					 }`
			});
			//pull back to CPU and verify
			const data = quadTest1.result.get(); //Float32Array
			let ok = true;
			for (let y = 0; y < H; ++y) {
				for (let x = 0; x < W; ++x) {
					const i = (y*W + x) * 4;
					const expected = 1000*y + x;
					if (data[i] !== expected) {
						console.error(`quadTest1 mismatch at (x=${x}, y=${y}): `
										+ `got ${data[i]}, expected ${expected}`);
						ok = false;
						break;
					}
				}
				if (!ok) break;
			}
			if (!ok) throw 'quadTest failed – Lamgl did not switch to QUAD geometry';
			console.log('quadTest passed – Lamgl QUAD geometry ok');
		}
		/*2025-6-25-546pET[
		Test pass, one vec4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testD
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1197 tenThousandFloatsOut test pass
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r0
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r1
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r2
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r3
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r4
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1079 Test pass, testMatmulAC_r9
		bellsack145_todoForkingFrom142Cuz(gl_VertexID)IsSlowInBellsackRaytracingSoGoingBackTo2Triangles.html:1406 quadTest passed – Lamgl QUAD geometry ok
		]*/
		
		{
			const H = 30, W = 40;
			const quadTest2SmallerUsingDefaultSvVersionAndPrecision = Lamgl({
				sh: [H, W, 4],
				sf: `out vec4 result;
					void main(){
						int x = int(gl_FragCoord.x); //0..W-1
						int y = int(gl_FragCoord.y); //0..H-1
						result = vec4(float(1000*y + x), 0., 0., 1.);
					}`
			});
			//pull back to CPU and verify
			const data = quadTest2SmallerUsingDefaultSvVersionAndPrecision.result.get(); //Float32Array
			let ok = true;
			for (let y = 0; y < H; ++y) {
				for (let x = 0; x < W; ++x) {
					const i = (y*W + x) * 4;
					const expected = 1000*y + x;
					if (data[i] !== expected) {
						console.error(`quadTest2 mismatch at (x=${x}, y=${y}): `
										+ `got ${data[i]}, expected ${expected}`);
						ok = false;
						break;
					}
				}
				if (!ok) break;
			}
			if (!ok) throw 'quadTest2 failed – Lamgl did not switch to QUAD geometry';
			console.log('quadTest2 passed – You dont have to give sv/vertexShaderCode, #version, or precision, just use Lamgl defaults.');
		}
		
		//Lamgl.testDisplay(true,Lamgl.time()); //FIXME remove this cuz its UI stuff
		
		console.log('END Lamgl.doBasicTests()');
	};
	
	vm.Tensor.prototype.copyTo = function(canvas){
		if(canvas != vm.glCanv){
			Todo('also support copying (slower) to other canvases than vm.glCanv aka Lamgl.glCanv. Its built into WebGL2 that if you give null as FrameBuffer, it writes to the canvas that WebGL2 was made from. To copy to another canvas youd have to copy from that canvas to another one or on some other path.');
		}
		if(this.sh.length != 3){
			Err('this.sh.length='+this.sh.length+' but expected [height, width, 4]');
		}
		let [h, w, ch] = this.sh;
		vm.setCanvasSize(canvas, h, w);
		Lamgl({
			sh: this.sh,
			sv: `#version 300 es
				//sv tensor.copyTo for tensor.display() to canvas
				void main() {
					int id = gl_VertexID; //TODO use in, vec2, XY; but without the commas, instead of gl_VertexID, cuz might be faster.
					int idx = id % ${w};
					int idy = id / ${w};
					float x = (float(idx) + 0.5) / float(${w});
					float y = (float(idy) + 0.5) / float(${h});
					gl_Position = vec4(x * 2.0 - 1.0, y * 2.0 - 1.0, 0.0, 1.0);
					gl_PointSize = 1.0;
				}
			`,
			sf: `#version 300 es
				//sf tensor.copyTo for tensor.display() to canvas
				precision highp float;
				uniform sampler2D tex;
				out vec4 outColor;
				void main() {
					ivec2 uv = ivec2(gl_FragCoord.xy);
					outColor = texelFetch(tex, uv, 0);
				}
			`,
			tex: this,
			sc: true, //output to Lamgl.glCanv aka vm.glCanv, the canvas that the WebGL2 was made from.
		});
	};
	
	vm.Tensor.prototype.display = function(){
		let canvas = vm.glCanv;
		vm.putCanvasInDomOnce(canvas);
		this.copyTo(canvas);
	};
	
	vm.putCanvasInDomOnce = function(canvas){ //does nothing if the canvas is already in the dom. Normally called on Lamgl.glCanv aka vm.glCanv
		if(!document.body.contains(canvas)){
			canvas.style.position = 'fixed';
			canvas.style.left = '0px';
			canvas.style.top = '0px';
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.zIndex = '-10'; // behind most content
			canvas.style.border = 'none';
			document.body.appendChild(canvas);
		}
		return canvas;
	};
	
	vm.setCanvasSize = function(canvas, h, w){
		if(canvas.width !== w || canvas.height !== h){
			canvas.width = w;
			canvas.height = h;
		}
	};
	
	vm.testDisplay = (isSparse, isDetailedLog, time)=>{
		console.log('Start testDisplay');
		let t = time || vm.time();
		const height = 400, width = 300;
		let tSmall = t%86400; //cuz float64 time cast to float32 loses the part of time that changes fast enuf to see
		let mapOut = Lamgl({
			sh: [height, width, 4],
			tSmall: tSmall,
			sv: `#version 300 es
				precision highp float;
				const int height = ${height};
				const int width = ${width};
				out vec2 uv;
				${isSparse ? '//sparsePoints' : 'in vec2 XY; //twoTriangles'}
				//const float tSmall = ${vm.jsNumToGlslFloat(tSmall)}; //TODO do this in uniform so Lamgl doesnt compile again every time
				void main(){
					${isSparse?
						`int idy = gl_VertexID / width;
						int idx = gl_VertexID % width;
						uv = vec2(float(idx)/float(width), float(idy)/float(height));
						gl_Position = vec4((float(idx)+.5)/float(width)*2. - 1.,
											(float(idy)+.5)/float(height)*2. - 1., 0., 1.);
						gl_PointSize = 1.0;`
						:
						`uv = XY * 0.5 + 0.5;
						gl_Position = vec4(XY, 0.0, 1.0);`
					}
				}`,
			sf: `#version 300 es
				precision highp float;
				uniform float tSmall;
				layout(location = 0) out vec4 outColor;
				in vec2 uv;
				void main(){
					float r = 0.5 + 0.5 * sin(sin(tSmall*.567) + uv.x * 20.0 + uv.y * 10.0);
					float g = 0.5 + 0.5 * cos(tSmall+cos(tSmall*1.876-uv.x*r) + uv.y * 30.0 - uv.x * 5.0);
					float b = 0.5 + 0.5 * sin(uv.x * 40.0 + uv.y * 40.0);
					//tempColor = vec4(1., .5, .4, 1.0);
					outColor = vec4(r, g, b, 1.0);
				}`,
		});
		
		let tensorOut = mapOut.outColor;
		if(!tensorOut){
			Err('No tensorOut');
		}
		console.log('tensorOut.sh='+JSON.stringify(tensorOut.sh));
		if(isDetailedLog){
			let floats = tensorOut.get();
			if(floats.length != height*width*4){
				Err('floats.length='+floats.length+' but expected height*width*4='+(height*width*4));
			}
			console.log('testDisplay contents: ');
			let countNonzeros = 0;
			for(let y=0; y<height; y++){
				let line = '';
				for(let x=0; x<width; x++){
					line += ' '
					for(let c=0; c<4; c++){
						if(c) line += ',';
						let f = floats[(y*width+x)*4+c];
						if(f) countNonzeros++;
						line += f;
					}
				}
				console.log(line);
			}
			if(!countNonzeros){
				Err('testDisplay, all '+floats.length+' floats from GPU are 0');
			}
		}
		//uses {sc:true} to output to canvas, that canvas being Lamgl.glCanv, and resizes if needed to match tensor size
		//and put that canvas in dom tree if its not already. It appears behind most dom stuff already on screen, acting as a background by canvas.style['z-index'], so u can put checkboxes, textareas, etc in front of it easily.
		tensorOut.display();
	};

	return vm.Lamgl;
	//requestAnimationFrame(() => { Lamgl.doBasicTests(); });
})();
</script>
<script>
//Var*.js, opensource/Apache2 (versions before Bellsack256/2025-8-3 are MIT) by Ben F Rayfield

console.error('TODO O1_ O2_ O3_ O4_ (objects)... P_ Ps_ (Ptrs) L_ Ls_ (Lits) by ORing, to compute Var.po as true or false');
//copied (then maybe modified) from VarTree_002.html 2025-7-5.
//Var class was copied 2025-4-16 from blobMonstersGame_2025-3-27.html then modified TODO...
//
//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn .mx and .poten
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt)
//so order of calling gob.brain(...vars) of many gobs and Vars, has no effect except float64 roundoff.
//Also dont modify prevP, epsilon, accelMul, or gp. Those are set externally.
//TODO over time, remove this.gob/optionalGob and use ONLY Var, and same for Game and other classes.
//They were made first, then redesigned as Var is their data format but its also a fast param like centerY.p.
//So far the tree is entirely organized by root.namespace.object.field, which is a Var tree 3 deep, as you see
//in the pic of json, but it can be any tree shape. Each var has a position, velocity, and 0 or more named childs.
//https://x.com/benrayfield/status/1877462454222958657 2025-1-9.
//
//To add new code, you move in a many dimensional space. Each possible code string is hashed to name
//it as a dimension. Position in that dimension means does the code exist or not. Child dimensions are its
//parameters, part of the high dimensional game state vector. It returns list or Int32Array of int voxels.
//You just write a javascript function of any parameters you want (Var instances which have
//position and velocity) and generate whatever pic you want based on that. The params will automatically
//change so the pics come to life.
//
const Var = function(optionalParentVar, optionalName, optionalBig, optionalGob){
	/*TODO[[[explained in https://chatgpt.com/g/g-p-67e3e1532ca08191983aad7a25c9c520-bellsack/c/691b4fcb-b89c-8327-85b6-ee2d9b5cd5ab 2025-11-17
	1 . Prefix vocabulary
	prefix	“look-back” distance d	semantics of .p
	O_	1	simple existence
	OO_	2	simple existence
	OOO_	3	simple existence
	OOOO_	4	simple existence
	(extendable)	d = # of O’s	
	P_ Ps_	1	exclusive / multi pointer
	L_ Ls_	1	exclusive / multi literal
	]]]*/
	//someVar.po (p object) is true if someVar.p!=0 means the object defined by someVar exists,
	//which normally includes someVar.X.p someVar.Y.p somevar.Z.p maybe someVar.ManaRefillRate.p etc.
	this.po = Math.random()<.5; //FIXME

	//FIXME remove optionalGob or set ob to it. BUT for security we should generate .ob from this.big||this.name.

	//fixme remove Var.brain cuz Var.getOb().brain would be that if ob is a Gob,
	//and remove Var.vars cuz thats now Var.pu aka the opposite spelling of Var.up.
	//this.brain = null; //where compiled (this.big || this.name) goes, normally a js func of Var's to list/array of int voxels.
	//this.vars = null;
	
	//If this.name is a hash id (or might be prefixed with something? todo), then its the hash of this.big which is probably a string of json (see Dagverse json norming, in dagball, TODO).
	//This must be verifiable. Dont just make up a name and make up a big that cant prove that its name is the hash of that.
	this.big = optionalBig || null; //can be a string or a list of strings to join by '\n' as lines.
	this.t = 0; //not used as of 2025-2-20 even though some code copies it, maybe later? TODO actual current time //TODO? this.t = utc time as float64 so has at least microsecond precision for 100+ more years.
	
	//TODO? this.ch = [] child vars list (gob.vars if this is gob.influence), if this is a .influence var
	//that is 1 for this thing exists and 0 for does not exist.
	//so there is 1 correct answer, or it should converge, to what .p and .v should a var be at time t
	//TODO? this.ns = string namespace, like game.ns.
	//TODO? this.pk = primaryKey of this Var. or should that be per scalar instead of per Var?
	//should pk depend on namespace? be concat to that? or what? pk certainly should not depend on t/time.
	this.name = optionalName || 'v'+(++generatedNameCounter);
	this.cache = {}; //holds constY and constX if this wraps a tile (Blob Monsters Game, not used in Bellsack as of 2025-11-13 but leave the cache field here anyways for general use. So far its been used as {} of string to number).
	/*too specific to one game (Blob Monsters Game). Var*.js is supposed to be more general.
	if(this.name.startsWith('tile')){
		if(isTileString(this.name)){
			let square = tileStringToSquare(this.name);
			this.cache.constY = SquareMidY(square);
			this.cache.constX = SquareMidX(square);
			//let yOfTopLeftCorner = SquareY(square);
			//let xOfTopLeftCorner = SquareX(square);
			//for Var.y() when Var.ob would be a QuadTile since it doesnt have Y and X Var childs cuz its in the square number instead
			//cant use this.constY cuz it will make a Var instance and put it in this.pu.constY
			//this.constY = yOfTopLeftCorner;
			//this.constX = xOfTopLeftCorner; //for Var.x()
			//this.cache.constY = yOfTopLeftCorner;
			//this.cache.constX = yOfTopLeftCorner;
		}
	}*/

	/*Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var.
	*/
	this.up = optionalParentVar || null;
	if(!this.up && this.name != 'V' && this.name != 'v'/*FIXME V vs v*/){ //FIXME remove this. The V global var is root of all Vars, but someone might rename it something else, who knows. This is a test to find those not in the tree at all 2024-11-21.
		throw new Error('Var not in the tree: '+this.path());
	}
	//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
	//Gobs normally go at height 2. Gob fields height 3.
	this.h = this.up ? this.up.h+1 : 0;
	
	/*if(this.name=='Y' && this.h==2){
		throw new Error('Var named '+this.name+' as child in namespace. should be 1 deeper.');
	}*/
	
	//pu is opposite of up aka down.
	//TODO make a {} whose Object.getPrototypeOf is custom built so any field that doesnt exist automatically creates
	//a Var instance as that child with that name and this Var as its parent and its .p of 0 and .v of 0 and other defaults.
	this.pu = {}; //mape of childVar.name to childVar.//this.down = {}; //mape of childVar.name to childVar.
	
	//2025-9-4+ going to use this as similar to someVar.ob=eval(someVar.big.join('\n'))
	//but u gotta take off the Js$ prefix to eval js like that, and theres also Glsl$ and Sak$ where
	//Sak$ is a mix of glsl and js and Var.
	//
	//2025-2-6+ will probably keep Var.ob as it can be Gob or Game instance
	//(like V.testnet.game.getOb() is a Game and sets V.testnet.game.ob and returns from that on next call of getOb()),
	//maybe other types later too. If you just type V.someOtherNamespace567.game.getOb() that should also make a Game instance.
	//TODO this field Var.gob will be removed???, Var class replaces Gob class. parent is this.up. childs are in this.pu.
	//can put same fields in Var as long as they're deriveable by Var.p Var.v Var.name Var.big etc.
	//The root (V) Var, and a namespace Var (like V/blobMonstersGameDefaultNamespace), dont have a Gob.
	//Its 1 layer deeper (theGobVar itself instead of gob.instance), and inside that is gob.vars.
	this.ob = null; //Gob or Game instance, whose parent Var is the same such as V.testnet: this.gob = optionalGob || null;
	
	//when first used, becomes a Map (not {}) whose keys are objects such as Lamgl.Tensor and values are Var's,
	//as an optimization to be like this.pu for childs. Its childs whose .big would be the string contents of the object,
	//like a Lamgl.Tensor would be 'Tsr$...sh/sizes and binary data in my kind of base64.
	//FIXME if joining with \n that would break it so .big joining that way gotta redesign.'.
	//The optimization is you dont have to hash the Lamgl.Tensor contents to store it in a child var by putting it
	//in for example. v.Bellsack.Room5.Ptr$AIWeightsVar.obs where if it were hashed it might go in
	//v.Bellsack.Room5.Ptr$AIWeightsVar.Tsr$345345somehash345345345
	//and v.Bellsack.Room5.Ptr$AIWeightsVar.Tsr$345345somehash345345345.big == 'Tsr$...binary data in that Lamgl.Tensor'.
	//Ptr$ means its childs are used as a stochasticVector (sums to 1 if the Ptr exists) of its possible values,
	//and in that case Ptr$AIWeightsVar is the name of the var and the tensor is its value.
	//You might also put json here using Json${...} (then the object would be the js {} form, or G$somestring etc.
	this.obs = null;
	
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	//dv is this i think, dont need da: this.da = 0; //da accel. dv velocity. dp position. so dv += da*dt; then dp += dv*dt; so we dont need dt param to accelerate by game.gravY.p.
	this.gr = 0; //same as (negative) .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.prevGr = this.gr; //for debug/logging. Has no effect on physics. Its just that .gr gets erased often.
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
	//use this.brain instead: this.evaled = null; //eval of this.big || this.name, a js lambda whose params are all Var objects, those in this.influence.vars or gob.vars
	
	/* A tighter security copy of this.p, that may differ from this.p like by game.sparseUpdate() or game.tryEval(string) etc.
	Decides if its evaled into local game state or removed. Should try to stay equal to this.p if this.y() this.x() is near enough to view.
	
	2025-2-18 mmMain:redesignDisorganizedBuggyTiles2025-2-18+ which led to the creation
	of Var.e and TODO Var.setE(number) or something like that TODO.
	
	Ive probably broken the loading of tiles again but ive got to mmMain:"fix why the tiles are appearing/disappearing approx like they should but at a few hundred pixels past where the gobs appear/disappear at the sparse distance (see sparseUpdate)"

	This whole tile thing is getting too complex. Its time for a small redesign, to get things straight in the design before writing more code. Its too many places things are being stored:
	Var.ob is a QuadTile, which has a square (uint53) and a Quad.
	game.wal is a BigTile containing Tile's.
	tile.dense is a 128x128 byte array.
	tile.sparse is a Quad.
	game.board is modified by a Quad in Tile.prototype.paintGame and it remembers that in tile.lastPaintedQuadOnGame (similar to gob.voxInGame int array but its a Quad instead).

	Theres also autoEval in Var.

	Theres Var.p NOT being used for create/delete at height 2 (V.testnet.objectName.p). State was supposed to be in the Var tree but some parts are not, and its causing an avalanche of cache errors that confusing me and getting way too much stuff tangled.
	Maybe I need a bit field in Var to say if its in the game or not, or a scalar field to say gradually how much, 0 to 1 in the simplest case.
	I recently changed Gob to not change its Var (gob.bo is a Var whose Var.ob is that Gob) when you edit the textarea. The var changes, but its a new Gob. Similarly, I dont want state stored in Tile thats not in Var, which might mean I have to redesign how you paint on BigTile to queue updates in some other structure and do them all at once (before next video frame).

	These redesigns wont be covered here[[[
	wikib upgrades.
	gob.m.IsSelected etc put in the Var tree.
	redesign gob.brain funcs to not modify their param Vars and instead be a pure-function (except maybe the mouse gob that reads Controls.mouseY etc) but I dont know how to do that efficiently.
	]]]

	This might turn into a bigger redesign than I thought, but think thru it carefully. In general I think I want to make game.wal (which is a BigTile) be a backing wrapper of the V/Var tree instead of storing out of sync caches of it, and I likely want another upgrade to the Var class which is Var.pExistsInGame but find something smaller to write it as maybe p.e. Yes, lets call it p.e for amount of eval, thats supposed to usually be the same as .p but .e goes thru more security checks, while .p can be changed by merging V tree across internet, its only evaled (TODO) into game.board etc	if !!p.e where p.e is normally 0 or 1. Also, we dont share Var.e across internet cuz its about local views of the Var tree, such as viewing it in a specific game.board game.gobs game.wal etc.
	...
	And im gonna need events to update things whenever .e changes, so .setE func instead of setting .e directly?
	*/
	this.e = 0;
	
	//gp works. it makes the gobs voxels overlap eachother less and bounce better. keep it. now is 2025-1-16.
	//gp: Like -dt*gr (gradient) usually goes into velocity, this part goes into position. p += -dt*gp.
	//This is an experimental field of Var added 2024-11-13 to try to solve that gobs overlap too much, take too long to accel away from eachother,
	//so this should slightly make them instantly jump away from eachother too.
	//I just doubled constraint solving efficiency of Blob Monster Game in 2 lines of code, in Var class:
	//"this.gp = 1.5; //TODO this.gp = 0;" and "let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);".
	//Now they overlap less. https://pic.x.com/7OjEWfA9hC (2024_pic.x.comSLASH7OjEWfA9hC.png)
	//This might be useful as a neuralnet param, built on the loss function it solves toward lower. Ive already live trained a 22 node sigmoid RNN
	//whose output is to recurse 15 cycles then take one node's output as potentialEnergy. Bent it like neural playdough. Havent tried this on it 2024-11-13.
	//--https://x.com/benrayfield/status/1856780041985687963
	//this.gp = 2.3; //TODO this.gp = 0;
	this.gp = DefaultGp;
	if(this.up && this.up.pu[this.name]){
		throw new Error('Duplicate Var, same name, same parent Var');
	}
	//if(this.up) this.up.pu[this.name] = this;
	//tie the new Var into its parent in TWO places
	//** fast own-prop lookup	(thisParent.child)
	//** iteration / filtering (thisParent.pu.child)								 */
	if(this.up){
		this.up.pu[this.name] = this;	 // existing behavior 2025-7-4 and earlier.
		this.up[this.name]	= this;	 // new: direct, non-proxy hit, 2025-7-5+
	}
	
	/*doesnt work, need Proxy: this.get = function(fieldName){
		console.log('fieldName='+fieldName);
		return this[fieldName]!==undefined ? this[fieldName] : this.pU(fieldName); //creates fieldName
	};*/
	
	//spring at-rest has one of its ends here (meaniung this.p is attracted to it by positive ps,
	//and you should probably not have negative ps cuz it will repel this.p toward positive or
	//negative infinity unless you have other physics forces preventing that).
	//has no effect if ps==0. position taRget, like in dagball.Ed having a target ave and strength as a parabola
	this.pr = 0;
	//spring strength. strength of p toward pr, as pr and ps define a parabola of poten
	this.ps = 0;
	
	this.cv = 0; //base kv. its cv+kv, not just kv, but kv is set by code dynamicly, and cv is set in the Var.
	
	//Set of functions like (ancestorVar,selfVar,map)=>{...code...} called when .p or .v changed or sometimes called
	//when nothing changed (just make sure not to miss when it does change, firing too much when it hasnt changed is ok).
	//anyVar.listen(ExampleEventListener) then .makeDirty() schedules it for anyVar.fireEvents()
	//and later you might anyVar.unlisten(ExampleEventListener).
	//This is null until first .listen(listener) call which creates this Set
	//(of functions of 3 params: ancestorOrSelfVar, selfVar, map).
	//Most Vars never get any listeners. fieldEditor (checkboxes, slidebars, wrapping Var)
	//and sync across network will be main uses of this event system, but as of 2025-11-13-750pET the new event system isnt working yet.
	this.listeners = null;
	
	//For efficiency, the Var event system does not create heap objects
	//such as listener({Var:theVar}). It just uses listener(ancestorOrTheVar,theVar,mapThatsNormallyEmpty).
	//
	//linked list pointer. Head is VarVM.dirtHead. Ends at null.
	//Undefined means not in the list. Null means this is the last node in the list.
	//A Var is dirty if .v!=0 or .dp or .dv or .kv or .mn or .mx etc have been modified.
	//You dont modify .p or .v directly. You wait for .nextState(dt) to be called doue to
	//the Var will be in the dirty list and it happens in the main program loop lamglLoopBody
	//once per cycle (TODO cuz 2025-11-13 its calling nextState only on specific Var's that it
	//knows are game objects, not in this event system of 2 linked lists).
	this.dirtNext = undefined; //not in the VarVM.dirtHead linked list
	this.tempNext = undefined; //like dirtyNext but a second linked list at VarVM.tempHead.
	
	//this is how u make wires, connect groups of Var's to eachother.
	//TODO this will be maybe a string, that tells which EdJoint (like in dagball)
	//this Var is joined to other Vars thru, that their .p and .v are held equal to other .p and .v,
	//and physics forces (gr, poten, etc) are summed (not averaged) across edjoint.
	//This can be reflected as a stochasticVector of Ptr$ej or maybe Ej$, Var childs,
	//but this is where it snaps to a particular edjoint or null for none.
	this.ej = null;
	
	
	this.path_ = null; //cache of this.path(), lazyEvaled
};

Var.prototype.opt = { //must be named opt instead of Opt cuz Opt would be a child, and this is for Var internals.
	//oneBitPerDimGradient: true, //test. should make balls ignore magnitude of gradient per dimension and use opt.oneBitPerDimGradientVal vs -opt.oneBitPerDimGradientVal instead
	//oneBitPerDimGradient: false, //normal
	//oneBitPerDimGradientVal: 20,
	//oneBitPerDimGradientVal: 1,
};

const VarVM = Var.prototype.vm = new function(){}; //put things shared by all Var's here.
VarVM.dirtHead = null; //head of linkedlist of dirty/modified Var's that need theVar.nextState(dt) called even if dt is 0.
//the second list used during processing VarVM.dirtyHead, in case Var.listeners cause Var's to be dirty.
//FIXME If listeners cause Var's to become dirty aVar.makeDirty() during someOtherVar.nextState(dt), then
//it could break that it does not depend on order of Var's which nextState is called. Its supposed to be in batches,
//and the batch is now 2025-11-13 done in lamglLoopBody but TODO do the batch in VarVM.nextState(dt)
//which should sparsely only update Var's whose .p or .v could possibly be changed by calling nextState,
//so for example if .v is 0 and nothing else has changed, .p position would not change nomatter the dt,
//and .v wouldnt change either, so even if you have millions of Var objects it wont run most of those except as needed.
//This sparse running can in theory, by Var.listeners, move that sparse attention (set of Var's to update) on its own
//like some kind of automata but by whatever game rules players create from inside the game using the level editor.
VarVM.tempHead = null;

//null or the Var at VarVM.dirtHead linked list head disconnected from the linked list.
VarVM.popDirt = function(){
	if(VarVM.dirtHead){
		let vr = VarVM.dirtHead;
		VarVM.dirtHead = vr.dirtNext;
		vr.dirtNext = undefined; //undefined means not in list. null means end of list.
		return vr;
	}else{
		return null;
	}
};

VarVM.popTemp = function(){
	if(VarVM.tempHead){
		let vr = VarVM.tempHead;
		VarVM.tempHead = vr.tempNext;
		vr.tempNext = undefined; //undefined means not in list. null means end of list.
		return vr;
	}else{
		return null;
	}
};

VarVM.pushDirt = function(vr){
	vr.dirtNext = VarVM.dirtHead; //may be null, which means end of list. undefined means this node is not in the list.
	VarVM.dirtHead = vr;
	return vr;
};

VarVM.pushTemp = function(vr){
	vr.tempNext = VarVM.tempHead; //may be null, which means end of list. undefined means this node is not in the list.
	VarVM.tempHead = vr;
	return vr;
};

VarVM.nextState = function(dt){
	while(this.dirtHead){ //move dirty list to temp list, reversed order but order should not matter.
		this.pushTemp(this.popDirt());
	}
	let vr = VarVM.tempHead;
	//TODO should there be a separate list of events BEFORE the nextState change, which would go here?
	while(vr){ //loop over VarVM.tempHead linked list
		//vr.nextState(dt) may fill VarVM.dirtHead linked list of Var's that become dirty, and we need to
		//be careful not to make the effects of Var.nextState(dt) depend on the order of Vars thats called on.
		//Will nextState call listeners, or should those all be batched after the updates? To be safe lets do that
		//in one more batch. 2 while loops instead of 1, so the first must not empty the list
		vr.nextState(dt);
		vr = vr.tempNext;
	}
	//AFTER the nextState change.
	while(vr = this.popTemp()){ //loop over VarVM.tempHead linked list while emptying it
		//after eachDirtyVar.nextState(dt) is called for every Var that it could have had an effect in,
		//do all the events, so they all see the same 
		vr.fireEvents();
	}
	//FIXME on some interval or maybe pick a random up to 10 dom nodes that
	//a Var.fieldEditor (makes checkbox, number box, slider, etc) existed in the dom tree
	//but does not exist anymore, so do theVar.unlisten(listener)
	//where listener.putInDom(domNode) made the editor UI that was deleted. Clean up unused object.
};

//no prototype so theres no .toString() .prototype etc in it. Useful for sandboxing.
var newVeryEmptyMap = ()=>{
	let map = {};
	Object.setPrototypeOf(map,null);
	return map;
};

const EmptySimpleMap = Object.freeze(newVeryEmptyMap());

//Any function (of Var param) added by this.listen(vr=>{ console.log('listened to '+vr.path()+'.p='+vr.p); }),
//then fireEvents calls each of those on (fixme it should say "(anc,me,EmptySimpleMap)" where anc means
//ancestor this.up.up.up or self aka this. ancestor or self. me param right after that is where
//the Var event happened, such as a change of its .p or .v),
//this Var. That sentence was too long, fixme. The event system does not create heap objects, but listeners may.
Var.prototype.fireEvents = function(){
	if(this.listeners){ //Set of function
		for(let listener of this.listeners){
			//listener(ancestorOrSelfVar,selfVar,{}) so possible future expansion of the event system to get events
			//for changes in childs of childs... nomatter how deep, costing only height
			//(number of someVar.up.up.up... before reaching v/V the root Var),
			//but for now 2025-11-13 I'm just doing ancestorOrSelfVar===selfVar and not firing events of parent of parent..
			listener(this,this,EmptySimpleMap); //calling it this way avoids heap allocation such as {Var:this}.
		}
	}
};

const ExampleVarListener = (ancestorOrSelfVar,selfVar,map)=>{
	console.log('ExampleVarListener event ancestorOrSelfVar='+ancestorOrSelfVar+' selfVar='+selfVar+' map='+JSON.stringify(map));
};
//do this in startBellsack V.listen(ExampleVarListener); //when root changes look for that on browser console. Root doesnt normally change.

//Like addEventListener. listener(ancestorOrSomeVar,someVar,{..optional details but is not used as of 2025-11-13..}).
//Search for "listener(ancestorOrSelfVar,selfVar,{}) so possible future expansion of the event system to get events"
//for more comments about it. Gets events of Var.fireEvents() which occurs when you VarVM.nextState(dt).
//There is no event for the creation or deletion of childs cuz mathly its a vector with value p=0 v=0 everywhere not specified,
//but in some 
Var.prototype.listen = function(listener){
	console.log(this.path()+'.listen('+listener+')');
	if(!this.listeners){ //Set of function
		this.listeners = new Set();
		//TODO if all listeners are removed for some time from this Var, get rid of the Set to save memory?
		//Most Var's wont have any listeners so its probably not a problem.
	}
	this.listeners.add(listener);
};

//opposite of Var.listen(listener)
//Test this by deleting the top panel containing ns.Opt.IsGraphicsDebug checkbox
//and verify ns.Opt.IsGraphicsDebug.listeners doesnt contain its listener anymore
//but did before the deletion. Successful test 2025-11-16-930aET.
Var.prototype.unlisten = function(listener){
	console.log(this.path()+'.unlisten('+listener+')');
	if(this.listeners){ //Set of function
		this.listeners.delete(listener);
	}
};

Var.prototype.unlistenAll = function(){
	if(this.listeners){ //Set of function
		this.listeners.clear();
	}
};

/* 225-11-13-820pET
Var*.js in Bellsack now has an event/listener system. Its still a many dimensional vector system for game states. If you change the .p position or .v velocity the usual ways (theVar.dp dv kv mn mx etc) then call theVar.makeDirty() it schedules the Var for events.

anc/ancestor is not used yet. me is the Var the event happened in. map is {} so its basiclly just the Var itself with no event details.

When I turn this event system on with the IsNewEventSystemY2025M11 checkbox, I noticed it bypassed my "only ball physics" checkbox and the walls/terrain started moving on its own, as if "only ball physics" was unchecked, so I knew the events were working.

http://V.Bellsack.Hello.World.listen((anc,me,map)=>{ console.log('me='+me.path()+' p='+me.p); });
                                             
Bellsack353.html:2354 v['FIXMEESCAPE_Bellsack']['FIXMEESCAPE_Hello']['FIXMEESCAPE_World'].listen((anc,me,map)=>{ console.log('me='+me.path()+' p='+me.p); })
undefined
http://V.Bellsack.Hello.World.set(2)
                                             
Var {big: null, t: 0, name: 'World', cache: {…}, up: Var, …}
VM1364:1 me=v['FIXMEESCAPE_Bellsack']['FIXMEESCAPE_Hello']['FIXMEESCAPE_World'] p=2
http://V.Bellsack.Hello.World.dp += 20
                                             
20
http://V.Bellsack.Hello.World.makeDirty()
                                             
Var {big: null, t: 0, name: 'World', cache: {…}, up: Var, …}
VM1364:1 me=v['FIXMEESCAPE_Bellsack']['FIXMEESCAPE_Hello']['FIXMEESCAPE_World'] p=2.3333333333333335


Lambda Rick 🏴‍☠️/acc
@benrayfield
·
13s
The event system in theory works the same nomatter the order of events in 1 video frame of the game. They get batched together and sum into temp vars then are merged.
Lambda Rick 🏴‍☠️/acc
@benrayfield
·
14m
It does not create heap objects for events so it can in theory handle many millions of events per second.
*/

//idempotent, adds this Var to VarVM.dirtHead linked list
//unless its already in that or VarVM.tempHead list as marked by this.dirtNext!==undefined.
Var.prototype.makeDirty = function(){
	/*if(this.dirtNext === this){ //not already queued
		this.dirtNext = VarVM.dirtHead; //push-front
		VarVM.dirtHead = this;
	}*/
	if(!this.isDirtyByList()){
		//not in dirty list or temp list. temp list only exists during VarVM.nextState(dt). This check makes it idempotent.
		VarVM.pushDirt(this);
	}
	return this; //for chaining
};

//make it dirty only if it actually changed
Var.makeDirtyIf = function(){
	if(this.isDirtyByContent()){
		this.makeDirty(); //causes this.isDirtyByList() to be true if u called it
	}
};

//true if its been marked as dirty by makeDirty.
Var.prototype.isDirtyByList = function(){
	return this.dirtNext!==undefined || this.tempNext!==undefined;
};

//true if is actually dirty by content, which can occur
//after changing many .dp .dv .kv etc fields before calling makeDirty.
//nextState(dt) can change this. So can any code that adds to .dp .dv etc then calls makeDirty.
//Dirty means it needs nextState(dt), so if it has nonzero velocity thats true,
//same as if certain other fields are nonzero or do not equal certain constants etc.
//This does not check .pr .ps (spring holding .p in a parabola shaped
//energy well) or Edjoints/Lit_ej/Ej_/Lit$ej/Ej$.
Var.prototype.isDirtyByContent = function(){
	return this.v || this.dp || this.dv || (this.kv!=this.cv) || (this.mn!=-Infinity) || (this.mx!=Infinity);
};


Var.prototype.potenNearPairs = function(funcOf2VarParams){
	return potenNearPairs(this.ns(), this.Cx.p, this.Cy.p, this.Cz.p, this.Cr.p, this.Cc.p, funcOf2VarParams);
};

Var.prototype.diffeqNearPairs = function(funcOf2VarParams){
	return diffeqNearPairs(this.ns(), this.Cx.p, this.Cy.p, this.Cz.p, this.Cr.p, this.Cc.p, funcOf2VarParams);
};

//like diffeqNearPairs but only returns a float.
//ns is namespace aka room such as v.Bellsack.Room5
var potenNearPairs = (ns,cx,cy,cz,cr,cc,funcOf2VarParams)=>{
	Err('TODO');
};

//returns a Map of Var to vec4 (todo fix that design it would be slow) OR mods the Var's in the 2 params of funcOf2VarParams
//such as bellCurve.X.dp bellCurve.X.dv bellCurve.X.mx etc.
//FIXME make them funcs on their own not built into a Var? or have both?
//cx cy cz are sphere center. cr is its radius. within that, vars whose Cx Cy Cz are both inside that sphere,
//are found and further filtered by they have to be within cc center-to-center-distance from eachother.
var diffeqNearPairs = (ns,cx,cy,cz,cr,cc,funcOf2VarParams)=>{
	//TODO also need ability to filter them by Odos$ or whatever paths and child.child.child Lone.Lone.Abc etc.
	Err('TODO Sak, and move Sak to Var*.js or stop hardcoding it in Var*.js, as its currently in Bellsack*.js, all in script tags not separate files but u can separate files');
};

//Returns a new child, that doesnt	exist (or isnt loaded, someone else in same namespace might have made it).
//is random but you might want autoinc or something like that. TODO?
Var.prototype.new = function(optionalPrefix, optionalSuffix){
	let prefix = optionalPrefix||'v'; //renaming V to v, as root. //let prefix = optionalPrefix||'V';
	let suffix = optionalSuffix||'';
	let name;
	do{
		name = prefix+(''+(1e9+randInt(1e9))).substring(1)+suffix; //like 'V123456789'
	}while(this.pu[name]);
	return this[name];
};

var randInt = max=>((Math.random()*max)|0);

//FIXME make this smaller
var DefaultEpsilon = window.DefaultEpsilon = 2**-7; //FIXME which scripts (of the 3 in this html) use this?
//var DefaultEpsilon = 2**-12; //FIXME is this small enuf? is it for float32 or float64?

var timeOffset_ = performance.timing.navigationStart;

//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
var time = ()=>((timeOffset_+performance.now())*.001);

var timeIdPrev = 0;

/*returns a float64 that is bigger than the last float64 returned by this and is as close to the current UTC time as possible.
..
Tested this on (Double.doubleToLongBits(1697766252.4079208)-Double.doubleToLongBits(1697766252.3960001)) in java which returned 49999.
I generated those 2 doubles on browser console in brave by:
x = TinyGlsl.time();
1697766252.3960001
for(let i=0; i<49999; i++) x = TinyGlsl.nextUpPositiveDouble(x)
1697766252.4079208
This works cuz all the positive finite doubles are sorted the same way as their raw long/int64 bits. The negatives come after that cuz high bit / sign bit is 1.
Name these tid (Time ID), like put that in webgl/glsl and canvas objects to know what time created them so can try deleting them in that same order or reverse order???
*/
var TimeId = ()=>{
	let now = time();
	return timeIdPrev = Math.max(now, nextUpPositiveDouble(timeIdPrev));
};

//does not call system clock. just increments by nextUpPositiveDouble. Is always bigger than the last call of TimeId() and the last call of FastTimeId().
var FastTimeId = ()=>(timeIdPrev = nextUpPositiveDouble(timeIdPrev));

//put a tid field (timeId) on the object if it doesnt already have one (0 doesnt count), then return the object.
//Example: let floats = TinyGlsl.putTid(new Float32Array(100));
var putTid = ob=>{
	if(!ob.tid){
		ob.tid = TimeId();
	}
	return ob;
};

//same as TinyGlsl.putTid(ob).tid but usually faster. Returns the timeId of the object, and creates one if it doesnt have it yet.
var tid = ob=>(ob.tid || putTid(ob).tid);

var tidComparator = (a,b)=>{
	//cant subtract cuz might lose the difference to roundoff
	let aTid = TinyGlsl.tid(a); //FIXME Lamgl replaced TinyGlsl
	let bTid = TinyGlsl.tid(b);
	if(aTid < bTid) return -1;
	if(aTid > bTid) return 1;
	return 0;
};

//a js {} to sort by valA.tid, valB.tid, etc.
var tidComparatorForMapKeys = map=>{
	return function(a,b){
		return TinyGlsl.tidComparator(map[a],map[b]);
	};
};

//This should be a little more than the common epsilon of 1 for pixel coordinates (1 pixel over)
//so it can jump a little past that. If its 1, it moves a little too slow. If 2 its noticably jumpy.
//var DefaultGp = 1.5; //normal
//var DefaultGp = -1.5; //fixme
//var DefaultGp = 11.5;
//var DefaultGp = -11.5;
//var DefaultGp = -.1;
//var DefaultGp = .1;
//var DefaultGp = .2;
var DefaultGp = 0;
//var DefaultGp = 5.5;
//var DefaultGp = 15.5;

console.error('TODO merge Var.prototype.touch into Var.prototype.makeDirty but dont call TimeId() that often cuz system clock could be the bottleneck in modding vars in that case. Instead only call TimeId() in lamglLoopBody once and call ...');
Var.prototype.touch = function(){
	this.t = TimeId(); //a unique time, increments by at least 1 ULP.
	return this; //for chaining calls
};

//delete me from the local V/Var tree
Var.prototype.del = function(){
	if(!this.up){
		Err('Already is root V/Var, cant del: '+this.path());
	}
	console.log('Deleting Var path='+this.path());
	delete this.up.pu[this.name];
	//FIXME this.up still exists, so if this.abc.def.ghi still exists then ghi.up.up... will still find this and parents.
};

//copy copyMe.p to this.p, copyMe.v to this.v, etc, but nothing in this.pu (childs) cuz thats not local.
//Its only the fields that count as longterm game state, not temp vars used DURING a physics cycle like this.gr.
//Does not copy .epsilon or .accelMul cuz those are set once in code in the varName/*p v e a*/ syntax,
//which I might change to include pr ps cv and maybe more, but i might leave that to the fieldEditor UI etc.
Var.prototype.copyLocalFrom = function(copyMe){
	this.p = copyMe.p;
	this.v = copyMe.v;
	this.pr = copyMe.pr;
	this.ps = copyMe.ps;
	this.cv = copyMe.cv;
};

Var.prototype.Mn = function(val){
	this.mn = Math.max(this.min,val);
	return this.makeDirty();
};

Var.prototype.Mx = function(val){
	this.mx = Math.min(val, this.mx);
	return this.makeDirty();
};

//does both Mn and Mx. Same as setting this.p (after this.nextState(dt)) but if others have set this.mn or this.mx
//and the value this sets it to is not in that allowed range, it does not get set at all. Thats to keep it independent
//of the order Var's are updated, which is less important in Blob Monsters Game than it was in dagball cuz Var is so
//far 2024-11-23 only used in 1 Gob/monster at a time, but in dagball they have EdJoint's. Might add EdJoints here later.
//Var.prototype.MnMx = function(val){
Var.prototype.set = function(val){
	this.mn = Math.max(this.mn,val);
	this.mx = Math.min(val, this.mx);
	return this.makeDirty();
};

//get namespace
Var.prototype.ns = function(){
	if(this.h <= 1){
		if(this.h == 0) throw Error('This is root Var, which namespaces are childs of.');
		return this;
	}
	return this.up.ns();
};

//gets the Game (like V.testnet.game) of the namespace, even if this is like V.testnet.someGob555
Var.prototype.getGameVar = function(){
	return this.ns().game; //TODO multiple views, each a Game instance.
};

Var.prototype.getGame = function(){
	return this.getGameVar().getOb(); //Game instance
};

//added 2025-7-5, not tested
Var.prototype.z = function(){
	//return this.cache.constZ!==undefined ? this.cache.constZ : (this.pu.Z || this.Z).p;
	return this.Z.p; //the Proxy is prototype of prototype of each Var so is only touched when childs dont exist
};

Var.prototype.y = function(){
	//Var.constY and .constX are created if isTileString(Var.name)
	//return (this.constY!==undefined) ? (this.constY) : ((this.pu.Y || this.Y).p);
	return this.Y.p; //the Proxy is prototype of prototype of each Var so is only touched when childs dont exist
};

Var.prototype.x = function(){
	//return this.cache.constX!==undefined ? this.cache.constX : (this.pu.X || this.X).p;
	return this.X.p; //the Proxy is prototype of prototype of each Var so is only touched when childs dont exist
};

//used on Var.name or Var.big of a tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
//or the longer form that goes in .big or the shorter form thats a literal instead of a hash after the first $.
var isTileString = s=>/^tile\d{1,16}\$/.test(s);

var tileStringToQuadTile = s=>{ //returns a QuadTile containing all the info in the string. TODO merge some of the code from Tile.toVar() into this.
	/*let i = s.indexOf('$');
	let base64 = s.substring(i+1);
	let tileNum = parseFloat(s.substring('tile'.length, i)); //0 to (2**53)-1, an integer.
	let height = SquareH(tileNum);
	let quadBytes = base64ToBytes(base64);
	return new Quad(height, quadBytes);
	*/
	let square = tileStringToSquare(s);
	return new QuadTile(square, new Quad(SquareH(square), tileStringToBytes(s)));
};

//0 to (2**53)-1, an integer. Use with SquareY SquareX SquareH and Square(h,y,x)
var tileStringToSquare = s=>parseFloat(s.substring('tile'.length, s.indexOf('$')));

var tileStringToH = s=>SquareH(tileStringToSquare(s));

//top Y. 1<<height is y height and x width.
var tileStringToY = s=>SquareY(tileStringToSquare(s));

//left X. 1<<height is y height and x width.
var tileStringToX = s=>SquareX(tileStringToSquare(s));

//is either the sha256 of the .big form or is the bytes for a Quad, so check if its the Var.name vs Var.big.
var tileStringToBytes = s=>base64ToBytes(s.substring(s.indexOf('$')+1));

//this.big can be a [] list of strings that get joined by \n, normally 1 line each,
//or a single string, or null/undefined to just use .name.
//.name is derived from .big if it exists. someVar.name == ('PrefixOfBigIncludingTheFirst$'+sha256(someVar.bigSt())),
//or if .bigSt() contains no '$' then it just puts some default prefix.
//it used to be gob$ (in Blob Monsters Game) but i think '$' is an ok prefix by itself.
Var.prototype.bigSt = function(){
	if(this.big === undefined || this.big == null){ //todo pick one, dont do undefined and null
		return this.name; //or ''? or null?
	}else if(typeof(this.big)=='string'){
		return this.big;
	}else{
		return this.big.join('\n');
	}
}

//lazy create ob (Gob or Game, depending on var path ends with .game or not, todo multiple views/games).
Var.prototype.getOb = function(){
	if(this.ob){
		return this.ob;
	}else{
		let bigSt = this.bigSt();
		console.err('//FIXME cant have Sak (which is created in Bellsack*.js (maybe will rename to Sak*.js?) in this Var*.js. reorganize.');
		if(bigSt.startsWith('Sak$')){
			return this.ob = Sak.trySakEval(bigSt);
		}
		/*
		if(this.h == 2){
			//raise this.t which is a unique (in this browser tab, not across network) UTC time (TimeId())
			//When multiple QuadTiles are at the same square,
			//TODO uses touch time (QuadTile.bo.t) to keep newest and turn older ones off,
			//but across network (TODO its still just 1 computer as of 2025-2-23) it wont trust .t and syncs by .p mainly.
			//Locally we use .t in some cases to choose .p values, and .e tries (within security rules) to stay equal to .p
			//when near the Y X of the view area, so it should all fit together.
			this.touch();
			let text = this.text();
			if(text.startsWith('(') || text.startsWith('gob$')){
				let game = this.getGame(); //likely a sibling, and game.influence===this.getGameVar()
				//text is a js lambda (brain) whose params if evaled should be Var objects, returns list of int voxels
				//fails cuz text is not evaled, is still a string: return this.ob = new Gob(game, text);
				let jsLambdaAsGobBrain = game.tryEval(text);
				return this.ob = new Gob(game, jsLambdaAsGobBrain);
			}else if(text == 'game'){
				//like V.testnet.game is the default path of the game,
				//but todo multiple games/views at once of each namespace.
				return this.ob = new Game(this);
			}else if(isTileString(this.name)){
				let qt = tileStringToQuadTile(this.big || this.name);
				this.ob = qt;
				qt.bo = this; //QuadTile.bo is its Var. Only if created/loaded by Var will it have a .bo field.
				return qt;
			}else{
				throw new Error('Uknown object type: '+text);
			}
		}else{
			throw new Error('this.h/height is '+this.h+' but Gob and Game go at height 2 (right after namespace at height 1)');
		}
		*/
	}
};

//copies from map to Var recursively. Overwrites where existed.
//You can fork world state by loading the part just past the namespace into another namespace you make up,
//which you can do many times per second such as for harmony-search of game states to look for lower poten/potentialEnergy.
//a json map of the kind V.toMap() creates, or subset of it, like you might do V.testnet.load({..parts inside V.testnet..})
//or you might V.load({testnet:{...},otherNamespace5:{...}}). This only copies it into the Var system,
//doesnt eval it (TODO should it? Maybe it will later and this comment not be updated FIXME?).
//
//If optional_isAutoEval is false (or param not given) then it doesnt call Var.eval() after loading,
//so for example if you load a tile it will appear in the Var tree but not in game.board or on screen.
//If you instead use optional_isAutoEval of true, it will do that eval and appear on screen,
//but be careful in that it can lead to remote-code-injection cross-site-scripting etc as the code may have
//come from an untrusted source, a peer to peer network of whatever js code ppl and AIs write as game content.
//To limit the risk of that, it should use game.tryEval(string) but as of 2025-2-17 it just evals nearly everything.
//Another way to limit that risk is to use wikibinator203 instead of javascript as the model of gob.brain code
//which is likely to be a far future upgrade.
Var.prototype.loadMap = function(map, optional_isAutoEval){

	//FIXME if its flatPu theres no map.pu

	this.p = map.p || 0; //position
	this.v = map.v || 0; //velocity
	if(map.pu){ //childs of any names
		for(let id in map.pu){
			let childMap = map.pu[id];
			//let childVar = this[id]; //reuses if exist, else creates using varProxyHandler as Var is a js Proxy object.
			let childVar = this.pu[id];
			if(!childVar){
				let big = childMap.big || id;
				childVar = this[big];
				if(childVar.name != id){
					Err('Wrong hash. big did not generate expected id of '+id+', from big='+big);
					//you could just do this[id] but that wouldnt create this[id].big which id is derived from.
				}
			}
			childVar.loadMap(childMap, optional_isAutoEval);
		}
	}
	if(optional_isAutoEval){
		console.log('Var.eval() cuz optional_isAutoEval='+optional_isAutoEval+', '+this.path());
		this.eval();
	}
};

Var.prototype.loadJson = function(json, optional_isAutoEval){
	this.loadMap(JSON.parse(json), optional_isAutoEval);
};

/*Var.prototype.clear = function(map){
	this.nextState(0);
	this.pu = {}; //empty this.pu
};*/
//Var.prototype.clear = function(map){ //FIXME why does Var.clear take a map param? Shouldnt it be theVar.clear() no param?
Var.prototype.clear = function(){
	if(this.dirtNext !== undefined){
		console.log('WARNING: The new (2025-11-13) Var event system has '+this+' in VarVM.dirtHead linked list, so Var.clear() it at that time might cause bugs? Just after VarVM.nextState(dt) is probably the best time to delete it. Or maybe it should be marked for clearing during VarVM.nextState(dt)? FIXME need to remove this from the VarVM.dirtHead list or VarVM.tempHead list. Since those are singly linked lists, we cant efficiently remove that here, have to wait for VarVM.nextState(dt) which does that but also that may put some Vars back into the dirty list by listeners of other Vars modifying some Vars then calling theVar.makeDirty() to say ijt did that or calling funcs which internally call makeDirty.');
	}
	//FIXME? calling nextState
	this.nextState(0);
	for(let key in this.pu){
		delete this[key]; //cuz is duplicated in this[childName] and this.pu[childName]
	}
	this.pu = {}; //empty this.pu
	this.listeners = null; //delete the Set of functions if exists
};

Var.prototype.toJson = function(excludeBig_or_optionsMap){
	return JSON.stringify(this.toMap(excludeBig_or_optionsMap));
};

Var.prototype.toJSON = function(){ //for if this is used in JSON.stringify(someVar) it auto calls someVar.toJSON()
	return this.toJson(false);
};

var Load = json=>{
	let isAutoEval = true;
	V.loadJson(json, isAutoEval);
};

var State = excludeBig=>V.toJson(excludeBig);

/*todo var Save = name=>{
	if(name === undefined){
		name = 'blobMonstersGame_'+time();
	}
	if(!name.includes('.')) name += '.vartree';
	let json = State();
	
};*/

var quicksave = function(name){
	console.log('quicksave '+name);
	localStorage.setItem('monst.'+name, State());
};

var quickload = function(name){
	console.log('quickload '+name);
	let json = localStorage.getItem('monst.'+name);
	if(json){
		Load(json);
	}
};

var saveFile = (fileName, contentType, text)=>{
	var blob = new Blob([text], {type: contentType});
	if(window.navigator.msSaveOrOpenBlob){
		window.navigator.msSaveBlob(blob, fileName);
	}else{
		var elem = window.document.createElement('a');
		elem.href = window.URL.createObjectURL(blob);
		elem.download = fileName;
		document.body.appendChild(elem);
		elem.click();
		document.body.removeChild(elem);
	}
};


//This existed in Blob Monsters Game before Bellsack but seems too specific to one game,
//so commenting out its contents. Maybe later this should be a place to hook in plugins.
//
//If this is a Tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF,
//then loads it into game.wal (BigTile) and game.board (64 megapixel array of nearest 8k x 8k square
//to game.Y.p game.X.p 2d coordinate where viewing, so careful not to load tile where it would wrap around that as its farther away.
//TODO also load gob if its that, aka its name starts with gob$ . Careful about remote code injection,
//check it for infinite loops, spam redirects of window.location, etc.
Var.prototype.eval = function(){
	/*if(this.name.startsWith('gob$')){
		//Todo();
		console.log('Ignoring Var.eval() for gob cuz gob puts itself in game.gobs list and has been working as of 2025-2-17, path='+this.path());
	}else if(isTileString(this.name)){
		let quadTile = this.getOb();
		game.wal.tile(quadTile.square).writeSparse(quadTile.quad); //idempotent and fast if that same quad is already there
	}else{
		console.warn('TODO how to load Var='+this.path());
	}*/
	console.warn('Ignoring attempted Var.eval of '+this.path());
};

/*//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
//Gobs normally go at height 2. Gob fields height 3.
Var.prototype.h = function(){
	return this.up ? (this.up.pathHeight()+1) : 0;
};*/

Var.prototype.toMap = function(excludeBig_or_optionsMap){
	//TODO make it just be options map
	let options = typeof(excludeBig_or_optionsMap)=='boolean' ? {excludeBig: excludeBig_or_optionsMap} : (excludeBig_or_optionsMap || {});
	let wasFromRoot = options.fromRoot;
	if(wasFromRoot) options.fromRoot = false;
	let ret = {
		p: this.p,
		v: this.v,
		//name: this.name,
		//pu: {},
	};
	if(this.t){
		ret.t = this.t; //UTC time updated. not all code will use this. but each Var is a time-series of 2 numbers: position and velocity.
	}
	if(this.pr){
		ret.pr = this.pr; //target position to spring toward
	}
	if(this.ps){
		ret.ps = this.ps; //spring strength of p toward pr
	}
	if(this.cv){
		ret.cv = this.cv; //base velocity decay, which kv is reset to in Var.nextState(dt)
	}
	if(this.big && !options.excludeBig){
		ret.big = this.big;
	}
	for(let childName in this.pu){
		//flatPu makes the json about half as deep. Childs start with capital letter,
		//built ins like p v toString start lowercase.
		let pu = options.flatPu ? ret : (ret.pu || (ret.pu = {}));
		pu[childName] = this.pu[childName].toMap(options); //not options.fromRoot
	}
	if(wasFromRoot){
		options.fromRoot = wasFromRoot; //dont modify except during recursion
		let findRoot = this;
		while(findRoot.up){
			ret = {[findRoot.name]: ret};
			findRoot = findRoot.up;
		}
	}
	return ret;
};

Var.prototype.text = function(){
	//return this.big || this.name;
	if(this.big){
		if(typeof(this.big)=='string'){
			return this.big;
		}else{
			return this.big.join('\n'); //this.big is list of lines. TODO always norm \r\n or \r by itself to \n
		}
	}else{
		return this.name;
	}
};

const DefaultMaxResults = 2**16;
const DefaultRadiusResults = 2**12;

Var.prototype.allVars = function(optionalListToFill){
	let list = optionalListToFill || [];
	list.push(this);
	for(let childName in this.pu){
		this.pu[childName].allVars(list);
	}
	return list;
};

//returns a list of Var in descending (or is it ascending? is positive good or bad? choose one.) order of goal(theVar)
//which returns a number for how good a match it is. Also limit by exclude negatives (or positives?) from if score is too low?
//Theres an optimization that if optionalMaxResults==1 it doesnt sort an array but just keeps the best in a loop,
//but either way it calls goal on every Var reachable from here.
//TODO optimize more in that case to not even create the array of all Var.
Var.prototype.searchTree = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	let vars = this.allVars();
	if(maxResults == 1){ //n cost
		let bestScore = -Infinity; //FIXME is this reversed from how i vars.sort it?
		let bestVar = null;
		for(let v of vars){
			let score = goal(v);
			if(bestScore < score){
				score = bestScore;
				bestVar = v;
			}
		}
		return bestVar ? [bestVar] : [];
	}else{ //n*log(n) cost
		vars.sort((varA,varB)=>Math.sign(goal(varA)-goal(varB))); //FIXME is this reversed?
		while(vars.length > maxResults) vars.pop();
		return vars;
	}
};

//TODO rename search to searchChilds and have another func searchTree.
//goal(anyVar)->score (FIXME or should it be loss which is -score or someConstant-score?
//As goal, any positive number passes, and any 0 or negative number does not match.
//Sort by that descending, of those which pass.
Var.prototype.search = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	//if(maxResults === undefined) maxResults = DefaultMaxResults;
	let scores = new Map();
	let ret = [];
	for(let n in this.pu){
		let childVar = this.pu[n];
		let score = goal(childVar);
		if(score > 0){
			scores.set(childVar, score);
			ret.push(childVar);
		}
	}
	ret.sort((a,b)=>{
		let scoreA = scores.get(a), scoreB = scores.get(b);
		if(scoreA < scoreB) return -1;
		if(scoreA > scoreB) return 1;
		return 0;
	});
	while(ret.length > maxResults) ret.pop();
	//console.log('Var.search got '+ret.length+' results, goal='+goal);
	/*if(game.gobs.length > 0 && ret.length == 0){ //FIXME remove this
		lastGoalWhenEmpty = goal;
		lastGobsListWhenEmptying = [...(game.gobs)];
	}*/
	return ret;
};

//get best child by .p andOr .t/timeUpdated.
//
//Used with Ptr$varname or Lit$varname, whose childs compete to be the 1 current value of it.
//Similar to Ptrs$varname and Lits$varname but those have many (0 or more).
// Returns the best (most up-to-date and existing) child Var.
// Priority: highest .p (nonzero = exists), then highest .t (latest update).
// Returns null if there are no children or if all have .p <= 0.
//
//Ok i put this in Var.js. now use it in index.html. Call NS.CCP.Lit$20_30.best()
//to get null or the best/current value of a=20 s=30, and where NS.CCP.Lit$20_30.best()
//might return NS.CCP.Lit$20_30._n20_n12_8_n19_12_18 for example.
//
//This is the GET copared to child.setBest().
Var.prototype.best = function() {
	let best = null;
	let bestP = -Infinity;
	let bestT = -Infinity;

	for (const name in this.pu) {
		const child = this.pu[name];
		if (!child) continue;

		if (child.p > bestP || (child.p === bestP && child.t > bestT)) {
			best = child;
			bestP = child.p;
			bestT = child.t;
		}
	}

	if (!best || best.p <= 0) return null;
	return best;
};

// Marks this Var as the current best (active) child among its siblings (this.up is parent).
// Clears all sibling .p values to 0, then sets this.p = 1 and updates this.t = time().
//Causes this.up.best()===this if called right after that, unless .p andOr .t etc changes certain ways.
Var.prototype.setBest = function(){
	const parent = this.up;
	if(!this.up) return; //root has no siblings
	
	// Deactivate all siblings
	for (const name in parent.pu) {
		const sib = parent.pu[name];
		if (sib && sib !== this) sib.p = 0; //TODO u might want to delete it also but not from this setBest func. See .e (vs .p)
	}

	// Activate this one
	this.p = 1;
	this.t = TimeId();
};

//FIXME rename centerY and centerX in existing game content to Y and X, like game.Y and game.X TODO game.Y and game.X.
//if its on the line, is not included. Has to be less than r distance. This is cuz sorts by a relative distance, and 0 must not be included.
Var.prototype.searchZYXR = function(z, y, x, r, maxResults){
	if(r === undefined) r = DefaultRadiusResults;
	//const rr = r*r;
	return this.search(
		vr=>{
			//return rr - ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
			let distSq = (vr.z()-z)**2 + (vr.y()-y)**2 + (vr.x()-x)**2;
			let dist = Math.sqrt(distSq);
			return dist;
			
			
			
			
			
			
			
			
			
			
			
			
			
			//FIXME this isnt cutting it off (by being 0 or less) at r aka radius.
			
			
			
			
			
			
			
			
			
			
			
			//let d = rr - ((vr.z()-z)**2 + (vr.y()-y)**2 + (vr.x()-x)**2);
			//return d;
			//return -d;
		},
		maxResults);
};

//makes a new goal that also	requires it be within r distance of (y,x) (not on the line).
Var.prototype.searchYXRGoal = function(y, x, r, goal, maxResults){
	const rr = r*r;
	return this.search(vr=>{
		//let isNear = rr > ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		//in case [the Var whose Var.ob is a QuadTile] doesnt have Y and X child Vars,
		//since its implied by the first number in Var.big in that case (see SquareY and SquareX funcs and tileSize).
		//See Var.constY and Var.constX which Var.y() and Var.x() use if they exist.
		let isNear = rr > ((vr.y()-y)**2 + (vr.x()-x)**2);
		if(!isNear) return 0;
		return goal(vr);
	}, maxResults);
};

Var.prototype.if0 = function(newP){
	if(!this.p) this.p = newP;
	return this;
};

Var.prototype.setNow = function(newP, optionalNewV){
	this.p = newP;
	if(optionalNewV !== undefined) this.v = optionalNewV;
	return this;
};

Var.prototype.setPr = function(optionalPr){ //spring target this.p. If you dont give optionalPr its this.p the current position.
	this.pr = optionalPr!==undefined ? optionalPr : this.p;
	return this;
};

Var.prototype.setPs = function(ps){ //spring strength of this.p toward this.pr
	this.ps = ps;
	return this;
};



Var.prototype.setSpring = function(ps, optionalPr){
	this.ps = ps;
	this.pr
	this.pr = pr;
};

//FIXME hashIdLen is not constant cuz they dont all have the same prefix.

//const hashIdLen = ('sha256$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
const hashIdLen = ('Gob$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
//
//FIXME theres gob$hash and tile9007199254595405$hash and tile9007199254595405$literalIfSmall,
//so should hashIdLen be renamed to minHashIdLen?

//TODO what should this limit be?
//If its longer	than this, auto hashes it and uses the hash (prefixed by what, in case it starts with a digit etc?)
//as the Var.name and the content hashed as the Var.big.
//so u can know if its a hash or not by its length. or could check for any chars then $ like sha256$thehash.
const MaxLiteralNameLen = hashIdLen-1;

const isLowercase = c=>(c >= 'a' && c <= 'z');

//Can the string be a Var literal path part? If not it goes in theVar.big and theVar.name is hash of that,
//with the prefix up to and including the first $ prefixing the hash, and if it has no $ it uses Gob$ .
//It is if first char is capital letter, its a valid js var name, and is short enuf.
var isVarLit = nameOrBig=>(
	nameOrBig.length <= MaxLiteralNameLen && /^[A-Z_$][a-zA-Z0-9_$]*$/.test(nameOrBig));

const MaxVarPathLen = 512; //including paths in paths, see isVarPath

/* A path part can contain another path as long as it starts with "v." or "ns." (such as v.Bellsack.Room5).
Does NOT check if the path exists, only its string syntax.
isVarPath('ns.Shapes.Sak$354hashofbell34234')
true
isVarPath('ns.Shapes.Sak$354hashofbell342 34')
false
isVarPath("ns.Odos.RatSnake5.Ghosts.DryBone20.Waves.Catapult9.Ptrs$fn['ns.Shapes.Sak$354hashofbell34234']")
true
isVarPath("ns.Odos.RatSnake5.Ghosts.DryBone20.Waves.Catapult9.Ptrs$fn['ns.Shapes.Sak$354hasho fbell34234']")
false

FIXME:
ns.Odos.Lone.Ghosts.Lone.Waves.WavyBell200.Ptrs$fn['v.Bellsack.Room1.Shape.Sak$NUrpaxxk7jDslEyguqyMLn4YUqCAC8gOIXmsf2DbzHB'].path()
'V.Bellsack.Room1.Odos.Lone.Ghosts.Lone.Waves.WavyBell200.Ptrs$fn.v.Bellsack.Room1.Shape.Sak$NUrpaxxk7jDslEyguqyMLn4YUqCAC8gOIXmsf2DbzHB'
should have made v.Bellsack.Room1.Shape.Sak$NUrpaxxk7jDslEyguqyMLn4YUqCAC8gOIXmsf2DbzHB display inline.
*/
var isVarPath = s => {
    if (s.length > MaxVarPathLen) return false;
    if (!(s.startsWith('ns.') || s.startsWith('v.'))) return false;

    // quick reject any whitespace
    if (/\s/.test(s)) return false;

    // reject any unescaped single-quote inside bracketed segments
    let inQuote = false, esc = false;
    for (let i = 0; i < s.length; i++){
        const c = s[i];
        if (esc)      { esc = false; continue; }
        if (c === '\\'){ esc = true;  continue; }
        if (c === '\''){ inQuote = !inQuote; continue; }
    }
    return !inQuote && !esc;   // balanced quotes & no trailing escape
};

//get or create child Var
Var.prototype.pU = function(nameOrBig){
	let ret;
	if(isVarLit(nameOrBig) || isVarPath(nameOrBig)){ //isVarLit already verifies isLowercase(nameOrBig[0])
		ret = this.pu[nameOrBig] || new Var(this, nameOrBig, null, this.ob||null); //auto puts it in this.pu[string]
	}else{
		if(isLowercase(nameOrBig[0])){
			Err('This often happens when you try to add a new function or field to the Var class at runtime. Put it in Var.prototype or in the Var constructor this.theField = null; or = undefined; so the Proxy (prototype of prototype of each Var instance) is not touched. One prototype deep is where you put class functions. Child Vars cant start with lowercase letter, such as toString p v or you gave: '+nameOrBig);
		}
		//let hash = hashStringToHex(nameOrBig);
		let name = hashStringToBase64(nameOrBig); //todo dont hash if its small enuf to be a literal id (dont use .big)
		/*if(nameOrBig.startsWith('mutid$')){ //FIXME 2025-1-9 removed the mutid$ prefix of tiles, so am not using it for anything.
			let i = nameOrBig.indexOf('$','mutid$'.length);
			if(i!=-1){ //found next $ like in mutid$tile3534523423$...
				name = nameOrBig.substring(i+1)+name; //mutid$tile3534523423$234324hash345345
			}else Err('no second $ found in mutid$...');
		*/
		//TODO this is likely blobMonstersGame Gob code not relevant to bellsack:
		
		
		/*too specific to Blob Monsters Game. TODO make plugin system for Var.eval() etc.
		
		if(nameOrBig.startsWith('tile')){ //like tile1971583262467328$ then base64 of its Quad bytes, if small, else then base64 of hash of that.
			if(isValidVarName(nameOrBig) && nameOrBig.length < 64){
				//considering size of tile1971583262467328$ (size 21) and 43 digits of sha256 base64 (21+43==64),
				//if its smaller then use it directly, else hash it.
				//isValidVarName might let vars be bigger like 100, but i havent used it much and am experimenting. Might need those bigger vars.
				name = nameOrBig;
			}else{ //FIXME this isnt running for nontiles, like anyPrefixblahblah4325$stufftohash
				let i = nameOrBig.indexOf('$');
				if(i == -1) Err('No $ after tile in var name');
				let prefix = nameOrBig.substring(0,i+1); //like tile1971583262467328$
				name = prefix+name; //like tile1971583262467328$thenbase64ofsha256ofdotbig
				
				//example:
				//tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF is the name of big:	//tile1971585409951104$qjB$pzN$oUR$$$2GwV$$$Bo$$$28$$$$lF$$$3k$pUg$oz$$oUc$nRJ$$$0BIBJ$I3lBIBZ$lF$$$3k$I3k$oUAClF$$$3lBlF0B$3lBI3lB$CArnF28$$$$lF$$$3k$$3k$oUQ8I3n4I3k$I3lBmRJ$I$0BI$0BI$2HyF2Hx$2Gzk2GygZ$lJlB$3k$$3k$nRJ$I$0BI$24I3k$I$$$$$$$$$
			}
			//TODO generate this.Y.p and this.X.p to be derived from SquareY and SquareX of 1971585409951104 like in tile1971585409951104$,
			//but dont let them change and dont spend time computing what if they change during physics. Tiles are constants.
			
			//My 128x128 game tiles have hash ids like this. The first number tells a power
			//of 2x2 size, y, and x: tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
			//Then 43 base64 digits of sha256 of the quadtree compressed content, which is normally a few hundred bytes.
		}else{
			//name = 'sha256$'+name; //no special prefixing
			name = 'Gob$'+name; //no special prefixing
		}*/
		
		let i = nameOrBig.indexOf('$');
		if(i == -1){
			name = 'Gob$'+name; //default prefix
		}else{
			//use same prefix from nameOrBig whatevers up to and including the first $ if exists 
			name = nameOrBig.substring(0,i+1)+name;
		}
		
		//ret = this.pu[name] || new Var(this, name, nameOrBig, this.gob||null); //auto puts it in this.pu[string]
		ret = this.pu[name] || new Var(this, name, nameOrBig, this.ob||null); //auto puts it in this.pu[string]
	}
	/*TODO this is likely blobMonstersGame Gob code not relevant to bellsack:
	if(ret.big && ret.big.startsWith('(')){ //likely a js function string
		let listOfLists = getParamNames(ret.big);
		if(listOfLists.length){
			ret.vars = []; //same order as in gob.vars, a list instead of the .pu {} of paramName to Var. Vars either way.
			for(let list of listOfLists){
				let paramName = list[0]; //TODO if theres more stuff in it, do whats normally done after getParamNames, fill in .p .v .epsilon andOr .accelMul etc.
				ret.vars.push(ret.pU(paramName));
			}
		}
	}*/
	return ret;
};

/*specific to Blob Monsters Game, shoulnt be part of Var*.js:
Var.prototype.think = function(){
	let brain = this.brain || (this.brain = eval(this.big || this.name));
	//no this is done in Gob.think: this.extraThink(); //do game.gravY.p etc.
	return brain(...(this.vars)); //list or Int32Array of int voxels. See YXC IY IX YXRGB etc funcs for int voxels.
};*/

const varProxyHandler = {
	/*get(target, prop, receiver){ //works 2025-7-4
		if(typeof(prop) === 'symbol'){
			return Reflect.get(target, prop, receiver);
		}
		return target[prop] || receiver.pU(prop);
	},*/
	//2025-7-5 moving varProxyHandler to be prototype of prototype of each Var instance, so .toString etc stay in its prototype.
	//If a childName is not found, creates it in thisVar.childName and in thisVar.pu.childName which point at the same Var,
	//so thisVar.pu.childName doesnt create it and theres some syntax thisVar.pu.?childName maybe, that can chain it get undefined at end.
	get(target, prop, receiver){
		if(typeof(prop) === 'symbol'){
			return Reflect.get(target, prop, receiver);
		}
		//return target[prop] || receiver.pU(prop);
		/*GPT-o3 says why change receiver.pU(prop) to target.pU.call(receiver, prop)
		-	 const child = target.Pu.call(receiver, prop);
		+	 const child = target.pU.call(receiver, prop);
			return child;
		}
		❓ Why not receiver.pU(prop)?
		When the instance (receiver) looks for pU, it doesn’t have an
		own-property, so the engine would walk up the prototype chain:
		VarPrototype → VarProxy → …
		That walk would re-enter the same proxy trap we’re executing right
		now, leading to an extra hop (and, in some cases, an infinite loop
		if guards were missing).

		By calling target.pU.call(receiver, …) we:

		grab the already-known method reference directly from the
		plain object that is the proxy’s target (VarPrototype),

		bind this to the real instance (receiver),

		avoid any second trip through the proxy machinery.

		This keeps the “first-touch” cost to one proxy invocation and guarantees
		that all subsequent property reads hit the freshly cached
		this[childName] own-property at plain-object speed.
		*/
		//return target[prop] || target.pU.call(receiver,prop);
		
		//Prototype-owned props (pU, path, toString, …)
		//if(prop in target){
		//	return target[prop];
		//}
		//Prototype-owned methods (pU, path, toString, …)
		//if(prop in Var.prototype){
		//	return Var.prototype[prop];
		//}
		
		
		/*//Already-materialised child (own-prop on the instance)
		const cached = Reflect.get(receiver, prop, receiver);
		if(cached !== undefined){
			return cached;
		}
		that caused infinite loop
		V.hello
		bellsack161.html:2384 Uncaught RangeError: Maximum call stack size exceeded
		at Reflect.get (<anonymous>)
		at Object.get (bellsack161.html:2384:26)
		at Reflect.get (<anonymous>)
		at Object.get (bellsack161.html:2384:26)
			Here’s the one-line fix that stops the infinite recursion.
		(Only the get trap is touched.)

		diff
		Copy
		Edit
		@@
		-		//Already-materialised child (own-prop on the instance)
		-		const cached = Reflect.get(receiver, prop, receiver);
		-		if(cached !== undefined){
		-			return cached;
		-		}
		+		//Already-materialised child (own-prop on the *instance*) – check without climbing the
		+		//prototype chain so we don’t re-enter this proxy trap.
		+		if (Object.prototype.hasOwnProperty.call(receiver, prop)) {
		+			return receiver[prop];
		+		}
		*/
		//Already-materialised child (own-prop on the *instance*) – check without climbing the
		//prototype chain so we don’t re-enter this proxy trap.
		if(Object.prototype.hasOwnProperty.call(receiver, prop)){
			return receiver[prop];
		}
		
		//First-touch child: create & cache via pU
		//return target.pU.call(receiver, prop);
		//First-touch child — use receiver.pU; the lookup
		//resolves on Var.prototype and never re-enters the proxy.
		return receiver.pU(prop);
	},
};

//Var.prototype = new Proxy(Var.prototype, varProxyHandler);
const VarProxy	 = new Proxy(Object.create(null), varProxyHandler);
Object.setPrototypeOf(Var.prototype, VarProxy); //2025-7-5 changing from Var being a Proxy to "instance → proto → proxy".


//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p is probably more efficient.
	return this.p;
};

var singleQuoteEscape = str=>{ //FIXME this has been appearing in anyVar.path() cuz of the syntax change, now is 2025-11-13
	return "'FIXMEESCAPE_"+str+"'";
};

//if doAbbrev, then if the path is the current ns (such as v.Bellsack.Room5) returns 'ns', else full path.
Var.prototype.path = function(doAbbrev){
	if(!this.path_){
		//return this.up ? this.up.path()+'.'+this.name : this.name;
		if(!this.up){
			this.path_ = this.name; //likely is 'v' the root, or previously (before 2025-10-30) was 'V'.
		}else if(doAbbrev && (this == ns)){
			this.path_ = 'ns';
		}else{
			let upPath = this.up.path(doAbbrev);
			if(isVarPath(this.name)){
				this.path_ = upPath+'.'+this.name;
			}else{
				this.path_ = upPath+'['+singleQuoteEscape(this.name)+']';
			}
		}
	}
	return this.path_;
};

Var.prototype.toString = function(){
	return this.path();//return this.up ? this.up.toString()+'.'+this.name : this.name;
	//return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

console.error('TODO this VarVM.next should be called instead of lamglLoopBody andOr VarGradientGL etc calling nextState on specificly the Vars it modified (ball states, bell5 states, etc), and do move opt={} into ns.Opt. The rule is, as in Var.makeDirty(), a Var is dirty if it has nonzero .v or has been modified, and nextState should be called on ALL Vars that are dirty. If it remains dirty after nextState(dt), such as its velocity has not yet run down by velocityDecay/kv/cv then it becomes dirty again and that happens again next cycle too. We wont have to directly call Var.touch() or the other 2 like it. VarVM.next Var.makeDirty Var.set .');
VarVM.next = function(dt){
	let list =  VarVM.dirtHead;				// capture current queue
	VarVM.dirtHead = null;					// new dirties start next list

	while(list){
		const d = list;						// current Var
		list     = d.dirtNext;				// advance before we overwrite
		d.dirtNext = d;						// self-ref ⇒ clean / inactive

		/* 1 ─ heavy integrator (only place .p / .v change) */
		d.nextState(dt);					// may change d.v

		/* 2 ─ notify observers once */
		if(d.listeners){
			for(const fn of d.listeners) try{ fn(d); } catch(e){ console.error(e); }
		}

		/* 3 ─ still moving? schedule itself for next frame */
		if(d.v !== 0){						// uses the public API
			d.makeDirty();					// will be processed next VarVM.next
		}
	}
};

Var.prototype.nextState = function(dt){
	
	if(this.p != this.p){ //FIXME remove this, was added 2025-8-5 during isBallCacheOptimization cuz balls keep turning NaN after few seconds
		this.p = (Math.random()-0.5)*30;
		this.v = 0;
		console.log('Var.nextState ugly hack just changed NaN p to '+this.p+' and v to '+this.v);
	}
	
	
	if(dt){
		//use someVar.nextState(0) to clear someVar.kv someVar.dp etc, without modifying someVar.p or .v etc.
		//For use during gradient of things that might happen but have not decided to make them happen.
		
		//this.v = 0; //FIXME
		//let nextP = this.p + dt*(this.v+this.dp);
		if(this.ps){ //spring strength is nonzero. TODO fix blobMonstersGame it has if(this.pr) should be ps.
			//this.gr += TODO something about this.pr and this.ps as parabola.
			//let positionDiff = this.pr-this.p; //FIXME is this backward? accel negative gradient
			let positionDiff = this.p-this.pr;
			let partOfGradientFromParabola = positionDiff*this.ps; //TODO divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ??? todo check calculus and would it break old game content.
			//let partOfGradientFromParabola = positionDiff/2*this.ps; //TODO verify this /2 is correct (vs /4 or *2 or sqrt2, etc, or just leave it as is): divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ???
			this.gr += partOfGradientFromParabola; //FIXME? this could be done as loss/poten/potentialEnergy instead of gr/gradient, but that would make it depend on perturbing multiple world states which might involve this Var in things outside this Var, so gr/gradient is maybe the best way to do it.
			//this.poten += this.ps*positionDiff*positionDiff;
		}
		/*if(Var.opt.oneBitPerDimGradient){ //FIXME this is outside the Var script, is part of Bellsack script, so shouldnt be here.
			if(this.gr < 0) this.gr = -Var.opt.oneBitPerDimGradientVal;
			if(this.gr > 0) this.gr = Var.opt.oneBitPerDimGradientVal;
			//3 possible values
		}*/
		let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);
		if(this.mn <= this.mx){
			nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
		}
		let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
		//let nextV = 0; //FIXME
		
		
		//let changePAmount = Math.abs(this.p-nextP);
		//if(changePAmount > 100 && this.ob==cShapedGob){ //FIXME remove this
		//	console.log('Var '+this.path()+' changePAmount='+changePAmount);
		//}
		
		this.p = nextP;
		this.v = nextV;
	}
	//this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.kv = this.cv; //cv is base kv. velocity decay per second continuously.
	this.dp = this.dv = this.poten = 0; //OLD: leave this.gr as is, since its not a sum, is just set all at once in one of the doPhysics funcs.
	this.prevGr = this.gr; //for debugging. has no effect on physics. previous gradient.
	this.gr = 0; //cuz in blobMonstersGame gr was set in doPhysicsA, but here we dont have that func.
	this.mn = -Infinity;
	this.mx = Infinity;
	//leave this.pr and this.ps (spring) as they are, which are inputs only, not moved by gradient.
	
	//If you change this.dp dv kv mn mx etc, call this.makeDirty() to schedule it for events as in aVar.listen(listener).
};

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = funcOrStr=>{
	const fnStr = funcOrStr.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
		.map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
	return params.map(match => {
		const [_, name, comment] = match;
		const numbers = comment ? comment.match(/\d+/g) : [];
		return [name, ...(numbers || []).map(Number)];
	});
};

Var.prototype.setOb = function(gobOrGame){
	this.ob = gobOrGame;
	return this;
};




//Example fields 'p' 'v' 'kv' 'dp' 'dv' 'mn' 'mx'. someVar.fieldGetter('p')() returns someVar.p
Var.prototype.fieldGetter = function(field){
	const thisVar = this;
	return ()=>(thisVar[field]);
};

//Example fields 'p' 'v' 'kv' 'dp' 'dv' 'mn' 'mx'.
//someVar.fieldSetter('p')(someVar.fieldGetter('p')()+1) increments someVar.p
Var.prototype.fieldSetter = function(field){
	//FIXME throw if field starts with a capital letter cuz thats child
	const thisVar = this;
	return val=>(thisVar[field] = val);
};

/*This makes (the next version of todo) the editor at the top left appear with input type=range sliders
of the selected Gob, in the selectedGobVarsDiv_table code, similar to this:
V.testnet.gob$Zxbv95B$dT3MVDu7Akt8PZNHAMeB4ZwNeats2TeDchR
Var.name												 .p																.pr	.ps	.cv
Y	min=0 max=16777215
74972.52934667701
min=0 max=16777215
0	min=0 max=100
0	min=0 max=3
0
X	min=0 max=16777215
75182.65197622102
min=0 max=16777215
0	min=0 max=100
0	min=0 max=3
0
heightToWidthRatio	min=-5 max=5
0.9336636940953708	min=-5 max=5
0	min=0 max=100
0	min=0 max=3
0
make a new SigmoidNumEditor of that field in this Var such as to edit thisVar.cv or thisVar.p.
Theres some arbitrary interpretation involved in which var names (Y and X especially) get scaled how much
in the display of the editor, how much of the range of the slidebar (input type=range) means which number ranges,
but if you call fieldEditor again later it will use updated Var values to give you a more relevant editor.
*/
Var.prototype.fieldEditor = function(field, isForMenu){
	//the first 2 params of every gob.brain func should be Y and X which range 0 to 0xffffff.
	let isYX = this.name=='Y' || this.name=='X';
	let add = 0;
	let mul = 1;
	let hardMin = -(2**30);
	let hardMax = 2**30;
	if(field == 'name'){ //string name so uses a StringViewer instead of a SigmoidNumEditor. Its just for displaying the string in the table.
		return new StringViewer(this.name);
	}else if(field == 'path'){ //string name so uses a StringViewer instead of a SigmoidNumEditor. Its just for displaying the string in the table.
		return new StringViewer(this.path());
	}else if(field == 'p'){ //position
		if(isYX){
			add = this.p|0;
			mul = 300; //FIXME?
			hardMin = 0;
			hardMax = 0xffffff;
		}else if(this.name=='gravY'){ //FIXME put these default ranges (how big does slider movement mean?) somewhere else
			add = 0; //FIXME?
			mul = 100; //FIXME?
			hardMin = -1000;
			hardMax = 1000;
		}else if(this.name=='DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = .002; //FIXME?
			hardMin = 0;
			hardMax = .02;
		}else if(this.name=='AddToDensityForTesting'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = .01; //FIXME?
			hardMin = -.1;
			hardMax = .1;
		}else if(this.name=='SignedDistanceNewtonIterations'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = 40; //FIXME?
			hardMin = 2;
			hardMax = 256;
		}else if(this.name=='SignedDistanceSpeed'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = .2; //FIXME?
			hardMin = 0;
			hardMax = 1;
		}else if(this.name=='DensityOfSlightAttractToVec3_mul'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = .15; //FIXME?
			hardMin = 0;
			hardMax = .5;
		}else if(this.name=='Display3dLocalMinsOfGradientMagLessThan'){
			//FIXME stop hard-coding these slider ranges. find a standard place to put it outside Var*.js
			add = 0; //FIXME?
			mul = .05; //FIXME?
			hardMin = 0;
			hardMax = .2;
		}else{
			/*//TODO should i remove is and do since those start with lowercase?
			//Var childs must start Capital, but its not just for childs.
			if((field.startsWith('is')||field.startsWith('Is') || field.startsWith('do')||field.startsWith('Do')) && (this.p===0 || this.p===1)){
				return new CheckboxVarEditor(this); //like for V.testnet.game.doRps
			}*/
			if((this.name.startsWith('Is') || this.name.startsWith('Do')) && (this.p===0 || this.p===1)){
				return new CheckboxVarEditor(this); //like for v.Bellsack.Room5.Opt.IsGraphicsDebug.p
			}
			//add = this.p;
			add = 0; //FIXME?
			mul = 10; //FIXME?
			hardMin = -100;
			hardMax = 100;
		}
	}else if(field == 'v'){ //velocity
		add = 0;
		if(isYX){
			mul = 100; //FIXME?
		}else{
			mul = 10; //FIXME?
		}
		hardMin = -1000; //FIXME?
		hardMax = 1000; //FIXME?
	}else if(field == 'pr'){ //target position, that a simulated spring pushes toward
		if(isYX){
			add = this.p|0;
			mul = 500; //FIXME?
			hardMin = 0;
			hardMax = 0xffffff;
		}else{
			add = this.p;
			mul = 10; //FIXME?
			hardMin = -100; //FIXME
			hardMax = 100; //FIXME
		}
	}else if(field == 'ps'){ //strength of the pr spring
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else if(field == 'cv'){ //bases velocity decay
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else if(field == 'kv'){ //dynamic velocity decay, that in Var.nextState is reset to Var.cv
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else{
		ave = 0; //FIXME?
		mul = 10; //FIXME?
		hardMin = -100;
		hardMax = 100;
	}
	//FIXME its not using hardMin or hardMax
	let getter = this.fieldGetter(field);
	let setter = this.fieldSetter(field,isForMenu); //FIXME does fieldSetter even take 2 params?
	const numEditor = new NumEditor(getter, setter);
	const sigmoidNumEditor = new SigmoidNumEditor(numEditor, add, mul);
	sigmoidNumEditor.labelPrefix = this.name; //not this.path() that would be too long, but TODO make the dom display that on hover in a title
	//FIXME throws "Have no dom" if do this early. Doing in SigmoidNumEditor.prototype.putInDom = function(dom) instead. sigmoidNumEditor.updateDom(); //cuz changed labelPrefix. Dont wait for user to change the slider (input type=range). Update it now.
	/*let extraSetterEvent = ()=>{
		//sigmoidNumEditor.
	};
	if(isForMenu){
		const innerSetter = this.fieldSetter(field);
		setter = val=>{
			innerSetter(val);
			console.error('TODO innerSetter');
			//throw new Error('TODO');
		};
	}else{
		setter = this.fieldSetter(field);
	}
	return new SigmoidNumEditor(new NumEditor(getter, setter), add, mul);
	*/
	return sigmoidNumEditor;
};

//returns a list of them which normally goes in VarEditors which is a list of lists of editors
//which exists in Blob Monsters Game 2025-11-13 but not in Bellsack. might bring in that code
//to display a 2d grid of these editors of some list of Vars you select or search for.
Var.prototype.fieldEditors = function(){
	return [
		//FIXME theres no "game.isDisplayFullVarNamesInTable" in bellsack. but dont want to
		//break compatibility. check if it exists anyways, but dont assume the 'game' var
		//even exists. we would do that as ns.Opt.NameOfOption.p in bellsack.
		this.fieldEditor(game.isDisplayFullVarNamesInTable.p ? 'path' : 'name'),
		
		this.fieldEditor('v',false), //false not isForMenu, cuz is for the 2d grid on the bottom right controlled by "vars" checkbox.
		this.fieldEditor('p',false),
		this.fieldEditor('pr',false),
		this.fieldEditor('ps',false),
		this.fieldEditor('cv',false),
	];
};

//var LogScale = function(mul){
//	this.mul = mul;
//};
//LogScale.prototype.forward = function(val){
//	//FIXME how do i get it into range 0 to 1? Just use sigmoid? Use tanh for range -1 to 1?
//	return this.mul*Math.log(val);
//};

//set(get()+1) increments the val, for example.
var NumEditor = function(get, set){
	this.get = get;
	this.set = set;
};

//wrapMe is a NumEditor such as wrapping a raw Var.ps or Var.p or Var.kv
var SigmoidNumEditor = function(wrapMe, optionalAdd, optionalMul, optionalMin, optionalMax){
	//FIXME put in event to unlisten in Var, and set slider state, similar to
	//how CheckboxVarEditor did it, cuz I changed ns.Opt.SignedDistanceNewtonIterations .
	this.add = optionalAdd || 0;
	this.mul = optionalMul || 1;
	this.min = optionalMin || (-(2**30));
	this.max = optionalMax || (2**30);
	this.wrapMe = wrapMe;
};

const sigmoid = x=>(1/(1+Math.exp(-x)));

const inverseSigmoid = x=>{
	x = Math.max(0, Math.min(x, 1)); //so outside that range its -Infinity or Infinity, instead of NaN
	return Math.log(x/(1-x));
};

SigmoidNumEditor.prototype.get = function(){
	//return sigmoid(this.add+this.mul*this.wrapMe.get());
	return sigmoid((this.wrapMe.get()-this.add)/this.mul);
};

SigmoidNumEditor.prototype.set = function(val){
	//this.wrapMe.set((inverseSigmoid(val)-this.add)/this.mul);
	//this.wrapMe.set(inverseSigmoid(val+this.add)*this.mul);
	this.wrapMe.set(Math.max(this.min, Math.min(this.add+this.mul*inverseSigmoid(val), this.max)));
	//console.log('SigmoidNumEditor set '+val);
	this.updateDom(); //needed to update the label under the slider when its in the menu
};

SigmoidNumEditor.prototype.updateDom = function(){
	if(!this.dom){
		Err('Have no dom');
	}
	let slider = document.getElementById(this.idPrefix+'_slider');
	let label = document.getElementById(this.idPrefix+'_label');
	let newVal = this.get();
	if(newVal != slider.valueAsNumber){ //less dom events, only if changed, cuz might interfere with mouse drag events of the slider
		//FIXME 2025-3-7 this is not updating the label in NS.game.gravY.fieldEditor('p'), which is the first time
		//I used a SigmoidNumEditor outside the grid menu on the bottom right of screen (that "vars" checkbox displays or not),
		//and that grid has its own update loop that runs once per video frame. Menu checkboxes and menu sliders
		//are a separate event system, so we probably need to make new event in SigmoidNumEditor.prototype.set
		//but without creating duplicate events in the grid sliders.
		slider.valueAsNumber = newVal;
		//label.textContent = this.wrapMe.get();
	}
	let correctLabelText = ''+this.wrapMe.get();
	if(this.labelPrefix) correctLabelText = this.labelPrefix+' '+correctLabelText;
	if(label.textContent != correctLabelText){ //avoid slow dom event if didnt change
		label.textContent = correctLabelText;
	}
};

var NextIdNum = 1000;

SigmoidNumEditor.prototype.putInDom = function(dom){
	if(this.dom){
		this.dom.innerHTML = ''; //clear previous
		this.dom = null;
	}
	const thisEditor = this;
	this.idPrefix = 'sigmoidNumEditor_'+(NextIdNum++);
	let s = '';
	
	s += '<font color=gray>add='+this.add+' mul='+this.mul+'</font><br>';
	s += '<input type=range id='+this.idPrefix+'_slider min=0, max=1 step=.001></input><br>';
	s += '<label id='+this.idPrefix+'_label value='+this.wrapMe.get()+'></input><br>';
	
	/*
	for(let i=0; i<selectedGob.vars.length; i++){
		let v = selectedGob.vars[i];
		for(let field of fields){
			let slider = document.getElementById('slider_'+v.name+'_'+field);
			//dont mod dom nodes, which causes event problems if mouse is acting on it, unless it actually changed
			let changed = slider.valueAsNumber != v[field];
			if(changed){
				slider.valueAsNumber = v[field];
			}
			let isBigDim = (v.name == 'Y' || v.name == 'X') && field=='p';
			if(!isBigDim){
				//if(changed){
					let label = document.getElementById('label_'+v.name+'_'+field);
					//label.innerHTML = ''+v[field];
					label.textContent = ''+v[field];
				//}
			}
		}
	}
	*/
	
	
	//dom.innerHTML = 'SigmoidNumEditor, add='+this.add+' mul='+this.mul; //FIXME
	dom.innerHTML = s;
	
	let slider = document.getElementById(this.idPrefix+'_slider');
	slider.addEventListener('input', function(){
		let val = this.valueAsNumber;
		//let prevVal = v[field];
		//v[field] = val;
		let prevVal = thisEditor.get();
		thisEditor.set(val);
		//console.log('Set '+v.path()+'.'+field+' from '+prevVal+' to '+val);
		console.log('SigmoidNumEditor changed from '+prevVal+' to '+val);
	});
	
	this.dom = dom;
	this.updateDom();
};

//like SigmoidNumEditor but made for viewing its string Var.name. Goes in VarEditors (list of lists of editor).
var StringViewer = function(str){
	this.str = str;
};

StringViewer.prototype.putInDom = function(dom){
	dom.innerHTML = this.str;
	this.dom = dom;
};

StringViewer.prototype.updateDom = function(){
	//do nothing. updateDom is just here for compatibility with SigmoidNumEditor
};

//for Var's whose value is 0 or 1, like V.testnet.game.doRps turns Rock Paper Scissors mode on/off.
//Puts a checkbox on screen that mods that var.p when clicked and updates itself on screen if Var changes
//after polling using this.updateDom();
var CheckboxVarEditor = function(theVar, optionalText){
	this.bo = theVar; //bo is opposite spelling of ob (object). object.bo gets Var. Var.ob gets object.
	//this.text = optionalText || theVar.path();
	this.text = optionalText || theVar.name;
};

/*var onDomDeleted = (domNode,callback)=>{
	if(!domNode.isConnected){
		callback();
		return;
	}
	//Choose a stable ancestor to observe
	let parent = domNode.parentNode || document;

	const obs = new MutationObserver(()=>{
		// If the node is no longer connected, it has left the DOM tree
		if(!domNode.isConnected){
			obs.disconnect();
			console.log('onDomDeleted calling callback='+callback);
			callback();
		}
	});

	obs.observe(parent, {
		childList: true,
		subtree: true
	});
	//FIXME when to this.bo.unlisten(varListener)? js doesnt have garbage collection (of this editor) listener.
	//Could check inside varListener (when the event happens) is dom/this.bo in the dom tree, and if not, then remove the listener.
	//That could happen cuz of dom.innerHTML = ''; called externally.
	/*TODO try this from gpt5.1
	function onRemovedFromDomTree(domNode, callback){
		// If it's already gone, fire immediately
		if(!domNode.isConnected){
			callback();
			return;
		}

		// Choose a stable ancestor to observe
		let parent = domNode.parentNode || document;

		const obs = new MutationObserver(()=>{
			// If the node is no longer connected, it has left the DOM tree
			if(!domNode.isConnected){
				obs.disconnect();
				callback();
			}
		});

		obs.observe(parent, {
			childList: true,
			subtree: true
		});
	}*
};*/

var addOnDomDeleted = function(node,callback){ //adds event listener
	if(!node)return;
	if(!node.isConnected){
		callback();
		return;
	}
	if(!addOnDomDeleted.list){
		addOnDomDeleted.list=[];
		addOnDomDeleted.obs=new MutationObserver(()=>{
			let a=addOnDomDeleted.list;
			for(let i=a.length-1;i>=0;--i){
				let o=a[i];
				if(!o.node.isConnected){
					a.splice(i,1);
					o.callback();
				}
			}
		});
		addOnDomDeleted.obs.observe(document,{childList:true,subtree:true});
	}
	addOnDomDeleted.list.push({node,callback});
};

CheckboxVarEditor.prototype.putInDom = function(dom){
	const thisEditor = this;
	this.idPrefix = 'checkboxVarEditor_'+(NextIdNum++);
	let firstVal = !!this.bo.p;
	let s = '<input type=checkbox id='+this.idPrefix+'_chk '+(firstVal?'checked':'')+'></input><label for='+this.idPrefix+'_chk title="'+thisEditor.bo.path()+'">'+this.text+'</label>';
	dom.innerHTML = s;
	this.dom = dom;
	const chk = document.getElementById(this.idPrefix+'_chk');
	let domListener = function(){
		thisEditor.bo.p = chk.checked ? 1 : 0;
		console.log('CheckboxVarEditor '+thisEditor.bo.path()+'.p = '+thisEditor.bo.p);
	};
	chk.addEventListener('input', domListener);
	let varListener = (anc,me,map)=>{ //this.bo is the Var edited. This code runs when the Var changes or sometimes when it didnt change.
		console.log('CheckboxVarEditor listener, me='+me.path()+' me.p='+me.p);
		//happens on its own when checkbox changes checked/unchecked: domListener();
		chk.checked = !!me.p; //p is 0 for unchecked, 1 for checked. other values like .3 or -19 count as checked.
	};
	this.bo.listen(varListener);
	addOnDomDeleted(chk, function(){
		thisEditor.bo.unlisten(varListener);
	}); //in case dom.innerHTML = '';
};

CheckboxVarEditor.prototype.updateDom = function(){
	if(!this.dom){
		Err('Have no dom');
	}
	let chk = document.getElementById(this.idPrefix+'_chk');
	let newVal = !!this.bo.p;
	if(chk.checked !== newVal){ //avoid slow dom event if value didnt change
		chk.checked = newVal;
	}
};

CheckboxVarEditor.prototype.deleteDom = StringViewer.prototype.deleteDom = SigmoidNumEditor.prototype.deleteDom = function(){
	if(this.dom){
		this.dom.innerHTML = '';
		delete this.dom;
	}
};







//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

//this uses js digits. i prefer dvBase64Digits cuz they are all valid in js var names and are in ascending order.
//dagball.bytesToBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

//bytesToBase64 = bytes=>jsBase64ToDvBase64(btoa(String.fromCharCode.apply(null, bytes))); //returns string


//use this one cuz its sorted by utf8 and ascii except = padding
const dvBase64Digits = '$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz=';
//This is whats made by javascript atob and btoa funcs. This one is only used internally for atob and btoa
const jsBase64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var bytesToJsBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

var jsBase64ToBytes = base64=>{ //returns Uint8Array
	const binaryString = atob(base64);
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
};

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

//dvBase64Digits and Uint8Array
var base64ToBytes = function(base64){
	return jsBase64ToBytes(dvBase64ToJsBase64(base64));
};
	
//dvBase64Digits and Uint8Array
var bytesToBase64 = function(bytes){
	return jsBase64ToDvBase64(bytesToJsBase64(bytes));
};

var digitJsToDv = {}; //transforms between 2 sets of base64 digits
var digitDvToJs = {};
for(let i=0; i<65; i++){ //last digit is = for padding, but dv base64 doesnt use it. js base64 does.
	let jsDigit = jsBase64Digits[i];
	let dvDigit = dvBase64Digits[i];
	digitJsToDv[jsDigit] = dvDigit;
	digitDvToJs[dvDigit] = jsDigit;
}

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

var dvBase64ToJsBase64 = function(dvBase64){
	let s = ''; //TODO char array or something is faster?
	for(let i=0; i<dvBase64.length; i++){
		s += digitDvToJs[dvBase64[i]];
	}
	while(s.length&3){ //while not a multiple of 4
		s += '='; //pad
	}
	return s;
};

var testBase64ToFromBytes = ()=>{
	let listOfByteArrays = [Uint8Array.of(2,3,17,255,254,3,3,2,171,170,199),Uint8Array.of(10),Uint8Array.of(),Uint8Array.of(1,2,3,4),Uint8Array.of(1,2,3,4,5),Uint8Array.of(1,2,3,4,5,6),Uint8Array.of(1,2,3,4,5,6,7)];
	for(let testNum=0; testNum<listOfByteArrays.length; testNum++){
		let bytes = listOfByteArrays[testNum];
		let b64 = bytesToBase64(bytes);
		let bytesRebuilt = base64ToBytes(b64);
		if(bytes.length != bytesRebuilt.length) Err('bytesRebuilt different len');
		for(let i=0; i<bytes.length; i++) if(bytes[i] != bytesRebuilt[i]) Err('bytes[i] != bytesRebuilt[i] i='+i);
		console.log('testBase64ToFromBytes_'+testNum+' test pass, bytes='+[...bytes].join(',')+' base64='+b64);
	}
};
testBase64ToFromBytes();

//TODO rewrite these comments:
//return 192 <= bytes[offset];
//return QFORK <= bytes[offset]; //QFORK is just below the line, of things above fork and things below dont. its an opcode to fork without knowing the length yet.
var byteHasChilds = byt=>(QFORK <= byt);
//var hasChilds = (bytes, offset)=>byteHasChilds(bytes[offset]);

var hashStringToHex = function(str){
	return bytesToHex(sha256(stringToBytes(str)));
};
var hashStringToBase64 = function(str){
	//return dagball.bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
	return bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
};
var utf8TextEncoder = new TextEncoder('utf-8');
var utf8TextDecoder = new TextDecoder('utf-8');
var stringToBytes = function(s){ return utf8TextEncoder.encode(s); };
var bytesToString = function(bytes){ return utf8TextDecoder.decode(bytes); };
var hexDigits = '0123456789abcdef'.split('');
var mapOfHexDigitToInt = {}; //vals are 0 to 15. filled in boot.
var mapOfDoubleHexDigitsToInt = {}; //vals are 0 to 255. filled in boot.
var bytesToHex = function(bytes){ return bytesAndRangeToHex(bytes,0,bytes.length); };
var doubleHexDigits = [];
for(let i=0; i<16; i++){
	mapOfHexDigitToInt[hexDigits[i]] = i;
	for(let j=0; j<16; j++){
		let hh = hexDigits[i]+hexDigits[j];
		doubleHexDigits.push(hh);
		mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
	}
};
var bytesAndRangeToHex = function(bytes,from,toExcl){
	let s = '';
	for(let i=from; i<toExcl; i++) s += doubleHexDigits[bytes[i]];
	return s;
};

//Var class was copied 2025-4-16 from blobMonstersGame_2025-3-27.html then modified TODO...
//blobMonstersGame used V.testnet. BellSack/LamGL will use V.bellsack.room1 or V.bellsack.makeUpARoomName etc,
//and V.htmls to put the html in,
//like v.htmls.sha256$9dda0dee909c8e96c82caf183cd938a1e07c23c9c79c06d5b53e626b36b54efc.big = '<html>...</html>' will load in iframe here,
//but only whichever of them has nonzero (or highest?) v.htmls.someHtml24353245.p.
//
//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
//const V = window.V = new Var(null, 'V'); //var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob)

const V = window.V = new Var(null, 'v'); //2025-10-30 renaming V to v as root. See 'ns.' and 'v.' prefixes in Var.prototype.path() and isVarLit and isVarPath.
console.log('Var.js, window.V.path() = '+window.V.path());

//FIXME 2025-9-5+ rename V to v (lowercase) in case a variable in Sak language is named "V", but those starting with a capital letter,
//as usual in the Var tree, are child Var's, and others (what about those that dont start with a letter at all?)
//are builtins like toString, length, p, v, mn, dp, dv, kv, etc.
//verlapping someVar.v, v meaning the root Var instance, never follows "." so is unambiguous in code strings.
//Just dont use local var "v" since its a keyword in Sak language. Might find a way not to clutter global namespace so much.

</script>
<script>
//VarUI*.js is opensource/Apache2 by Ben F Rayfield
//TODO continue this from https://chatgpt.com/g/g-p-67e3e1532ca08191983aad7a25c9c520-bellsack/c/68f6adc8-d6dc-8327-a7fb-f24dd1773489
/*
see those "SHOW:" checkboxes in left panel in bellsack*.html, I want one for the root VarUI aka VarUI(V).
I want this to appear on screen and actually work. It must go in its own script tag with a comment saying //VarUI*.js,
and it must not modify the Var*.js script but will depend on it. How do we get started?

lets go with, VarUI does NOT hold points to child VarUIs, so that a VarUI can only reach child VarUIs thru the Var tree,
so if those are deleted, no problem except it leaves the dom tree containing something thats not there in Var side,
and in that case it should just clear the div of that child. Var.name is immutable, so we can key by it without that
Var itself, so I want VarUI.cobs (child dom objects) to be separate from VarUI.dobs (main few dom objects).
VarUI.cobs[childName] is the div that child goes in.
*/

var VarUI = function(vr, selfDob){ //class VarUI, takes a Var and a html div (dob, Dom OBject).
	//normally contains Ptr$targ (best() child is the Var displayed by this VarUI)
	//and Ch (childs, .Ch.p is 1 to expand, 0 not to) and Vec (Sort, IsPtr, SelA/SelB selection, etc)
	this.vr = vr;
	
	/*this.dobs and naming the outermost one 'self' is how I did the UI tree in Wikibinator203DragAndDropTree.html:
	//map of string to dob (dom object).
	//TODO dobs for the 2 childs, prefix and suffix, etc.
	//TODO also include dobs for "include extra divs, normally empty, in every Splat, in every
	//possible place in that splat it could be dropped, including hidden splats".
	this.dobs = { //Wikibinator203DragAndDropTree.html
		self: selfDob,
	};
	*/
	this.dobs = { //VarUI*.js
		self: selfDob,
	};
};

//make a list of child VarUIs, in order of this.vr.Ch[childName].Var.Sort.p and return it as []. Nonbacking. Backed by V/Var tree.
//FIXME that doesnt necessarily match which VarUI's are created yet,
//since Var's themselves are a large data structure that VarUI's view parts of as needed.
VarUI.prototype.ch = function(){
	Todo();
};

console.log('TODO VarUI*.js, put it in the SHOW: list at top left, it goes right above the CODE textfield and textarea or may spawn its own text boxes i dont know.');

</script>
<script>
//TODO what to call this *.js
//TODO "in bellsack UI add the potentialEnergy(pixel)=(mass*mass/2) thing grok 2d game engine talk 2025-12-12"
</script>
<script>
//Sak*.js (which might get merged with Var*.js TODO?), opensource/Apache2 by Ben F Rayfield
//TODO Sak will be a programming language that mixes javascript and GLSL
//to GPU optimize in some cases with mat4 vec4 vec3 int float etc, thru Lamgl which Bellsack already uses.

const Sak = {

	//shared array for things like mulM4M4(int,int)=>int 2 pointers in 1 pointer out.
	flo: new Float32Array(1<<12), //TODO what size?
	
	//stack pointer into Sak.Flo
	sp: 0,
	
	//Example: Sak.falloc(16) returns a pointer into a new range size 16 in Sak.Flo, such as to put a mat4.
	//Use negative numFlos to pop.
	falloc: numFlos=>{
		const ret = Sak.sp;
		Sak.sp += numFlos;
		return ret;
	},

	//'Sak$2+3' => 'Sak$'. '2+3' => '';
	getPrefix: code=>{
		let i = code.indexOf('$');
		return i==-1 ? '' : code.substring(0,i+1);
	},
	
	//uses default prefix '$' if none found.
	getPrefixSafe: code=>{
		return Sak.getPrefix(code) || '$';
	},
	
	withoutPrefix: code=>{
		let i = code.indexOf('$');
		return i==-1 ? code : code.substring(i+1);
	},

	//caches in Sak.cacheJsEval the first time, so make sure this returns something reuseable
	//like a function or js {} from json if ur gonna call it twice.
	trySakEval: sakCode=>{
		//FIXME remove prefix like Sak$ andOr Js$
		let evaledTo = Sak.cacheSakEval[sakCode];
		if(evaledTo !== undefined){
			return evaledTo;
		}else{
			if(!Sak.allowSakCode(sakCode)){
				Err('Not Sak.allowSakCode of sakCode['+sakCode+']');
			}
			let js = Sak.transpileSakToJs(sakCode);
			return Sak.cacheSakEval[sakCode] = Sak.tryJsEval(js);
		}
	},
	
	//only the func part. must not have headers etc
	transpileSakToJs: sakCode=>{
		let js = Sak.withoutPrefix(sakCode);
		//fixme this would change xfloat to xlet. not tokenizing. did it the lazy way.
		js = js.replaceAll('float ','let ').replaceAll('int ','let ').replaceAll('mat4 ','let ')
			.replaceAll('mat3 ','let ').replaceAll('mat2 ','let ')
			.replaceAll('vec2 ','let ').replaceAll('vec3 ','let ').replaceAll('vec4 ','let ');
		//TODO need to change * between Mat4 and Vec4 to MulM4V4(theMat4,theVec4) and create MulM4V4 func etc.
		//TODO Lamgl optimize some parts especially someVar.potenNearPairs((thingA,thingB)=>{...}) and someVar.diffeqNearPairs
		//where in diffeq, it uses some vec4's as vec4(velocityX, velocityY, velocityZ, poten)
		//so its not just a density/poten field, it will have 3d velocity at each high dimensional point
		//so it can do things like spinning wheels, speed up pads, friction, etc,
		//though its hard to prove it doesnt create perpetual-motion-machines if we define surface velocity like that,
		//we will deal with that with velocity decay (var.kv) and by u dont have to use surface-velocity or friction in all objects.
		//As of 2025-9-4 Bellsack and Blob Monsters Game and Dagball, all 3 of those games dont have friction
		//cuz they just define a volume (or 2d area if its a 2d game) as an infinite set of points you can query for
		//but has no concept of those points moving. They simply exist or they dont in each possible cross-section.
		//Therefore I with poten only (not the other 3 numbers in the vec4) I can get velocity in normal-vector direction
		//from any point on its surface but not parallel/tangent velocity cuz it does not specify enuf information
		//to have a parallel/tangent velocity at all. Its not 0. Its not nonzero. Its just not a concept in the code yet.
		return js;
	},
	
	// only the func part. must not have headers etc
	transpileSakFnCodeToGlsl: sakFnCode => {
		let glsl = sakFnCode;

		glsl = glsl
			// replace JS 'let' and 'var' only
			.replace(/\b(let|var)\b/g, 'float')
			// keep consts as const
			.replace(/\bMath\./g, '')
			.replace(/\bPI\b/g, '3.14159265359')
			// remove arrow header like "w=>{" or "foo => {"
			.replace(/^\s*\w+\s*=>\s*{/, '{')
			// normalize numbers like 5. -> 5.0
			.replace(/(\d+)\.(?!\d)/g, '$1.0');

		if (!/float\s+\w+\s*\(/.test(glsl))
			glsl = `float sakFn(in vec3 w, in vec3 ns) ${glsl}`;

		return glsl;
	},

	
	//TODO transpile the query parts (diffeqNearPairs, potenNearPairs, etc) to js and the big loops/parallelForks to glsl.
	
	//does not check if its allowed by allowSakCode, just does it, with caching.
	sakEval: sakCode=>Sak.jsEval(Sak.transpileSakToJs(sakCode)),
	
	allowSakCode: sakCode=>true, //FIXME filter code that has infinite loops, doesnt prove its max memory and compute steps, etc.
	
	allowJsCode: jsCode=>true, //FIXME filter code that has infinite loops, doesnt prove its max memory and compute steps, etc.
	
	cacheSakEval: {},
	
	cacheJsEval: {},
	
	//caches in Sak.cacheJsEval the first time, so make sure this returns something reuseable
	//like a function or js {} from json if ur gonna call it twice.
	tryJsEval: jsCode=>{
		let evaledTo = Sak.cacheJsEval[jsCode];
		if(evaledTo !== undefined){
			return evaledTo;
		}else{
			if(!Sak.allowJsCode(jsCode)){
				Err('Not Sak.allowJsCode of jsCode['+jsCode+']');
			}
			return Sak.cacheJsEval[jsCode] = eval(jsCode);
		}
	},
	
	//does not check if its allowed by allowJsCode, just does it, with caching.
	jsEval: jsCode=>{
		return Sak.cacheJsEval[jsCode] || (Sak.cacheJsEval[jsCode] = eval(jsCode));
	},
	
	//Returns js [] list of tokens. You can know what kind of token it is by its first 1-2 chars. "//" "/*" "'" "\"" "`" etc,
	//as string literals keep their quotes. Sak.tokenize(code).join("")==code should always be true even if code string is buggy.
	//
	//tokenize in general, multiple possible languages. javascript string literals and comments. will add GLSL mat4 etc todo,
	//and some combo of those together will be the Sak language, javascript but with GLSL primitive types and funcs built in
	//so parts get GPU optimized even if using lambdas like in v.Bellsack.Room5.Some.Thing.potenNearPairs((varA,varB)=>{...});
	//tho that func doesnt work yet, its meant to get GPU optimized in some cases,
	//using vec4(varA.dp,varA.dv,varA.kv,varA.p) or something like that,
	//and another data structure vec4(velocityX,velY,velZ,poten) or something like that, and maybe vec2(varA.p,varA.v) etc.
	//Similar for diffeqNearPairs vs potenNearPairs.
	//
	//Briefly looked at the code of js-tokens.
	//I disliked that js-tokens stores syntax type and makes tokenizing logic depend on it.
	//My tokenizer's state thru 4 passes is always a list of strings that if you list.join("")
	//them u get original string exactly.
	//QUOTE: postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
	//https://www.npmjs.com/package/js-tokens click CODE go into file /js-tokens/index.js
	//to see the code Im talking about. Did not use that code even if GPT saw it since I told GPT to
	//first split by comments and string literals (first of 4 passes),
	//which cuts down on the kinds of patterns
	//you have to consider in the parts between the comments/stringLiterals
	//since a comment can have broken code in it
	//but the code containing such a comment or string literal is correct.
	//Inside such comment or string literal might be code with comments in that code, and so on.
	//I just cut that off completely in the first pass, turn each comment and stringLiteral into 1 token.
	//Unlike js-tokens, the Sak.tokenize(string)=>[tokens...] tokenizer could in theory run in parallel
	//after 1 thread runs phase 1 (turn all the comments and string literals into 1 token each, and whatever
	//code is between them), then could run the next 3 phases in parallel. About as many threads
	//as comments+stringLits. Those phases (now looks like 5, was thinking 4 but an extra whitespace fix is fifth) are:
	//"var tokenizeJsOrGlslOrSak = code=>splitMergeFixWhitespace(splitOther(joinTokensWronglySplitIn_splitNumbersAndEllipsis(
	//	splitNumbersAndEllipsis(splitBetweenCommentsAndStringLiterals(code)))));".
	//Should get that down to 3 phases cuz 2 of them are fixes for the phase right before them.
	//If you do it as a state machine, you might need alot of states. Is the last char ending a quote or not?
	//U gotta think about that every time. etc. So I just got rid of that,
	//once u are tokenizing stuff other than comments and string literals,
	//you dont have to check if its a comment or literal anymore.
	//Then I got all the number literals and vararg "..." and left just what was between them,
	//so at that point every "." is object.field .
	//Then between all that I split by ( ) [ ] . / + += => % etc.
	//The tokenizing code doesnt even know the javascript keywords for if else etc,
	//which in theory makes it easier for me to make a new language
	//I'm calling Sak that adds mat4 vec3 etc from GLSL.
	//
	//TODO make ALL_VARS constant, but whats its value? Where do I hook it in?
	//Due to the impossibility of halting-oracles, the ALL_VARS constant, representing the
	//set of all infinity possible Var instances (whose unique id is theVar.path() which returns
	//a string like "v.Bellsack.Room55.Hello.World"), is necessary to make sure you either
	//do not compute gradient of part or whole of the game state unless you include every Var
	//which it has a nonzero gradient for, which is used to accelerate by the negative gradient of loss.
	//
	//TODO rewrite this confusing big paragraph,
	//and some of this shouldnt be in Bellsack its related to other projects:
	//Sak.tokenize(codeString) has far less attack-surface than js-tokens cuz it does a first pass to
	//remove comments and string literals from future calculations. Bugs in the parsing of number literals
	//and [ ] ( ) etc, occur only after those comments/literals are set in stone.
	//Its true, but heres what could go wrong after it and some speculative input and output devices
	//that might be in future versions of Bellsack use Sak language for player created content)...
	//... (at transpile time, which is usually
	//(if GPU JIT compiler decides to, which you use thru WebGL2 GLSL ES 300 GPU shaders and
	//up to (depending on your system, i only have 8gB GPU memory in that test) 7gB of small GL textures
	//used as random-access memory in batches), see Lamgl for details,
	//just type Lamgl.doBasicTests() on browser console to get started or theres a button in some htmls.
	//about 1/4 second before it appears on screen then after it can run fast enuf in theory to stream
	//to/from WebAudioAPI by GPU optimized synth or go thru browser->tomcat->JSoundCard->oneMicInTwoSpeakersOut.
	//My synth JSoundCard is lowest lag on Linux, much lower lag than WebAudioAPI, and could in theory
	//operate both and by some possible player created content
	//(new GPU code allowed if passes local firewall created by my VM,
	//todo Sak.allowJsCode(string) and Sak.allowSakCode(string) both just allow everything so far 2025-9-5)
	//do echolocate between them or other effects I've made the air vibrate on my lips when I
	//whispered from 10 feet away from a microphone 2 feet away from a speaker,
	//and even if you put it right up against the speaker cone it doesnt explode or vanish in volume.
	//the same as it paints the screen by anyTensor.display()
	//(continued from somewhere above in this text)...of [height,width,4] for vec4 per pixel
	//aka 128 bit color but falls to 24 bit color at generated
	//canvas that auto puts itself as background of your webpage as soon as you call tensor.display()).
	//Bugs in the parsing of number literals
	//and [ ] ( ) etc, occur only after those comments/literals are set in stone.
	
	tokenize: code=>tokenizeJsOrGlslOrSak(code),
	
	manualTestTokenize_code:
		`// tricky tokenizer test with many edge‑cases —
		const π		 = 3.141_59;
		let	 bigInt	= 1_000n;			 // BigInt literal

		// dot‑paths & alias
		const path	= v.Bellsack.Room1.X;
		const ghost = ns.Odos$hash.Lone.Lone;
		ghost.B507...
		/*/* /* /* other kind of comment*/
		/**//***/

		// string literals with line‑continuations
		const s1 = 'single‑quoted \'with\' backslash‑continued line\\\nsecond line';
		const s2 = "double‑quoted \"with\" backslash‑continued line\\\nsecond line";
		const tmpl = \`template literal with // fake comment\nand /* fake block */ text\nand an escaped backtick \\\`\`;

		// numeric zoo
		let hex = 0xDEAD_BEEF;
		let bin = 0b1010_1111;
		let oct = 0o7_5_5;

		// rest‑param & spread
		function add(...nums){ return nums.reduce((a,b)=>a+b,0); }
		const arr = [1,2,3];
		add(...arr);
		`,
	
	//TODO verify these are correct. probably some small things wrong with it 2025-9-5-11aET.
	manualTestTokenize_tokens: [
		"// tricky tokenizer test with many edge‑cases —",
		"\n",
		"\t\t",
		"const",
		" ",
		"π",
		"\t\t ",
		"=",
		" ",
		"3.141_59",
		";",
		"\n\t\t",
		"let",
		"\t ",
		"bigInt",
		"\t",
		"=",
		" ",
		"1_000n",
		";",
		"\t\t\t ",
		"// BigInt literal",
		"\n",
		"\n\t\t",
		"// dot‑paths & alias",
		"\n",
		"\t\t",
		"const",
		" ",
		"path",
		"\t",
		"=",
		" ",
		"v",
		".",
		"Bellsack",
		".",
		"Room1",
		".",
		"X",
		";",
		"\n\t\t",
		"const",
		" ",
		"ghost",
		" ",
		"=",
		" ",
		"ns",
		".",
		"Odos$hash",
		".",
		"Lone",
		".",
		"Lone",
		";",
		"\n\t\t",
		"ghost",
		".",
		"B507",
		".",
		".",
		".",
		"\n\t\t",
		"/*/* /* /* other kind of comment*/",
		"\n\t\t",
		"/**/",
		"/***/",
		"\n\n\t\t",
		"// string literals with line‑continuations",
		"\n",
		"\t\t",
		"const",
		" ",
		"s1",
		" ",
		"=",
		" ",
		"'single‑quoted '",
		"with",
		"' backslash‑continued line\\\nsecond line'",
		";",
		"\n\t\t",
		"const",
		" ",
		"s2",
		" ",
		"=",
		" ",
		"\"double‑quoted \"",
		"with",
		"\" backslash‑continued line\\\nsecond line\"",
		";",
		"\n\t\t",
		"const",
		" ",
		"tmpl",
		" ",
		"=",
		" ",
		"`template literal with // fake comment\nand /* fake block */ text\nand an escaped backtick \\``",
		";",
		"\n\n\t\t",
		"// numeric zoo",
		"\n",
		"\t\t",
		"let",
		" ",
		"hex",
		" ",
		"=",
		" ",
		"0xDEAD_BEEF",
		";",
		"\n\t\t",
		"let",
		" ",
		"bin",
		" ",
		"=",
		" ",
		"0b1010_1111",
		";",
		"\n\t\t",
		"let",
		" ",
		"oct",
		" ",
		"=",
		" ",
		"0o7_5_5",
		";",
		"\n\n\t\t",
		"// rest‑param & spread",
		"\n",
		"\t\t",
		"function",
		" ",
		"add",
		"(",
		"...",
		"nums",
		")",
		"{",
		" ",
		"return",
		" ",
		"nums",
		".",
		"reduce",
		"(",
		"(",
		"a",
		",",
		"b",
		")",
		"=>",
		"a",
		"+",
		"b",
		",",
		"0",
		")",
		";",
		" ",
		"}",
		"\n\t\t",
		"const",
		" ",
		"arr",
		" ",
		"=",
		" ",
		"[",
		"1",
		",",
		"2",
		",",
		"3",
		"]",
		";",
		"\n\t\t",
		"add",
		"(",
		"...",
		"arr",
		")",
		";",
		"\n\t\t"
	],
	
	manualTestTokenize: ()=>{
		// Tokenizer test snippet – contains exactly ONE template literal (` ... `)
		const code = Sak.manualTestTokenize_code;
		let tokens = Sak.tokenize(code);
		if(tokens.join("") != code){
			throw new Error('joined tokens dont equal original');
		}
		if(JSON.stringify(tokens) != JSON.stringify(Sak.manualTestTokenize_tokens)){
			throw new Error('observed tokens dont match manualTestTokenize_tokens, tho that might be cuz manualTestTokenize_tokens is the wrong tokens.');
		}
		console.log('Test pass: JSON.stringify(tokens) != JSON.stringify(Sak.manualTestTokenize_tokens), tokens.length='+tokens.length);
		//TODO put correct output here and rename it from manualTestTokenize to testTokenize, throw if fails.
		return tokens;
	},
	
	/*console.log(Sak.parseHeaders(`Sak$SomeHeader: hello world
	OtherHeader: blah blah
	OtherHeader: blu blu
	Fn: w=>{
		float dx = w.Cx.p-ns.X.p;
		...
	}`))
	VM323:1 
	{SomeHeader: Array(1), OtherHeader: Array(2), Fn: Array(1)}
	Fn
	: 
	['w=>{\n    float dx = w.Cx.p-ns.X.p;\n    ...\n}']
	OtherHeader
	: 
	(2) ['blah blah', 'blu blu']
	SomeHeader
	: 
	['hello world']
	[[Prototype]]
	: 
	Object
	undefined
	console.log(Sak.parseHeaders(`Sak$SomeHeader: hello world
	OtherHeader: blah blah
	OtherHeader: blu blu
	Fn: w=>{
		float dx = w.Cx.p-ns.X.p;
		...
	}`).Fn[0])
	VM352:1 w=>{
		float dx = w.Cx.p-ns.X.p;
		...
	}
	*/
	parseHeaders: code=>{
		if (!code.startsWith("Sak$"))
			throw new Error(`Not a Sak block: missing 'Sak$' prefix (starts with: ${JSON.stringify(code.slice(0, 20))})`);

		code = code.slice("Sak$".length).trim();

		const result = {};
		const lines = code.split(/\r?\n/);
		let currentKey = null;
		let foundHeader = false;

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];
			const m = line.match(/^([A-Z$][\w$]*):(.*)$/);
			if (m) {
				foundHeader = true;
				const key = m[1];
				const val = m[2].replace(/^\s+/, '');
				if (!result[key]) result[key] = [];
				result[key].push(val);
				currentKey = key;
			} else if (currentKey !== null) {
				result[currentKey][result[currentKey].length - 1] += '\n' + line;
			} else {
				// only throw if this happens *after* headers have started
				if (foundHeader && !/^\s*$/.test(line))
					throw new Error(`Invalid Sak syntax before header at line ${i + 1}: ${JSON.stringify(line)}`);
			}
		}

		for (const key in result) {
			result[key] = result[key].map(v =>
				v.replace(/^\s*\n/, '').replace(/\s+$/, '')
			);
		}

		if (!foundHeader) {
			result.Fn = [code.replace(/^\s*\n/, '').replace(/\s+$/, '')];
		}

		return result;
	},

};


//splits by 2 kinds of comments // /* and 3 kinds of string literals ' " `
//and in theory also \ at end of line in string literal cancels that next line break.
//Returns a list of comments, string literals, and OTHERs (whatevers between those)
//which when you list.join("") returns the original string exactly.
//First-pass JS tokenizer for Sak lambdas.
var splitBetweenCommentsAndStringLiterals = src=>{
	const out=[];
	const len=src.length;
	let from=0,i=0;
	function push(end){ if(end>from) out.push(src.slice(from,end)); }
	while(i<len){
		const c=src[i];
		const n=i+1<len?src[i+1]:"";
		if(c==="/"&&n==="/"){
			push(i); let j=i+2;
			while(j<len){ const d=src[j];
				if(d==="\r"&&src[j+1]==="\n"){ j+=2; break; }
				if(d==="\n"){ j+=1; break; }
				j+=1; }
			out.push(src.slice(i,j)); i=from=j; continue; }
		if(c==="/"&&n==="*"){
			push(i); let j=i+2;
			while(j<len){ if(src[j]==="*"&&src[j+1]==="/"){ j+=2; break; }
				if(src[j]==="\r"&&src[j+1]==="\n"){ j+=2; continue; }
				j+=1; }
			out.push(src.slice(i,j)); i=from=j; continue; }
		if(c==="'"||c==='"'||c==="`"){
			const q=c; push(i); let j=i+1;
			while(j<len){ const d=src[j];
				if(d==="\\"){
					// 1) backslash \r \n	→	skip “\\r\n”
					if(src[j+1]==="\r" && src[j+2]==="\n"){ j+=3; continue; }
					// 2) backslash \n	 →	skip “\\n”
					if(src[j+1]==="\n"){ j+=2; continue; }
					// 3) ordinary escape	→	skip backslash *and* next char
					j+=2; continue;
				}
				//if(d===q){
				//	let k=j-1,bs=0;
				//	while(k>=i&&src[k]==="\\"){ bs++; k--; }
				//	if(bs%2===0){ j+=1; break; }
				//}
				// we arrive here only if the preceding character wasn’t
				// a backslash we have already skipped, so this quote closes
				//if(d===q){ j+=1; break; }
				// close only when the quote is *not* escaped
				if(d===q){
					let k=j-1, bs=0;
					while(k>=i && src[k]==="\\"){ bs++; k--; }
					if(bs%2===0){			 // even ⇒ not escaped
						j+=1;				 // include the closing quote
						break;
					}
				}
				if(d==="\r"&&src[j+1]==="\n"){ j+=2; continue; }
				j+=1;
			}
			out.push(src.slice(i,j)); i=from=j; continue; }
		if(c==="\r"&&n==="\n"){ i+=2; continue; }
		i+=1; }
	push(len);
	return out;
};

/*
// matches a JavaScript numeric literal (decimal, hex, bin, oct, float, exponent, BigInt, underscores)
const NUM_LITERAL_RE = /^(?:0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*n? # hex (0xFF, 0xFFn, 0xF_F) |0[bB][01](?:_?[01])*n? # binary (0b1010, 0b1_0n) |0[oO][0-7](?:_?[0-7])*n? # octal (0o755, 0o7_5n) |(?:\d(?:_?\d)*\.(?:\d(?:_?\d)*)?|\.\d(?:_?\d)*)(?:[eE][+\-]?\d(?:_?\d)*)? # floats (.5, 1.2, 3., 1.2e3) |\d(?:_?\d)*(?:[eE][+\-]?\d(?:_?\d)*) # ints with exponent (1e3, 1_0e+2) |\d(?:_?\d*)n?)$ # plain ints & BigInt (123, 1_000n) /x; VM5350:3 Uncaught SyntaxError: Invalid regular expression: missing /Understand this error i dont know about thse # comments. we are in js

const NUM_LITERAL_RE = new RegExp(
	"^(?:0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*n?|0[bB][01](?:_?[01])*n?|0[oO][0-7](?:_?[0-7])*n?|(?:\\d(?:_?\\d)*\\.(?:\\d(?:_?\\d)*)?|\\.\\d(?:_?\\d)*)(?:[eE][+\\-]?\\d(?:_?\\d)*)?|\\d(?:_?\\d)*(?:[eE][+\\-]?\\d(?:_?\\d)*)|\\d(?:_?\\d*)n?)$"
);

undefined
NUM_LITERAL_RE.test('2.34')
true
NUM_LITERAL_RE.test('a2.34')
false
NUM_LITERAL_RE.test('+2.34')
false
NUM_LITERAL_RE.test('-2.34')
false
NUM_LITERAL_RE.test('2.34e-7')
true
NUM_LITERAL_RE.test('2.34e-744')
true
*/
const NUM_LITERAL_RE = new RegExp("^(?:0[xX][0-9A-Fa-f](?:_?[0-9A-Fa-f])*n?|0[bB][01](?:_?[01])*n?|0[oO][0-7](?:_?[0-7])*n?|(?:\\d(?:_?\\d)*\\.(?:\\d(?:_?\\d)*)?|\\.\\d(?:_?\\d)*)(?:[eE][+\\-]?\\d(?:_?\\d)*)?|\\d(?:_?\\d)*(?:[eE][+\\-]?\\d(?:_?\\d)*)|\\d(?:_?\\d*)n?)$"
);
NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;

// Build a splitter that matches EITHER "..." or a JS number literal.
// Uses the already-defined global NUM_LITERAL_RE.
const NUM_OR_ELLIPSIS_RE = new RegExp(
	'(' + '\\.\\.\\.' + '|' +
	NUM_LITERAL_RE.source.replace(/^\^/, '').replace(/\$$/, '') +
	')',
	'g'
);

//step after splitBetweenCommentsAndStringLiterals. list of tokens in. equalOrBigger list out. still .join("") to original string exactly.
//
//I said to GPT [make it also split by "..." since i want that vararg syntax tokenized
//in this step too. number literals and ... , so the only "." left is object.field]
//
// Split ONLY OTHER tokens on number literals and "...".
// Comments/strings are passed through untouched. join("") stays identical.
var splitNumbersAndEllipsis = tokens=>{
	const out = [];
	for (const t of tokens) {
	if (!t) continue;
	const c0 = t[0], c1 = t[1] || '';

	// keep comments and strings as-is
	if ((c0 === '/' && (c1 === '/' || c1 === '*')) ||
		c0 === '"' || c0 === "'" || c0 === '`') {
		out.push(t);
		continue;
	}

	// OTHER: split by ... and numeric literals (capturing group keeps matches)
	const parts = t.split(NUM_OR_ELLIPSIS_RE);
	for (let i = 0; i < parts.length; i++) {
		const s = parts[i];
		if (s !== '') out.push(s);
	}
	}
	return out;
};

//[fixme theres a whitespace fix after this, that whitespace should not have been grouped in with the // comment its the \n suffix of]
//Last tokenizing step, for splitting all other syntax chars, var names, built in keywords, etc. ( ) [ ] . VarName5 etc.
// ─── Final sweep: break “OTHER” chunks into identifiers, whitespace, and single-char punctuators.
//	 • comments, strings, "..." and number-literals are passed through untouched.
//	 • join("") of the result still equals the original source.
//
// Final sweep: break the remaining OTHER chunks into
//	 • identifiers / keywords
//	 • whitespace runs
//	 • operators / punctuators (longest-match, so “===” not “= = =”)
//
// Comments, strings, “…”, and number-literals are passed through unchanged.
// Result still satisfies tokens.join("") === original source.
//
// ───── final slicer ──────────────────────────────────────────────────────────
var splitOther = tokens => {
	const out = [];

	// quick helpers
	const isWS		 = c => /\s/.test(c);
	const isIdentStart = c => /[A-Za-z_$]/.test(c);
	const isIdentPart	= c => /[A-Za-z0-9_$]/.test(c);

	// longest-first operator table (covering every JS punctuator)
	const OPS = [
	">>>=", "<<=", ">>=", "**=", "&&=", "||=", "??=",
	">>>",	"===", "!==",
	"&&", "||", "??",
	"**", "<<", ">>",
	"+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "=>",
	"==", "!=", "<=", ">=",
	"++", "--", "?.", "...",
	];
	// index by first char for speed
	const byFirst = OPS.reduce((m, op) => {
	(m[op[0]] ||= []).push(op);
	return m;
	}, Object.create(null));

	for (const t of tokens) {
	if (!t) continue;
	const c0 = t[0], c1 = t[1] || "";

	// pass-through for non-OTHER kinds
	if ((c0 === "/" && (c1 === "/" || c1 === "*")) || // comments
		c0 === "'" || c0 === '"' || c0 === "`"	 ||	 // strings
		t === "..."							||		 // ellipsis
		NUM_LITERAL_RE.test(t)) { out.push(t); continue; }

	// true OTHER  →  rescan
	let i = 0;
	while (i < t.length) {
		const ch = t[i];

		// identifier / keyword
		if (isIdentStart(ch)) {
		let j = i + 1;
		while (j < t.length && isIdentPart(t[j])) j++;
		out.push(t.slice(i, j));
		i = j;
		continue;
		}

		// whitespace run
		if (isWS(ch)) {
		let j = i + 1;
		while (j < t.length && isWS(t[j])) j++;
		out.push(t.slice(i, j));
		i = j;
		continue;
		}

		// operator / punctuator (longest match)
		const cand = byFirst[ch] || [];
		let matched = null;
		for (const op of cand) {
		if (t.startsWith(op, i)) { matched = op; break; }
		}
		if (matched) {
		out.push(matched);
		i += matched.length;
		} else {
		out.push(ch); // single char ( { } ( ) [ ] . , ; : ? ! ~ ^ & | + - * / % < > = )
		i += 1;
		}
	}
	}

	return out;
};

// Re-joins tokens that belong to the same identifier but were split
// by splitNumbersAndEllipsis — e.g. "sha"+"256" → "sha256".
var joinTokensWronglySplitIn_splitNumbersAndEllipsis = tokens=>{
	const out=[];
	const isIdentChar = c=> /[A-Za-z0-9_$]/.test(c);

	function isCommentOrString(tok){
		if(!tok) return false;
		const c0=tok[0], c1=tok[1]||"";
		return (c0==="/"&&(c1==="/"||c1==="*")) || c0==="'" || c0==='"' || c0==="`";
	}

	for(let i=0;i<tokens.length;i++){
		let t=tokens[i];

		// comments and strings are left untouched
		if(isCommentOrString(t)){ out.push(t); continue; }

		// merge as long as the boundary is identifier-character → identifier-character
		while(i+1<tokens.length){
			const u=tokens[i+1];
			if(isCommentOrString(u)) break;

			const last	= t[t.length-1];
			const first = u[0];

			if(isIdentChar(last) && isIdentChar(first)){
				t += u;			// glue them together
				i++;			 // consume next token
			}else{
				break;
			}
		}
		out.push(t);
	}
	return out;
};

//fix the whitespace that gets on the end of some tokens. No token should start or end with whitespace
//unless that token is all whitespace.
//BEFORE: "// rest‑param & spread\n" is followed by "\t\t" but shoulda been:
//"// rest‑param & spread" is followed by "\n\t\t".
//
// ─────────────────────────────────────────────────────────────────────────────
//	Post-pass: split off leading / trailing whitespace from every non-WS token.
//	• Pure-WS tokens are kept unchanged.
//	• join("") of the returned array still equals the original source.
// ─────────────────────────────────────────────────────────────────────────────
var splitMergeFixWhitespace = tokens=>{
	const out = [];
	for (const t of tokens) {
		if (t === "") continue;

		// pure-whitespace token? keep as-is
		if (/^\s+$/.test(t)) { out.push(t); continue; }

		// leading	 whitespace run
		let i = 0;
		while (i < t.length && /\s/.test(t[i])) i++;
		if (i) out.push(t.slice(0, i));					// push the WS part

		// core (no surrounding WS)
		let j = t.length - 1;
		while (j >= i && /\s/.test(t[j])) j--;
		out.push(t.slice(i, j + 1));						 // push the trimmed token

		// trailing whitespace run
		if (j + 1 < t.length) out.push(t.slice(j + 1));
	}
	return out;
};

//tokenizeJsOrGlslOrSak(code).join("")==code is always true even if theres errors in the code string,
//but it might tokenize it strangely if there are errors like unclosed string literals.
//It will support all of javascript, including 2 kinds of comments // /* and 3 kinds of
//string literals ' " ` that last one is multiline. I first separate comments and strings.
//then number literals and "..."/vararg. Then simple splitting by += / VarName5 : ? etc.
//var tokenizeJsOrGlslOrSak = code=>splitOther(splitNumbersAndEllipsis(
//	splitBetweenCommentsAndStringLiterals(code)));
var tokenizeJsOrGlslOrSak = code=>splitMergeFixWhitespace(splitOther(joinTokensWronglySplitIn_splitNumbersAndEllipsis(
	splitNumbersAndEllipsis(splitBetweenCommentsAndStringLiterals(code)))));









console.log(
`TODOS...

lets do something easier first tho might end up being bigger code. Using the [] list of strings returned by Sak.tokenize(codeString), divide it into a tree of [] where the first thing in each [] is a string or {}. 'x=>(x*x + 1)' becomes ['x','=>','(','x','*','x',' ','+',' ','1',')']. Then this next func turns that into: ['LAM',['LAMPARS','x'],'=>',['LAMBODY','(',['PLUS',['MUL','x','*','x'],' ','+',' ','1'],')']] or something like that. If u need to store more data than 'PLUS' you put {type:'PLUS', otherStuff:5} in place of 'PLUS' for example.


I'm making a programming language called Sak (short for Bellsack which does isosurfaces made of 3d bellcurves and other shapes) which will be a mix of javascript and GLSL. It will let you use mat4, vec4, vec3, float, int, js lists, and loops, query parts in CPU, big loops in GPU. Bellsack310.html has a Sak object you can use on browser console but its early experiments for now. These lambdas you make with Sak are going in the V/Var tree so it will scale. I want you to come up with an upgrade plan to gradually make those n balls on the circle thing which will be a Sak$ game rule that does some kind of poten loop but not a potenNearPairs loop. it will have a [] list of Var's of the balls and loop from there. it will be computed in cpu. and do the rest of the Sak upgrade.
u know how in python cant just call GPU. u gotta bring in a library thats hard to change cuz its got compiled C/++ in it. Sak brings the instant eval (takes 1/4 second on first compile, more or less depending on complexity) to GPU code thru Lamgl which Bellsack already runs on.

bellsack ... vec4 of poten float and vec3 velocity per point instead of jyst density field. make monster trucks. ... make Var tree fast for names being var paths or rel paths like game.Room55.Abc or ns.Abc where ns is room akanamespace.... if its ns.Thingamajig.Blah567['ns.Abc.Ggggooooggg'] then ns.Abc.Ggggooooggg will be cached in ns.Thingamajig.Blah567['ns.Abc.Ggggooooggg'].ptr so u dont have to parse it. might do similar for path strings in .big in some Types5678$ prefix. so u use ns.Thingamaaaaak.Ptr[...].p=1 as a stochastic vector. make rps balls chase eachother ballpairrule for dv, how? make it a js lambda code string (glsl? need tree childs) with 2 ball params as Code$... and have its childs have Cx Cy Cz R for defining a volume and PairCdist for cdnter to cdnter distance it applies if pairs of balls both in that volume are near enuf eachother. what does this func do? mods Var.dv? For other code u can name vars like ns.Thing.Blah.p in the code. so 2 hashes deep, the first givrs the fumcand child gives some of the params. cache these that refer to a Var in those Vars. do numvarstouched+1 calls for poten. just 1 each for dp dv kv mn mx etc. mark which vars changed so nextstate only those. ns.Odos$4566hash34.Odo5.Ghost67.Wave99 ns.Odos$Ball.Lone.Lone.B500 ns.Odos$566hashofmandelbulbcode567 ns.BallPairRule$4567788. ... make ballpairrules work on gpu by vec4(dp,dv,kv,setValElseNANOrSomeConstIfCantNaN). output 1 vec4 per var for diffeq. output up to 8 of them by multi texture out. so up to 8 vars used per ball. sparsely for different 1..8 vars per ballpairrule. reads some set of vars. writes some set. when reading u only read position and maybe for friction also velocity but friction will be built into core of game engine and customized by returning vec4(velx,vely,velz,poten). no player created shader reads velocity. or should it? generalize queries to ns.AnyType$codehash.*.*.* or maybe do it as js code that returns a js list of vars. yes. make it a js lambda, of 0 params in simplest case. make transpile glsl to js by float and int becomes let, etc, and implement Sine MulM4V4 MulM4M4 LenV3 etc that mods one shared float42array and each such func returns int ptr into it and takes either int ptr or float value params and returns similar. so there types Odos$ Rule$ User$ and maybe later DagVar$. Each rule does a query in cpu then runs rule on combos of those results, either in cpu or gpu. rps chasing/running/teamcapture. ManaRefillRate. algebra equation by least squared error by Poten. even if u just wanna put one instance of the rule like between 3 specific vars across 2 or 3 waves/gobs, u make it as a general Rule$. if it has tuneable params include those as vars. put json map in .big of rule instance, localname maps to 'ns.Thing.Blah5'. put tbat in .big. also other vars as its child vars. so those 2 groups if vars are whats different about this rule instance. make such instance have ptrs to those, which can create cycles in var "tree". put them in var.dag diff than var.pu but var.Varname duplicates ptr in either. so this can be like DagVar$ without the lambda axgob parts. '{"l":"ns.Thing.Blah5","r":...}' make rule instance and rule itself each have such a dag map. rule also has a code string. instead of a map of json the rule simply uses the ns.Thing.Blah5 directly. or maybe it should be vec2 l = ns.Thing.Blah5; vec2 r = ...; in rule instance. allow Rule$ to be both rule and instance, if it doesnt refer to any fields it lacks. Odos$ PotenRule$ DiffeqRule$. u get uniform arrays of float p[] float v[] for each var read. maybe ManaRefillRateP and ManaRefillRateV. ManaDp += ManaP*(1.-ManaRefillRateP)+ManaRefillRateP; or something like that. at end it auto puts ManaDp ManaDv ManaKv ManaMnx in vec4. for up to 8 such vars out. AManaP BManaP if theres 2 gobs each with mana. tho manarefillrate and mana are just ballrule not ballpairrule. rps is ballpairrule aka a DiffeqRule. nbody is a PotenRule. Poten += cuz theres only 1 poten float shared used relatively. so make Bell5 that way in Odos$. need a syntax for query all pairs of one bell5 with one ball buto only those near eachother within some max distance center to center, and only if both are inside some given sphere volume the rule applies in. need a syntax for saying its a PotenRule, and syntax for saying its a DiffeqRule. SQL? Mongodb syntax? etc? query{ ... } ...... forall Bel Forall Bal{ } want way to, after filtering, split a set remaining, like in named var Bal, into BalA and BalB. then further filter like to say theyre within some distance of eachother. is it like db rows? what if i let there be resultsets, like list of lists, abstractly cuz can be loop withput storing it, resultset as value of var(not V Bar but in this lang im making). let balls = ...; let pairsOfFilteredBalls = ...; let nextFilteredPairs = pairsOfFilteredBalls ...; then how do i call the loop body on it? let diffeqs = pairsOfFilteredBalls. this is too complex. just make a few standard loop types, including NearPairsIn(var to use my Cx Cy Cz R and CC for max center to center dist) and EachIn(var yo use my sphere). so maybe... TheSphereWithCC.potenNearPairs((BalA,BelB)=>{ ... }) which adds to poten or returns poten. just 1 float poten. so might need sep gradient func. TheSphereWithCC.diffeqNearPairs(..) mods vars or returns a js Map of var to vec4. TheSphere.diffeqEach(ball=>{...}). 'Js$V.loadMap({Bellsack:{...}});' goes in .big. use vec4 mat4 vec3 float int etc as if its glsl bit use ns.Thing.Blah5.X.p like its js. will transpile it to some combo of js (for query parts and small code small loops etc) and glsl for big loops etc. tracj which vars changed so can nextstate them. Beval is bellsack eval. Beval('V.loadMap({Bellsack:{...}});'); Put those things in Var. V.eval('V.loadMap({Bellsack:{...}});') even tho its a static func. will need if a rule is not its own only instance then it has child instances instead. in Odos$hash.odo.ghost.wave.X .Y .Z .Mana etc. in both of those, a .big func needsto get some of its vars from child.child... 3+1 levels deep in case of odos and 1+1 deep in case of instance if rule. also u cant even run the odos one by itself cuz u gotta merge with other odos/species for same named odo or ghost. remember to do multi species shaders like 10 species each 10 shaders for 100 nearby species. just make such collision physics a func u call from ns/room with a sphere volume. maybe call it Sak to mean bellsack. Start storing code in .big as list of lines add \n automaticly. make a new file format similar to jsonl but its 2 \n to separate so u can have multiline. so its a stream. rename V to v so it cant be a child name ot local var name. In the case of odo ghost wave, the code in Odos$ is only run on the wave. simple. its a lambda of its childs to fliat. In case of the few kinds of ruleloops, lets say the deeper (instance) code/ptrs/vars occur first and the parent/shallower code second. maybe the instance is Js$ then code that takes a func as param then calls that func on some Var objects andor on itself. in general lets make Js$ be lambdas but since its not exactly js, is a mix of js and glsl, lets use prefix Sak$. So lets make them all lambdas including lambdas calling lambdas. check if allowed to run it by code string to avoid infloops etc and to gpu optimize the var.potenNearPairs var.iffeqNearPairs etc. add to Proxy to create .sak on read it if passes filter of code string. so u can v.Bellsack.Room1.Sak$4567hash3567.sak(...params) to call it as a func. Use that ability to put calls of Lamgl in Var tree .big so can implement a 1 million param mini LLM that talks about and creates game content and other mini AIs etc. Js$ Glsl$ Sak$ Odos$ User$. Odos should technically be Sak$ but it has deeper tree. The Sak lambdas can only mutate.p and .v thru var.nextState like by diffeq and poten loops or singles. sak lambdas can technically make more lambdas by putting in .big. For AI, a Tensor should be useable as a .big even before its name is decided but thats tricky not sure if i can. could put .tsr for tensor like (not sure if need anymore).dag cache and .pu, make .tsr be starts null but becomes z Map of Lamgl.Tensor to Var whose .big is Tsr$ then contents of that tensor. so we dont have to fill in its .big or .name yet but can use its .p and.v. Lets make that .ob in general for objects used as childs but not hashed yet. could cause duplicates. Ptr$nameAbc will imply a stochasticvector, .p sums to 1 of its childs if Ptr itself exists. Remember, any tensor can .display() but ud gave to pause bellsack dispkaying that way to see it. Lets make some test lambdas and display them, lambdas as Sak$ so they go in the Var tree. Make them use Lamgl.dont forget to tensor free. And remake bell5s as Saks. And make rps game rule as a someSphereVarWithCC.diffeqNearPairs(...). and make a mandelbulb ghost and use it with bell5 ghost. ... X Y Z built in. X.p or x? or v.X.p v.Y.p v.Z.p Odos$hashofbell5code$(x,y,z,wv)=>{ float dx = x-wv.Cx.p; float dy float dz float distSq = R stddev return exp(-distSq/2) or something like that. dont forget u can use vec3 etc } EdJoint$ instead of putting it as x y z fbuiltins in each Var? make some balls stay on a circle perimeter together but the circle varies in Cx Cy Cz rotation radius. name specific balls in it. can i have arrays for that? do it. name the balls in a js [] list by ns.something.Lone.Lone.B507 etc. js loop over it.

{
	Bellsack:{
		Room1:{

			// Gaussian ball / bell5 density (smooth “ball”)
			Odos$hashBell5:{
				big:[
					"Odos$(ball=>{",
					"\tconst dx = ball.X.p - ball.Cx.p;",
					"\tconst dy = ball.Y.p - ball.Cy.p;",
					"\tconst dz = ball.Z.p - ball.Cz.p;",
					"\tconst r2 = ball.Cr.p * ball.Cr.p;",
					"\treturn Math.exp( -(dx*dx + dy*dy + dz*dz) / (2*r2) );",
					"})"
				],
				// all four balls share one Ghost now
				Lone:{					// Odo (still nameless)
					BellGhost:{			// single shared Ghost
						B507:{p:1,v:0,	Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:0.5}},
						B508:{p:1,v:0,	Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:0.5}},
						B509:{p:1,v:0,	Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:0.5}},
						B510:{p:1,v:0,	Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:0.5}}
					}
				}
			},

			// circle-alignment rule (keeps balls on a circle)
			Sak$CircleAlign_6e42b3:{
				big:[
					"Sak$(()=>{",
					"\tconst P = ns.CircleParams;",
					"\tconst g = ns.Odos$hashBell5.Lone.BellGhost;",
					"\tconst balls = [g.B507,g.B508,g.B509,g.B510];",
					"\tconst n = balls.length;",
					"\tfor(let i=0;i<n;++i){",
					"\t\tconst b = balls[i];",
					"\t\tconst a = 6.2831853*i/n;",
					"\t\tb.Cx.p = P.Cx.p + P.Cr.p*Math.cos(a);",
					"\t\tb.Cz.p = P.Cz.p + P.Cr.p*Math.sin(a);",
					"\t\tb.Cy.p = P.Cy.p;",
					"\t}",
					"})"
				],
				p:1,v:0,
				comment:[
					"circle-alignment rule for the four Gaussian balls",
					"p is mutable weight / enable"
				]
			},

			CircleParams:{
				comment:[
					"centre (Cx,Cy,Cz) and radius (Cr) driving the circle rule"
				],
				Cx:{p:0},	Cy:{p:1.2},	Cz:{p:0},	Cr:{p:2.5}
			}
		}
	}
}



List every Prefix$ type im gonna have in there, including:
Odos$ - Odos$hashofsakcode.odoname.ghostname.wavename
Sak$ - lambda of sak syntax. Sak$hashofcode or Sak$hashofcode.Instance45345 and instance may have code of its own, and if it does then it may take its parent as param as a func to somevar.ob(...) call as a lambda. User$ - ed25519 pubkey. leave this for later. a pubkey is a growing set of things it signed. sigs are 64 bytes so 4/3 that big as base64. pubkeys are 32 bytes. password=>ns.User$ed25519pubkey . (password,message)=>ns.User$ed25519pubkey.thatMessage to mean userVar signed it.
Json\${"Hello":["World",42]}
Html$<html>...
Jsp$jspFileContentForTheTomcatPart
Ptr$name its childs are used as a stochasticVector whose .p's sum to 1 if the ptr exists. ptr exists if its .p is 1, does not exist if its .p is 0. Use Var.obs as a Map you can put a Lamgl.Tensor or string or other object in, used as immutable (dont modify it), and u can skip hashing it, as Var.obs is similar to Var.pu. The child's primaryKey is the tensor in that case, tho its by === not content so there could be duplicates, which is necessary to store tensors efficiently as they exist in GPU memory and we do calculations in gpu many tensors long without copying back to cpu. to copy back to cpu its tensor.get() returns Float32Array.
Tsr$ a Lamgl.Tensor object G$string u just remove the G$ prefix. so ('G$'+someVar.ob)==SomeVar.big if it is such a string and then u look for ob. Same for json. u can get the {} map form of it in ob. use as immutable, dont mutate there.

Switch to UI and game design. the tools we use in the game. Odos$code... is named Odos$hashofcode. so that gives us n knobs/vars per wave. Odos$code.Odo1.Ghost2.Wave3.X .Y .Z .ManaRefillRate etc. Thats all good. no changes needed there. We might have 30 different species of wave/odos and 1 of some and 40 of others, so a mix of 200 or so waves forming lets say 1 ghost and each ball is also a ghost. the main ghost is the terrain, in that case. so we got these vars on screen, colored knobs on rings in 3d. So u select 2 or 3 or maybe 10 vars/knobs and make a puredatalike node up from them, 10 inputs to this box, which has 1 or more outputs. dag. +(x,y) *(x,y) sine(x) -(x) distSq(x,y,z,x2,y2,z2) etc. we build these from more of these. Then we add poten(someFunc(...)) so the .p of that poten node is how much we multiply the (first/leftmost) output float of someFunc(...) when adding to total loss of the game state aka poten. Similarly dv(someVar,someFunc(...)) would add dv(someVar,someFunc(...)).p*someFunc(...).outs[0] to someVar.dv. So poten(...) and dv(...) and dp(...) and kv(...) and mn(...) and mx(...) and mnx(...) and a few other built in parts of the Var class maybe, are the top nodes in the dag. vars are the leafs. For example, to compute e/exp by diffeq on theVar you do dp(theVar,theVar) which makes theVar increase exponentially gradually by dt at a rate of its own float value per second continuously. Start theVar.p = 1; Do that for 1 second in many dt size physics cycles. theVar.p should approx equal Math.E.

problem is puredata can get full of lots of lines and boxes. so i want functions of vector in to vector out. vecIns=>vecOuts which can be different sizes, even differ in sizes across different functions. These are simply piece of code that transform i input floats to o output floats. They are constant vector fields. They can be made of code or of combining multiple vector fields.

computing of poten has to be done in gradient numVars+1 times. since we are gonna do that sparsely, each node should remember its last value, and only update value upward from whatever node changed recursively, so things that didnt change dont have to be recomputed. if its +(*(b,c),*(d,e)) and d changes, then *(d,e) is recomputed, then +(*(...),*(d,e)) is recomputed without recomputing *(b,c), just using the prev value of *(b,c) cuz it wasnt marked from below that it changed. So we can change d by adding epsilon, compute total poten of whole game state, then change d back, to compute the derivative at d.

Waves, rules, etc will sometimes specify a Jo. Its a 1 Jo to many Vars mapping, but each nonJo var must map to at most 1 Jo
Todo
join: Cx Jo$GripA
join: Cy Jo$GripB
join: Cz Jo$GripC43

{
	p:1,v:0,
	Bellsack:{
		p:1,v:0,
		Room1:{
			p:1,v:0,
			Odos$bell5abcd1234:{
				p:1,v:0,
				big:[
					"Odos$",
					"comment: Example Odos$ bell5",
					"readFields: Cx Cy Cz Cr",
					"func: (wv,X,Y,Z)=>{",
					"	float dx = X.p - wv.Cx.p;",
					"	float dy = Y.p - wv.Cy.p;",
					"	float dz = Z.p - wv.Cz.p;",
					"	float dist2 = dx*dx + dy*dy + dz*dz;",
					"	return wv.p * exp(-dist2/(2.*wv.Cr.p*wv.Cr.p));",
					"}"
				],
				Lone:{
					p:1,v:0,
					Lone:{
						p:1,v:0,
						B500:{p:1,v:0, Cx:{p:0},Cy:{p:0},Cz:{p:0}, Cr:{p:0.6}}
					}
				}
			},

			PotenNearPairs$grav123hash:{
				p:1,v:0,
				big:[
					"PotenNearPairs$",
					"comment: Example PotenNearPairs$ gravity",
					"aOdos: Odos$bell5abcd1234",
					"aNonzeroFields: Cr",
					"aReadFields: X Y Z Cr",
					"bOdos: Odos$bell5abcd1234",
					"bNonzeroFields: Cr",
					"bReadFields: X Y Z Cr",
					"func: (a,b,Cc)=>{",
					"	float dx=a.Cx.p-b.Cx.p;",
					"	float dy=a.Cy.p-b.Cy.p;",
					"	float dz=a.Cz.p-b.Cz.p;",
					"	float dist2=dx*dx+dy*dy+dz*dz;",
					"	float r=sqrt(dist2);",
					"	if(r<Cc) r=Cc;",
					"	return -(a.p*b.p)/r;",
					"}"
				],
				Gravity01:{p:1,v:0, Cx:{p:0},Cy:{p:0},Cz:{p:0}, Cr:{p:64},Cc:{p:0.5}}
			},

			PotenOnes$center321hash:{
				p:1,v:0,
				big:[
					"PotenOnes$",
					"comment: Example PotenOnes$ centering",
					"odos: Odos$bell5abcd1234",
					"nonzeroFields: Cr",
					"readFields: X Y Z",
					"func: (g)=>{",
					"	float r2=g.Cx.p*g.Cx.p+g.Cy.p*g.Cy.p+g.Cz.p*g.Cz.p;",
					"	return 0.01*r2;",
					"}"
				],
				Centering01:{p:1,v:0, Cx:{p:0},Cy:{p:0},Cz:{p:0}, Cr:{p:64}}
			},

			DiffeqOnes$decay456hash:{
				p:1,v:0,
				big:[
					"DiffeqOnes$",
					"comment: Example DiffeqOnes$ decay",
					"odos: Odos$bell5abcd1234",
					"nonzeroFields: Cr",
					"readFields: Cr",
					"func: (g)=>{",
					"	g.Cr.dV(-0.1*g.Cr.p);",
					"}"
				],
				Decay01:{p:1,v:0, Cx:{p:0},Cy:{p:0},Cz:{p:0}, Cr:{p:32}}
			},

			DiffeqNearPairs$repulse789hash:{
				p:1,v:0,
				big:[
					"DiffeqNearPairs$",
					"comment: Example DiffeqNearPairs$ repulsion",
					"aOdos: Odos$bell5abcd1234",
					"aReadFields: Cx Cy Cz",
					"bOdos: Odos$bell5abcd1234",
					"bReadFields: Cx Cy Cz",
					"func: (a,b)=>{",
					"	float dx=a.Cx.p-b.Cx.p;",
					"	float dy=a.Cy.p-b.Cy.p;",
					"	float dz=a.Cz.p-b.Cz.p;",
					"	float dist2=dx*dx+dy*dy+dz*dz;",
					"	if(dist2<1.0){",
					"		a.Cx.dP(0.1*dx);",
					"		b.Cx.dP(-0.1*dx);",
					"	} ",
					"}"
				],
				Repulse01:{p:1,v:0, Cx:{p:0},Cy:{p:0},Cz:{p:0}, Cr:{p:64},Cc:{p:1}}
			},

			PotenGlobal$rule111hash:{
				p:1,v:0,
				big:[
					"PotenGlobal$",
					"comment: Example PotenGlobal$ constant",
					"func: ()=>{",
					"	return 1.0;",
					"}"
				],
				Global01:{p:1,v:0}
			},

			User$abcdefffhash:{
				p:1,v:0,
				big:[
					"User$",
					"comment: Example User$",
					"pubkey: ed25519:abcdef123456"
				]
			},

			Jo$Blah55:{p:1,v:0, comment: 'jo is edjoint like in dagball, see join: lines in .big'},
			
		}
	}
}

`
);

</script>
<script>
//Bellsack*.js, opensource/Apache2 (versions before Bellsack256/2025-8-3 are MIT) by Ben F Rayfield.
"use strict";

var Err = msg=>{ throw new Error(msg); };

/***************************************************************
 * 1) Config
 ***************************************************************/

//rock paper scissors constants from blobMonstersGame_2025-3-27.html copied 2025-8-18.
const GteamShield = 0;
const GteamRock = 1; //see game.doRps.p and Gob.m.team
const GteamPaper = 2; //see game.doRps.p and Gob.m.team
const GteamScissor = 3; //see game.doRps.p and Gob.m.team

//rock paper scissors constants from blobMonstersGame_2025-3-27.html copied 2025-8-18.
//A capture happens when 2 teams touch at the same pixel and a random weighted coin
//is heads cuz otherwise it sometimes wont break ties. Its per pixel,
//so if they slightly squeeze by in any strange shape without touching, even while reshaping, theres no capture.
//This works whether the distance cache (game.rps.tridist) has been updated or not. Its a big cache of 64 megapixels,
//normally only updated on the screen you're viewing at the time, and stays that way until you look near there again.
//The distance cache game.rps.tridist is where the ambient-light-like colors come from, showing the distance from
//each pixel to nearest voxel of REDTEAM, GREENTEAM, and BLUETEAM. Thats for chasing and running from eachother.
//Detecting collisions is easier. If you are on BLUETEAM your goal is to turn the whole game world blue
//before REDTEAM or GREENTEAM turn it those colors instead. Each team captures 1 color and is captured by the
//other color, around and around. Or maybe the amount of time the game world is mostly blue. I dont know.
//The game is supposed to produce a continuous stream of fun, that you can jump in for a minute, join a team,
//and leave, or 10 minutes. Its not longterm accumulation of items like in a RPG. Nobody gets kicked out for being
//captured or losing. They just change teams when captured.
//but the game should accumulate new species over long times, pieces of javascript code that bend into different
//shapes and move differently. This is the cambrian-explosion, that the game gets more and more fun over time cuz
//of player created content, including content by LLMs.
var predatorOf = team=>{ //reverse it so red chases green chases blue chases red.
	if(team == GteamShield) return GteamShield; //FIXME there is no predator or prey of GteamShield. its for walls and shields and is neutral.
	if(team == GteamScissor) return GteamRock;
	if(team == GteamPaper) return GteamScissor;
	if(team == GteamRock) return GteamPaper;
	Err('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
var preyOf = team=>{
	if(team == GteamShield) return GteamShield; //FIXME there is no predator or prey of GteamShield. its for walls and shields and is neutral.
	if(team == GteamRock) return GteamScissor;
	if(team == GteamScissor) return GteamPaper;
	if(team == GteamPaper) return GteamRock;
	Err('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

//TODO move this (Bellsack options) to ns.Opt or an Opt in ns.User.SomeUser435345.Opt or something like that?
//and make all values be numbers in .p (so no true/false use 1/0,
//and strings use ns.Opt.Lit$varname.StringValue.p=1 and must start with capital letter).
const opt = {
	//horizon: 60.0,			// how far to search for surfaces
	horizon: 1000,			// how far to search for surfaces
	//isRaymarch: 1,		 // variable-step or fixed-step. has the extra squiggley raytrace bug.
	isRaymarch: 0, //not has the extra squiggley raytrace bug. is less accurate than isRaymarch:1 in some ways, more accurate in others.
	//raytraceStep: .2,
	//raytraceStep: .1,
	//raytraceStep: .05,
	raytraceStep: .03,
	//raytraceStep: .01,
	//marchMaxSteps: 50,	 // maximum steps
	//marchMaxSteps: 150,	 // maximum steps
	//marchMaxSteps: 200,	 // maximum steps
	//marchMaxSteps: 40,	 // maximum steps
	marchMaxSteps: 300,	 // maximum steps
	//marchMaxSteps: 100,	 // maximum steps
	//closeEnufToZero: 0.01, // tolerance for crossing
	closeEnufToZero: 0.003, // tolerance for crossing
	//closeEnufToZero: 0.001, // tolerance for crossing
	//closeEnufToZero: 0.00001, // tolerance for crossing
	//circleBandPx: 1.5,		// ring thickness in screen px
	//circleBandPx: 7, //fat
	circleBandPx: 4, //normal
	//circleBandPx: 2, //thin
	//circleBandPx: 1,
	//circleBandPx: 0, //dont display rings
	//circleBandPx: 0,
	knobAngleBand: 0.15,	// how wide an angle for each knob (approx)
	//TOTAL_BELLS: 100000,
	//TOTAL_BELLS: 10000,
	//TOTAL_BELLS: 10000,
	TOTAL_BELLS: 2000,
	//TOTAL_BALLS: 22000,
	//TOTAL_BALLS: 5000,
	//TOTAL_BALLS: 2000,
	TOTAL_BALLS: 700,
	//TOTAL_BALLS: 70,
	//TOTAL_BALLS: 80,
	//TOTAL_BALLS: 300,
	//TOTAL_BALLS: 30,
	//TOTAL_BALLS: 150,
	//TOTAL_BALLS: 80,
	//NEAR_BELL5_TOTAL: 192,
	//NEAR_BELL5_TOTAL: 150,
	//NEAR_BELL5_TOTAL: 120,
	//NEAR_BELL5_TOTAL: 100,
	NEAR_BELL5_TOTAL: 80,
	//NEAR_BELL5_TOTAL: 50,
	//NEAR_BELL5_TOTAL: 30,
	//NEAR_BELL5_TOTAL: 170,
	//NEAR_BELL5_TOTAL: 10, //FIXME
	//NEAR_BELL5_TOTAL: 50, //each (simplest kind of, aka bell5) bell is 5 floats
	//NEAR_BELL5_TOTAL: 60, //each (simplest kind of) bell is 5 floats
	//NEAR_BELL5_TOTAL: 30, //each (simplest kind of) bell is 5 floats
	//NEAR_BALLS_TOTAL: 150,
	//NEAR_BALLS_TOTAL: 90,
	//NEAR_BALLS_TOTAL: 50,
	//NEAR_BALLS_TOTAL: 200,
	//NEAR_BALLS_TOTAL: 70,
	//NEAR_BALLS_TOTAL: 35,
	//NEAR_BALLS_TOTAL: 10,
	//NEAR_BALLS_TOTAL: 100,
	//NEAR_BALLS_TOTAL: 150,
	//NEAR_BALLS_TOTAL: 50, //each (simplest kind of) ball is 3 floats
	//NEAR_BALLS_TOTAL: 300, //each (simplest kind of) ball is 3 floats
	//NEAR_BALLS_TOTAL: 30, //each (simplest kind of) ball is 3 floats
	//NEAR_BALLS_TOTAL: 10,
	NEAR_BALLS_TOTAL: 3,
	KNOB_COUNT: 5,
	//displayCenterForwardOfCam: -4, //test
	displayCenterForwardOfCam: 0, //test
	//displayCenterForwardOfCam: 4, //normal
	displayTerrain: true, //normal
	//displayTerrain: false, //test
	color1: [1.0,0.2,0.2],
	color2: [0.2,1.0,0.2],
	color3: [0.2,0.2,1.0],
	doLamglLoopBody: true, //normal, tho havent got it to work as of 2025-6-29
	//doLamglLoopBody: false, //test
	//its checkbox instead: doPhysics: true, //normal soon after 2025-7-12 cuz adding physics code...
	//doPhysics: false, //test
	//signedDistanceNewtonIterations: 128,
	//signedDistanceNewtonIterations: 32,
	//moving to ns.Opt.SignedDistanceNewtonIterations.p signedDistanceNewtonIterations: 16,
	//signedDistanceNewtonIterations: 8,
	//signedDistanceNewtonIterations: 4,
	//signedDistanceSpeed: .1,
	//moved to ns.Opt.SignedDistanceSpeed.p in slider in top/red panel. signedDistanceSpeed: .3,
	//signedDistanceSpeed: 1,
	//signedDistanceSpeed: .15,
	//signedDistanceSpeed: .5, //0 to 1, affects how accurately it computes signedDistance. Lower is more accurate but needs higher signedDistanceNewtonIterations else its less accurate.
	minShootInterval: .2, //seconds
	//minShootInterval: .03, //seconds
	//minShootInterval: .1, //seconds
	//ballShootSpeed: 2.5,
	//ballShootSpeed: 22.5,
	ballShootSpeed: .9,
	//ballShootSpeed: .1,
	//gravityY: .3,
	gravityY: .03,
	//gravityY: .01,
	//gravityY: .2,
	//gravityY: .1,
	//gravityY: 0,
	//gravityY: 5.2,
	//gravityY: .6,
	//log_ballCacheVec4: true, //test, only logs if isBallCacheOptimization
	log_ballCacheVec4: false, //normal
	logLamglLoopBodyNthLogAddToGradientEtc: false,
	//moving to checkbox: graphicsDebug (changing that to ns.Opt.IsGraphicsDebug.p): true, //test, uses sfSourceMaker('graphicsDebug'), includes displaying (todo) ballCacheVec4 as vec3 near isosurface per ball, but only happens if the kind of physics (if chkIsBallCacheOptimization is checked) makes ballCacheVec4 (Lamgl.Texture).
	//graphicsDebug: false, //normal, uses sfSourceMaker('graphicsMain')
	//graphicsDebug_ballCacheVec4_displayRadius: .05, //only used if graphicsDebug and isBallCacheOptimization checkbox is checked.
	graphicsDebug_ballCacheVec4_displayRadius: .2, //only used if graphicsDebug (changing that to ns.Opt.IsGraphicsDebug.p) and isBallCacheOptimization checkbox is checked.
	graphicsDebug_distanceToBall_displayRadius: .3,
	//moved to be a checkbox: nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3: true, //normal. turned this back on 2025-8-9 in bellsack272.
	//moved to be a checkbox: nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3: false, //test, the old way before 2025-8-2
	//xyzGradientLimit: 10, //vec3 of gradient in nearestPointOnIsosurfaceFromXYZ is held to max this radius smoothly, where if its max half of this radius it doesnt change.
	xyzGradientLimit: 30, //vec3 of gradient in nearestPointOnIsosurfaceFromXYZ is held to max this radius smoothly, where if its max half of this radius it doesnt change.
	//densityOfSlightAttractToVec3_mul: 2.1,
	//2025-11-23 moving to ns.Opt.DensityOfSlightAttractToVec3_mul.p: densityOfSlightAttractToVec3_mul: .1, //range 0 (dont use) to probably shouldnt go higher than 10.
	//allTimeSpeeds0: true, //test. like pause but you can still move camera around and reshape terrain and emit balls, but balls and terrain dont move on their own. for testing isBallCacheOptimization where 2025-8-5 the balls are often flying away fast and becoming NaN .p and .v so numBalls becomes 0. Hold them still while figuring that out. Fix the bugs.
	allTimeSpeeds0: false, //normal
	physicsCyclesPerVideoFrame: 1, //normal
	//physicsCyclesPerVideoFrame: 4, //test
	//physicsCyclesPerVideoFrame: 8, //test
	//moved to checkbox debugGraphicsOnBallThatUsesSignedDistancePerPixel: true, //test
	//debugGraphicsOnBallThatUsesSignedDistancePerPixel: false, //normal
	//ballRadius: .05,
	ballRadius: .135,
	//rpsAccelMul: 1,
	//rpsAccelMul: .1,
	rpsAccelMul: 0,
	//rpsAccelMul: .4,
	logShaderTiming: false, //false is normal
	//maxBallSpeed: .7,
	//maxBallSpeed: 1.7,
	maxBallSpeed: 6.7,
	
	//when opt.brightMultiplierInIsosurface != 1, it does an extra rgbd Lamgl call to darken if ur inside
	//brightMultiplierInIsosurface: .4, //FIXME this might only work when graphicsDebug (changing that to ns.Opt.IsGraphicsDebug.p)?
	//darken factor when camPos is inside isosurface (densityAtXYZ(camPos)<0.) so open areas where balls can move are bright, and solid areas where they shouldnt be are dark.
	brightMultiplierInIsosurface: .2, //extra dark
	//brightMultiplierInIsosurface: .1, //very dark, for testing
	//doMouseOverlayEtc: true,
	doMouseOverlayEtc: false,
};

var centerToCenterDistance = (gobA, gobB)=>{
	return Math.hypot(gobA.X.p-gobB.X.p, gobA.Y.p-gobB.Y.p, gobA.Z.p-gobB.Z.p);
};

var ballHitsBall = (ballA,ballB)=>(centerToCenterDistance(ballA,ballB)<=(2*opt.ballRadius));

var bootDuration = undefined;

var estimateFPS = 60; //changed by update_estimateFPS many times per second. target FPS is 60 at least cuz thats how fast most HDMI screens update and is fast enuf for games.
var estimateFPS_lastTime = undefined;
var update_estimateFPS = function(){
	if(estimateFPS_lastTime === undefined) estimateFPS_lastTime = Lamgl.time();
	let now = Lamgl.time();
	let dt = Math.max(0,Math.min(now-estimateFPS_lastTime,1));
	estimateFPS_lastTime = now;
	return estimateFPS = estimateFPS*(1-dt) + 1; //TODO adjustable decay rate. +1 is 1 frame per frame to decay toward
};

console.log('Starting Bellsack. opt.NEAR_BELL5_TOTAL='+opt.NEAR_BELL5_TOTAL+', opt.NEAR_BALLS_TOTAL='+opt.NEAR_BALLS_TOTAL+', and the higher those are the longer it takes to WebGL compile. Each being 50 Takes about 1 second. Each being 100-150 takes about 8 seconds. TODO fix this loading time, should be alot lower.');


// Detailed flop estimation for physics pass
//This was made before the ballCache optimization, which made it alot faster. TODO update.
var estimateNumFlopsMapPerPhysicsCall = opt=>{
	const numBalls					 = opt.NEAR_BALLS_TOTAL;				// {# balls}
	const numBells					 = opt.NEAR_BELL5_TOTAL;					// {# bells per density eval}
	const newtonIterationCount		 = truncated_SignedDistanceNewtonIterations();// {Newton iterations/SDF}

	const flopPerBell				= 34;	 // {flops in one sumOfBellcurves iteration}
	const flopPerBallPair			= 20;	 // {flops in one ball–ball SDF slot}

	// GPU threads = 3 variables per ball + 1 neutral thread
	const numGpuThreads				= 3 * numBalls + 1;

	// Isosurface SDF cost per ball:
	//	 newtonIterationCount × 5 density calls/iter × numBells × flopPerBell
	const isosurfaceCostPerBall		= newtonIterationCount * 5 * numBells * flopPerBell;

	// Ball–ball loop cost per ball:
	//	 numBalls × flopPerBallPair
	const ballBallCostPerBall		= numBalls * flopPerBallPair;

	// Signed-distance cost per ball = isosurface + ball–ball
	const signedDistanceCostPerBall	= isosurfaceCostPerBall + ballBallCostPerBall;

	// Loss() cost per thread = numBalls × signedDistanceCostPerBall
	const lossCostPerThread			= numBalls * signedDistanceCostPerBall;

	// Total physics FLOPs = numGpuThreads × lossCostPerThread
	return numGpuThreads * lossCostPerThread;
};
var called_estimateNumFlopsMapPerPhysicsCall = null; //written once in startBellsack cuz it needs to read ns in ns.Opt.SignedDistanceNewtonIterations.p which doesnt exist yet


const bellsackStartLoadingTime = Lamgl.time();

// region to place random bellcurves
//const WORLD_SIZE = 70;
//const WORLD_SIZE = 30;
//const WORLD_SIZE = 15;
const WORLD_SIZE = 22;
//const WORLD_SIZE = 40;
//const WORLD_SIZE = 25;

//use this as x y and z position for things not to display or do physics on
//such as empty slots in "uniform vec3 ballXYZ[${opt.NEAR_BALLS_TOTAL}];".
const NULLXYZ = 1000000;

/***************************************************************
 * 2) Large set of bellcurves + a spatial grid
 ***************************************************************/

function pickRandomColor() {
	let r = Math.floor(128 + 128 * Math.random());
	let g = Math.floor(128 + 128 * Math.random());
	let b = Math.floor(128 + 128 * Math.random());
	return `rgb(${r},${g},${b})`;
}

/*class BellCurve {
	constructor(x, y, z, radius, strength, IsSelected) {
	this.x = x;
	this.y = y;
	this.z = z;
	this.radius = radius;
	this.strength = strength;
	// We'll store an integer color in [0..255] x 3 for convenience
	// or store it as random floats in [0..1], or just store a string and parse it in JS.
	// We'll store as random floats 0..1 so we can pass them to GPU if we want.
	// But for big sets we might skip it. For demonstration, let's store them anyway:
	this.colorR = 0.5 + 0.5 * Math.random();
	this.colorG = 0.5 + 0.5 * Math.random();
	this.colorB = 0.5 + 0.5 * Math.random();
	this.IsSelected = !!IsSelected;
	}
}*/

var Dom = id=>document.getElementById(id);

var Chk = id=>{
	//return true; //FIXME
	let dom = Dom(id);
	if(dom){
		//console.log('dom node id='+id+' checked='+dom.checked);
		return dom.checked;
	}else{
		console.log('WARNING: dom node of checkbox not found so returning false as if unchecked, id='+id);
		return false;
	}
};

var doTestDisplay = ()=>{
	const isSparse = document.getElementById('testDisplayIsSparseXY').checked;
	const bigLog = document.getElementById('testDisplayLogsBigTensor').checked;
	Lamgl.testDisplay(isSparse, bigLog, Lamgl.time());
	if(document.getElementById('continueTestDisplay').checked){
		requestAnimationFrame(doTestDisplay);
	}
};

/*class SpatialGrid {
	constructor(cellSize) {
		//this.cellSize = cellSize;
		//this.cells = new Map();
		this.bellList = []; //FIXME remove this when get SpatialGrid working
	}
	/*_cellKey(x,y,z) {
	let ix = Math.floor(x/this.cellSize);
	let iy = Math.floor(y/this.cellSize);
	let iz = Math.floor(z/this.cellSize);
	return `${ix},${iy},${iz}`;
	}*
	insert(bc) {
	/*let k = this._cellKey(bc.x, bc.y, bc.z);
	if(!this.cells.has(k)) this.cells.set(k, []);
	this.cells.get(k).push(bc);
	*
	this.bellList.push(bc);
	}
	queryNearby(cx,cy,cz, range){
	let ret = [];
	let rangeSq = range**2;
	for(let bell of this.bellList){
		if((bell.x-cx)**2 + (bell.y-cy)**2 + (bell.z-cz)**2 <= rangeSq){
			ret.push(bell);
		}
	}
	return ret;
	/*
	const minX = Math.floor((cx-range)/this.cellSize);
	const maxX = Math.floor((cx+range)/this.cellSize);
	const minY = Math.floor((cy-range)/this.cellSize);
	const maxY = Math.floor((cy+range)/this.cellSize);
	const minZ = Math.floor((cz-range)/this.cellSize);
	const maxZ = Math.floor((cz+range)/this.cellSize);
	let arr=[];
	for(let ix=minX; ix<=maxX; ix++){
		for(let iy=minY; iy<=maxY; iy++){
		for(let iz=minZ; iz<=maxZ; iz++){
			let key=`${ix},${iy},${iz}`;
			if(this.cells.has(key)){
			arr.push(...this.cells.get(key));
			}
		}
		}
	}
	return arr;
	*
	}
}*/

//let allBells=[];
//let spatialGrid=null;
var allBell5s = ()=>Object.values(NS.Bell5.pu);

let NS = V.Bellsack.Room1; //FIXME make this a url param or something
let ns = NS;
let v = V;
let Ball = NS.Ball; //Var where balls are childs

let nextBallNameSuffix = 1;

var newBallName = ()=>('B'+(nextBallNameSuffix++));

function buildWorld(){
	//use Var.search* instead. spatialGrid=new SpatialGrid(10);
	//let Bell5 = NS.Bell5; //creates something like V.Bellsack.Room1.Bells which is a Var instance
	for(let i=0; i<opt.TOTAL_BELLS; i++){
		let x = (Math.random()-0.5)*WORLD_SIZE;
		let y = (Math.random()-0.5)*WORLD_SIZE;
		let z = (Math.random()-0.5)*WORLD_SIZE;
		//TODO use ns.T for time
		let r = 0.2+ 0.3*Math.random();
		let s = Math.random()*2.0-1.0;
		let bell = NS.Bell5.new('B'); //Var instance
		//pr is spring target for p. ps is spring strength. These hold eachVar.p toward these starting values
		//while the 3d bellcurves can vibrate like if balls land on them.
		let springStrength = 10;
		//let springStrength = 0;
		bell.X.setNow(x).setPr(x).setPs(springStrength);
		bell.Y.setNow(y).setPr(y).setPs(springStrength);
		bell.Z.setNow(z).setPr(z).setPs(springStrength);
		bell.R.setNow(r).setPr(r).setPs(springStrength);
		bell.setNow(s).setPr(s).setPs(springStrength); //see dagball.Circ.influence and dagball.Ball.influence, this goes in parent of the fields.
		//Err('TODO remove spatialGrid etc');
		
		
		//let bc= new BellCurve(x,y,z,r,s,false);
		//allBells.push(bc);
		//spatialGrid.insert(bc);
	}
	console.log("Created", allBell5s().length, "bellcurves in", WORLD_SIZE, "^3 region");
	
	let ballSpread = WORLD_SIZE;
	ballSpread = 7; //FIXME
	console.error('TODO [TODO use ns.T for time, that all objects read, similar to ns.X ns.Y ns.Z.] see that comment, do it, and change X Y Z to Cx Cy Cz Cr etc');
	for(let i=0; i<opt.TOTAL_BALLS; i++){
		let ball = Ball[newBallName()];
		ball.X.p = (Math.random()-0.5)*ballSpread;
		ball.Y.p = (Math.random()-0.5)*ballSpread;
		ball.Z.p = (Math.random()-0.5)*ballSpread;
		//TODO use ns.T for time, that all objects read, similar to ns.X ns.Y ns.Z.
		//ns.T.p will allow a shape function (like bell5 or mandelbulb etc) to vary by time
		//without having to use diffeq. (x,y,z,t) is a 4d coordinate.
		//At each (x,y,z,t) theres a density. Positive density is inside the solid shape/terrain/etc.
		//0 density is on isosurface. Negative density is open area, where balls etc can move around.
		//An escalator is a constant 4d shape that repeats on an interval.
		//A catapult can be put on such a time loop to launch whatevers in its bucket repeatedly.
		//A tree with fractal branches and leafs can be made to swing in cheap fake window
		//by simply bending a certain way at certain times by an equation built in.
		//potenfunc can depend on ns.T.p also.
		
		ball.Tm.p = 1+randInt(3); //team, rock paper or scissors (or 0 is shield/doesntChangeTeamsWhenHit)
		//ball.Tm.p = 0; //GteamShield
		//ball.Tm.p = randInt(4); //team, shield rock paper or scissors (or 0 is shield/doesntChangeTeamsWhenHit)
		let springStrength = 0; //let balls move anywhere
		//let springStrength = 3.45; //hold ball near its starting position by invisible spring
		//let springStrength = -.45; //hold ball near its starting position by invisible spring
		//let springStrength = .05; //hold ball near its starting position by invisible spring
		ball.X.setPr(ball.X.p).setPs(springStrength);
		ball.Y.setPr(ball.Y.p).setPs(springStrength);
		ball.Z.setPr(ball.Z.p).setPs(springStrength);
		ball.Z.p = (Math.random()-0.5)*ballSpread;
		//ball.X.p = 0;
		//ball.Z.p = 0;
		
		/*let fract = i/opt.TOTAL_BALLS;
		ball.X.p = fract*ballSpread;
		ball.Y.p = fract*ballSpread;
		ball.Z.p = fract*ballSpread;
		*/
		//ball.R.p = (.5+.5*Math.random()); //red
		//ball.G.p = (.5+.5*Math.random()); //green
		//ball.B.p = (.5+.5*Math.random()); //blue
	}
	console.error('TODO addExampleWavyBells');
	//addExampleWavyBells();
	console.error('TODO using addExampleWavyBells, ns.Cw.Sak$123hashOfCode456.Wave1234 c being code/species (1 ghost per species), and balls stay as they are. Split later into multi species per 3 shaders, like 1-10 species per shader and 1-10 such groups compiled together, so can up to 100 species of terrain on screen at once. And do the (x,y,z,otherParams...)=>density thing, instead of just (x,y,z,otherParams...)=>density thing, so it can pump easier without having to change over time, as its at the core a 4d crossSection instead of 3d.');
};
var lastWavyBellFn = null;
var addExampleWavyBells = ()=>{
	/*console.log(Sak.transpileSakToJs(Sak.parseHeaders(V.Bellsack.Room1.Shape.Sak$2BG2aMMdjVDlwNcq6KKZU7YSBcFd$n1cidl$fzShYyR.big).Fn[0]))
	VM525:1 w=>{
		let dx = w.Cx.p-ns.X.p;
		let dy = w.Cy.p-ns.Y.p;
		let dz = w.Cz.p-ns.Z.p;
		let distSq = dx*dx + dy*dy + dz*dz;
		distSq += 5.*sin(dist2*1.09); //make it more wavy 3d shapes
		return w.p*Math.exp(-distSq/(2.*w.Cr.p*w.Cr.p)); //bell curve observation Cr stdDev
	}*/
let wavyBellShape = `Sak$w=>{
	//float dx = w.Cx.p-ns.X.p;
	//float dy = w.Cy.p-ns.Y.p;
	//float dz = w.Cz.p-ns.Z.p;
	float dx = w.X.p-ns.X.p;
	float dy = w.Y.p-ns.Y.p;
	float dz = w.Z.p-ns.Z.p;
	float distSq = dx*dx + dy*dy + dz*dz;
	distSq += 5.*sin(dist2*1.09); //make it more wavy 3d shapes
	//return w.p*Math.exp(-distSq/(2.*w.Cr.p*w.Cr.p)); //bell curve observation Cr stdDev
	return w.p*Math.exp(-distSq/(2.*w.R.p*w.R.p)); //bell curve observation Cr stdDev
}`;
	//ns.Cw.NameOfCodeAndGhost.NameOfWave as in the odoGhostWave system, simplified version of it
	//where all terrain shares the same odo (not named) and ghost is the code (hash id of it),
	//so every wave in that ghost is summed, and the ghosts are merged by max (of density)
	//so they can be sharded into multiple GPU shaders (used with Lamgl)
	//so you dont have to recompile other ghosts/codes/species just to add or change one of them.
	//There will be around 1-10 species/code per shader (group of 3 shaders: raytrace,
	//find point on isosurface nearest to each ball center (makes ballCache),
	//coompute physics using ballCache). 1-10 of those in each group of 3 shaders,
	//and (not implemented here in wavyBellShape but todo for future expansion) multiple such groups,
	//so you might have 10 species per shader group (of 3 shaders) and 10 groups,
	//so in 30 shader calls you get raytracing and physics of multiple instances of 100 unique species.
	let wavyBellShapeVar = ns.Cw[wavyBellShape]; //the ghost/species
	//let wavyBellShapeVar = ns.Shape[wavyBellShape];
	if(!wavyBellShapeVar.name.startsWith('Sak$')){
		Err('wavyBellShapeVar.name = '+wavyBellShapeVar.name);
	}
	if(wavyBellShapeVar.big != wavyBellShape){
		Err('wavyBellShapeVar.big = '+wavyBellShapeVar.big);
	}
	//console.error('TODO use '+wavyBellShapeVar.path()+' in wave.Ptrs$fn and raytrace it, first species other than balls and bell5s. '+wavyBellShapeVar.path()+'.big['+wavyBellShapeVar.big+']');
	-    console.error('TODO use '+wavyBellShapeVar.path()+' in wave.Ptrs$fn and raytrace it, first species other than balls and bell5s. '+wavyBellShapeVar.path()+'.big['+wavyBellShapeVar.big+']');
	// ------------------------------------------------------------------
	//  create N wavy-bell “species” and give each a Ptrs$fn entry
	// ------------------------------------------------------------------
	//const N = opt.NEAR_WAVY_BELLS_TOTAL ?? 32;   // add to opt if not present
	const N = opt.TOTAL_BELLS; //same number of wavy bells as bell5s. opt.NEAR_WAVY_BELLS_TOTAL ?? 32;   // add to opt if not present
	//let fnKey = wavyBellShapeVar.path();   // e.g. "ns.Shape.Sak$2B…"
	let fnKey = wavyBellShapeVar.path();   // e.g. "ns.Cw.Sak$2B…"
	let waveSpread = WORLD_SIZE;
	waveSpread = 7; //FIXME
	for(let k = 0; k < N; k++){
		//let wave = ns.Odos.Lone.Ghosts.Lone.Waves['WavyBell'+k];
		let wave = wavyBellShapeVar['WavyBell'+k];
		//add that func (wavyBellShapeVar) to that wave/Var so its called on that Var to update it every graphics/physics cycle
		//lastWavyBellFn = wave.Ptrs$fn[fnKey]; //use lastWavyBellFn for debug on browser console 2025-10-30+
		//lastWavyBellFn.p = 1;
		
	    //randomize bell position / radius here if desired
	    //      wave.Cx.p = someX;  wave.Cr.p = someR;
		wave.X.p = (Math.random()-0.5)*waveSpread;
		wave.Y.p = (Math.random()-0.5)*waveSpread;
		wave.Z.p = (Math.random()-0.5)*waveSpread;
		wave.Tm.p = 1+randInt(3); //team, rock paper or scissors (or 0 is shield/doesntChangeTeamsWhenHit)
		//ball.Tm.p = 0; //GteamShield
		//ball.Tm.p = randInt(4); //team, shield rock paper or scissors (or 0 is shield/doesntChangeTeamsWhenHit)
		let springStrength = 0; //let wave move anywhere
		//let springStrength = 3.45; //hold ball near its starting position by invisible spring
		//let springStrength = -.45; //hold ball near its starting position by invisible spring
		//let springStrength = .05; //hold ball near its starting position by invisible spring
		wave.X.setPr(wave.X.p).setPs(springStrength);
		wave.Y.setPr(wave.Y.p).setPs(springStrength);
		wave.Z.setPr(wave.Z.p).setPs(springStrength);
		wave.Z.p = (Math.random()-0.5)*waveSpread;
		
		console.log('created '+wave.path());
		
		console.log('I might leave it as wave.X wave.Y etc, since ns.X and wave.X are different Vars. FIXME change .X .Y .Z .R to .Cx .Cy .Cz .Cr cuz X Y Z are for sampling, Cx Cy Cz for 3d object center, but i gotta adjust Var.search code etc that way, cant just do it all at once here, now is 2025-10-30 im writing this.');
		
	}
};
buildWorld();

var multiprobe_vec3Offsets = [[0,0,0]]; //start with ball center. Add points near it (as 3d offsets)...
//var multiprobeCubeSides = [opt.ballRadius, opt.ballRadius*3];
var multiprobeCubeSides = [opt.ballRadius, opt.ballRadius*3, opt.ballRadius*6, opt.ballRadius*10, opt.ballRadius*15]; //FIXME this is too many. if theres 2 here its a total of 17 probes. each more adds 8 probes.
console.log('multiprobesPerBall='+(1+multiprobeCubeSides.length*8));
for(let cubeSide of multiprobeCubeSides) for(let dx=-1; dx<=1; dx+=2) for(let dy=-1; dy<=1; dy+=2) for(let dz=-1; dz<=1; dz+=2){
	multiprobe_vec3Offsets.push([cubeSide*dx, cubeSide*dy, cubeSide*dz]);
}
console.log('multiprobe_vec3Offsets='+JSON.stringify(multiprobe_vec3Offsets));
var multiprobe_vec3Offsets_glsl = 'const vec3 multiprobe_vec3Offsets['+multiprobe_vec3Offsets.length+'] = vec3[]('+multiprobe_vec3Offsets.map(
	xyz=>('vec3('+Lamgl.jsNumToGlslFloat(xyz[0])+','+Lamgl.jsNumToGlslFloat(xyz[1])+','+Lamgl.jsNumToGlslFloat(xyz[2])+')'))
	.join(',')+');';

/***************************************************************
 * 5) Single-Pass FS: Raymarch + Billboard Circles + GPU knobs
 ***************************************************************/

const svSource = `#version 300 es
in vec2 XY; //in vec2 position; If you call it "in vec2 XY;" then Lamgl does 2 triangles instead of gl_ VertexID.
//uniform int width;
out vec2 uv;
//out int ID;
void main(){
	//cant do this cuz its TRIANGLES instead of POINTS so theres too few vertexs, so use ID.x instead: ID = gl _VertexID; //so VarGradientGL generated sf/fragmentShader can use it
	uv = XY * 0.5 + 0.5;
	//ID = int(uv.x*float(width)); //range 0 to width-1
	gl_Position = vec4(XY, 0, 1); //normal
	//gl_Position = vec4(XY, XY.y, 1.+XY.x*2.1); //test Bellsack292_tiltedThe2TrianglePolygonsSoTheyDontFillTheScreen_byChanging(svSource).html
}`;

// I’ll then return the diff as a clean patch.
// We'll define NEAR_BELL5_TOTAL = opt.NEAR_BELL5_TOTAL
// We'll do a ring search for each bell & also a local tangent-plane transform
// to see if it's near 1 of the 5 knob angles, coloring them differently.
//funcName is one of strings: physicsSimple physicsCacheNearestVec4PerBall physicsUseNearestVec4PerBall graphicsMain graphicsDebug (changing that to ns.Opt.IsGraphicsDebug.p) (todo maybe graphicsOverlay)
//
//sfSourceMaker generates WebGL2 GLSL ES 300 fragement shader code for shaders that need (nearby parts of) the
//game world to be loaded into GPU memory. For other shaders u just call Lamgl directly any time u want.
//U can pass their outputs to eachother across Lamgl calls which return {} of Lamgl.Tensor objects.
//See Lamgl.doBasicTests() for examples of how to call Lamgl.
const sfSourceMaker = funcName=>{
const graphicsDebug = funcName=='graphicsDebug';
const isPhysicsElseGraphics = funcName!='graphicsMain' && !graphicsDebug;
const hasBallCacheUniformIn = graphicsDebug || funcName=='physicsUseNearestVec4PerBall';
if(!Chk('displayBallCacheVec3AsSecondBall')){
	throw new Error('No displayBallCacheVec3AsSecondBall, so sfSourceMaker is being called before dom is loaded');
}
const displayBallCacheVec3AsSecondBall = Chk('displayBallCacheVec3AsSecondBall');
const do_displayBallCacheVec3AsSecondBall = displayBallCacheVec3AsSecondBall && graphicsDebug;
const doRings = !isPhysicsElseGraphics && Chk('chkLevelEditor') && !Chk('chkSeparateRingsAsTexture');
//multiprobe: Before 2025-12-2 it was always 1 nearestPointOnIsosurfaceFromXYZ per ball,
//but going forward when this checkbox is checked, it might do for example 25 samples per ball,
//in 12 directions at 3 distances from center, or 5 samples one in center and 4 farther out in case
//of localmin, or maybe 9 for 3 distances from center in 4 directions.
const multiprobePhysics = Chk('multiprobe_isosurfaceBallPhysics') && isPhysicsElseGraphics; //TODO only do this in some of the physics shaders but not others. 2025-12-2 theres 3 main shaders, 1 graphics and 2 physics: raytrace, find nearest points on isosurface to each ball, use points on isosurface to do physics. The plan is to have 3 physics shaders by splitting "find nearest points on isosurface to each ball" into 2 shaders when multiprobe (multiprobe_isosurfaceBallPhysics) checkbox is checked. The first one does multiprobe_vec3Offsets.length GPU threads per ball to each run 1 nearestPointOnIsosurfaceFromXYZ from ballCenter+offsetVec3, and that should use the fourth number as sortVal vec4(x,y,z,sortVal). The next shader picks the vec4 with lowest sortVal (which is normally some combo of being close to isosurface aka density near 0 AND having low distance to ball center), and keep just 1 best of those found per ball. Then the last physics shader is unchanged. Raytracing is also unchanged.
//const nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3 =
//	Dom('chk_nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3').checked;
return `#version 300 es
precision highp float;
//sf/fragmentShader ${funcName}
in vec2 uv;
//in int ID; //int x from 0 to width-1, and since height=1 its pixel index
out vec4 outColor;

uniform int width;
//uniform float width; //FIXME make it int, but this might be crashing gl as int cuz Lamgl doesnt support uniform int vars yet?
//ID: range 0 to width-1. set in main(). Used by generated VarGradientGL.
//FIXME the generated VarGradientGL code goes at first line in main()
//which would be before ID is set in main(), so need to generate ID too
int ID; //FIXME this should be generated in perturbGlsl, not manually written here.

uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform float horizon;
uniform float isRaymarch;
uniform float closeEnuf;
uniform float DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan; //normally is approximately closeEnuf or maybe closeEnuf*10.
/*2025-11-21+ added another slider ns.Opt.AddToDensityForTesting which lets me see the whole 3d density field at any densityAtXYZ(vec3)=sum, at any sum. Normally this is 0 but I add to it this slider amount so the surface expands/shrinks. Result: No unusually high or low density found near bug. Still bugging.
*/
uniform float AddToDensityForTesting; //normally 0.0 but for testing 2025-11-21+ to see other slices we add AddToDensityForTesting inside densityAtXYZ(vec3) and vary it with a slider in the top/red panel.
uniform float circleBandPx;
uniform float knobAngleBand;	// how large an angle difference to consider a knob
uniform int selectedBellI; //-1 if none. 0 to NEAR_BELL5_TOTAL-1 if selected.

uniform float mouseY;
uniform float mouseX;

uniform int SignedDistanceNewtonIterations;
uniform float SignedDistanceSpeed; //ns.Opt.SignedDistanceSpeed.p
uniform float DensityOfSlightAttractToVec3_mul; //ns.Opt.DensityOfSlightAttractToVec3_mul.p
uniform float Display3dLocalMinsOfGradientMagLessThan; //ns.Opt.Display3dLocalMinsOfGradientMagLessThan.p

//uniform vec3 bellPositions[${opt.NEAR_BELL5_TOTAL}];
uniform float bellX[${opt.NEAR_BELL5_TOTAL}]; //TODO all in 1 float[${5*opt.NEAR_BELL5_TOTAL}]
uniform float bellY[${opt.NEAR_BELL5_TOTAL}];
uniform float bellZ[${opt.NEAR_BELL5_TOTAL}];
uniform float bellRadii[${opt.NEAR_BELL5_TOTAL}];
uniform float bellStrengths[${opt.NEAR_BELL5_TOTAL}];

//dynamic loop limits ── these come from JS every frame
uniform int	uBellCount;			// ≤ ${opt.NEAR_BELL5_TOTAL}
uniform int	uBallCount;			// ≤ ${opt.NEAR_BALLS_TOTAL}

//VarGradientXYZ does not support vec3 uniforms, but its ok to have vec3s where
//we are not computing gradient. We compute it in ballXYZ (changing to ballX ballY ballZ)
//but not in "uniform vec3 color2;" etc.
//uniform vec3 ballXYZ[${opt.NEAR_BALLS_TOTAL}];
uniform float ballX[${opt.NEAR_BALLS_TOTAL}]; //TODO all in 1 float[${3*opt.NEAR_BALLS_TOTAL}]
uniform float ballY[${opt.NEAR_BALLS_TOTAL}];
uniform float ballZ[${opt.NEAR_BALLS_TOTAL}];
${(funcName=='graphicsMain' || funcName=='graphicsDebug') ?
	`uniform float BallColorFloat[${opt.NEAR_BALLS_TOTAL}]; //24 bit color per ball` : '//no BallColorFloat'}

// We'll do no per-bell color for now, just ring vs knob vs surface. 
// If you want each bell to have a random color, you'd need arrays for that.
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;

${(graphicsDebug || (funcName=='physicsUseNearestVec4PerBall')) ?
	(Dom('addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform').checked ?
		`uniform vec4 ballCacheVec4[${opt.NEAR_BALLS_TOTAL}]; //for physicsUseNearestVec4PerBall and graphicsDebug` :
		'uniform sampler2D ballCacheVec4; //for physicsUseNearestVec4PerBall and graphicsDebug'
	)
	:
	'//no ballCacheVec4'
}

const int MARCH_MAX_STEPS = ${opt.marchMaxSteps};
const int KNOB_COUNT = ${opt.KNOB_COUNT};

//const float	BALL_R	 = 2.35;				 // TODO: make this a uniform array
//const float	BALL_R	 = .7;				 // TODO: make this a uniform array
//const float	BALL_R	 = 0.135;				 // TODO: make this a uniform array
const float	BALL_R	 = ${opt.ballRadius};				 // TODO: make this a uniform array
const float	BALL_R2	= BALL_R * BALL_R;		// radius², used in c term

//const int NEAR_BELL5_TOTAL = ${opt.NEAR_BELL5_TOTAL};
//const int NEAR_BALLS_TOTAL = ${opt.NEAR_BALLS_TOTAL};
//max array sizes stay as compile-time constants
const int NEAR_BELL5_TOTAL = ${opt.NEAR_BELL5_TOTAL};
const int NEAR_BALLS_TOTAL = ${opt.NEAR_BALLS_TOTAL};

uniform float numBalls; //at most NEAR_BALLS_TOTAL, ignore higher indexed balls, its padding

const float NULLXYZ = ${Lamgl.jsNumToGlslFloat(NULLXYZ)};

//#define EPSILON ${Lamgl.jsNumToGlslFloat(DefaultEpsilon)}
const float EPSILON = ${Lamgl.jsNumToGlslFloat(DefaultEpsilon)};

//const int SHAPE_BALL = 0;
//const int SHAPE_BELL5 = 1;
const int SHAPE_BELL5 = 0;
//TODO const int SHAPE_WAVY_BELL5 = 1;

const int NUM_SHAPES = 1;

//EstimatePhysicsFlop: bells*25
float sumOfBellcurves(in vec3 p){
	float val=0.;
	//for(int i=0; i<${opt.NEAR_BELL5_TOTAL}; i++){
	for(int i=0; i<uBellCount; ++i){
		//vec3 d = p - bellPositions[i];
		vec3 d = p - vec3(bellX[i],bellY[i],bellZ[i]);
		float dist2= dot(d,d);
		//dist2 += sin(dist2*33.); //FIXME this adds a sine wave outward from center of each bell5
		//dist2 += sin(dist2*3.9); //FIXME this adds a sine wave outward from center of each bell5
		//dist2 += 5.*sin(dist2*1.09); //FIXME this adds a sine wave outward from center of each bell5
		val += bellStrengths[i]* exp(-dist2/(2.0 * bellRadii[i]* bellRadii[i]));
	}
	return val;
}

//1 shapeId per species/codeType. There can be many instances of each species. TODO should instance be part of int shapeId? Maybe 12 bits per instance 12 bits per shape? Or a byte each?
float densityAtSXYZ(int shapeId, vec3 xyz){
	switch(shapeId){
		case SHAPE_BELL5:
			return sumOfBellcurves(xyz);
		default:
			return 0.;
	}
}

/*
//sum of all the species/codeTypes, including the 5 float 3d bellcurves.
//EstimatePhysicsFlop: sumOfBellcurves
//EstimatePhysicsFlop_temp: bells*25
//There are 2 densityAtXYZ funcs, one in GPU (and maybe will be multiple, one per species or group of species), and one in CPU/js called much fewer times per second just to find if camera is inside/outside and simple things like that.
float densityAtXYZ(in vec3 xyz){
	float density = sumOfBellcurves(xyz);
	density += AddToDensityForTesting;
	//TODO add other species/codeTypes here.
	return density;
}*/
float densityAtXYZ(vec3 xyz){//TODO replace all calls of densityAtXYZ with calls of densityAtSXYZ.
	return densityAtSXYZ(SHAPE_BELL5, xyz);
	//TODO other shapes? Should this loop over all int shapeId instead of just SHAPE_BELL5? Callers should be upgraded to call densityAtSXYZ instead of this.
}

// Regular-tetrahedron directions (all pair-wise equidistant)
const vec3 v0 = vec3( 1.0,	1.0,	1.0);
const vec3 v1 = vec3(-1.0, -1.0,	1.0);
const vec3 v2 = vec3(-1.0,	1.0, -1.0);
const vec3 v3 = vec3( 1.0, -1.0, -1.0);

${
multiprobe_vec3Offsets_glsl //Include this in any case, cuz various checkboxes use it
/*multiprobePhysics ?
`//is multiprobe. Defining directions. Lets try just cube corners at 3 distances for now.
${multiprobe_vec3Offsets_glsl} //creates const vec3[] named multiprobe_vec3Offsets`
:
`//no multiprobe, just 1 sample each (if samples at all, some physics shaders do).
vec3 multiprobe_vec3Offsets[1] = vec3[](vec3(0.,0.,0.));`
*/
}

vec3 gradientOfFourDensities(in vec4 fourDensities){
	float d0 = fourDensities.x;
	float d1 = fourDensities.y;
	float d2 = fourDensities.z;
	float d3 = fourDensities.w;
	return vec3(
		(d0 - d1 - d2 + d3),	 // ∂/∂x*4
		(d0 - d1 + d2 - d3),	 // ∂/∂y*4
		(d0 + d1 - d2 - d3)	// ∂/∂z*4
	)/(4.*EPSILON);
}

vec4 fourDensitiesAtXYZ(in vec3 p){
	float d0 = densityAtXYZ(p + EPSILON*v0);
	float d1 = densityAtXYZ(p + EPSILON*v1);
	float d2 = densityAtXYZ(p + EPSILON*v2);
	float d3 = densityAtXYZ(p + EPSILON*v3);
	return vec4(d0,d1,d2,d3);
}

vec4 fourDensitiesAtSXYZ(int shapeId, vec3 p){
	float d0 = densityAtSXYZ(shapeId, p + EPSILON*v0);
	float d1 = densityAtSXYZ(shapeId, p + EPSILON*v1);
	float d2 = densityAtSXYZ(shapeId, p + EPSILON*v2);
	float d3 = densityAtSXYZ(shapeId, p + EPSILON*v3);
	return vec4(d0,d1,d2,d3);
}

vec3 gradientAtSXYZ(int shapeId, vec3 xyz){
	return gradientOfFourDensities(fourDensitiesAtSXYZ(shapeId,xyz));
}

//gradient by 4 samples of densityAtXYZ which reads uniform float arrays only, no textures.
vec3 gradientAtXYZ(in vec3 p){
	// Sample the scalar field at the four vertices
	return gradientOfFourDensities(fourDensitiesAtXYZ(p));
	/*
	// Re-combine to isolate each partial derivative
	return vec3(
		(d0 - d1 - d2 + d3),	 // ∂/∂x*4
		(d0 - d1 + d2 - d3),	 // ∂/∂y*4
		(d0 + d1 - d2 - d3)	// ∂/∂z*4
	)/(4.*EPSILON);
	*/
}

//Use this instead of normalize(vec3). Returns length 1 if was already nonzero else vec3(0.,0.,0.).
/*GPT-o3 says 2025-8-2:[[[
In “pure” GLSL the result is undefined when the input length is 0.
The spec literally says:

“If x has length 0, the result is undefined.”
— Open GL ES 3.0 Shading Language §8.4, description of normalize (fn 10)

Because it’s undefined, IHVs are free to implement it in whatever is cheapest for their hardware:

GPU / driver	normalize(vec3(0)) actually produces
many NVidia PC drivers	vec3(0,0,0) (they clamp the reciprocal to 0)
most mobile Adreno / Mali	vec3(NaN,NaN,NaN) (division-by-zero flows through)
some older Intel drivers	implementation-dependent (zero in VS, NaN in FS)

So on your machine it may well appear to “work”, but on another browser / GPU the same shader explodes with NaNs. That’s why production code always guards it, e.g.:
]]]
*/
vec3 Norm(in vec3 p){
	float len = length(p);
	return len==0. ? vec3(0.,0.,0.) : p/len;
	
	//return normalize(p); //FIXME if p is all 0s this may get nans on some computers
}

//TODO optimize by calling densityAtXYZ 10 times instead of 16, in caller of this, redesign it:
//Reason for slowness is it computed 2 level gradient, gradient of a func that calls gradient,
//so 16 samples instead of 4. also can reduce that 16 to 10 by not considering order of pairs
//of v0+v4 vs v4+v1 vec3s summed. also dont multiply by epsilon every time.
//bellsack253FixedRedCirclesButGotLow(evenWhenBallCacheOptimizationIsOff)_diffBetweenBellsack240(40FPS)AndBellsack253(10FPS)AndFix253ThenProceedOnOptimization (Bellsack253.html vs Bellsack240.html).
//Its cuz its 4 groups of 4 samples, so 4 pairs of vectors added, and some of those sums duplicate eachother
//if you use the same size epsilon for both levels.
//
//UPDATE 2025-8-2 this is not an attract anymore but depends only on gradient angle relative to ball.
//observe is a point looking for part of isosurface nearest to ball center. attractTo is ball center.
//You mix this with densityAtXYZ (of isosurface) in nearestPointOnIsosurfaceFromXYZ by multiplying them
//or something like that (to experiment with, cuz a double newton loop would be better but too slow).
float densityOfSlightAttractToVec3(in vec3 observe, in vec3 attractTo){
//float densityOfSlightAttractToLowerDistance(float distance){
	/*float distance = length(observe-attractTo);
	//return 1+.01*tanh(distance);
	return 1.+distance;
	*/
	
	vec3 toAttract = attractTo-observe;
	vec3 gradientAtObserve = gradientAtXYZ(observe);
	vec3 toAttractNorm = Norm(toAttract);
	vec3 gradientNorm = Norm(gradientAtObserve);
	float dotProd = dot(toAttractNorm,gradientNorm); //0 if perpendicular (or either is 0), 1 or -1 if parallel
	//dotProd = isnan(dotProd) ? 0. : dotProd;
	float dotProdMag = abs(dotProd);
	float notDotProdMag = 1.-dotProdMag;
	//or should it be 1.-dotProd*dotProd or 1-abs(dotProd)?
	//float addToLossFromDotProd = .0045*(1.-dotProd)*(1.-dotProd); //prefer parallel (perpendicular surface)
	//float addToLossFromDotProd = .1*(1.-abs(dotProd)); //prefer parallel (perpendicular surface)
	//float addToLossFromDotProd = (1.-abs(dotProd)); //prefer parallel (perpendicular surface)
	//float addToLossFromDotProd = .0000000000001*dotProd; //prefer parallel (perpendicular surface)
	//float addToLossFromDotProd = densityOfSlightAttractToVec3_mul*dotProdMag; //wrong
	float addToLossFromDotProd = DensityOfSlightAttractToVec3_mul*notDotProdMag; //prefer parallel (perpendicular surface)
	return addToLossFromDotProd;
	//return 0.;
	//float distance = length(toAttract);
	//float addToLossFromDistance = distance; //prefer closer
	//return addToLossFromDotProd+addToLossFromDistance; //global minimum is 0
}

//fractionDone is 0.0 in first iteration of newtonLoop and 1.0 in last iteration and gradually between,
//to implement whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector.
float mergedDensity_isosurface_and_slightAttractToVec3(in vec3 observe, in vec3 attractTo, float fractionDone){
	//return densityAtXYZ(observe)+densityOfSlightAttractToVec3(observe,attractTo);
	
	//Fixed bug by adding abs in abs(densityAtXYZ(observe))+densityOfSlightAttractToVec3(observe,attractTo);
	//and one other place so its together a nonnegative loss function.
	//
	//Fixing bellsack302Bug_itsNotMovingTheSameInsideVsOutsideTheIsosurface 2025-8-24 in theory...
	//ive had enuf of this. Switch to the one im already using, which is simply SolveByMinimizeSum
	//of the sum of the 2 terms, but use abs(d(p)) instead of d(p) directly, as the first term, and
	//the second (angle loss) term is already nonnegative. so both are nonnegative. so newton loop
	//to minimize abs(d(p))+(1-abs(dot(norm(p-i),norm(gradient(d,p))))). so the only difference is an abs.
	/*GPTo3 talk 2025-8-24{{{{{
	Divide them into these categories: SolveBySumEqZero(isosurface way only, including if you somehow change the angle loss term into distance by flipping it depending on sign of isosurface) SolveByMinimizeSum(loss way only, including if you convert signedDistance into unsigned distance) SolveByBoth(including if you do iso way in some direction(s) and loss way in other direction(s)) SolveByOther(harmonySearch, random search, andOr any other way). All 4 of these categories are ways to find nearest point on isosurface to a queryPoint (such as ball center). I dislike SolveByOther cuz all those i know so far are jumpy which interferes with gradient calculation, but in case you have ideas other than the first 3, label them that. Now, categorize all those so far.
	...
	go into canvas editor. make a 2d table. algorithm is row. columns describe algorithms. make 1 column be the category (of those 4 i listed). another column for does it have each particular problem. problems include: * redaccabs - reduced accuracy of finding isosurface due to abs(signedDistance) (including if you square signedDistance) * discontinuous or very sharp near surface * ever has global minimum thats not on isosurface


	https://chatgpt.com/g/g-p-67e3e1532ca08191983aad7a25c9c520-bellsack/c/68a61c09-5c5c-832d-b402-e0ae345322aa
	not all these yes/no are correct:
	# Methods to Find Nearest Point on Isosurface (to a Ball)
	Legend: **Yes** = has the problem, **No** = does not.
	| Algorithm																| Category					 | Formula / Schematic													 | redaccabs | discontinuous near surface | steep near surface | global minimum not on isosurface | countYes | Notes																																								 |
	| ---------------------------------------- | ------------------ | --------------------------------------------- | --------- | -------------------------- | ------------------ | -------------------------------- | -------- | ------------------------------------------------------------------------------------- |
	| **Signed‑root blend**										| SolveBySumEqZero	 | F = sign(d) · sqrt(d² + α·pen²)							 | **No**		| **No**										 | **No**						 | **No**													 | **0**		| Smooth & symmetric; zero only when d=0 and pen=0. α≈0.01–0.1.												 |
	| **Augmented Lagrangian**								 | SolveByMinimizeSum | L = ½ d² + μ·d + ½ ρ·pen² (update μ,ρ)				| **No**		| **No**										 | **No**						 | **No**													 | **0**		| Robust; μ retains side info; needs tiny outer loop.																	 |
	| **Projected Newton (split step)**				| SolveByBoth				| Newton to d→0, then tangential descent on pen | **No**		| **No**										 | **No**						 | **No**													 | **0**		| Fast; tune β; occasionally re‑snap to wall.																					 |
	| **Constrained Gauss–Newton (2‑eq root)** | SolveByBoth				| G=\[d, 1−dot(u,n)]; solve (JᵀJ)δ=−JᵀG				 | **No**		| **No**										 | **No**						 | **No**													 | **0**		| Principled; 2×2 solve; may need damping.																							|
	| **Angle‑normalized sum (iso‑style)**		 | SolveBySumEqZero	 | F = d + λ·(1−dot(u,n))·sign(d)								| **No**		| **No**										 | **Yes**						| **No**													 | **1**		| Keeps sign; may need smoothing guard for unit vectors; kink near d≈0 unless smoothed. |
	| **Conservative sign add**								| SolveBySumEqZero	 | F = d + sign(d)·pen													 | **No**		| **No**										 | **Yes**						| **No**													 | **1**		| Simple; sharper near d≈0.																														 |
	| **Plain add/subtract** *(pitfall)*			 | SolveBySumEqZero	 | F = d ± pen																	 | **No**		| **No**										 | **No**						 | **Yes**													| **1**		| Fails on one side (root shifts/vanishes).																						 |
	| **Smooth ‖d‖ + angle loss**							| SolveByMinimizeSum | L = smoothAbs(d) + λ·pen											| **Yes**	 | **No**										 | **No**						 | **No**													 | **1**		| Stable minimization; loses sign/direction right at wall.															|
	| **Quadratic loss**											 | SolveByMinimizeSum | L = ½ d² + ½ λ·pen²													 | **Yes**	 | **No**										 | **No**						 | **No**													 | **1**		| Zero when both terms zero; good as refinement; unsigned d².													 |
	| **Abs‑weighted sum** *(pitfall)*				 | SolveBySumEqZero	 | F = d + pen·\|d\|														 | **Yes**	 | **No**										 | **Yes**						| **No**													 | **2**		| Loses preference exactly on wall; root remains at d=0.																|
	| **Stochastic / annealing**							 | SolveByOther			 | random / global search over surface					 | **No**		| **Yes**										| **No**						 | **Yes**													| **2**		| Jumpy; not gradient‑friendly; poor per‑frame stability.															 |
	| **Alternating projections**							| SolveByOther			 | bounce between wall & normal ray							| **No**		| **Yes**										| **No**						 | **Yes**													| **2**		| Simple but can ping‑pong on high curvature.																					 |

	**Key:** d = densityAtXYZ(p) (signed); pen = 1−dot(unit(p−ball), unit(∇d)); u = unit(p−ball); n = unit(∇d).



	----------

	# Methods to Find Nearest Point on Isosurface (to a Ball)

	Legend: **Yes** = has the problem, **No** = does not.

	| Algorithm																| Category					 | Formula / Schematic													 | redaccabs | discontinuous near surface | steep near surface | slow cuz double loop | global minimum not on isosurface | countYes | Notes																																															|
	| ---------------------------------------- | ------------------ | --------------------------------------------- | --------- | -------------------------- | ------------------ | -------------------- | -------------------------------- | -------- | -------------------------------------------------------------------------------------------------- |
	| **Constrained Gauss–Newton (2‑eq root)** | SolveByBoth				| G = \[ d , 1 - dot(u,n) ]										 | **No**		| **No**										 | **No**						 | **No**							 | **No**													 | **0**		| Principled; 2×2 solve; may need damping.																													 |
	| **Signed-dot two‑eq root**							 | SolveByBoth				| G = \[ d , sign(d)\*dot(u,n) − 1 ]						| **No**		| **Yes**										| **No**						 | **No**							 | **No**													 | **1**		| Uses sign(d)·dot(u,n) so flips sign exactly at d=0; otherwise smooth; solved with same 2×2 method. |
	| **Projected Newton (split step)**				| SolveByBoth				| Newton to d→0, then tangential descent on pen | **No**		| **No**										 | **No**						 | **Yes**							| **No**													 | **1**		| Fast; tune β; occasionally re‑snap to wall.																												|
	| **Signed‑root blend**										| SolveBySumEqZero	 | F = sign(d) · sqrt(d² + α·pen²)							 | **No**		| **Yes**										| **No**						 | **No**							 | **No**													 | **1**		| Smooth but flips sign exactly at d=0; treat as discontinuous there. α≈0.01–0.1.										|
	| **Augmented Lagrangian**								 | SolveByMinimizeSum | L = ½ d² + μ·d + ½ ρ·pen² (update μ,ρ)				| **Yes**	 | **No**										 | **No**						 | **No**							 | **No**													 | **1**		| Robust; μ retains side info; needs tiny outer loop.																								|
	| **Angle‑normalized sum (iso‑style)**		 | SolveBySumEqZero	 | F = d + λ·(1−dot(u,n))·sign(d)								| **No**		| **No**										 | **Yes**						| **No**							 | **No**													 | **1**		| Keeps sign; may need smoothing guard; kink near d≈0 unless smoothed.															 |
	| **Conservative sign add**								| SolveBySumEqZero	 | F = d + sign(d)·pen													 | **No**		| **No**										 | **Yes**						| **No**							 | **No**													 | **1**		| Simple; steeper near d≈0.																																					|
	| **Plain add/subtract** *(pitfall)*			 | SolveBySumEqZero	 | F = d ± pen																	 | **No**		| **No**										 | **No**						 | **No**							 | **Yes**													| **1**		| Fails on one side (root shifts/vanishes).																													|
	| **Smooth ‖d‖ + angle loss**							| SolveByMinimizeSum | L = smoothAbs(d) + λ·pen											| **Yes**	 | **No**										 | **No**						 | **No**							 | **No**													 | **1**		| Stable minimization; loses sign/direction right at wall.																					 |
	| **Quadratic loss**											 | SolveByMinimizeSum | L = ½ d² + ½ λ·pen²													 | **Yes**	 | **No**										 | **No**						 | **No**							 | **No**													 | **1**		| Zero when both terms zero; good as refinement.																										 |
	| **Abs‑weighted sum** *(pitfall)*				 | SolveBySumEqZero	 | F = d + pen·\|d\|														 | **Yes**	 | **No**										 | **Yes**						| **No**							 | **No**													 | **2**		| Loses preference exactly on wall; root remains at d=0.																						 |
	| **Stochastic / annealing**							 | SolveByOther			 | random / global search over surface					 | **No**		| **Yes**										| **No**						 | **No**							 | **Yes**													| **2**		| Jumpy; not gradient‑friendly; poor per‑frame stability.																						|
	| **Alternating projections**							| SolveByOther			 | bounce between wall & normal ray							| **No**		| **Yes**										| **No**						 | **No**							 | **Yes**													| **2**		| Simple but can ping‑pong on high curvature.																												|

	**Key:** d = densityAtXYZ(p) (signed); pen = 1−dot(unit(p−ball), unit(∇d)); u = unit(p−ball); n = unit(∇d).



	new subject. add a new row: Its a SolveByVec2EqualsZeroZero. It uses d(p) as is. It does not use e(p). Instead it uses the 2 normed (len 1) vectors (gradient of d(p) as usual, and direction to/from ball as usual). Call those vecGrad and vecBall. So we've been using 1-abs(dot(vecGrad,vecBall)) or something like that, which is 0 when the 2 vectors are parallel (1 minus abs of: -1 or 1) and is 1 at worst angles. This profers the normal vector of isosurface be pointing exactly toward or exactly away from ball. We make 2 numbers the are both solved by SolveBySumEqZero, so together thats SolveByVec2EqualsZeroZero. We simply use a signed number for the angle by preferring vecGrad be in same direction as vecBall OR preferring it be opposite direction of vecBall, depending on sign(d(p)). We know from that sign whether the ball center (p) is inside vs outside the isosurface.

	Added the new row “Signed-dot two-eq root” with its problem flags (Yes on the discontinuity, No elsewhere) and updated its countYes to 1. Let me know if any of those flags should be different or if you’d like further detail in the Notes cell.

	You say its "discontinuous near surface". But im not sure what you mean since at each point it is a vec2 not a scalar.

	make u and n both be from isosurface point i. norm(p-i) and norm(gradient(p)). So when they're same direction, ball is inside isosurface cuz it has positive density aka d(p). When ball is outside isosurface they are opposite directions. We take sign(d(p)) to know if p is inside vs outside, and from that we build the function to solve. something like vec2(d(p), sign(d(p))*dot(norm(p-i),norm(gradient(d,p))))



	[You can give the angle constraint both positive / negative values simply by adding the sign instead of multiplying it: g2(p) = dot(u , n) + sign( d(p) ); side of wall d(p) sign target dot(u,n) g2 when aligned g2 off-target outside ball (d > 0) +1 –1 (–1)+(+1)=0 > 0 inside ball (d < 0) –1 +1 (+1)+(–1)=0 < 0] No. I mean for a certain ball position p, thats already either inside or outside, that it would have positives and negatives in range. It likely is, by the problem i gave, impossible to define it that way, but i still would have preferred it. If it can be done, find a way. If not, say its mathly impossible. The reason I dislike 1 of the scalars in vec2 having a 0 as an extreme, is that the newton loop would tend to be jumpy if it cant reach 0 in 1 of them. Lets take just the original funcs: vec2(d(p), 1-abs(dot of angle stuff)). We do want that to converge to vec2(0,0). The range is vec2(plus/minus infinity, 0..1). If we simply choose a sum of 2 next step vectors and move p by that in the newton loop, is that basically what we're doing here? Is there a better way?


	Given 3x2 jacobian, aka 2 vec3s (gradientDensity,gradientAngle) each being a gradient (one of d(p) and one of the angle loss), and current point i (searching outward from p for the isosurface), and opt.signedDistanceSpeed (0..1) to multiply how far to jump per newton iteration, then what should nextI be (the next i)?
	}}}}}
	*/
	
	//fractionDone is 1 depending on a checkbox (TODO which?), else increases from 0 to 1 gradually during the newton-loop
	//of finding the approx nearest vec3 on isosurface to a ball center.
	//The gradual 0..1 way makes it vary its behaviors alot depending on the loop size (number of newton iterations)
	//since it does more iterations with fractionDone near 0 before it reaches near 1, so it does most of the work
	//and the remaining newton iterations have little effect if they've already found a localMin.
	//That might be fixed by scaling the amount of change per newton iteration by the number of iterations,
	//which is in ns.Opt. something what was that var or other options? 2025-12-2.
	return abs(densityAtXYZ(observe))+fractionDone*densityOfSlightAttractToVec3(observe,attractTo); //sum of 2 nonnegatives
	//If you change the abs here u gotta also change it in gradientAtXYZ_including_densityOfSlightAttractToVec3
	
	//FIXME TODO int shapeId in densityOfSlightAttractToVec3 etc.
}

//use with gradientOfFourDensities
vec4 fourDensitiesOf_densityOfSlightAttractToLowerDistance(in vec3 observe, in vec3 attractTo, float fractionDone){
	float d0 = densityOfSlightAttractToVec3(observe+EPSILON*v0, attractTo);
	float d1 = densityOfSlightAttractToVec3(observe+EPSILON*v1, attractTo);
	float d2 = densityOfSlightAttractToVec3(observe+EPSILON*v2, attractTo);
	float d3 = densityOfSlightAttractToVec3(observe+EPSILON*v3, attractTo);
	return fractionDone*vec4(d0,d1,d2,d3);
}

vec3 gradientAtXYZ_including_densityOfSlightAttractToVec3(in vec3 observe, in vec3 attractTo, float fractionDone){
	vec4 surfaceFourDensities = fourDensitiesAtXYZ(observe);
	
	//This abs is part of the fix for bug bellsack302Bug_itsNotMovingTheSameInsideVsOutsideTheIsosurface .
	//adding the abs like in mergedDensity_isosurface_and_slightAttractToVec3, since this duplicates it:
	surfaceFourDensities = abs(surfaceFourDensities);
	
	vec4 attractToBallCenterFourDensities = fourDensitiesOf_densityOfSlightAttractToLowerDistance(observe,attractTo,fractionDone);
	//vec4 mergedFourDensities = surfaceFourDensities*attractToBallCenterFourDensities;
	vec4 mergedFourDensities = surfaceFourDensities+attractToBallCenterFourDensities;
	return gradientOfFourDensities(mergedFourDensities);
}

// Positive outside, negative inside.
//EstimatePhysicsFlop: balls*8
float signedDistanceToBallsAtXYZExcludingBallIndex(vec3 fromXYZ, int excludeBallIndex){
	float minSignedDistance = NULLXYZ; //big positive
	//for(int bi=0; bi<NEAR_BALLS_TOTAL; bi++){
	for(int bi=0; bi<uBallCount; ++bi){
		if(bi != excludeBallIndex){ //TODO nonbranching
			vec3 otherXYZ = vec3(ballX[bi],ballY[bi],ballZ[bi]);
			float centerToCenterDistance = length(fromXYZ-otherXYZ);
			//float signedDistance = centerToCenterDistance-2.*BALL_R; //TODO balls can have diff radius than eachother?
			float signedDistance = centerToCenterDistance-BALL_R; //only 1 ball. TODO balls can have diff radius than eachother?
			minSignedDistance = min(minSignedDistance, signedDistance);
		}
	}
	return minSignedDistance;
}

//returns a vec3 of length at most 1, same vec3 as input if its length is already at most .5 .
vec3 easeVec3Unit(vec3 p){
	//wolframalpha: graph y = x*(1 - UnitStep(x - 0.5)) + UnitStep(x - 0.5)*(1-.25/x), x = -1 to 5
	float len = length(p);
	return len<.5 ? p : (p/len*(1.-.25/len));
}

//returns a vec3 of at most radius maxRadius,
//that is identityFunc (other than roundoff) if at most maxRadius/2
vec3 easeVec3(vec3 p, float maxRadius){
	return easeVec3Unit(p/maxRadius)*maxRadius;
}

//scaled tanh
float stanh(float x, float scale){
	return scale*tanh(x/scale);
}

/*
//3 scaled tanhs
vec3 stanh(vec3 x, float scale){
	return scale*tanh(x/scale);
}

vec3 limitGradient(vec3 gradient){
	return stanh(gradient,${Lamgl.jsNumToGlslFloat(opt.gradientLimit)});
}*/

/*2025-11-16 TODO GPT helps with this kind of math problem. Theres some quotes of GPT in the comments
from months ago too. I just said to GPT:
No more crashing bugs. just physics adjustment. the balls are going thru the surface sometimes.
when they do, some keep going, but others come back as if bouncing just too far into penetration.
there might have been another surface nearby behind it interfering, not sure. but the point is i
want you to help me make more accurate "vec3 nearestPointOnIsosurfaceFromXYZ(in vec3 p0)"
function so the balls bounce on the correct point on the surface, smoothly bounce. remember it
is done globally by position += dt*velocity; velocity -= dt*gradient(lossFunc,position);
velocity *= Math.exp(-dt*velocityDecayPerSec);
*/
//vec3 nearestPointOnIsosurfaceFromXYZ(in vec3 p0){
//startFrom is normally ballCenter+multiprobe_vec3Offsets[offsetId].
//ballCenter doesnt have to be the center of a ball. It can be any vec3. Thats just what its normally used for.
//In theory it could also be used for isosurface-isosurface physics but as of 2025-12-2 its only ball-isosurface physics.
/*
2025-12-2 vec3 nearestPointOnIsosurfaceFromXYZ(vec3 ballCenter, vec3 startFrom) i added vec3 startFrom.
that makes sense cuz thats how the optimization works, it cares about the 3d angle to ballCenter
but starts its search for localMin at a chosen vec3 startFrom
*/
//endItersEarly ranges 0 to SignedDistanceNewtonIterations inclusive and is only used for displaying the internal workings of this algorithm for testing.
vec3 nearestPointOnIsosurfaceFromXYZ(vec3 ballCenter, vec3 startFrom, int endItersEarly){ //default startFrom is ballCenter. You can brute-force past localMins by calling this more times with more startFrom's near ballCenter, which as of 2025-12-2 Im coding this to try to solve the saddlering bug which I only partially solved before by tuning it so it doesnt land on the blob floating in mid air, but the better solution im attempting here is to start the newton loops first position outside that so it doesnt have the chance to get stuck there in the first place, and trying maybe 17 (multiprobe_vec3Offsets.length) of those in parallel per ball.
	//vec3	p	 = ballCenter;
	vec3	p	 = startFrom;
	float speed = SignedDistanceSpeed; //float speed = {Lamgl.jsNumToGlslFloat(ns.Opt.SignedDistanceSpeed.p)}; //float speed = {Lamgl.jsNumToGlslFloat(opt.signedDistanceSpeed)};
	//opt.signedDistanceNewtonIterations must be at least 2 so fractionDone not divide by 0,
	//and normally you would use between 8 and 32 or else it does not find it very accurately.
	//Higher numbers never (or rarely?) make it worse, just stop having any effect after reach a localMin.
	int iter = SignedDistanceNewtonIterations; //moving this to gl uniform 2025-11-16
	int possiblySmallerIter = iter-endItersEarly; //so iter still affects fractionDone. Same as iter except for some of the debug graphics.
	for(int i=0; i<possiblySmallerIter; ++i){ //for(int i=0; i<iter; ++i){
		//bug bellsack302Bug_itsNotMovingTheSameInsideVsOutsideTheIsosurface
		//FIXME BUG FOUND 2025-8-22-930aET[[even though densityOfSlightAttractToVec3 is correct in what angles
		//it prefers, and that its 0 for best angle and 1 for worst angles, that this 0..1 range
		//gets added to a number (from densityAtXYZ) that can be positive or negative,
		//so densityOfSlightAttractToVec3 being 0 is worse than densityOfSlightAttractToVec3
		//being 0.1, cuz when density is -0.1, sum of the 2 is 0?
		//Ive run into a bug where an isosurface (solve sum = 0) and loss (solve for lower sum) function
		//are merged, so it only works on 1 side of the surface. If I turn distance into loss, I lose accuracy
		//near the surface. If I turn loss into distance, its discontinuous.
		//It actually works on 1 side of the isosurface, most of the time.
		//Very accurate. Its based on nearest point (to a chosen point
		//like a ball center) on isosurface will ALWAYS, for sure,
		//have a normal vector exactly pointing at that ball center.
		//So I newton loop including gradient.
		//It doesnt stop there. Thats just to find the nearest point
		//on the isosurface. I then use that to define a loss function
		//of the whole game, summing that for all balls near all possible
		//parts of the isosurface, and run that in parallel to compute
		//gradient of loss of whole game.
		//The effect of using newton-loop inside a high dimensional gradient
		//is that some parts of my game state is computed to at least the 17th derivative
		//(but not true in general, it just accelerates by negative gradient(lossFunc,position),
		//but computes more accurate gradient with higher signedDistanceNewtonIterations),
		//if opt.signedDistanceNewtonIterations is 16.
		//]]
		//see more about the bug in comments of mergedDensity_isosurface_and_slightAttractToVec3.
		${Dom('nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3').checked ?
		`//UPdate that didnt fix it, saddlering bug is likely cuz of localmins which this doesnt fix. fractionDone gradually increases influence of densityOfSlightAttractToVec3 later in loop to deal with
		//circular saddlepoints (saddlerings aka bottle openings) which were not finding the nearest point when
		//queried near center of that bottle opening. 2025-11-10+ this is an experiment to fix that.
		
		//Saddlering bug fixed in Bellsack 352 by adding fractionDone param which varies the influence of the
		//normal-vector during newton-loop, starting the search for nearest point by "find the surface" only,
		//and gradually prioritizing the surface normal being same direction to ball center.
		
		//float fractionDoneOrConstant1 = ${Chk('whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector') ? 'float(i)/float(iter-1)' : '1.'};
		float fractionDoneOrConstant1 = ${Chk('whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector') ? 'sqrt(float(i)/float(iter-1)); //sqrt is experiment 2025-11-16 to make it reach near 1 sooner, cuz ive been seeing balls go thru walls and disabling this (setting to fractionDone=1 always) stopped it from doing that, but I cant remove it completely or the saddlering bug comes back.' : '1.;'}
		float sd = mergedDensity_isosurface_and_slightAttractToVec3(p,ballCenter,fractionDoneOrConstant1);
		vec3	g	 = gradientAtXYZ_including_densityOfSlightAttractToVec3(p,ballCenter,fractionDoneOrConstant1); //4 calls of a merged density function`
		:
		`float sd = densityAtXYZ(p);
		vec3	g	 = gradientAtXYZ(p); //4 calls of densityAtXYZ`
		}
		g = easeVec3(g,${Lamgl.jsNumToGlslFloat(opt.xyzGradientLimit)}); //limit to this max radius, cuz gradient of gradient can get jumpy/chaotic
		float gL	= length(g) + 1e-9;		// avoid /0
		float step= sd / gL;				 // project onto iso-normal
		p		 -= g * (step / gL) * speed;
		//sd		 = densityAtXYZ(p); //TODO optimize 1 less call of densityAtXYZ at end its not using the last one
	}
	return p;
}

vec3 nearestPointOnIsosurfaceFromXYZ(vec3 ballCenter, vec3 startFrom){
	return nearestPointOnIsosurfaceFromXYZ(ballCenter, startFrom, 0); //endItersEarly is 0 so does the whole loop. Its only nonzero for debug graphics to display whats happening during the newton loop.
}

//START nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
${(()=>{
	let code = '';
	if(!hasBallCacheUniformIn){
		code += '//not hasBallCacheUniformIn';
	}else{
		code += `//yes hasBallCacheUniformIn:
		//You use nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache many times
		//and nearestPointOnIsosurfaceFromXYZ (the expensive calculation) fewer times,
		//to make one last adjustment to the output of nearestPointOnIsosurfaceFromXYZ,
		//based on perturbing each of hundreds of dimensions by VarGradientGL.
		//Instead of a double loop of nearestPointOnIsosurfaceFromXYZ,
		//you run nearestPointOnIsosurfaceFromXYZ (slow) in the outer loop
		//and nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache (fast) in the inner loop.
		//You should get about the same vec3 from both, used in physics
		//of ball-isosurface and ball-ball collisions smoothly by gradient of loss func,
		//and maybe someday small amounts of isosurface-isosurface.
		//
		//made by GPT-o3 todo verify this algebra and code:
		//
		//------------------------------------------------------------------------------
		//	nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
		//------------------------------------------------------------------------------
		//	cachedSurfaceXYZ : vec3	– approximate surface point read from ballCacheVec4
		//	ballCenter			 : vec3	– current ball position
		//
		//	Purpose
		//	-------
		//	Move cachedSurfaceXYZ a distance distanceToSlide along the outwardNormal so
		//	that densityAtXYZ( refinedSurfaceXYZ ) equals zero in the *current* field.
		//
		//	Linear-fit proof using the same variable names as the code
		//	----------------------------------------------------------
		//			outwardNormal = normalize( ballCenter − cachedSurfaceXYZ )
		//
		//			Define helper that displaces cachedSurfaceXYZ by signedOffset
		//			along outwardNormal:
		//
		//					 displacedPoint(signedOffset) = cachedSurfaceXYZ
		//																				+ signedOffset * outwardNormal
		//
		//			Field samples used below:
		//					densityForwardSample	= densityAtXYZ( displacedPoint(+EPSILON) )
		//					densityBackwardSample = densityAtXYZ( displacedPoint(−EPSILON) )
		//
		//			Assume densityAtXYZ varies *linearly* between −EPSILON and +EPSILON:
		//
		//					densityAtXYZ( displacedPoint(offset) )
		//							≈ densityMidpoint
		//								+ gradientAlongNormal * offset
		//
		//			where
		//					gradientAlongNormal = (densityForwardSample − densityBackwardSample)
		//																/ (2 * EPSILON)					// central difference
		//
		//					densityMidpoint		 = (densityForwardSample + densityBackwardSample)
		//																* 0.5										// midpoint value
		//
		//			We want densityAtXYZ to be zero after sliding:
		//
		//					0 = densityMidpoint + gradientAlongNormal * distanceToSlide
		//
		//			Solve for distanceToSlide:
		//
		//					distanceToSlide = −densityMidpoint / gradientAlongNormal
		//
		//			refinedSurfaceXYZ = cachedSurfaceXYZ
		//													+ outwardNormal * distanceToSlide
		//------------------------------------------------------------------------------
		`;

		if(Dom('cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache').checked){
			code += `vec3 nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache(in vec3 cachedSurfaceXYZ, in vec3 ballCenter){
				//yes cheatTheOptimizationIn_*, cheat the slow way to see if the below code is the problem. If this works, then it is.
				${Chk('multiprobe_cheatTheOptimizationIn') ?
				`//is multiprobe_cheatTheOptimizationIn so loop then return bestFoundPoint (of about 17/multiprobe_vec3Offsets.length() tries), instead of just searching once.
				//FIXME what if the full offsets array isnt there cuz !multiprobePhysics? This could go off end of array and make GL not compile?
				//or worse, silently not multiprobe here cuz of multiprobe_vec3Offsets being only size 1. TODO go make it always put those offsets.
				float bestSortVal = 1e30;
				vec3 bestFoundPoint = ballCenter;
				for(int offsetId=0; offsetId<multiprobe_vec3Offsets.length(); offsetId++){
					vec3 startFrom = ballCenter+multiprobe_vec3Offsets[offsetId];
					vec3 foundPoint nearestPointOnIsosurfaceFromXYZ(cachedSurfaceXYZ,startFrom);
					//compare them. considers distance AND is it on the isosurface.
					float densityNearIsosurface = densityAtXYZ(foundPoint); //FIXME use densityAtSXYZ or else it only works for the bell5 terrain
					float sortVal = multiprobeSortVal(foundPoint, densityNearIsosurface, ballCenter);
					if(sortVal < bestSortVal){
						bestSortVal = sortVal;
						bestFoundPoint = foundPoint;
					}
				}
				return bestFoundPoint;
				`
				:
				`vec3 startFrom = ballCenter;
				return nearestPointOnIsosurfaceFromXYZ(cachedSurfaceXYZ,startFrom); //NOT multiprobe_cheatTheOptimizationIn so just use ballCenter as startFrom. search once, not ~17 times.`
				}
			}`;
		}else{
			if(Dom('ballCacheOptimizationUsesFastGradientAlongLineElse4Samples').checked){
				code += `vec3 nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache(in vec3 cachedSurfaceXYZ, in vec3 ballCenter){
					//not cheatTheOptimizationIn_*
					//YES ballCacheOptimizationUsesFastGradientAlongLineElse4Samples (along line)
					//Approximate outward normal (points from cachedSurfaceXYZ toward the ball)
					vec3 outwardNormal = Norm(ballCenter - cachedSurfaceXYZ);

					// Density samples taken EPSILON ahead and behind along that normal
					float densityForwardSample	= densityAtXYZ(cachedSurfaceXYZ + EPSILON * outwardNormal);
					float densityBackwardSample = densityAtXYZ(cachedSurfaceXYZ - EPSILON * outwardNormal);

					// Central slope (keeps sign) and midpoint density
					float gradientAlongNormal = (densityForwardSample - densityBackwardSample)
												/ (2.0 * EPSILON);
					float densityMidpoint		 = 0.5 * (densityForwardSample + densityBackwardSample);

					// Signed distance we must slide along the normal
					float distanceToSlide = 0.0;
					if (abs(gradientAlongNormal) > 1e-9) {					// avoid divide-by-zero
						distanceToSlide = -densityMidpoint / gradientAlongNormal;
					}

					// Refined nearest point on the iso-surface
					return cachedSurfaceXYZ + outwardNormal * distanceToSlide;
				}`;
			}else{
				code += `vec3 nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache(in vec3 cachedSurfaceXYZ, in vec3 ballCenter){ //gpt5thinking said to try this to explore the wrong mirror theory
					//NO ballCacheOptimizationUsesFastGradientAlongLineElse4Samples (4 samples)
					// Use the *field* normal, not the ball vector, to avoid “mirror” tangential pushes
					vec3 grad = gradientAtXYZ(cachedSurfaceXYZ); //the 4 samples
					float gradLen2 = dot(grad, grad);
					if (gradLen2 < 1e-12) return cachedSurfaceXYZ;	// flat / undefined, don’t move

					vec3 n = grad / sqrt(gradLen2);								 // unit normal of the iso
					// Orient the normal so it points toward the ball (stable sign)
					if (dot(n, ballCenter - cachedSurfaceXYZ) < 0.0) n = -n;

					// One projected-Newton step: p <- p - f(p) * (n / (n·∇f)) . Since n‖∇f, n·∇f = |∇f|.
					float f0 = densityAtXYZ(cachedSurfaceXYZ);
					float distanceToSlide = -f0 / sqrt(gradLen2);	 // same as -f0 / dot(n, grad)
					return cachedSurfaceXYZ + n * distanceToSlide;
				}`;
			}
		}
	}
	return code;
})()}//END nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache


/*2025-12-2
Bellsack381.html
File
I didnt upgrade "float signedDistanceToIsosurfaceAtXYZ(in vec3 p0)" or "float signedDistanceToIsosurfaceAtXYZ_estimateUsingBallCache(in vec3 p0_akaBallCenter, in vec3 ballCacheVec3)". The plan is to have an extra Lamgl call when multiprobe checkbox is checked that merges it all into 1 vec4 ballCache per ball, so it should fit into that same thing. but signedDistanceToIsosurfaceAtXYZ can no longer run by itself in 1 gpu thread cuz u gotta have multiple threads to find that vec4 on isosurface nearest the ball (approximate). Depending on checkbox/V/Var options it might call nearestPointOnIsosurfaceFromXYZ or nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache. or both. Normally it does nearestPointOnIsosurfaceFromXYZ in the first pass, and nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache more times in second pass. Im getting tangled and confused. Write out how it did work and what i should change it to.

Bellsack381.html:495 Uncaught Error: ERROR: 0:457: 'nearestPointOnIsosurfaceFromXYZ' : no matching overloaded function found
ERROR: 0:457: '=' : dimension mismatch
ERROR: 0:457: '=' : cannot convert from 'const mediump float' to 'highp 3-component vector of float'

	return p; //446
} //447
 //448
//START nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache //449
//not hasBallCacheUniformIn//END nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache //450
 //451
 //452
// Positive outside, negative inside. //453
//EstimatePhysicsFlop: signedDistanceNewtonIterations*(5*densityAtXYZ) //454
//EstimatePhysicsFlop_temp: signedDistanceNewtonIterations*5*bells*25 //455
float signedDistanceToIsosurfaceAtXYZ(in vec3 p0){ //456
	vec3 p = nearestPointOnIsosurfaceFromXYZ(p0); //alot slower than nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache //457
	float distance = length(p0-p); //458
	//was reversed: return sign(densityAtXYZ(p))*distance; //TODO optimize 1 less call of densityAtXYZ. FIXME is this reversed sign? //459
	return -sign(densityAtXYZ(p))*distance; //TODO optimize 1 less call of densityAtXYZ //460
} //461
 //462
//not hasBallCacheUniformIn //463
 //464
 //465
 
 Pass A – physicsCacheNearestVec4PerBall One fragment thread per ball. will i be able to change this to passA0 multiple fragments per ball. passA1 1 fragment per ball, reading the multiple from passA0
 
 // Use ONLY in the cache–building passes (A0 / A1). float signedDistanceSearch(in vec3 p0){
 vec3 p = nearestPointOnIsosurfaceFromXYZ(p0); // 1- or 17-seed search
 no. A0 uses 17 gpu threads per ball. A1 uses 1 GPU thread per ball and does 17 texelFetches.
 */


// Positive outside, negative inside.
//EstimatePhysicsFlop: signedDistanceNewtonIterations*(5*densityAtXYZ)
//EstimatePhysicsFlop_temp: signedDistanceNewtonIterations*5*bells*25
float signedDistanceToIsosurfaceAtXYZ(vec3 p0, vec3 startFrom){ //default startFrom is p0 but the approx 17 vec3 offsets (first of them is 0,0,0) plus that will be used in their own gpu threads or loop in single thread depending on options.
	vec3 p = nearestPointOnIsosurfaceFromXYZ(p0, startFrom); //alot slower than nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
	float distance = length(p0-p);
	//was reversed: return sign(densityAtXYZ(p))*distance; //TODO optimize 1 less call of densityAtXYZ. FIXME is this reversed sign?
	return -sign(densityAtXYZ(p))*distance; //TODO optimize 1 less call of densityAtXYZ
}

${hasBallCacheUniformIn?`//yes hasBallCacheUniformIn:
float signedDistanceToIsosurfaceAtXYZ_estimateUsingBallCache(in vec3 p0_akaBallCenter, in vec3 ballCacheVec3){
	vec3 p = nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache(
				ballCacheVec3, p0_akaBallCenter); //alot faster than nearestPointOnIsosurfaceFromXYZ
	float distance = length(p0_akaBallCenter-p);
	
	//bug: p is near isosurface so epsilon change in it can be positive vs negative,
	//but replace p with p0_akaBallCenter and you get which side the ball is on.
	//return -sign(densityAtXYZ(p))*distance; //TODO optimize 1 less call of densityAtXYZ
	return -sign(densityAtXYZ(p0_akaBallCenter))*distance; //TODO optimize 1 less call of densityAtXYZ
}`:
'//not hasBallCacheUniformIn'}


//balls and surface, excluding ballX[excludeBallIndex] ballY ballZ, which you can give -1 to not exclude any balls.
//EstimatePhysicsFlop: signedDistanceToIsosurfaceAtXYZ+signedDistanceToBallsAtXYZExcludingBallIndex
//EstimatePhysicsFlop_temp: (signedDistanceNewtonIterations*5*bells*25)+balls*8
float signedDistanceAtXYZExcludingBallIndex(vec3 fromXYZ, vec3 startFrom, int excludeBallIndex){
	return min(signedDistanceToIsosurfaceAtXYZ(fromXYZ, startFrom),
		signedDistanceToBallsAtXYZExcludingBallIndex(fromXYZ, excludeBallIndex));
}

${hasBallCacheUniformIn?`//yes hasBallCacheUniformIn:
//Uses selfBallIndex as the only ball to check against for isosurface-ball phyiscs but
//uses selfBallIndex as the only ball not to check against in ball-ball physics.
//
float signedDistanceAtXYZExcludingBallIndex_estimateUsingBallCache( //slow using texture
		in vec3 fromXYZ_akaBallCenter, in int selfBallIndex){
		
	/*FIXME
	[signedDistanceAtXYZExcludingBallIndex_estimateUsingBallCache takes one query
	point (fromXYZ) but then loops over every ball’s cached iso-surface point]

	cuz signedDistanceAtXYZExcludingBallIndex (both kinds) do 2 signed distances: to isosurface, and to balls. the isosurface uses densityAtXYZ(vec3) which loops over bells to sum them, in a newton loop.. The ball-ball signed distance just loops over balls to find the nearest ball. then whichever is closer, to another ball or to the isosurface, t returns that. so that seems correct.

	BUT maybe its causing a bug when it returns a ball as the nearest thing but then does the optimization that was only designed for ball-isosurface.
	
	So im removing ball-ball physics and doing only isosurface-ball physics
	in this ballCache optimization, and once its working better, I'll add it back
	as a separate calculation.
		
	vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(selfBallIndex,0), 0); //slow, from texture, compared to uniforms
	vec3 ballCacheVec3 = ballVec4.xyz;
	float a = signedDistanceToIsosurfaceAtXYZ_estimateUsingBallCache(
		fromXYZ_akaBallCenter, ballCacheVec3);
	float b = signedDistanceToBallsAtXYZExcludingBallIndex(fromXYZ_akaBallCenter,selfBallIndex);
	return min(a,b);
	*/
	
	${Dom('addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform').checked ?
		'vec4 ballVec4 = ballCacheVec4[selfBallIndex]; //signedDistance: fast, uniform cuz addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform, but was slow to copy it to CPU then to uniform'
		:
		'vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(0,selfBallIndex), 0); //signedDistance: slow, from texture, compared to uniforms. 2025-12-2+ using [numBalls,numOffsets,4] and using an extra Lamgl call (3 physics shaders not 2), for example 17 vec3 offsets it tries to find nearest point on isosurface starting from each, for same ball center vec3.'
		//'vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(selfBallIndex,0), 0); //signedDistance: slow, from texture, compared to uniforms'
	}
	vec3 ballCacheVec3 = ballVec4.xyz;
	return signedDistanceToIsosurfaceAtXYZ_estimateUsingBallCache(
		fromXYZ_akaBallCenter, ballCacheVec3); //isosurface-ball physics
	//TODO ball-ball physics
}`:
'//not hasBallCacheUniformIn'}

//min distance from surface of ball to every point inside the isosurface volume and every point inside other balls.
//EstimatePhysicsFlop: signedDistanceAtXYZExcludingBallIndex
//EstimatePhysicsFlop_temp: (signedDistanceNewtonIterations*5*bells*25)+balls*8
float signedDistanceOfBall(int ballIndex, vec3 startFrom){ //uniform memory only
	vec3 ballXYZ = vec3(ballX[ballIndex],ballY[ballIndex],ballZ[ballIndex]);
	return signedDistanceAtXYZExcludingBallIndex(
		ballXYZ, startFrom, ballIndex)-BALL_R;
}

${hasBallCacheUniformIn?`//yes hasBallCacheUniformIn:
float signedDistanceOfBall_estimateUsingBallCache(int ballIndex){ //uniform and texture memory
	return signedDistanceAtXYZExcludingBallIndex_estimateUsingBallCache(
		vec3(ballX[ballIndex],ballY[ballIndex],ballZ[ballIndex]),ballIndex)-BALL_R;
}`:
'//not hasBallCacheUniformIn'}

//balls and surface. does not exclude any balls, so is not the right signedDistance func for accelerating a ball
//cuz it will detect collision with itself.
float signedDistanceAtXYZ(vec3 fromXYZ, vec3 startFrom){
	return signedDistanceAtXYZExcludingBallIndex(fromXYZ,startFrom,-1); //-1 dont exclude any ball index
}

//spring force for how far ball is inside isosurface volume
float lossOf_sdWithRadius(float sdWithRadius){
	//TODO merge this constant (5.3) into accelMul? Put it in opt.signedDistanceAccel or something like that.
	//return 5.3*sdWithRadius*sdWithRadius;
	return 25.3*sdWithRadius*sdWithRadius;
	//return 1.3*sdWithRadius*sdWithRadius;
	//return .3*abs(sdWithRadius);
}

${(()=>{ //START loss switch
switch(funcName){

case 'graphicsMain': case 'graphicsDebug':
return '//graphics and graphicsDebug, dont use loss()';

case 'physicsSimple':
return `//physicsSimple
//Loss function for VarGradientGL
//High when balls are colliding with the isosurface volume.
//EstimatePhysicsFlop: balls*signedDistanceOfBall
//EstimatePhysicsFlop_temp: balls*((signedDistanceNewtonIterations*5*bells*25)+balls*8)
float loss_optimizedBy_physicsSimple(){ //same as loss_optimizedBy_physicsUseNearestVec4PerBall but slower
	float loss = 0.;
	//vec3 inFrontOfCam = camPos+vec3(0.,0.,10.);
	vec3 posVisibleWhenCamStarts = vec3(0.,0.,10.);
	//for(int bi=0; bi<NEAR_BALLS_TOTAL; bi++){
	for(int bi=0; bi<uBallCount; ++bi){
		//vec3 p = ballXYZ[bi];
		
		//vec3 p = vec3(ballX[bi],0.,0.);
		//vec3 p = vec3(ballX[bi],0.,0.);
		vec3 p = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		//vec3 p = vec3(ballX[bi],-ballY[bi],ballZ[bi]);
		//vec3 p = vec3(0.,ballY[bi],0.);
		
		//FIXME dont branch by continue. use ifTrue*chance+ifFalse*(1-chance),
		//for updating each branching float var as nonbranching, and you set ifTrue float and ifFalse float,
		//doesnt have to be named ifTrue or ifFalse. The webgl compiler might do that anyways in some cases.
		//
		//if(p.x >= (NULLXYZ/2.)) continue;			// unused slot.
		if(float(bi) >= (numBalls-.5)){
			//TODO NONBRANCHING
			continue; //padding, dont use this as ball, its vec3(NULLXYZ,NULLXYZ,NULLXYZ) or that differing by epsilon
		}
		
		/*
		//simple physics
		float d = densityAtXYZ(p);
		//d *= d;
		//d = -d; //flip accel direction. FIXME
		//d = 0.;
		
		d = max(0., d); //flat 0 in open areas, but solid volumes (inside isosurface) still repel.
		
		//l += d*d;							 // simple ‖distance‖² penalty
		loss += d; //FIXME do detailed collision detection and squared signedDistance of overlap
		*/
		
		
		//float sd = signedDistanceToIsosurfaceAtXYZ(p);
		//float sd = signedDistanceAtXYZExcludingBallIndex(p,bi);
		//float sdWithRadius = sd-BALL_R;
		//float sdWithRadius = signedDistanceAtXYZExcludingBallIndex(p,bi);
		
		/*FIXME should there be a loop over all ~17 vec3 offsets (from ballXYZ) or should it be done in separate GPU threads?
		Theres 6 checkboxes relevant to the 2025-12 redesign:
		isBallCacheOptimization
			multiprobe_isosurfaceBallPhysics
		debugGraphicsOnBallThatUsesSignedDistancePerPixel
			multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel
		cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
			multiprobe_cheatTheOptimizationIn
		*/
		${multiprobePhysics ?
		`//is multiprobe, but since this is physicsSimple, dont split into more GPU threads, and instead loop here.
		for(int offsetId=0; offsetId<multiprobe_vec3Offsets.length(); offsetId++){
			vec3 startFrom = p+multiprobe_vec3Offsets[offsetId]; //When offsetId is 0 startFrom==p aka same position as ball center. The others are points near the ball center such as 2 groups of 8 cube corners at 2 sizes of cube, totalling 17 places to start looking for points on isosurface near ball center. They're all compared to ball center regardless where they start from.
			float sdWithRadius = signedDistanceOfBall(bi, startFrom);
		}
		`
		:
		`vec3 startFrom = p; //not multiprobe, use same position as ball to start looking for nearest point on isosurface
		float sdWithRadius = signedDistanceOfBall(bi, startFrom);`
		}
		
		
		sdWithRadius = min(0.,sdWithRadius); //normal
		//dont min it, this experiment is to try to make balls stick to isosurface
		
		
		//loss += 5.3*sdWithRadius*sdWithRadius; //spring force for how far ball is inside isosurface volume
		loss += lossOf_sdWithRadius(sdWithRadius); //spring force for how far ball is inside isosurface volume
		//loss += .3*sdWithRadius; //spring force for how far ball is inside isosurface volume
		
		//loss += p.y*2.3; //gravity
		//float distanceToCam = length(p-camPos);
		//loss += .3*distanceToCam*distanceToCam;

		//all balls move toward (0,0,0) experiment
		//float distanceToOrigin = length(p);
		//loss += distanceToOrigin*distanceToOrigin*.001;
		
		
		//float distanceToInFrontOfCam = length(p-inFrontOfCam);
		//float distErr = length(p-posVisibleWhenCamStarts);
		//float targetDist = 2.;
		//float targetDist = 0.;
		//float distErr = (distanceToOrigin-targetDist);
		//loss += .01*distErr*distErr;
		//loss += .3*p.y*p.y; //attract to plane at p.y=0
		//loss += .003*abs(p.y); //attract to plane at p.y=0
		
		
		//loss += .1*p.y; //gravity, only on balls
		loss += ${Lamgl.jsNumToGlslFloat(opt.gravityY)}*p.y; //gravity, only on balls
		//loss += 2.3*p.y; //gravity, only on balls
		
		
		//loss += .3*distErr*distErr;
		//loss += 2.1*distanceToOrigin*distanceToOrigin;
		//loss += 2.1*distanceToOrigin;
		//loss += .1*distErr*distErr;
		//loss += -1.4*p.z;
	}
	//TODO add ball ball collisions to loss like did in dagball
	return loss;
}`;

case 'physicsCacheNearestVec4PerBall':
return '//physicsCacheNearestVec4PerBall does use a loss but its somewhere else, search for loss_optimizedBy_';

case 'physicsUseNearestVec4PerBall':
/*return `
//This takes 1 less Var/dim cuz lacks the +1 neutral sample of VarGradientGL when called on physicsSimple.
//Instead it returns the gradient of loss directly,
//which is a more straightforward calculation to do in this optimization.
//OLD:
//physicsUseNearestVec4PerBall, second Lamgl call has loss() that
//uses vec4 per ball from physicsCacheNearestVec4PerBall
//float loss_optimizedBy_physicsUseNearestVec4PerBall(){ //same as loss_optimizedBy_physicsSimple but faster
float lossGradient_optimizedBy_physicsUseNearestVec4PerBall(){ //same as loss_optimizedBy_physicsSimple but faster
	//FIXME this was copied from loss_optimizedBy_physicsSimple 2025-7-26 but not upgraded
	//to the ballCacheVec4 way of computing loss which does NOT use signedDistanceOfBall.

	//float loss = 0.;
	//vec3 posVisibleWhenCamStarts = vec3(0.,0.,10.);
	float lossGradient = 0.;
	for(int bi=0; bi<uBallCount; ++bi){
		if(float(bi) >= (numBalls-.5)){
			//TODO NONBRANCHING
			continue; //padding, dont use this as ball, its vec3(NULLXYZ,NULLXYZ,NULLXYZ) or that differing by epsilon
		}
		
		//vec3 p = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(bi,0), 0);
		vec3 isosurfaceXYZ_neutral = ballVec4.xyz; //from the float[~500] thats neutral not perturbed
		float densityAt_isosurfaceXYZ_neutral = ballVec4.w; //from the float[~500] thats neutral not perturbed

		//---------- cached neutral values ------------------------------
		vec4 cacheEntry						 = texelFetch(ballCacheVec4, ivec2(bi, 0), 0);
		vec3 isoPosNeutral					= cacheEntry.xyz;	 // nearest point on iso-surface (neutral)
		float densityNeutral					= cacheEntry.w;	 // Density(isoPosNeutral)	in neutral pass

		//---------- ball centre (this is *not* perturbed) ---------------
		vec3 ballCenter						 = vec3(ballX[bi], ballY[bi], ballZ[bi]);

		//---------- normal at iso-surface (toward the ball) -------------
		//vec3 normalDir						= normalize(ballCenter - isoPosNeutral);
		vec3 normalDir						= Norm(ballCenter - isoPosNeutral);

		//|∇Density| along that normal	(finite difference, no gradientAtXYZ)
		float rhoForward	= densityAtXYZ(isoPosNeutral + EPSILON * normalDir);
		float rhoBackward = densityAtXYZ(isoPosNeutral - EPSILON * normalDir);
		float gradMagAlongNormal			 = (rhoForward - rhoBackward) / (2.0 * EPSILON);

		//---------- density under the *perturbed* bell parameters -------
		float densityPerturbed				= densityAtXYZ(isoPosNeutral);
		float deltaDensity					= densityPerturbed - densityNeutral;

		//---------- surface slide along its normal ----------------------
		float deltaSD						 = -deltaDensity / gradMagAlongNormal;

		//---------- new iso-surface point for perturbed field -----------
		vec3 isoPosPerturbed					= isoPosNeutral + normalDir * deltaSD;

		//---------- signed distances (no clamping) ----------------------
		float sdNeutral						 = length(ballCenter - isoPosNeutral)	 - BALL_R;
		float sdPerturbed					 = length(ballCenter - isoPosPerturbed) - BALL_R;

		//---------- loss values & contribution to ∂loss/∂param ----------
		float lossNeutral					 = lossOf_sdWithRadius(sdNeutral);
		float lossPerturbed					 = lossOf_sdWithRadius(sdPerturbed);

		lossGradient += (lossPerturbed - lossNeutral) / EPSILON;
		//lossGradient = .005; //FIXME
		
		//loss += ${Lamgl.jsNumToGlslFloat(opt.gravityY)}*p.y; //gravity, only on balls
		//lossGradient +=
	}
	//return loss;
	//return lossGradient*1000.;
	//return lossGradient*.1;
	return lossGradient;
}
`;*/

/*
lets split off another func Its like nearestPointOnIsosurfaceFromXYZ but uses ballCacheVec4 and some other params to estimate it.

nearestPointOnIsosurfaceFromXYZ returns a vec3. nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache(vec4 ballCacheVec4, vec3 ballCenter);

We will go back to this code

float loss_optimizedBy_physicsSimple(){ //same as loss_optimizedBy_physicsUseNearestVec4PerBall but slower
	float loss = 0.;
	for(int bi=0; bi<uBallCount; ++bi){
		vec3 p = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		if(float(bi) >= (numBalls-.5)){
			//TODO NONBRANCHING
			continue; //padding, dont use this as ball, its vec3(NULLXYZ,NULLXYZ,NULLXYZ) or that differing by epsilon
		}
		float sdWithRadius = signedDistanceOfBall(bi);
		sdWithRadius = min(0.,sdWithRadius);
		loss += lossOf_sdWithRadius(sdWithRadius); //spring force for how far ball is inside isosurface volume
		loss += ${Lamgl.jsNumToGlslFloat(opt.gravityY)}*p.y; //gravity, only on balls
	}
	return loss;
}

but named loss_optimizedBy_physicsUseNearestVec4PerBall (not lossGradient_optimizedBy_physicsUseNearestVec4PerBall cuz is loss, not lossGradient).

We will verify loss_optimizedBy_physicsUseNearestVec4PerBall does exactly the same thing as loss_optimizedBy_physicsSimple, and why wouldnt it, cuz its gonna be the same code.

THEN mod it to call nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache instead of nearestPointOnIsosurfaceFromXYZ. Which gets called inside signedDistanceOfBall. We will use the estimated vec3 instead of the more accurate one, but other than that, same func.


But to start with, give me nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache 
*/
return `//physicsUseNearestVec4PerBall
float loss_optimizedBy_physicsUseNearestVec4PerBall(){ //same as loss_optimizedBy_physicsSimple but many times faster and a little less precise
	float loss = 0.;
	for(int bi=0; bi<uBallCount; ++bi){
		vec3 p = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		if(float(bi) >= (numBalls-.5)){
			//TODO NONBRANCHING
			continue; //padding, dont use this as ball, its vec3(NULLXYZ,NULLXYZ,NULLXYZ) or that differing by epsilon
		}
		//float sdWithRadius = signedDistanceOfBall(bi);
		
		
		//use nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache
		//instead of nearestPointOnIsosurfaceFromXYZ.
		//signedDistanceOfBall calls nearestPointOnIsosurfaceFromXYZ,
		//so have to fork that.
		//First, make sure this loss_optimizedBy_physicsUseNearestVec4PerBall works.
		//2025-8-9 loss_optimizedBy_physicsUseNearestVec4PerBall does work often but unreliable, fixme.
		float sdWithRadius = signedDistanceOfBall_estimateUsingBallCache(bi); //about 20x faster than signedDistanceOfBall(bi)
		${Dom('holdBallsOnIsosurface').checked ? 'sdWithRadius += BALL_R; //holdBallsOnIsosurface uses ball center, not ball surface' : ''}
		
		${Dom('chkBallCacheOptimizationIgnoresBallBallCollisions').checked?
		'//YES chkBallCacheOptimizationIgnoresBallBallCollisions':
		`//NO chkBallCacheOptimizationIgnoresBallBallCollisions
		float sdWithRadiusOtherBalls = signedDistanceToBallsAtXYZExcludingBallIndex(p,bi);
		sdWithRadius = min(sdWithRadius, sdWithRadiusOtherBalls);
		`}
		
		
		${Dom('holdBallsOnIsosurface').checked ?
			'//opt.holdBallsOnIsosurface so commentedOut: sdWithRadius = min(0.,sdWithRadius); dont min it, this experiment is to try to make balls stick to isosurface' :
			'sdWithRadius = min(0.,sdWithRadius); //normal, negative is isosurface-ball or ball-ball collision'}
			
		
		loss += lossOf_sdWithRadius(sdWithRadius); //spring force for how far ball is inside isosurface volume
		loss += ${Lamgl.jsNumToGlslFloat(opt.gravityY)}*p.y; //gravity, only on balls
	}
	return loss;
}`;

default: return '//FIXME unknown funcName='+funcName;
} //END loss switch
})()}

// step function
float stepFunction(float val, float lastVal){
	// if isRaymarch>0.5 => variable step
	float doVar= step(0.5, isRaymarch);
	float fixedSz = ${Lamgl.jsNumToGlslFloat(opt.raytraceStep)}; //float fixedSz= 0.2;
	float raw= 2.0* abs(val);
	float minimal=0.001;
	float stDist= max(raw, minimal);
	return mix(fixedSz, stDist, doVar);
	
	//return abs(val);
	//return stDist;
	//return val; //FIXME
}

/*Bellsack289 experiment // find the implicit surface
float findSurface(in vec3 origin, in vec3 dir, out vec3 outPos){
	float t=0.0;
	float val=0.0, lastVal=0.0;
	bool found=false;
	vec3 p; //position, moving from origin
	vec3 v = dir*11.5; //velocity
	for(int i=0;i<MARCH_MAX_STEPS;i++){
		if(t> horizon) break;
		//vec3 p= origin + dir*t;
		val = densityAtXYZ(p); //val= sumOfBellcurves(p);
		if(i>0 && (sign(val)!=sign(lastVal) || abs(val)< closeEnuf)){
			found= true;
			// approximate crossing
			//float dt= ( stepFunction(val,lastVal)*abs(lastVal) ) / ( abs(val)+ abs(lastVal)+ 1e-9 );
			//t= t- stepFunction(val,lastVal)+ dt;
			//outPos= origin + dir*t;
			outPos = p; //FIXME add dt*something which is a partial last step for extra accuracy
			break; //TODO optimize by nonbranching
		}
		lastVal= val;
		//float stSz= stepFunction(val,lastVal);
		//t+= stSz;
		float dt = .01;
		v -= dt*gradientAtXYZ(p);
		p += dt*v; //each ray is a ball rolling along the 3d density field toward lower densityAtXYZ(p)
		//FIXME, experimental curved space (geodesic related?)
	}
	if(!found) return 999999.0;
	return t;
}*/
// find the implicit surface

//Raytrace or raymarch. Return distance along ray to where it hits
//at densityAtXYZ(outPos) is or is very near 0 (though has been buggy it could be much farter off),
//copies that vec3 to outpos, and returns distance of origin to outPos OR 999999.0 if didnt hit surface.
float findSurface(in vec3 origin, in vec3 dir, out vec3 outPos){
	float t=0.0;
	float val=0.0, lastVal=0.0;
	bool found=false;
	for(int i=0;i<MARCH_MAX_STEPS;i++){
		if(t> horizon) break;
		vec3 p= origin + dir*t;
		val = densityAtXYZ(p); //val= sumOfBellcurves(p);
		${ns.Opt.Display3dLocalMinsOfGradientMagLessThan.p>0 ?
			//'val += Display3dLocalMinsOfGradientMagLessThan*length(gradientAtXYZ(p)); //FIXME this is not the right calculation.'
			`float gradMag = length(gradientAtXYZ(p));
			if(gradMag<Display3dLocalMinsOfGradientMagLessThan){ //debug graphics, isnt really something here, but balls have been bouncing on it anyways near middle of saddlerings 2025-11-25.
				outPos = p;
				found = true;
				break;
			}
			`
			:
			'//ignore ns.Opt.Display3dLocalMinsOfGradientMagLessThanDiv.p cuz <= 0'
		}
		if(i>0 && (sign(val)!=sign(lastVal) || abs(val)< closeEnuf)){
			found= true;
			// approximate crossing
			float dt= ( stepFunction(val,lastVal)*abs(lastVal) ) / ( abs(val)+ abs(lastVal)+ 1e-9 );
			t= t- stepFunction(val,lastVal)+ dt;
			outPos= origin + dir*t;
			break; //TODO optimize by nonbranching
		}
		lastVal= val;
		float stSz= stepFunction(val,lastVal);
		t+= stSz;
	}
	if(!found) return 999999.0;
	return t;
}

//same as findSurface but finds surface differently and may go thru surfaces its buggy 2025-11-22.
float findSurfaceByGradientsAlongRay(in vec3 origin, in vec3 dir, out vec3 outPos){
	const float safety     = .3; //theres some var in Bellsack opt = {}, how far u go per raytrace step or finding nearest point step, and it might have been .3
	//const float safety     = 0.9;      // under‑estimate factor
	const float gradDecay  = 0.05;     // decay per iteration
	const int   STEPS      = MARCH_MAX_STEPS;

	float t            = 0.0;          // param along ray
	float decayingGrad = 1e-3;         // start with tiny non‑zero

	float val = densityAtXYZ(origin);
	for(int i = 0; i < STEPS; ++i){
		vec3  p        = origin + dir * t;
		val            = densityAtXYZ(p);
		vec3  g        = gradientAtXYZ(p);
		float gradMag  = length(g);

		// exponential decay then instant raise to the new max
		decayingGrad  = max(gradMag, decayingGrad * (1.0 - gradDecay));

		// sphere‑tracing bound using the smoothed gradient magnitude
		float stepLen = safety * abs(val) / (decayingGrad + 1e-6);
		
		// advance – if already on the surface stepLen becomes zero ⇒ sticky
		t += stepLen;

		// early exit condition encoded without branches: break when stepLen==0
		// GLSL for‑loops can’t break branch‑lessly, so we just let further
		// iterations do no movement once |f|→0.
	}

	outPos = origin + dir * t;
	return abs(val) < 0.01 ? t : 999999.0; // loose acceptance, no branching inside loop
}

/*
//findSurface_byInstantMaxDecayingDownGradientMagnitudeToChooseStepSize
float findSurfaceByGradientsAlongRay(in vec3 origin, in vec3 dir, out vec3 outPos){
	float decayingGradMag = 0.; //increases instantly by max, decays down slow
	float gradDecay = .05; //how fast decayingGradMag decays
	for(int i=0;i<MARCH_MAX_STEPS;i++){
		float val = densityAtXYZ(p);
		vec3 gradient = gradientAtXYZ(p);
		float gradMag = length(gradient);
		decayingGradMag *= 1.-gradDecay; //TODO exp(-dt*gradDecayPerSec)?
		decayingGradMag = max(decayingGradMag, gradMag);
		float predicted 
		float stepSize = todo sommething about decayingGradMag;
		TODO
	}
	FIXME TODO
}

/* 


I said[[[
make another float var, that step size is multiplied by. this var ranges 0 to 1. this var decreases instantly if something goes too far. this var increases slowly, like multiplying it by 1.05 per ray step or something like that. its a warning signal to do smaller steps for a short time if some condition happens. that condition is what we need to design. The condition should be that predicted density is too far from observed density, that it predicted better or worse. Each step, make a float prediction of what densityAtXYZ(vec3) will return. Then compare them. abs of that gives you error. that error pumps stepValve lower. stepValve ranges 0 to 1. at 0 nothing moves. at 1 it moves about as fast as it does now or maybe 5 times that. so it could choose to step slower or faster based on accumulation of recent warning signals. Input data will be you get vec3 gradient and float density at each next point you choose to sample by your output is the next step size to use, move vec3 along that ray that far, then the loop repeats. I want you to design this so that the bug i mentioned, where the shape of the raytraced isosurface appears different depending on vec3 camera position viewing it from but for most places it doesnt do that, its just when the findSurface function doesnt find the surface but finds something up to an inch on my screen off where the surface should be and paints it there instead
]]]
gpto3 2025-11-22-2pET said:
//findSurface_byInstantMaxDecayingDownGradientMagnitudeToChooseStepSize
// Marches once along the ray with a step that adapts to a decaying
// record of recent gradient magnitudes.  No binary‑search – just keep
// advancing until the signed value flips or the iteration budget runs
// out.
//   • decayingGradMag rises instantly to the current |∇f|, then shrinks
//     by (1‑gradDecay) each iteration, giving a smoothed upper‑bound.
//   • step = safety * |f| / decayingGradMag   (sphere‑tracing style)
//   • when |f| reaches 0 the step collapses to 0 and the point sticks.
// Returns the hit distance (or 999999.0 if no hit).  Writes the hit
// position into outPos.
float findSurfaceByGradientsAlongRay(in vec3 origin, in vec3 dir, out vec3 outPos){
	const float safety     = 0.9;      // under‑estimate factor
	const float gradDecay  = 0.05;     // decay per iteration
	const int   STEPS      = MARCH_MAX_STEPS;

	float t            = 0.0;          // param along ray
	float decayingGrad = 1e-3;         // start with tiny non‑zero

	float val = densityAtXYZ(origin);
	for(int i = 0; i < STEPS; ++i){
		vec3  p        = origin + dir * t;
		val            = densityAtXYZ(p);
		vec3  g        = gradientAtXYZ(p);
		float gradMag  = length(g);

		// exponential decay then instant raise to the new max
		decayingGrad  = max(gradMag, decayingGrad * (1.0 - gradDecay));

		// sphere‑tracing bound using the smoothed gradient magnitude
		float stepLen = safety * abs(val) / (decayingGrad + 1e-6);
		
		// advance – if already on the surface stepLen becomes zero ⇒ sticky
		t += stepLen;

		// early exit condition encoded without branches: break when stepLen==0
		// GLSL for‑loops can’t break branch‑lessly, so we just let further
		// iterations do no movement once |f|→0.
	}

	outPos = origin + dir * t;
	return abs(val) < 0.01 ? t : 999999.0; // loose acceptance, no branching inside loop
}
*/

//given 2 vec4(red,green,blue,depth), returns the one of min depth.
//These are for chaining textures using prevPic (texture in).
vec4 minDepth(vec4 rgbdA,vec4 rgbdB){
	return (rgbdB.w<rgbdA.w)?rgbdB:rgbdA;
}

// ---------------------------------------------------------------------------
// BallResult – closest hit on any sphere of fixed radius BALL_R.
// colour is just a grey placeholder; replace it however you like.
// ---------------------------------------------------------------------------

//there might be more BallResult fields later even tho 2025-7-7 its float,vec3,int just like RingResult
//but the int means which ball instead of which angle slice aka knob in the ball.
struct BallResult {
	float t;		//distance along the ray
	vec3 pos;		//hit-point in world space	(handy for shading)
	int i;		//index of the sphere that was hit
	int pass;	 //0 = real ball center, 1 = ballCacheVec4.xyz if do_displayBallCacheVec3AsSecondBall
};

${doRings ?
`//doRings: For billboard ring & knobs. 
// We'll store bestRingT, bestRingColor, etc.
struct RingResult{
	float t;
	vec3 color;
	int i; //index 0 to NEAR_BELL5_TOTAL-1 of the ring
};
RingResult findNearestBillboard(in vec3 origin, in vec3 dir){
	RingResult rr;
	rr.t= NULLXYZ;
	rr.color= vec3(0.0);
	rr.i = -2;

	// We'll define a stable planeRight, planeUp for the knob angles
	// We'll pick worldUp= (0,1,0) unless dot(worldUp, camForward)>0.9 => pick (1,0,0).
	vec3 worldUp= vec3(0,1,0);
	//float d= abs(dot(worldUp, normalize(camForward)));
	float d= abs(dot(worldUp, Norm(camForward)));
	if(d>0.9){
		worldUp= vec3(1,0,0);
	}
	
	/*FIXME? GPT-o3 says: If camForward happens to be parallel to worldUp the first cross
	is ≈ (0,0,0) ⇒ NaNs. You handled the almost-parallel case (d>0
	*/
	vec3 planeRight= Norm( cross(camForward, worldUp) );
	vec3 planeUp	 = Norm( cross(planeRight, camForward) );

	//for(int i=0; i<NEAR_BELL5_TOTAL; i++){
	for(int i=0; i<uBellCount; ++i){
		// skip if it's dummy
		//if(bellPositions[i].x>=NULLXYZ) continue;
		if(bellX[i]>=NULLXYZ) continue; //FIXME do all loops, ignore later loops, cuz nonbranching
		// plane intersection
		float denom= dot(dir, Norm(camForward));
		if(abs(denom)<1e-9) continue; //FIXME do all loops, ignore later loops, cuz nonbranching
		vec3 bellXYZ = vec3(bellX[i],bellY[i],bellZ[i]);
		float tC= dot( (bellXYZ-origin), Norm(camForward))/ denom;
		//float tC= dot( (bellPositions[i]-origin), Norm(camForward))/ denom;
		if(tC<0.01 || tC> horizon) continue;

		// dist3D from the plane point to bell center
		vec3 planePt= origin + dir* tC;
		float distCenter= distance(planePt, bellXYZ);

		// approximate how many px is "1 px" at distance tC
		float pxScale= 0.003 * tC;
		float band= circleBandPx * pxScale;

		// ring check
		float ringDiff= abs(distCenter - bellRadii[i]);
		if(ringDiff < band){
			// we have found a ring. Possibly a knob.
			// local 2D coords in plane: localX= dot(planeRight, (planePt-center)), localY= dot(planeUp, (planePt-center))
			vec3 localVec= planePt - bellXYZ;
			float localX= dot(localVec, planeRight);
			float localY= dot(localVec, planeUp);
			float angle= atan(localY, localX); // in [-pi, pi]
			if(angle<0.0) angle += 6.2831853; // so [0..2pi)
			float knobAngle= 6.2831853 / float(KNOB_COUNT); // 2pi/5 => ~1.2566
			// find which knob index is closest:
			float kFloat= angle / knobAngle; // e.g. 2.2 => knob #2
			float kRound= floor( kFloat+0.5 );
			float angleDiff= abs( kFloat - kRound );
			// if angleDiff < knobAngleBand? We do a subband. e.g. 0.2 => yes
			float angleThresh= knobAngleBand; // e.g. 0.2 or 0.15
			if(angleDiff < angleThresh){
				// color the knob
				float knobIdx= mod( kRound, float(KNOB_COUNT) );
				// map 0->red,1->green,2->blue,3->white,4->black for example
				// We'll do a quick if-else or a small array. For brevity, do if else:
				vec3 knobColor;
				if(knobIdx<0.5) knobColor= vec3(1,0,0);
				else if(knobIdx<1.5) knobColor= vec3(0,1,0);
				else if(knobIdx<2.5) knobColor= vec3(0,0,1);
				else if(knobIdx<3.5) knobColor= vec3(1,1,1);
				else knobColor= vec3(0,0,0);
				// pick that
				if(tC< rr.t){
					rr.t= tC;
					rr.color= knobColor;
					rr.i = i;
				}
			} else {
				// it's ring but not a knob => e.g. gray
				if(tC< rr.t){
					rr.t= tC;
					rr.color= vec3(0.6,0.6,0.6);
					rr.i = i;
				}
			}
		}
	}
	return rr;
}` : '//no doRings'}

//Theres 2 passes in debug graphics, 1 in normal graphics. The extra is to display a second ball
//of the same color and with odd vs even pixel columns, centered on the nearest point on isosurface
//as best it can estimate it. This estimation was hard to get right so this is a good test case.
BallResult findNearestBall(in vec3 origin, in vec3 dir ${do_displayBallCacheVec3AsSecondBall?', int pass':''}){
	float bestT	 = NULLXYZ;		 // none yet
	float bestIdx = -1.0;
	vec3	bestPos = vec3(0.0);
	int bestPass = -1;

	const float R2 = BALL_R * BALL_R;

	for(int i=0; i < uBallCount; ++i){
		${do_displayBallCacheVec3AsSecondBall ?
		`//pass is param: for(int pass=0; pass<2; pass++){ //ball then ballCache
		vec3	c	 = pass==0 ?
			vec3(ballX[i], ballY[i], ballZ[i]) :
			//texelFetch(ballCacheVec4, ivec2(i,0), 0).xyz; //WARNING: if texelFetch this address twice it could make GPU return all 0s, FIXME?
			texelFetch(ballCacheVec4, ivec2(0,i), 0).xyz; //WARNING: if texelFetch this address twice it could make GPU return all 0s, FIXME?
		` :
		`int pass = 0; //no displayBallCacheVec3AsSecondBall
		vec3	c	 = vec3(ballX[i], ballY[i], ballZ[i]);`}
		
		vec3	oc	= origin - c;

		float b	 = dot(oc, dir);
		float d	 = b*b - (dot(oc, oc) - R2);			// discriminant
		float okD = step(0.0, d);						// 1 if d ≥ 0

		float root = sqrt(max(d, 0.0));

		float t0	 = -b - root;						// enter
		float t1	 = -b + root;						// exit
		// choose the first positive root (t0 if it’s ≥0, else t1)
		float tCand = mix(t1, t0, step(0.0, t0));
		float hit	 = okD * step(0.0, tCand);			// 1 if real & in front

		// keep nearest valid hit so far
		float closer = hit * step(tCand, bestT);
		bestT	 = mix(bestT,	 tCand,			 closer);
		bestIdx = mix(bestIdx, float(i),		closer);
		bestPos = mix(bestPos, origin + tCand*dir, closer);
		//bestPass = mix(bestPass, pass,				 closer); //float vs int breaks
		bestPass = int( mix( float(bestPass), float(pass), closer ) );	// <- fixed
		${do_displayBallCacheVec3AsSecondBall ? '//}//end 2 pass' : ''}
	}

	return BallResult(bestT, bestPos, int(bestIdx), bestPass);
}

// shading the surface
vec3 shadeSurface(in vec3 p){
	float eps= 0.001;
	//float base= sumOfBellcurves(p);
	float base = densityAtXYZ(p);
	
	${graphicsDebug ?
	`//2025-11-20+ experiment to turn "raytracing squiggle" errors
	//into bright green surfade. miss by more than tolerance?  flag it
	//if(abs(base) > closeEnuf){
	if(abs(base) > DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan){ //move ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan slider in top/red panel to adjust how much bright green error shows, how far off it has to be. Track down bugs in raytracing and physics with this. Added 2025-11-21.
		return vec3(0.0, 1.0, 0.0); //constant bright-green debug colour
	}`
	:
	'//NOT IsGraphicsDebug so no DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan'
	}
	
	vec3 grad= vec3(0);
	for(int k=0;k<3;k++){
	vec3 offset= vec3(0);
	offset[k]= eps;
	//float val2= sumOfBellcurves(p+ offset);
	float val2 = densityAtXYZ(p+offset);
	grad[k]= (val2 - base)/ eps;
	}
	vec3 N= Norm(grad);
	vec3 L= Norm(vec3(1,1,1));
	float bright= 1.8/(1.0+ exp(-2.5* dot(N,L)));
	float weirdBright = .5+.5*sin(bright*10.);
	float wx= dot(N,vec3(1,0,0))*0.5 +0.5;
	float wy= dot(N,vec3(0,1,0))*0.5 +0.5;
	float wz= dot(N,vec3(0,0,1))*0.5 +0.5;
	float sumw= wx+wy+wz +1e-9;
	vec3 angleColor= (color1*wx + color2*wy + color3*wz)/ sumw;
	//return angleColor* bright;
	//return bright;
	//return angleColor;
	//return vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	//float smul = 8.;
	float smul = 2.5;
	vec3 stable3dColor = vec3(.5+.5*sin(p[0]*smul),.5+.5*sin(p[1]*smul),.5+.5*sin(p[2]*smul));
	vec3 abc = vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	vec3 ret = abc*.03+stable3dColor*.7+bright*-.3;
	${graphicsDebug ?
	`//graphicsDebug=true
	float minDistanceTo_ballCacheVec4 = 1000000.;
	float minDistanceTo_ball = 1000000.;
	for(int bi=0; bi<uBallCount; ++bi){
		if(float(bi) >= (numBalls-.5)){
			continue;
		}
		${Dom('addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform').checked ?
			'vec4 ballVec4 = ballCacheVec4[bi]; //shadeSurface: fast, uniform cuz addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform, but was slow to copy it to CPU then to uniform' :
			'vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(bi,0), 0); //shadeSurface: slow, from texture, compared to uniforms'
		}
		//vec4 ballVec4 = texelFetch(ballCacheVec4, ivec2(bi,0), 0);
		vec3 isosurfaceXYZ_neutral = ballVec4.xyz; //from the float[~500] thats neutral not perturbed
		//float densityAt_isosurfaceXYZ_neutral = ballVec4.w; //from the float[~500] thats neutral not perturbed
		float distToIsosurfaceEstimate = length(isosurfaceXYZ_neutral-p);
		minDistanceTo_ballCacheVec4 = min(minDistanceTo_ballCacheVec4,distToIsosurfaceEstimate);
		vec3 otherBallXYZ = vec3(ballX[bi],ballY[bi],ballZ[bi]);
		float distanceTo_ball = length(otherBallXYZ-p);
		minDistanceTo_ball = min(minDistanceTo_ball, distanceTo_ball);
	}
	if(minDistanceTo_ball < ${Lamgl.jsNumToGlslFloat(opt.graphicsDebug_distanceToBall_displayRadius)}){
		ret = vec3(0,.5,1); //1/3 green 2/3 blue on isosurface near ball, not estimate, actual distance
	}
	if(minDistanceTo_ballCacheVec4 < ${Lamgl.jsNumToGlslFloat(opt.graphicsDebug_ballCacheVec4_displayRadius)}){
		ret = vec3(1.,0.,0); //red near isosurfaceXYZ_neutral, a small unshaded ball around it
	}
	` : '//graphicsDebug=false'}
	return ret;
}


float LT(float b, float c){ //lessThan. b<c ? 1. : 0., similar to step(b,c) which is b<=c ? 1. : 0.
	return 1.0-step(c, b);
}

float GT(float b, float c){ //greaterThan. b > c ? 1. : 0.
	return 1.0 - step(b, c);
}

float LTE(float b, float c){ // lessThanOrEqual. b <= c ? 1. : 0.
	return step(b, c);
}

float GTE(float b, float c){ // greaterThanOrEqual. b >= c ? 1. : 0.
	return step(c, b);
}
//vec3 limitGradient(vec3 gradient){
//};

float Mix(float a, float fractionB, float b) {
	return mix(a, fractionB, b);
}

float sigmoid(float x){ return 1./(1.+exp(-x)); }

//compares vec3s found near a ball position so u keep the best vec3, excluding vec3s that are suck at localMins such as in the saddlering bug.
float multiprobeSortVal(vec3 pointNearIsosurface, float densityNearIsosurface, vec3 ballPos){
	return abs(densityNearIsosurface)*500. + length(pointNearIsosurface-ballPos);
}

${(()=>{ //run this block of code and return a string to become part of this big string literal
switch(funcName){

case 'physicsSimple':
return `void main(){ //physics, use with VarGradientGL (which calls Lamgl)
	//gradient code will be auto inserted here by VarGradientGL for numVars+1 gpuThreads/pixels,
	//which will perturb loss() based on at most 1 of the uniform floats being changed per thread.
	outColor = vec4(loss_optimizedBy_physicsSimple(), 0., 0., 0.);
}`;

case 'physicsCacheNearestVec4PerBall':
case 'physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters':
//physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters is same
//as physicsCacheNearestVec4PerBall except SignedDistanceNewtonIterations+1 times more vec4s returned
//per call of nearestPointOnIsosurfaceFromXYZ cuz it has that many times more GPU threads that call
//nearestPointOnIsosurfaceFromXYZ(vec3, vec3, int endItersEarly) with different values of endItersEarly.
//endItersEarly ranges 0 to SignedDistanceNewtonIterations inclusive.
//
//physicsCacheNearestVec4PerBall returns vec4(nearestPointOnIsosurface, sortValForIfmultiprobe) cuz
//u gotta store vec4 per pixel in Lamgl.Tensor of shape [height,width,4].
//offsetIndex is 0 when NOT multiprobe, else is 0..(multiprobe_vec3Offsets.length()-1).
//The offset at multiprobe_vec3Offsets[0] is vec3(0.,0.,0.) aka the ball center itself.
let code = `vec4 ballCacheVec4(int ballIndex, int offsetIndex, int endItersEarly){ //default endItersEarly is 0
	vec3 ballPos = vec3(ballX[ballIndex],ballY[ballIndex],ballZ[ballIndex]);
	vec3 offsetVec3 = multiprobe_vec3Offsets[offsetIndex]; //array size may be 1 vec3 even if multiprobe_vec3Offsets exists in js with more such as 17 vec3s, if !multiprobePhysics
	vec3 startFromVec3 = ballPos+offsetVec3;
	vec3 nearestPointOnIsosurface = nearestPointOnIsosurfaceFromXYZ(ballPos, startFromVec3);
	//FIXME use densityAtSXYZ instead of densityAtXYZ, but wheres the shapeId? bell5s are not the only shape. there could be mandelbulb etc.
	float densityAtPointNearIsosurface = densityAtXYZ(nearestPointOnIsosurface); //TODO remove this when not multiprobe
	float sortVal = multiprobeSortVal(nearestPointOnIsosurface, densityAtPointNearIsosurface, ballPos);
	return vec4(nearestPointOnIsosurface,sortVal);
}`;
if(funcName == 'physicsCacheNearestVec4PerBall'){
	code += `void main(){ //physicsCacheNearestVec4PerBall, use with Lamgl (not VarGradientGL). This is the one with just 2 physics shader. 2023-12-2 about to make that 3 physics shaders by including multiprobe_vec3Offsets depending on a checkbox.
		//Makes the extra param for physicsUseNearestVec4PerBall (or 4 params if split 1 var/float list each)
		//FIXME return vec3 nearest point and float (fourth number) of d(loss)/d(densityAtXYZ)
		//ID = int(uv.x*float(width)); //range 0 to width-1. gpu thread id.
		int ballId = int(gl_FragCoord.y); //ballX ballY ballZ etc
		int offsetId = int(gl_FragCoord.x); //multiprobe_vec3Offsets
		outColor = ballCacheVec4(ballId, offsetId, 0); //endItersEarly=0 so get just the last vec3, the one likely near isosurface
	}`;
}else if(funcName == 'physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters'){
	code += `void main(){ //physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters which makes vec4(x,y,z,colorRGBOrMaybeShouldBeOffsetId)
		int ballId = int(gl_FragCoord.y); //ballX ballY ballZ etc
		int numPointsPerNewtonLoop = SignedDistanceNewtonIterations+1;
		int offsetId_and_endItersEarly = int(gl_FragCoord.x); //multiprobe_vec3Offsets.length*numPointsPerNewtonLoop
		int offsetId = offsetId_and_endItersEarly/numPointsPerNewtonLoop;
		int endItersEarly = offsetId_and_endItersEarly%numPointsPerNewtonLoop;
		outColor = ballCacheVec4(ballId, offsetId, endItersEarly);
	}`;
}else throw new Error('funcName='+funcName);
return code;

case 'physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters':
//same as physicsCacheNearestVec4PerBall except SignedDistanceNewtonIterations+1 times more vec4s returned
//per call of nearestPointOnIsosurfaceFromXYZ cuz it has that many times more GPU threads that call
//nearestPointOnIsosurfaceFromXYZ(vec3, vec3, int endItersEarly) with different values of endItersEarly.
//endItersEarly ranges 0 to SignedDistanceNewtonIterations inclusive.
return `vec4 ballCacheVec4(int ballIndex, int offsetIndex){
	vec3 ballPos = vec3(ballX[ballIndex],ballY[ballIndex],ballZ[ballIndex]);
	vec3 offsetVec3 = multiprobe_vec3Offsets[offsetIndex]; //array size may be 1 vec3 even if multiprobe_vec3Offsets exists in js with more such as 17 vec3s, if !multiprobePhysics
	vec3 startFromVec3 = ballPos+offsetVec3;
	vec3 nearestPointOnIsosurface = nearestPointOnIsosurfaceFromXYZ(ballPos, startFromVec3);
	//FIXME use densityAtSXYZ instead of densityAtXYZ, but wheres the shapeId? bell5s are not the only shape. there could be mandelbulb etc.
	float densityAtPointNearIsosurface = densityAtXYZ(nearestPointOnIsosurface); //TODO remove this when not multiprobe
	float sortVal = multiprobeSortVal(nearestPointOnIsosurface, densityAtPointNearIsosurface, ballPos);
	return vec4(nearestPointOnIsosurface,sortVal);
}
void main(){ //physicsCacheNearestVec4PerBall, use with Lamgl (not VarGradientGL). This is the one with just 2 physics shader. 2023-12-2 about to make that 3 physics shaders by including multiprobe_vec3Offsets depending on a checkbox.
	//Makes the extra param for physicsUseNearestVec4PerBall (or 4 params if split 1 var/float list each)
	//FIXME return vec3 nearest point and float (fourth number) of d(loss)/d(densityAtXYZ)
	//ID = int(uv.x*float(width)); //range 0 to width-1. gpu thread id.
	int ballId = int(gl_FragCoord.y); //ballX ballY ballZ etc
	int offsetId = int(gl_FragCoord.x); //multiprobe_vec3Offsets
	outColor = ballCacheVec4(ballId, offsetId);
}`;

case 'physicsUseNearestVec4PerBall':
return `void main(){ //physicsUseNearestVec4PerBall, use with VarGradientGL (which calls Lamgl).
	//TODO 1 less Var/dimension cuz theres no +1 for neutral sample
	//when doing lossGradient, compared to loss in physicsSimple.
	//takes extra param (or 4 params if split 1 var/float list each) made
	//in earlier physicsCacheNearestVec4PerBall call of Lamgl.
	//its still just returning loss() like in physicsSimple, but is different loss code to do the optimization.
	//outColor = vec4(lossGradient_optimizedBy_physicsUseNearestVec4PerBall(), 0., 0., 0.); //numVars GPU threads, return gradient directly.
	outColor = vec4(loss_optimizedBy_physicsUseNearestVec4PerBall(), 0., 0., 0.); //numVars+1 GPU threads, return loss.
}`;

case 'graphicsMain': case 'graphicsDebug':
return `
vec3 gridColor(vec3 position){
	return vec3(
		max(0.,mod(position.x,0.1)-.09)*100.,
		max(0.,mod(position.y,0.1)-.09)*100.,
		max(0.,mod(position.z,0.1)-.09)*100.
	);
}

void main(){ //graphics, use with Lamgl (not VarGradientGL)
	//generate instead in perturbGlsl: ID = int(uv.x*float(width)); //range 0 to width-1
	// build a ray from pixel
	vec2 st= uv*2.0-1.0;
	vec3 dir= Norm( camForward + st.x*camRight + st.y*camUp );

	${doRings ?
	`// 1) find ring
	RingResult rRing= findNearestBillboard( camPos, dir );
	
	//TODO 2025-11-24 add this code to display localmins of saddlering bug, thing should appear in middle of saddlering
	//let grad = gradientAtXYZ(cam
	//FIXME where does this code go? in raytracing loop...
	
	
	float ringDistance = rRing.t;
	` : 'float ringDistance = NULLXYZ; //no doRings in main'};
	
	${do_displayBallCacheVec3AsSecondBall?'int pixelX = int(uv.x*float(width)); //range 0 to width-1':''}
	BallResult ball = findNearestBall(camPos, dir ${do_displayBallCacheVec3AsSecondBall?', pixelX&1':''});
	float ballDistance = ball.t;

	// 2) find surface
	vec3 surfPos= vec3(0);
	float surfaceDistance = ${opt.displayTerrain ?
		(Chk('findSurfaceByGradientsAlongRay') ?
			'findSurfaceByGradientsAlongRay( camPos, dir, surfPos ); //third mode that ignores opt.isRaymarch (FIXME reorganize graphics options cuz thats confusing). experimental 2025-11-22, havent seen findSurfaceByGradientsAlongRay work as i write this now.'
			:
			'findSurface( camPos, dir, surfPos ); //2 possible modes depending on opt.isRaymarch being 1 or 0'
		)
		:
		'NULLXYZ;'
	}

	float minDistance = min(surfaceDistance, min(ringDistance, ballDistance));
	if(minDistance < NULLXYZ){
		if(surfaceDistance<=ringDistance && surfaceDistance<=ballDistance){ //surface
			vec3 c = shadeSurface(surfPos);
			//outColor = vec4(c+gridColor(surfPos),1.0);
			//outColor = vec4(c,1.0);
			outColor = vec4(c*2.1+gridColor(surfPos)*.3,1.0);
		}else if(ballDistance<=ringDistance && ballDistance<=surfaceDistance){ //ball
			//float bright = 1.-sigmoid(ballDistance*.1-1.5);
			//make pass 1 half brightness
			float brightMulCuzPass = (ball.pass == 1) ? 0.5 : 1.0;
			float bright = (1.-sigmoid(ballDistance*.1-1.5));
			float mulA = mod(ballDistance,2.3)/2.3;
			float balColFloat = BallColorFloat[ball.i]; //24 bit color from rock paper scissors teams
			float ballRed	 = mod(balColFloat, 256.0)/256.;
			float ballGreen = mod(floor(balColFloat / 256.0), 256.0)/256.;
			float ballBlue	= floor(balColFloat / 65536.0)/256.;
			${Dom('debugGraphicsOnBallThatUsesSignedDistancePerPixel').checked?
			`//yes opt.debugGraphicsOnBallThatUsesSignedDistancePerPixel
			//outColor = vec4(.2*bright,.5*bright*mulA,.9*bright,1.0); //FIXME constant blue color of ball just to see if it displays balls
			//float signedDistance = signedDistanceAtXYZ(ball.pos);
			${Chk('multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel') ?
			`//is multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel, so do ~17 size loop of searching for smallest possible signedDistance.
			//This is an expensive calculation to do per pixel, even more expensive to do it in a multiprobe loop inside each pixel, but thats what the options say to do.
			float signedDistance = 1e30; //find smallest, which may be negative aka deepest penetration, or closest thing its to. distance to terrain or other balls.
			for(let offsetId=0; offsetId<multiprobe_vec3Offsets.length(); offsetId++){
				float foundSignedDistance = signedDistanceAtXYZExcludingBallIndex(ball.pos,startFrom,ball.i);
				signedDistance = min(foundSignedDistance, signedDistance); //find best of the ~17 multiprobes
			}
			`
			:
			`vec3 startFrom = ball.pos; //not multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel, just search once.
			float signedDistance = signedDistanceAtXYZExcludingBallIndex(ball.pos,startFrom,ball.i);`
			}
			//float debugRedBrightness = sigmoid(signedDistance);
			//float debugRedBrightness = signedDistance > 0. ? 1. : 0.;
			//float debugRedBrightness = .5+.5*sin(signedDistance*14.1)
			//float debugRedBrightness = mod(signedDistance,.1)*10.;
			//float debugRedBrightness = sigmoid(signedDistance*4.);
			//float debugRedBrightness = 1.-max(0.,abs(signedDistance*5.));
			//float debugRedBrightness = 1.-max(0.,abs(signedDistance*5.));
			float debugRedBrightness = 0.;
			//float debugBlueBrightness = signedDistance > 0. ? 1. : 0.;
			//float debugBlueBrightness = 0.;
			//float debugBlueBrightness = .7;
			//float debugBlueBrightness = .05 + .08/(abs(signedDistance)+.00001);
			float debugBlueBrightness = signedDistance*5.;
			//outColor = vec4(debugRedBrightness,.1*bright*mulA,.3*bright,1.0); //FIXME constant blue color of ball just to see if it displays balls
			//float blue = max(0.,mod(ball.pos.x,0.1)-.09)*100.;
			//outColor = vec4(debugRedBrightness*5.,0.,blue,1.0); //FIXME constant blue color of ball just to see if it displays balls
			`:`
			//no opt.debugGraphicsOnBallThatUsesSignedDistancePerPixel
			float debugRedBrightness = 0.;
			float debugBlueBrightness = bright;
			`}
			float gridBright = .2;
			outColor = vec4(ballRed+debugRedBrightness, ballGreen, ballBlue+debugBlueBrightness, 1.)+vec4(gridColor(ball.pos)*gridBright,0.);
			outColor *= brightMulCuzPass;
		}else{ //ring. TODO remove this if !doRings
			${doRings ? 'outColor = vec4(rRing.color,1.0);' : 'outColor = vec4(1.,1.,0.,1.); //no doRings'}
		}
	}else{
		outColor= vec4(0.5,0.5,0.5,1.0);
	}
	//Do this in last shader, the one where circle is painted around mouse,
	//just make whole thing darker there if so.
	//if(densityAtXYZ(camPos) > 0.){ //camera is in solid volume (not open area).
	//	//c = c*.4; //darken color
	//	outColor *= ${opt.brightMultiplierInIsosurface}; //darken color
	//}
	outColor.w = minDistance; //for rgbd sorting by d aka depth aka 3d distance from camPos
	
	//if(mod(uv.x,.02) < .01){
	//	outColor = vec4(.1, .5, .9, 1.); //FIXME, display vertical blue lines for testing
	//}
	/*
	float bifractionY = uv.y*2.-1.; //range -1 to 1
	float bifractionX = uv.x*2.-1.;
	float distanceToMouse = length(vec2(mouseY-bifractionY, mouseX-bifractionX));
	if(distanceToMouse < .02){
		outColor = vec4(.1, .8, .3, 1.); //display circle around mouse
	}*/
}`; //end graphics
} //end switch(funcName)
})()} //end block of code
`;
};

var truncated_SignedDistanceNewtonIterations =
	()=>Math.max(2,Math.min(ns.Opt.SignedDistanceNewtonIterations.p|0, 256));

//These are the nearby (to camPos) bell5's (weighted 3d bellcurves)
//in 5 Float32Arrays for use in cpuDensityAtXYZ(xyz)=>float.
var bellR = null; //new Float32Array(opt.NEAR_BELL5_TOTAL);
var bellSelf = null; //new Float32Array(opt.NEAR_BELL5_TOTAL);
var bellX = null; //new Float32Array(opt.NEAR_BELL5_TOTAL);
var bellY = null; //new Float32Array(opt.NEAR_BELL5_TOTAL);
var bellZ = null; //new Float32Array(opt.NEAR_BELL5_TOTAL);

/* copied from sfSourceMaker 2025-11-9. Modifying to run on CPU so can darken when densityAtXYZ(camPos)>0.
//EstimatePhysicsFlop: bells*25
float sumOfBellcurves(in vec3 p){
	float val=0.;
	//for(int i=0; i<${opt.NEAR_BELL5_TOTAL}; i++){
	for(int i=0; i<uBellCount; ++i){
		//vec3 d = p - bellPositions[i];
		vec3 d = p - vec3(bellX[i],bellY[i],bellZ[i]);
		float dist2= dot(d,d);
		//dist2 += sin(dist2*33.); //FIXME this adds a sine wave outward from center of each bell5
		//dist2 += sin(dist2*3.9); //FIXME this adds a sine wave outward from center of each bell5
		//dist2 += 5.*sin(dist2*1.09); //FIXME this adds a sine wave outward from center of each bell5
		val += bellStrengths[i]* exp(-dist2/(2.0 * bellRadii[i]* bellRadii[i]));
	}
	return val;
}

//sum of all the species/codeTypes, including the 5 float 3d bellcurves.
//EstimatePhysicsFlop: sumOfBellcurves
//EstimatePhysicsFlop_temp: bells*25
float densityAtXYZ(in vec3 xyz){
	float density = sumOfBellcurves(xyz);
	//TODO add other species/codeTypes here.
	return density;
}*/
var cpuSumOfBellcurves = xyz=>{ //xyz.length==3
	let val=0.;
	//what if its less than that many bells? then search is broken cuz theres always more than that in the system.
	for(let i=0; i<opt.NEAR_BELL5_TOTAL; ++i){ //uBellCount: opt.NEAR_BELL5_TOTAL,
		let dist2 = (xyz[0]-bellX[i])**2 + (xyz[1]-bellY[i])**2 + (xyz[2]-bellZ[i])**2;
		val += bellSelf[i]* Math.exp(-dist2/(2.0 * bellR[i]* bellR[i])); //bellSelf is bellStrengths. bellR is bellRadii.
	}
	return val;
}

//densityAtXYZ(vec3)=>float is the GLSL one. This is the CPU one which should in theory compute the
//same between CPU and GPU but u gotta keep it updated with Sak code which transpiles both to js and to glsl
//and is w=>{..code to read ns.X.p ns.Y.p ns.Z.p (which vec3 xyz means)
//w.ManaRefillRate.p and w.OtherVar.p etc... and return float density. }
//There are 2 densityAtXYZ funcs, one in GPU (and maybe will be multiple, one per species or group of species), and one in CPU/js called much fewer times per second just to find if camera is inside/outside and simple things like that.
var cpuDensityAtXYZ = xyz=>{
	let density = cpuSumOfBellcurves(xyz);
	density += ns.Opt.AddToDensityForTesting.p;
	//TODO add other species/codeTypes here.
	return density;
}

//generate these live cuz depends on checkbox etc starting 2025-8-8
/*
const sfSource_physicsSimple = ()=>sfSourceMaker('physicsSimple'); //returns loss (ignore last 3 numbers)
const sfSource_physicsCacheNearestVec4PerBall = ()=>sfSourceMaker('physicsCacheNearestVec4PerBall'); //vec4(nearestPointOnIsosurface, density)
const sfSource_physicsUseNearestVec4PerBall = ()=>sfSourceMaker('physicsUseNearestVec4PerBall'); //returns gradient (ignore last 3 numbers)
const sfSource_graphicsMain = ()=>sfSourceMaker('graphicsMain'); //returns vec4(red,green,blue,1.)
//Of those 4, some are used with Lamgl directly, and some are used with modded code by VarGradientGL that calls Lamgl.
const sfSource_graphicsDebug = ()=>sfSourceMaker('graphicsDebug'); //also has ballCacheVec4 param to display those vec3s near isosurface per ball thats nearest to that part of isosurface, to check if ballCacheVec4 is accurate.
*/


//physicsNumGpuThreads=balls*3+1

//physicsCycle
//EstimatePhysicsFlop: physicsNumGpuThreads*loss
//EstimatePhysicsFlop_temp: (balls*3+1)*(balls*((signedDistanceNewtonIterations*5*bells*25)+balls*8))
//
//balls=50
//signedDistanceNewtonIterations=32
//EstimatePhysicsFlop_temp2: (50*3+1)*(50*((32*5*50*25)+50*8))
//
//2025-7-22/Bellsack225.html Quick estimate of number of flop (multiply or add of float32) my Bellsack game does
//per physics cycle: (balls*3+1)*(balls*((signedDistanceNewtonIterations*5*bells*25)+balls*8))
//= 1.5 billion if there are 50 balls and 50 3d bellcurves nearby. Thats a TRIPLE LOOP (1 fork 2 loops)
/* TODO update 25 to 34, and update 8 to 20. GPT-o4-mini-high said it.
Your arithmetic is spot-on for the formula you wrote:
However, the assumed constants (25 flops per bell and 8 flops per ball–ball test) are optimistic. If we plug
in the more accurate counts we derived earlier—≈34 flops per bell in sumOfBellcurves and ≈20 flops per slot in
the ball–ball loop—the same pattern gives:
js
Copy
Edit
(50*3 + 1)									 // 151 GPU threads
* 50										 // 50 balls in loss()
* ( 32*5*50*34	 // 5 density calls/iter × 32 iters × 50 bells × 34 flops/bell	
	+ 50*20 )		// 50 slots × 20 flops/slot
≈ 2.06e9 FLOPs
So your form is correct (“triple loop”: threads × balls × (isosurface + ball–ball)), and your arithmetic checks out, but to match our detailed count we should use:
34 flops per bell (not 25)
20 flops per ball–ball slot (not 8)
That raises your 1.5 billion estimate up to ≈2.06 billion FLOPs per physics pass.
*/

/***************************************************************
 * 6) Create & link
 ***************************************************************/

/*let vs=compileShader(gl,gl.VERTEX_SHADER,svSource);
let fs=compileShader(gl,gl.FRAGMENT_SHADER,sfSource);
let program= gl.createProgram();
gl.attachShader(program,vs);
gl.attachShader(program,fs);
gl.linkProgram(program);
if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
	console.error("link err:",gl.getProgramInfoLog(program));
	throw new Error("link fail");
}
gl.useProgram(program);

// uniform locs
let loc_bellPos = gl.getUniformLocation(program,"bellPositions");
let loc_bellRad = gl.getUniformLocation(program,"bellRadii");
let loc_bellStr = gl.getUniformLocation(program,"bellStrengths");

let loc_camPos	 = gl.getUniformLocation(program,"camPos");
let loc_camFwd	 = gl.getUniformLocation(program,"camForward");
let loc_camRight = gl.getUniformLocation(program,"camRight");
let loc_camUp	= gl.getUniformLocation(program,"camUp");

let loc_horizon	= gl.getUniformLocation(program,"horizon");
let loc_isRay	= gl.getUniformLocation(program,"isRaymarch");
let loc_closeE	 = gl.getUniformLocation(program,"closeEnuf");
let loc_circPx	 = gl.getUniformLocation(program,"circleBandPx");
let loc_knobAng	= gl.getUniformLocation(program,"knobAngleBand");
let loc_selectedBellI	 = gl.getUniformLocation(program,"selectedBellI");

let loc_col1	 = gl.getUniformLocation(program,"color1");
let loc_col2	 = gl.getUniformLocation(program,"color2");
let loc_col3	 = gl.getUniformLocation(program,"color3");

// VAO
let quadVBO= gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,quadVBO);
let quadData= new Float32Array([
	-1,-1, 1,-1, -1,1,
	-1,1, 1,-1, 1,1
]);
gl.bufferData(gl.ARRAY_BUFFER,quadData,gl.STATIC_DRAW);

let vao= gl.createVertexArray();
gl.bindVertexArray(vao);
//let posLoc= gl.getAttribLocation(program,"position");
let posLoc= gl.getAttribLocation(program,"XY"); //renamed position to XY for Lamgl compatibility	
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
gl.bindVertexArray(null);
*/

/***************************************************************
 * 7) Searching up to NEAR_BELL5_TOTAL
 ***************************************************************/

let nearBells=[]; //nearest opt.NEAR_BELL5_TOTAL (or less if theres not that many) child Var's of NS.Bell5.
let selectedBellI = -1; //index in nearBells, copied into GPU for display
//
//TODO each species (bell5, bell10, bell13, mandelbulb, etc) all in 1 float[numInstances*numFloatsInThatSpecies],
//but until then im using numFloatsInThatSpecies of float[numInstances] each.
//
//let gpuPos= new Float32Array(opt.NEAR_BELL5_TOTAL*3);
//
//let gpuRad = new Float32Array(opt.NEAR_BELL5_TOTAL); //3d bellcurve radius aka stdDev
//let gpuStr = new Float32Array(opt.NEAR_BELL5_TOTAL); //3d bellcurve strength
//let bellX = new Float32Array(opt.NEAR_BELL5_TOTAL);
//let bellY = new Float32Array(opt.NEAR_BELL5_TOTAL);
//let bellZ = new Float32Array(opt.NEAR_BELL5_TOTAL);

/*var Shuffle = arr=>{
	for (var i = arr.length - 1; i > 0; i--){
		var j = randInt(i + 1);
		[arr[i], arr[j]] = [arr[j], arr[i]];
	}
};*/

/*fixme still need to update selectedBellI in lamglLoopBody
function updateNearBells(){
	let rng= 200;
	let cpx= camPos[0], cpy= camPos[1], cpz= camPos[2];
	if(opt.displayCenterForwardOfCam){
		let fwd = calculateForwardVector(camQ);
		cpx += fwd[0]*opt.displayCenterForwardOfCam
		cpy += fwd[1]*opt.displayCenterForwardOfCam;
		cpz += fwd[2]*opt.displayCenterForwardOfCam;
	}
	/*let cands= spatialGrid.queryNearby(cpx,cpy,cpz, rng);
	//FIXME 2025-3-27 this is returning all 100k bells cuz cell size is 10.
	cands.sort((a,b)=>{
		let da=(a.x-cpx)**2+(a.y-cpy)**2+(a.z-cpz)**2;
		let db=(b.x-cpx)**2+(b.y-cpy)**2+(b.z-cpz)**2;
		return da-db;
	});*
	//nearBells = cands.slice(0,opt.NEAR_BELL5_TOTAL);
	nearBells = NS.Bell5.searchZYXR(cpx, cpy, cpz, 10000000, opt.NEAR_BELL5_TOTAL); //FIXME is this param order backward for camPos?
	//Shuffle(nearBells); //randomly reorder. Is this why some graphics bugs happen? dont want it depending on order of bell5s.
	//let prev_selectedBellI = selectedBellI;
	selectedBellI = -1; //none
	for(let i=0;i<nearBells.length; i++){
		//gpuPos[i*3+0]= nearBells[i].x;
		//gpuPos[i*3+1]= nearBells[i].y;
		//gpuPos[i*3+2]= nearBells[i].z;
		bellX[i] = nearBells[i].X.p;
		bellY[i] = nearBells[i].Y.p;
		bellZ[i] = nearBells[i].Z.p;
		gpuRad[i]	= nearBells[i].R.p; //radius
		gpuStr[i]	= nearBells[i].p; //see dagball.Circ.influence and dagball.Ball.influence aka strength
		if(nearBells[i].IsSelected.p){
			if(selectedBellI != -1){
				throw new Error('Found second selected bell. max 1.');
			}
			selectedBellI = i; //FIXME what if Shuffle(nearBells) interferes with this?
		}
	}
	//if(prev_selectedBellI != selectedBellI) console.log('selectedBellI='+selectedBellI);
	//console.log('selectedBellI='+selectedBellI);
	/*for(let i=nearBells.length; i<opt.NEAR_BELL5_TOTAL; i++){ //FIXME remove this?
	gpuPos[i*3+0]= 9999;
	gpuPos[i*3+1]= 9999;
	gpuPos[i*3+2]= 9999;
	gpuRad[i]= 0.01;
	gpuStr[i]= 0.0;
	nearBells[i].IsSelected = false;
	}*
}*/

/***************************************************************
 * 8) Camera + Gamepad
 ***************************************************************/

//let camPos=[0,0,5];
let camPos=[0,0,-5];
//let camPos=[0,0,0];
//let camPos=[0,0,-12]; //far back so can see balls 2025-7-17
let camQ	=[0,0,0,1];

var allBalls = ()=>Ball.searchZYXR(0, 0, 0, 1e7, 1e7);

var findRandomBall = ()=>{ //anywhere, not necessarily nearby
	let balls = allBalls();
	if(balls.length==0) Err('No balls');
	return balls[randInt(balls.length)];
};

var ballNearestZYX = (z,y,x)=>Ball.searchZYXR(z, y, x, 1e9, 1)[0];

var shootBall = ()=>{
	console.log('shootBall');
	let ball = findRandomBall();
	let camFwd = calculateForwardVector(camQ);
	//let camDirection = Norm(camF);
	
	//add directly to .p and .v outside of physics loop, but in physics loop use the temp vars .dp .dv etc
	let startDistanceInFrontOfCam = .6;
	ball.X.p = camPos[0]+camFwd[0]*startDistanceInFrontOfCam;
	ball.Y.p = camPos[1]+camFwd[1]*startDistanceInFrontOfCam;
	ball.Z.p = camPos[2]+camFwd[2]*startDistanceInFrontOfCam;
	//let accel = 3;
	let accel = opt.ballShootSpeed;
	ball.X.v = camFwd[0]*accel;
	ball.Y.v = camFwd[1]*accel;
	ball.Z.v = camFwd[2]*accel;
};

let timeLastShot = 0;

function updateFromGamepad(dt){
	let now = Lamgl.time();
	let gps= navigator.getGamepads();
	if(!gps) return;
	let gp= gps[0];
	if(!gp) return;
	let lx= gp.axes[0], ly= gp.axes[1];
	let rx= gp.axes[2], ry= gp.axes[3];
	const dead= 0.06;
	//const dead= 0; //FIXME
	let lLen= Math.hypot(lx,ly);
	if(lLen>dead){
		let leftover= lLen- dead;
		lx*= leftover/lLen;
		ly*= leftover/lLen;
	} else { lx=0; ly=0; }
	let rLen= Math.hypot(rx,ry);
	if(rLen>dead){
	let leftover2= rLen- dead;
		rx*= leftover2/rLen;
		ry*= leftover2/rLen;
	} else { rx=0; ry=0; }
	ry*=-1;
	let turnSpd = 2;
	//let turnSpd = .8;
	//let turnSpd = .6;
	rx *= turnSpd;
	ry *= turnSpd;
	rotateCamera(rx,ry,dt);

	let fwdVal= gp.buttons[7]?.value - gp.buttons[6]?.value;
	let upDown= -ly;
	let leftRight= lx;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= Norm(rig);
	upv= Norm(cross(rig, fwd));
	let moveSpd=2.0;
	//let moveSpd=.8;
	camPos[0]+= (fwd[0]*fwdVal + upv[0]*upDown + rig[0]*leftRight)* moveSpd* dt;
	camPos[1]+= (fwd[1]*fwdVal + upv[1]*upDown + rig[1]*leftRight)* moveSpd* dt;
	camPos[2]+= (fwd[2]*fwdVal + upv[2]*upDown + rig[2]*leftRight)* moveSpd* dt;
	
	let buttonLb = gp.buttons[4].value; //button above the left analog trigger, 0 or 1
	let buttonRb = gp.buttons[5].value; //button above the right analog trigger
	
	if(buttonLb || buttonRb){
		let timeSinceShot = now-timeLastShot;
		if(timeSinceShot > opt.minShootInterval){
			timeLastShot = now;
			shootBall();
		}
	}
	
	if(Chk('holdABallInFrontOfCamera')){
		let ball = ns.Ball.B1;
		if(!ball){
			throw new Error('Didnt find the ball for holdABallInFrontOfCamera');
		}
		//let ball = findRandomBall();
		//let distanceInFrontOfCam = .4;
		let distanceInFrontOfCam = .9;
		ball.X.p = camPos[0]+fwd[0]*distanceInFrontOfCam;
		ball.Y.p = camPos[1]+fwd[1]*distanceInFrontOfCam;
		ball.Z.p = camPos[2]+fwd[2]*distanceInFrontOfCam;
		ball.X.v = 0;
		ball.Y.v = 0;
		ball.Z.v = 0;
	}
}

function rotateCamera(rx, ry, dt){
	const threshold= 0.001;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));

	let combined=[0,0,0,1];
	if(Math.abs(rx)> threshold){
		let yawAngle= -rx*2.0* dt;
		let yawQ= createQuaternion(upv,yawAngle);
		combined= multiplyQuaternions(yawQ,combined);
	}
	if(Math.abs(ry)> threshold){
		let pitchAngle= -ry*2.0* dt;
		let pitchQ= createQuaternion(rig,pitchAngle);
		combined= multiplyQuaternions(combined,pitchQ);
	}
	camQ= multiplyQuaternions(combined, camQ);
	camQ= normalizeQuaternion(camQ);
}

/***************************************************************
 * 9) CPU overlay of ring+knobs is removed. 
 *	But user wants to “click + drag” to update the 5 numbers per bell?
 *	That now means we have no 2D or “visible overlay.” 
 *	We'll do a trivial approach:
 *	If user clicks => we do a “nearest billboard ring.” 
 *	Then if it’s near a knob => store which bell & knob. 
 *	Drag changes that param.	But we cannot see them, 
 *	because we removed the CPU overlay.
 ***************************************************************/

// For demonstration, we'll still handle mouse so user can drag (like a big invisible UI).
// We'll do the same findKnobAt approach in JS, but that means we replicate the plane intersection logic in JS 
// or we do readPixels but that’s more complicated. 
// We'll replicate the plane logic + local tangent-plane transform here. 
// If you truly want *perfect* matching, you'd do a readback from a picking buffer or do an extra pass, but that’s advanced.

// We'll do a minimal approach, scanning the same nearBells.	
// If found ring & knob => we set dragState. Then as user drags => we adjust radius, or strength, or x,y,z, etc.

let dragState=null;

let Controls = {mouseY: 0, mouseX: 0};

let did_bootLamglDomEvents = false;
let bootLamglDomEvents = ()=>{
	console.log('START bootLamglDomEvents, Lamgl.glCanv='+Lamgl.glCanv);
	//Lamgl.Gl(); //create Lamgl.glCanv if not already exist.
	let mousedown = e=>{
		let rect= Lamgl.glCanv.getBoundingClientRect();
		let mx= e.clientX- rect.left;
		//FIXME findKnobAt is flipped in y, +y is up. let my= e.clientY- rect.top;
		//let my= rect.y-e.clientY; //cuz flipped. FIXME
		let my= e.clientY- rect.top;
		my = rect.height-1-my; //cuz flipped. FIXME.
		let k= findKnobAt(mx,my);
		if(k){
			//for(let bc of allBells) bc.IsSelected = false; //unselect all
			for(let bc of Object.values(NS.Bell5.pu)) bc.IsSelected.p = 0; //unselect all
			//if(dragState) dragState.bc.IsSelected = false; //unselect prev selection
			dragState={
				bc: k.bc,
				knobIndex: k.knobIndex,
				startY: my,
				startVal: getParamVal(k.bc,k.knobIndex)
			};
			dragState.bc.IsSelected.p = 1; //select next
			selectVar(dragState.bc); //bc is a bell5/3dBellcurve. Select it in varPathTxt/mainTextarea.
		}
	};
	Lamgl.glCanv.addEventListener("mousedown", mousedown);
	Lamgl.glCanv.addEventListener("mousemove", e=>{
		//mousedown(e); //FIXME
		let rect= Lamgl.glCanv.getBoundingClientRect();
		let my= e.clientY-rect.top; //FIXME
		my = rect.height-1-my; //FIXME cuz flipped y between cpu and gpu
		let mx= e.clientX- rect.left;
		Controls.mouseY = my;
		Controls.mouseX = mx;
		//console.log('mousemove y'+my+' x'+mx);
		if(!dragState) return;
		let dy= my- dragState.startY;
		let newVal= dragState.startVal+ (-dy*0.02);
		setParamVal(dragState.bc, dragState.knobIndex, newVal);
	});
	Lamgl.glCanv.addEventListener("mouseup", e=>{
		for(let bc of Object.values(NS.Bell5.pu)) bc.IsSelected.p = 0; //unselect all
	});
	Lamgl.glCanv.addEventListener("mouseup", e=>{
		dragState=null;
	});
	console.log('END bootLamglDomEvents, Lamgl.glCanv='+Lamgl.glCanv);
}

var selectedKnob = null;

// We replicate the plane logic for ring & knob detection in JS. 
// See the approach used in the fragment code, but we do it once for every bell5. 
// Then we pick whichever is closest in tC. If ringDiff < band => we also do knob angle check.
function findKnobAt(mx,my){
	console.log('findKnobAt mx='+mx+' my='+my);
	let camForward = calculateForwardVector(camQ); //FIXME this was added 2025-3-27 dont know if its the correct camForward
	let camUp= calculateUpVector(camQ); //FIXME
	let camRight= cross(camForward, camUp); //FIXME
	camRight= Norm(camRight); //FIXME
	console.log('camForward='+camForward);

	// transform pixel -> st => [-1..1], st => build ray
	//let width = Lamgl.glCanv.width, height = Lamgl.glCanv.height;
	const rectCanvas = Lamgl.glCanv.getBoundingClientRect(); //cuz canvas stretches
	const width	= rectCanvas.width; //pixels on screen, not in canvas coordinates
	const height = rectCanvas.height;
	//let stx= (mx/(float(width))) *2.0 -1.0; 
	let stx= (mx/width) *2.0 -1.0; 
	//let sty= (my/(float(height)))*2.0 -1.0;
	let sty= (my/height)*2.0 -1.0;
	// but we are in JS, so do
	let stxF= (mx/width)*2 -1;
	let styF= (my/height)*2-1;
	let dir= Norm( vecAdd( camForward, vecAdd( scale(camRight,stxF), scale(camUp,styF) ) ) );

	// define plane normal= camForward
	let n= Norm(camForward);
	let bestT= 999999;
	let bestBell=null;
	let bestKnob=-1;

	// define stable planeRight, planeUp
	let wUp= [0,1,0];
	let d= Math.abs(dot(wUp, n));
	if(d>0.9){
	wUp= [1,0,0];
	}
	let pRight= Norm( cross(n, wUp) );
	let pUp	 = Norm( cross(pRight, n) );

	for(let i=0; i< nearBells.length; i++){
	let bc= nearBells[i];
	if(bc.X.p>9000) continue; //NULLXYZ? or that might be 0. this is padding in nearBells list in case dont find enuf bells.
	let denom= dot(dir, n);
	if(Math.abs(denom)<1e-9) continue;
	let c= [bc.X.p, bc.Y.p, bc.Z.p];
	let diff= vecSub(c, camPos);
	let tC= dot(diff,n)/ denom;
	
	
	
	
	//if(tC<0.01 || tC> opt.horizon) continue; //commentedout 2025-3-28 for testing
	if(tC<0.01 || tC> opt.horizon) continue;
	
	
	
	
	// planePt
	let planePt= vecAdd( camPos, scale(dir, tC) );
	let distC= length( vecSub(planePt, c) );
	// ring diff
	let pxScale= 0.003* tC;
	let band= opt.circleBandPx* pxScale;
	//let ringDiff= Math.abs(distC- bc.radius);
	let ringDiff= Math.abs(distC- bc.R.p);
	if(ringDiff < band){
		// might be a knob
		// local2D
		let localVec= vecSub(planePt, c);
		let localX= dot(localVec, pRight);
		let localY= dot(localVec, pUp);
		let angle= Math.atan2(localY, localX);
		if(angle<0) angle+= 2*Math.PI;
		let knobAng= 2*Math.PI/ opt.KNOB_COUNT; 
		let kFloat= angle/ knobAng;
		let kRound= Math.floor(kFloat+0.5);
		let angleDiff= Math.abs( kFloat- kRound );
		if(angleDiff < opt.knobAngleBand){
		// it's a knob
		if(tC< bestT){
			bestT= tC;
			bestBell= bc;
			bestKnob= kRound % opt.KNOB_COUNT;
		}
		} else {
		// ring
		// maybe store a separate best ring, but user only wants to drag knobs.
		// so if it’s ring only => no knob => no drag
		// skip
		}
	}
	}
	if(!bestBell) return null;
	selectedKnob={bc: bestBell, knobIndex: bestKnob};
	console.log('selectedKnob='+JSON.stringify(selectedKnob));
	setParamVal(selectedKnob.bc, selectedKnob.knobIndex,
	getParamVal(selectedKnob.bc, selectedKnob.knobIndex)+.001);
	return selectedKnob;
}

// minimal vector utilities in JS:
function vecAdd(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];}
function vecMulNum(a,mul){ return [a[0]*mul, a[1]*mul, a[2]*mul];}
function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];}
function dot(a,b){ return a[0]*b[0]+ a[1]*b[1]+ a[2]*b[2];}
function cross(a,b){
	return [
	a[1]*b[2]- a[2]*b[1],
	a[2]*b[0]- a[0]*b[2],
	a[0]*b[1]- a[1]*b[0]
	];
}
function scale(a,s){return [a[0]*s, a[1]*s, a[2]*s];}
function length(a){ return Math.hypot(a[0],a[1],a[2]);}
function Norm(a){
	let L= length(a);
	if(L<1e-9) return [0,0,0]; //FIXME what epsilon size, if any?
	return [a[0]/L, a[1]/L, a[2]/L];
}

/***************************************************************
 * 11) Editing the 5 knobs means x,y,z,radius,str
 ***************************************************************/

function getParamVal(bc,k){
	switch(k){
	case 0: return bc.X.p;
	case 1: return bc.Y.p;
	case 2: return bc.Z.p;
	case 3: return bc.R.p;
	case 4: return bc.p;
	}
}
function setParamVal(bc,k,v){
	//console.log('setParamVal k='+k+' v='+v+' bc='+bc);
	switch(k){
	case 0: bc.X.p = v; break; //FIXME might need to bc.X.setNow(v) so bc.X.nextState(dt) doesnt overwrite it
	case 1: bc.Y.p = v; break;
	case 2: bc.Z.p = v; break;
	case 3: bc.R.p = Math.max(0.01,v); break;
	case 4: bc.p = v; break;
	}
}

/***************************************************************
 * 12) Render/Physics loop
 ***************************************************************/
 
var lamglLoopBody_count = 0;

//added timeSpeedOfVar func, such as timeSpeedOfVar(V.Bellsack.Room1.Ball.B1072.X) returns 1
//and timeSpeedOfVar(V.Bellsack.Room1.Bell5.B004182260.X) returns 0 so 2025-7-24 I froze the terrain
//in time but am still computing its gradient someVar.gr every video frame.
var timeSpeedOfVar = vr=>{
	if(opt.allTimeSpeeds0){
		return 0;
	}
	if(Dom('chkOnlyBallPhysics').checked){
		//TODO dont waste computing on it in VarGradientGL if not gonna use certain Var's that have timeSpeed 0.
		//If put that optimization in, then it will run faster when its only balls moving not terrain,
		//but since I plan to have terrain also moving, the optimization wouldnt get used much,
		//or maybe in some game modes it would I dont know.
		return ((vr.up.name == 'Ball') || (vr.up.up.name=='Ball')) ? 1 : 0; //only balls (including ball.p and ball.X.p Y and Z, not terrain
	}else{
		return 1; //normal
	}
};

var B = null; //ball nearest camPos or maybe just in front of it

//var teamColorFloats = [0x77aa88, 0xff0000, 0x00ff00, 0x0000ff];
var teamColorFloats = [0x111111, 0xff0000, 0x00ff00, 0x0000ff];
//var teamColorFloats = [0x000000, 0xff0000, 0x00ff00, 0x0000ff];

//u still gotta call Var.nextState(dt) at end. Only modifies ballA, not ballB.
var doGameRulesOnPairOfBalls = (ballA, ballB, dt)=>{
	if(ballA != ballB){
		let centerDist = centerToCenterDistance(ballA,ballB);
		//let hit = centerDist<=(2*opt.ballRadius);
		//let nearHit = centerDist<=(3.5*opt.ballRadius); //dont have to actually touch, just be near
		let nearHit = centerDist<=(2.8*opt.ballRadius); //dont have to actually touch, just be near
		let attractSign = 0;
		if(predatorOf(ballA.Tm.p)==ballB.Tm.p) attractSign = -1; //ballA runs from its predator ballB
		if(preyOf(ballA.Tm.p)==ballB.Tm.p) attractSign = 1; //ballA chases its prey ballB
		if(attractSign && centerDist){
			//let approxInverseDistanceSquared = 1/(.001+centerDist*centerDist);
			let approxInverseDistanceSquared = 1/(opt.ballRadius+centerDist*centerDist);
			let attractForce = attractSign*approxInverseDistanceSquared*opt.rpsAccelMul;
			let dx = ballA.X.p-ballB.X.p;
			let dy = ballA.Y.p-ballB.Y.p;
			let dz = ballA.Z.p-ballB.Z.p;
			let normDx = dx/centerDist; //-1 to 1
			let normDy = dy/centerDist; //-1 to 1
			let normDz = dz/centerDist; //-1 to 1
			ballA.X.dv -= dt*normDx*attractForce;
			ballA.Y.dv -= dt*normDy*attractForce;
			ballA.Z.dv -= dt*normDz*attractForce;
		}
		if(predatorOf(ballA.Tm.p)==ballB.Tm.p && nearHit){
			//console.log('ballB captures ballA');
			ballA.Tm.p = ballB.Tm.p; //ballB captures ballA
			//ballA.Tm.set(ballB.Tm.p); //ballB captures ballA, but wait for nextState in case multiple changes conflict in which case dont change it
		}
	}
};

//u still gotta call Var.nextState(dt) at end.
var doGameRulesOnListOfNearBalls = (balls,dt)=>{
	for(let ballA of balls){
		for(let ballB of balls){
			doGameRulesOnPairOfBalls(ballA,ballB,dt);
		}
	}
};

//meant to be the last step in graphics cuz isnt fully rgbd compatible cuz doesnt compute using .w aka the d in rgbd,
//but maybe we can do that later, tho it might cost more Lamgl calls so may be best to leave it as not fully compatible.
//FIXME how do we get the camera angles etc like in glsl func shadeSurface?
/*var paintVoxels = (ballCacheVec4_seeInsideAllNewtonIters, prevPic_rgbd)=>{
	throw new Error('TODO call Lamgl. display it similar to how LamglNBody_333_50kParticles.html works');
};*/
// overwrite prevPic_rgbd with Newton-hop voxels (one Lamgl call)
var paintVoxels = (pts, prevPic_rgbd)=>{ //by GPT-o3 2025-12-15-945aET, todo test this, when physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters checkbox is checked to display newton loop internal points.
	if(!pts) return prevPic_rgbd;						// nothing to do

	const scrH = prevPic_rgbd.sh[0], scrW = prevPic_rgbd.sh[1];
	const ptsH = pts.sh[0],          ptsW = pts.sh[1];
	const totalPts = ptsH * ptsW;						// vertices we care about
	
	let camFwd = calculateForwardVector(camQ);
	let camUp = calculateUpVector(camQ);
	let camRight = cross(camFwd, camUp);
	camRight = normalize(camRight);

	return Lamgl({
		// draw to the same rgbd texture we got from earlier stages
		verts: totalPts, //in size, in units of sparse points aka GPU threads. Use gl_PointSize.
		sh: [scrH, scrW, 4], //out size, same size as prevPic_rgbd aka the off screen texture its painting over, optionally using doSharedTextureOptimization which is a common thing to do for rgbd. 

		sv: `//uniform sampler2D pts;
			//uniform int ptsW, totalPts;
			//uniform vec3 camPos, camRight, camUp, camFwd;
			//uniform float tanHalfFovY, aspect;
			
			// one-at-a-time uniform declarations (Lamgl rule)
			uniform sampler2D pts;
			uniform int ptsH;
			uniform int ptsW;
			uniform int totalPts;

			uniform vec3 camPos;
			uniform vec3 camRight;
			uniform vec3 camUp;
			uniform vec3 camFwd;

			uniform float tanHalfFovY;
			uniform float aspect;
		
			void main(){
				/*//testing can i see it at all, despite this is the wrong calculation:
				//gl_Position = vec4( float(gl_VertexID % 512) / 256.0 - 1.0, float(gl_VertexID/512)/256. - 1., 0., 1.);
				float fraction = float(gl_VertexID)/float(totalPts);
				gl_Position = vec4(fraction*2.-1., fraction*2.-1., 0., 1.); //diagonal across screen, put the points there as test
				gl_PointSize = 10.0;
				//gl_PointSize = 1.0;
				*/

				/* ------ decode this voxel’s texel ----------------------------------- */
				int iy = gl_VertexID / ptsW;          // row inside pts texture
				int ix = gl_VertexID % ptsW;          // col inside pts texture
				vec3 P = texelFetch(pts, ivec2(ix, iy), 0).xyz;   // world-space XYZ

				/* ------ world → camera space ---------------------------------------- */
				vec3 V = P - camPos;
				float z = dot(V, camFwd);             // forward depth ( V·F )

				if (z <= 0.0) {                       // point is behind the camera
					gl_Position = vec4(2.0);          // park off-screen, skip raster
					return;
				}

				/* ------ project to NDC using SAME formula as ray-builder ------------- *
				float ndcX =  dot(V, camRight) / z;   //  st.x = (V·R)/(V·F)
				float ndcY = -dot(V, camUp   ) / z;   //  st.y = −(V·U)/(V·F)
				gl_Position = vec4(ndcX, ndcY, 0.0, 1.0);   // clip-space
				gl_PointSize = 8.0;                         // visible yellow dot
				*/
				float ndcX =  dot(V, camRight) / z;   // perspective-divide → affine 3-D→2-D
				float ndcY =  dot(V, camUp   ) / z;
				gl_Position = vec4(ndcX, ndcY, 0.0, 1.0);   // (x,y)/z is the classic pin-hole projection
				gl_PointSize = clamp(10./z, 1., 30.); // size shrinks with distance → visible 3-D depth cue
			}`,

		sf: `out vec4 inOutColor;							// writing directly back
			void main(){ inOutColor = vec4(1.0, 0.85, 0.1, 1.0); }	// solid debug yellow. FIXME put color in .w of pts and get it out of there`,

		pts: pts,
		ptsH, ptsW, totalPts,
		camPos, camRight, camUp, camFwd,
		tanHalfFovY: Math.tan(opt.fovY_deg * Math.PI / 360),
		aspect: scrW / scrH,

		// draw *into* the existing texture
		inOutColor: prevPic_rgbd
	}).inOutColor;										// same tensor, now with dots
};
 
var lamglLoopBody = ()=>{
	let pause = Dom('pauseBellsack');
	if(!pause || pause.checked){
		console.log('PAUSE, lamglLoopBody ending cuz pauseBellsack');
		return;
	}
	//console.log('lamglLoopBody_count='+(++lamglLoopBody_count));
	//let dt = 1/60; //FIXME compute and clamp this by Lamgl.time()
	let dt = 1/estimateFPS;
	//console.log('lamglLoopBody');
	//let tSmall = Lamgl.time() % 1000.0;
	let tSmall = Lamgl.time() % 86400;
	let camFwd = calculateForwardVector(camQ);
	let camUp = calculateUpVector(camQ);
	let camRight = cross(camFwd, camUp);
	camRight = normalize(camRight);
	
	//moving this to a checkbox (TODO use !!ns.Opt.IsNewEventSystemY2025M11.p instead
	//aka ns.Opt.IsNewEventSystemY2025M11.fieldEditor('p').putInDom(someDiv) makes the checkbox and label appear.
	//const isNewEventSystemY2025M11 = true; //not working as of 2025-11-13-650pET but will soon
	//const isNewEventSystemY2025M11 = false; //old system where lamglLoopBody called someVar.nextState(dt) instead of VarVM.nextState(dt) handling it sparsely.

	let height = Lamgl.glCanvasHeight, width = Lamgl.glCanvasWidth;

	let rect = Lamgl.glCanv ? Lamgl.glCanv.getBoundingClientRect() : {height,width}; //that height and width stretched to full screen canvas. first time glCanv wont exist.
	
	nearBells = NS.Bell5.searchZYXR(camPos[2], camPos[1], camPos[0], 10000000, opt.NEAR_BELL5_TOTAL); //FIXME is this param order backward for camPos?
	
	selectedBellI = -1; //none
	for(let i=0;i<nearBells.length; i++){
		if(nearBells[i].IsSelected.p){
			if(selectedBellI != -1){
				throw new Error('Found second selected bell. max 1.');
			}
			selectedBellI = i; //FIXME what if Shuffle(nearBells) interferes with this?
		}
	}
	
	
	if(nearBells.length != opt.NEAR_BELL5_TOTAL){
		throw new Error("TODO do the thing [ballXVars.push(V.Const['IgnoreX'+i].setNow(NULLXYZ,0));] like did with balls in lamglLoopBody in case theres less total bells.");
	}
	
	let bellRVars = nearBells.map(bell=>(bell.R));
	let bellSelfVars = nearBells.map(bell=>bell); //copy
	let bellXVars = nearBells.map(bell=>(bell.X));
	let bellYVars = nearBells.map(bell=>(bell.Y));
	let bellZVars = nearBells.map(bell=>(bell.Z));
	
	bellR = new Float32Array(opt.NEAR_BELL5_TOTAL);
	bellSelf = new Float32Array(opt.NEAR_BELL5_TOTAL);
	bellX = new Float32Array(opt.NEAR_BELL5_TOTAL);
	bellY = new Float32Array(opt.NEAR_BELL5_TOTAL);
	bellZ = new Float32Array(opt.NEAR_BELL5_TOTAL);
	
	let balls = Ball.searchZYXR(camPos[2], camPos[1], camPos[0], 10000000, opt.NEAR_BALLS_TOTAL); //FIXME is this param order backward for camPos?
	let ballX = new Float32Array(opt.NEAR_BALLS_TOTAL);
	let ballY = new Float32Array(opt.NEAR_BALLS_TOTAL);
	let ballZ = new Float32Array(opt.NEAR_BALLS_TOTAL);
	//let ballXYZVars = [];
	let ballXVars = [];
	let ballYVars = [];
	let ballZVars = [];
	
	let BallColorFloat = new Float32Array(opt.NEAR_BALLS_TOTAL); //GteamRock GteamPaper GteamScissor etc.
	
	for(let i = 0; i < opt.NEAR_BALLS_TOTAL; i++){
		if(i < balls.length){
			ballXVars.push(balls[i].X);
			ballYVars.push(balls[i].Y);
			ballZVars.push(balls[i].Z);
		}else{
			ballXVars.push(V.Const['IgnoreBallX'+i].setNow(NULLXYZ,0));
			ballYVars.push(V.Const['IgnoreBallY'+i].setNow(NULLXYZ,0));
			ballZVars.push(V.Const['IgnoreBallZ'+i].setNow(NULLXYZ,0));
		}
	}
	
	for(let i=opt.NEAR_BELL5_TOTAL; i<opt.NEAR_BELL5_TOTAL; i++){ //pad in case theres less near bells than opt.NEAR_BELL5_TOTAL
		bellRVars.push(V.Const['IgnoreBell5R'+i].setNow(NULLXYZ,0));
		bellSelfVars.push(V.Const['IgnoreBell5Self'+i].setNow(NULLXYZ,0));
		bellXVars.push(V.Const['IgnoreBell5X'+i].setNow(NULLXYZ,0));
		bellYVars.push(V.Const['IgnoreBell5Y'+i].setNow(NULLXYZ,0));
		bellZVars.push(V.Const['IgnoreBell5Z'+i].setNow(NULLXYZ,0));
	}
	
	let ballXYZVars = ballXVars.concat(ballYVars).concat(ballZVars);
	//for(let vr of ballXYZVars){
	for(let i=0; i<balls.length; i++){
		BallColorFloat[i] = teamColorFloats[balls[i].Tm.p|0]; //Tm is team like in Rock Paper Scissors (RPS)
		for(let vr of [ballXVars[i],ballYVars[i],ballZVars[i]]){
			//base velocityDecay, otherwise it wont stop moving or would
			//have equal chance to slow down vs speed up by slight float32 roundoff
			//vr.cv = 1.3; //base velocity decay
			//vr.cv = 4; //base velocity decay
			//vr.cv = .8; //base velocity decay
			//vr.cv = .3; //base velocity decay
			vr.cv = .1; //base velocity decay
			//vr.cv = 0;
			//vr.cv = .8; //base velocity decay
			//vr.cv = 3.3; //base velocity decay
			//vr.cv = 13.3; //base velocity decay
			//vr.cv = 30.;
			//FIXME Var.accelMul should be 1, but this is for testing...
			//vr.accelMul = .1;
			//vr.accelMul = 10;
			vr.accelMul = 23;
			//vr.accelMul = 1;
			//vr.accelMul = 4;
			//vr.accelMul = 9.5;
			//vr.accelMul = 50;
			//vr.accelMul = 250;
			//vr.accelMul = 50000000;
			//vr.accelMul = 500000;
			//vr.accelMul = 1;
			//vr.accelMul = 0; //velocity changes by negative gradient
			//vr.gp = 11.1; //position changes by negative gradient
		}
	}
	V.Const.NULLXYZ.setNow(NULLXYZ,0);
	
	for(let i=0; i<nearBells.length; i++){
		for(let vr of [bellRVars[i],bellSelfVars[i],bellXVars[i],bellYVars[i],bellZVars[i]]){
			//vr.cv = 1.31;
			//vr.cv = 1.31;
			vr.cv = 2.31;
			//vr.accelMul = .01;
			//vr.accelMul = .001;
			vr.accelMul = .001*50;
		}
	}
	for(let i=0; i<ballX.length; i++){
		//ballXYZ[i] = ballXYZVars[i].p; //copy position from the physics list to graphics list
		ballX[i] = ballXVars[i].p; //copy position from the physics list to graphics list
		ballY[i] = ballYVars[i].p;
		ballZ[i] = ballZVars[i].p;
	}
	
	for(let i=0; i<bellX.length; i++){
		bellX[i] = bellXVars[i].p; //copy position from the physics list to graphics list
		bellY[i] = bellYVars[i].p;
		bellZ[i] = bellZVars[i].p;
		bellR[i] = bellRVars[i].p;
		bellSelf[i] = bellSelfVars[i].p;
	}
	
	let isBallCacheOptimization = Dom('chkIsBallCacheOptimization').checked;
	//isBallCacheOptimization creates ballCacheVec4 which displays in sfSource_graphicsDebug.
	//changing the old id=graphicsDebug checkbox to ns.Opt.IsGraphicsDebug.p and a Var.fieldEditor
	//of it which generates the checkbox, and if you hover mouse it tells the Var.path()
	//its an editor of that 1/0 value.
	//OLD: let isGraphicsDebug = Chk('graphicsDebug') && isBallCacheOptimization;
	let isGraphicsDebug = !!ns.Opt.IsGraphicsDebug.p && isBallCacheOptimization;
	//console.log('isGraphicsDebug='+isGraphicsDebug);
	let ballCacheVec4 = null;
	//Depending on checkbox options, a tensor gets copied to ballCacheFloatArray or not,
	//and used in a 1 physics shader (second of 2) and 1 graphics shader
	let ballCacheFloatArray = null;
	//Theres numBalls*offsetsPerBall GPU threads in the first of 2 or 3 physics shaders.
	//Its 2 physics shaders if offsetsPerBall is 1, 3 if its bigger.
	let offsetsPerBall = Chk('multiprobe_isosurfaceBallPhysics') ? multiprobe_vec3Offsets.length : 1;
	if(multiprobe_vec3Offsets.length < 2) throw new Error('Too few offsets multiprobe_vec3Offsets.length='+multiprobe_vec3Offsets.length);
	let ballCacheVec4_seeInsideAllNewtonIters = null; //an optional debug graphics that displays sparse points where the newton iterations happen for each ball to start at many nearby points and look for points nearest on isosurface to ball center. This is for finding bugs in that where it fails to find isosurface.
	for(let whichLamglCall=0; whichLamglCall<2; whichLamglCall++){
		let isPhysicsElseGraphics = !whichLamglCall; //physics first
		if(isPhysicsElseGraphics && !Dom('chkDoPhysics').checked){
			continue;
		}
		let lamglOrVargradientglParam = {
			//sh: isPhysicsElseGraphics ? [1, ] : [height, width, 4],
			sv: svSource, //very small
			sf: isPhysicsElseGraphics ? sfSourceMaker('physicsSimple') :
				(isGraphicsDebug ? sfSourceMaker('graphicsDebug') : sfSourceMaker('graphicsMain')), //the main work
			//241 was hardcoded for an experiment. width is added automatically in VarGradientGL: width: isPhysicsElseGraphics ? 241 : width, //FIXME //width: width,
			tSmall: tSmall,
			
			bellRadii: isPhysicsElseGraphics ? bellRVars : bellR,
			bellStrengths: isPhysicsElseGraphics ? bellSelfVars : bellSelf,
			bellX: isPhysicsElseGraphics ? bellXVars : bellX,
			bellY: isPhysicsElseGraphics ? bellYVars : bellY,
			bellZ: isPhysicsElseGraphics ? bellZVars : bellZ,
			//bellPositions: gpuPos,
			
			//ballXYZ: isPhysicsElseGraphics ? ballXYZVars : ballXYZ, //Var's for gradient else floats
			ballX: isPhysicsElseGraphics ? ballXVars : ballX, //Var's for gradient else floats
			ballY: isPhysicsElseGraphics ? ballYVars : ballY,
			ballZ: isPhysicsElseGraphics ? ballZVars : ballZ,
			
			//prevent GLSL loop unrolling by using uniform int instead of constant cuz compiler is being slow
			uBellCount: opt.NEAR_BELL5_TOTAL,
			uBallCount: opt.NEAR_BALLS_TOTAL,
			
			numBalls: balls.length,
			camPos: camPos,
			camForward: camFwd,
			camRight: camRight,
			camUp: camUp,
			horizon: opt.horizon,
			isRaymarch: opt.isRaymarch,
			closeEnuf: opt.closeEnufToZero,
			DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan:ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.p,
			AddToDensityForTesting: ns.Opt.AddToDensityForTesting.p,
			circleBandPx: Dom('chkLevelEditor').checked ? opt.circleBandPx : 0,
			knobAngleBand: opt.knobAngleBand,
			selectedBellI: selectedBellI,
			color1: opt.color1,
			color2: opt.color2,
			color3: opt.color3,
			mouseY: Controls.mouseY/rect.height*2-1, //range -1 to 1
			mouseX: Controls.mouseX/rect.width*2-1,
			SignedDistanceNewtonIterations: truncated_SignedDistanceNewtonIterations(),
			SignedDistanceSpeed: ns.Opt.SignedDistanceSpeed.p,
			DensityOfSlightAttractToVec3_mul: ns.Opt.DensityOfSlightAttractToVec3_mul.p,
			Display3dLocalMinsOfGradientMagLessThan: ns.Opt.Display3dLocalMinsOfGradientMagLessThan.p,
		};
		let par = {}; //second param of VarGradientGL
		if(!isPhysicsElseGraphics){
			lamglOrVargradientglParam.sh = [height, width, 4];
			lamglOrVargradientglParam.width = width; //instead of VarGradientGL generates it
		}//else VarGradientGL computes it from the js [] lists of Var, that many plus one.
		const IsNewEventSystemY2025M11 = Chk('IsNewEventSystemY2025M11');
		if(isPhysicsElseGraphics){ //physics
			let physicsDt = dt/opt.physicsCyclesPerVideoFrame;
			for(let physicsCycle=0; physicsCycle<opt.physicsCyclesPerVideoFrame; physicsCycle++){
				let isLastPhysicsCycleInThisVideoFrame = physicsCycle==(opt.physicsCyclesPerVideoFrame-1);
				doGameRulesOnListOfNearBalls(balls, physicsDt);
				if(isBallCacheOptimization){ //physicsUseNearestVec4PerBall optimization
					lamglOrVargradientglParam.sf = sfSourceMaker('physicsCacheNearestVec4PerBall');
					//FIXME gotta tell it to use multiprobe or not, as physicsCacheNearestVec4PerBall will take sh=[balls,offsets,4]
					//lamglOrVargradientglParam.sh = [1,ballX.length,4];
					//ballX.length == ballY.length == ballZ.length
					lamglOrVargradientglParam.sh = [ballX.length,offsetsPerBall,4]; //[height,width,4]. output size. not input size.
					//lamglOrVargradientglParam.width = ballX.length;
					lamglOrVargradientglParam.width = offsetsPerBall; //wrap around that
					//Lamgl.Tensor size [1,numBalls,4], each being vec3 of approx nearest point
					//on isosurface to ball center, and float of d(loss)/d(density) at that point.
					//Tensor in GPU memory, dont waste time copying back to CPU,
					//but if u want that for testing use ballCacheVec4.get() for Float32Array.
					let timeMakeBallCacheGPUCallStarted = opt.logShaderTiming ? Lamgl.time() : 0;
					ballCacheVec4 = Lamgl(lamglOrVargradientglParam).outColor; //[numBalls,offsetsPerBall,4]
					let timeMakeBallCacheGPUCall = opt.logShaderTiming ? (Lamgl.time()-timeMakeBallCacheGPUCallStarted) : 0;
					if(opt.logShaderTiming) console.log('timeMakeBallCacheGPUCall='+timeMakeBallCacheGPUCall);
					
					if(offsetsPerBall>1){ //extra shader to merge them
						console.log('if(offsetsPerBall>1){ //extra shader to merge them');
						ballCacheVec4 = Lamgl({
							sh: [ballX.length,1,4], //output size has 1 where offsetsPerBall normally goes
							sf: `uniform sampler2D ballMultiCacheVec4; //the multiprobe outputs to merge, such as 17*150 of them for 17 GPU threads for each of 150 balls, we loop size 17 per ball here and keep the best one by multiprobeSortVal which is stored in .w (the fourth number) of each of these
								out vec4 oneVec4PerBallOut;
								void main(){
									int ballId = int(gl_FragCoord.y);
									//int offsetId = int(gl_FragCoord.x);
									vec4 best = vec4(0.,0.,0.,1e30); //big sortVal, never return this.
									for(int offsetId=0; offsetId<${multiprobe_vec3Offsets.length}; offsetId++){ //get multiprobe_vec3Offsets.length from the js list since we dont need the offsets themselves in this tiny shader that merges multiprobe outputs from another tensor
										//its ivec2(offsetId,ballId) cuz ivec2(x,y) despite i write it as sh=[y,x,4]
										vec4 xyzs = texelFetch(ballMultiCacheVec4,ivec2(offsetId,ballId),0); //x y z sortVal, from GPU thread ballId*offsetsPerBall+offsetId.
										best = (xyzs.w<best.w) ? xyzs : best; //.w is sortVal, keep whichever has lowest sortVal
									}
									oneVec4PerBallOut = vec4(best.xyz,0.); //drop sortVal, so same as the old way where there was only 1 sample per ball, just found point on/near isosurface using more GPU threads, merged in this 1 GPU thread for that 1 ball, numBalls total GPU threads.
								}`,
							ballMultiCacheVec4: ballCacheVec4.free(1), //to merge by sortVal in ball, offsetsPerBall vec4s become 1 vec4 per ball
						}).oneVec4PerBallOut;
					}
					//Now, either way, ballCacheVec4 is [numBalls,1,4] but WARNING: it used to be [1,numBalls,4]
					//but as long as its converted to Float32Array ballCacheFloatArray it will flatten the same.
					//If bugs come up in rows vs cols, maybe only 1 ball works, it could be this, later. Watch for that 2025-12-2+.
					//Its used as "uniform vec4 ballCacheVec4[${opt.NEAR_BALLS_TOTAL}]; //for physicsUseNearestVec4PerBall and graphicsDebug"
					//which is just [numBalls,4], not [1,numBalls,4] or [numBalls,1,4] in uniform float array so should be ok.
					
					ballCacheVec4.fr = 1; //garbcol after used by next Lamgl call
					if(isGraphicsDebug) ballCacheVec4.fr++; //delay garbcol by 1 more so the graphics cycle after this physics cycle uses it too.
					if(opt.log_ballCacheVec4){
						let ballCacheVec4Floats = ballCacheFloatArray || (ballCacheFloatArray = ballCacheVec4.get()); //copy from GPU to CPU
						//console.log('ballCacheVec4Floats='+JSON.stringify([...ballCacheVec4Floats]));
						let s = 'ballCacheVec4Floats=';
						for(let i=0; i<ballCacheVec4Floats.length; i+=4){
							s += '\ni='+i+'/'+ballCacheVec4Floats.length+' isosurfaceXYZ x='+ballCacheVec4Floats[i]+' y='+ballCacheVec4Floats[i+1]+' z='+ballCacheVec4Floats[i+2]+' neutralDensity='+ballCacheVec4Floats[i+3];
						}
						console.log(s);
					}

					if(isLastPhysicsCycleInThisVideoFrame && Chk('physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters')){
						if(Chk('physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters_cheaperFasterUse1PerBallForBasicDisplayTest')){
							console.log('ballCacheVec4_seeInsideAllNewtonIters = ballCacheVec4; //FIXME remove this. it tests if paintVoxels works at all');
							ballCacheVec4_seeInsideAllNewtonIters = ballCacheVec4.free(1000000000); //FIXME remove this. it tests if paintVoxels works at all
						}else{
							//get SignedDistanceNewtonIterations+1 times more vec4s for debug (of physics) graphics.
							//display farther below. dont forget to .free().
							lamglOrVargradientglParam.sf = sfSourceMaker('physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters');
							let SignedDistanceNewtonIterations = truncated_SignedDistanceNewtonIterations();
							let pointsPerBall = offsetsPerBall*(SignedDistanceNewtonIterations+1);
							lamglOrVargradientglParam.sh = [ballX.length,pointsPerBall,4]; //[height,width,4]. output size. not input size.
							lamglOrVargradientglParam.width = pointsPerBall; //wrap around that
							ballCacheVec4_seeInsideAllNewtonIters = Lamgl(lamglOrVargradientglParam).outColor; //[numBalls,pointsPerBall,4]
						}
					}
					
					lamglOrVargradientglParam.sf = sfSourceMaker('physicsUseNearestVec4PerBall');
					if(Dom('addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform').checked){ //todo merge duplicate code of ballCacheVec4.get() etc.
						lamglOrVargradientglParam.ballCacheVec4 = ballCacheFloatArray || (ballCacheFloatArray = ballCacheVec4.get()); //Float32Array to go in uniform
						//fill ballCacheFloatArray so its used in graphics shader too
						if(!ballCacheFloatArray){
							Err('No ballCacheFloatArray in second of 2 physics shaders after ballCacheVec4.get().');
						}
						ballCacheVec4.free(); //free GPU memory
					}else{
						lamglOrVargradientglParam.ballCacheVec4 = ballCacheVec4;
					}
					delete lamglOrVargradientglParam.sh; //so VarGradientGL fills it in
					delete lamglOrVargradientglParam.width; //so VarGradientGL fills it in
					//Err('TODO since VarGradientGL of sfSource_physicsUseNearestVec4PerBall uses 1 less Var/dimension input than VarGradientGL of physicsSimple (cuz returns gradient directly instead of returning loss), need to adjust sh in VarGradientGL andOr here in lamglLoopBody');
					//par.sfRetGrad = true; //sf code returns gradient directly instead of loss.
					//2025-8-6 leave par.sfRetGrad false, as usual, so numVars+1 GPU threads (not numVars)
				}//else physicsSimple
				//This is the 1st or 2nd (VarGradientGL calls) Lamgl call of this physics cycle.
				if(Dom('testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu').checked){
					par.testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu = true;
				}
				let timePhysicsSimpleOrUseBallCacheGPUCallStart = opt.logShaderTiming ? Lamgl.time() : 0;
				let jsMap = VarGradientGL(lamglOrVargradientglParam, par); //js Map of Var to addToGradient
				let timePhysicsSimpleOrUseBallCacheGPUCall = opt.logShaderTiming ? (Lamgl.time()-timePhysicsSimpleOrUseBallCacheGPUCallStart) : 0;
				if(opt.logShaderTiming) console.log('timePhysicsSimpleOrUseBallCacheGPUCall='+timePhysicsSimpleOrUseBallCacheGPUCall);
				
				/*2025-8-12 Bellsack281:
				timeMakePic=0.0004999637603759766
				Bellsack281.html:5480 timeDisplayPic=0.0002999305725097656
				Bellsack281.html:5401 timeMakeBallCacheGPUCall=0.0008997917175292969
				Bellsack281.html:5437 timeUseBallCacheGPUCall=0.009799957275390625
				I put more logging. It seems we only need to track flops in the second of 2 physics Lamgl calls:
				let timeUseBallCacheGPUCallStart = Lamgl.time();
				let jsMap = VarGradientGL(lamglOrVargradientglParam, par); //js Map of Var to addToGradient
				let timeUseBallCacheGPUCall = Lamgl.time()-timeUseBallCacheGPUCallStart;
				console.log('timeUseBallCacheGPUCall='+timeUseBallCacheGPUCall);
				*/
				
				
				let nthLog = 0;
				for(let [vr, addToGradient] of jsMap){
					let max = 1000; //truncate into plus/minus this. todo scaledTanh? easeInOut? etc?
					vr.gr += Math.max(-max, Math.min(addToGradient, max)); //gr is gradient
					nthLog++;
					if(opt.logLamglLoopBodyNthLogAddToGradientEtc && 50 <= nthLog && nthLog < 60) console.log('lamglLoopBody, nthLog='+nthLog+' addToGradient='+addToGradient+' vr.gr='+vr.gr+' par.sfRetGrad='+par.sfRetGrad);
				}
				//ballXYZVars.map(vr=>{
				for(let [vr,gradient] of jsMap){
					if(IsNewEventSystemY2025M11){
						//mark these Var's as dirty cuz game physics may have modified them.
						//Game physics will, like I did in dagball and will do in Bellsack soon (now is 2025-11-13),
						//run custom GPU code made in a text box on the left side of the game window
						//that you edit the code of any ring/RingResult (such as a bell5 or a mandelbulb) selected by mouse.
						vr.makeDirty(); //VarVM.nextState(physicsDt) will call vr.nextState(FIXME what dt? i need physicsDt*timeSpeedOfVar(vr)).
					}else{
						//let localDt = dt*timeSpeedOfVar(vr); //0 to ignore
						//use physicsDt for multiple smaller dt's of physics cycle per video frame
						let localDt = physicsDt*timeSpeedOfVar(vr); //0 to ignore
						vr.nextState(localDt); //update vr.p and vr.v based on vr.gr etc. moves the balls.
					}
				}
				let maxBallSpeedSq = opt.maxBallSpeed**2;
				for(let ball of balls){
					let speedSq = ball.X.p**2 + ball.Y.p**2 + ball.Z.p**2;
					if(speedSq > maxBallSpeedSq){
						let speed = Math.sqrt(speedSq);
						let mul = opt.maxBallSpeed/speed;
						ball.X.v *= mul; //slow down to opt.maxBallSpeed
						ball.Y.v *= mul;
						ball.Z.v *= mul;
					}
				}
			}
		}else{ //graphics
			if(isGraphicsDebug){
				if(lamglOrVargradientglParam.ballCacheVec4){
					Err('graphics should not already have ballCacheVec4, was about to add it');
				}
				//lamglOrVargradientglParam.ballCacheVec4 = ballCacheVec4;
				if(Dom('addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform').checked){ //todo merge duplicate code of ballCacheVec4.get() etc.
					if(!ballCacheFloatArray){
						Err('No ballCacheFloatArray in graphics after 2 physics shaders that should have made it.');
					}
					lamglOrVargradientglParam.ballCacheVec4 = ballCacheFloatArray; //Float32Array to go in uniform
				}else{
					lamglOrVargradientglParam.ballCacheVec4 = ballCacheVec4;
				}
				//console.log('Added ballCacheVec4 to Lamgl param {}, about to call Lamgl with isGraphicsDebug.');
			}
			lamglOrVargradientglParam.BallColorFloat = BallColorFloat;
			let timeMakePicStart = opt.logShaderTiming ? Lamgl.time() : 0;
			
			
			let map = Lamgl(lamglOrVargradientglParam);
			let rgbd = map.outColor; //FIXME does it have d/depth? make it.
			
			//chain calls of rgbd using prevPic. vec4(red,green,blue,depthForSorting)
			
			if(Dom('chkLevelEditor').checked && opt.circleBandPx && Dom('chkSeparateRingsAsTexture').checked){
				//If !Dom('chkSeparateRingsAsTexture').checked then graphicsMain/graphicsDebug does the rings,
				//if anything does the rings.
				rgbd = Lamgl({ //ring graphics, using prevPic/rgbd. TODO remove findNearestBillboard in sfSourceMaker.
					sh: rgbd.sh,
					sv: svSource, //very small
					sf: `#version 300 es
						precision highp float;
						uniform sampler2D prevPic;
						in vec2 uv;
						out vec4 outColor;
						uniform vec3 camPos;
						uniform vec3 camForward;
						uniform vec3 camRight;
						uniform vec3 camUp;
						uniform float bellX[${opt.NEAR_BELL5_TOTAL}]; //TODO all in 1 float[${5*opt.NEAR_BELL5_TOTAL}]
						uniform float bellY[${opt.NEAR_BELL5_TOTAL}];
						uniform float bellZ[${opt.NEAR_BELL5_TOTAL}];
						uniform float bellRadii[${opt.NEAR_BELL5_TOTAL}];
						uniform int	uBellCount;			// ≤ ${opt.NEAR_BELL5_TOTAL}
						uniform float horizon;
						//uniform float isRaymarch;
						//uniform float closeEnuf;
						uniform float circleBandPx;
						uniform float knobAngleBand;	// how large an angle difference to consider a knob
						//uniform int selectedBellI; //-1 if none. 0 to NEAR_BELL5_TOTAL-1 if selected.
						
						const int KNOB_COUNT = ${opt.KNOB_COUNT};

						
						const float NULLXYZ = ${Lamgl.jsNumToGlslFloat(NULLXYZ)};
						
						// For billboard ring & knobs. 
						// We'll store bestRingT, bestRingColor, etc.
						struct RingResult{
							float t;
							vec3 color;
							int i; //index 0 to NEAR_BELL5_TOTAL-1 of the ring
						};

						vec4 minDepth(vec4 a,vec4 b){return(b.w<a.w)?b:a;}
						
						vec3 Norm(in vec3 p){
							float len = length(p);
							return len==0. ? vec3(0.,0.,0.) : p/len;
						}
						
						RingResult findNearestBillboard(in vec3 origin, in vec3 dir){
							RingResult rr;
							rr.t= NULLXYZ;
							rr.color= vec3(0.0);
							rr.i = -2;

							// We'll define a stable planeRight, planeUp for the knob angles
							// We'll pick worldUp= (0,1,0) unless dot(worldUp, camForward)>0.9 => pick (1,0,0).
							vec3 worldUp= vec3(0,1,0);
							//float d= abs(dot(worldUp, normalize(camForward)));
							float d= abs(dot(worldUp, Norm(camForward)));
							if(d>0.9){
								worldUp= vec3(1,0,0);
							}
							
							/*FIXME? GPT-o3 says: If camForward happens to be parallel to worldUp the first cross
							is ≈ (0,0,0) ⇒ NaNs. You handled the almost-parallel case (d>0
							*/
							vec3 planeRight= Norm( cross(camForward, worldUp) );
							vec3 planeUp	 = Norm( cross(planeRight, camForward) );

							//for(int i=0; i<NEAR_BELL5_TOTAL; i++){
							for(int i=0; i<uBellCount; ++i){
								// skip if it's dummy
								//if(bellPositions[i].x>=NULLXYZ) continue;
								if(bellX[i]>=NULLXYZ) continue; //FIXME do all loops, ignore later loops, cuz nonbranching
								// plane intersection
								float denom= dot(dir, Norm(camForward));
								if(abs(denom)<1e-9) continue; //FIXME do all loops, ignore later loops, cuz nonbranching
								vec3 bellXYZ = vec3(bellX[i],bellY[i],bellZ[i]);
								float tC= dot( (bellXYZ-origin), Norm(camForward))/ denom;
								//float tC= dot( (bellPositions[i]-origin), Norm(camForward))/ denom;
								if(tC<0.01 || tC> horizon) continue;

								// dist3D from the plane point to bell center
								vec3 planePt= origin + dir* tC;
								float distCenter= distance(planePt, bellXYZ);

								// approximate how many px is "1 px" at distance tC
								float pxScale= 0.003 * tC;
								float band= circleBandPx * pxScale;

								// ring check
								float ringDiff= abs(distCenter - bellRadii[i]);
								if(ringDiff < band){
									// we have found a ring. Possibly a knob.
									// local 2D coords in plane: localX= dot(planeRight, (planePt-center)), localY= dot(planeUp, (planePt-center))
									vec3 localVec= planePt - bellXYZ;
									float localX= dot(localVec, planeRight);
									float localY= dot(localVec, planeUp);
									float angle= atan(localY, localX); // in [-pi, pi]
									if(angle<0.0) angle += 6.2831853; // so [0..2pi)
									float knobAngle= 6.2831853 / float(KNOB_COUNT); // 2pi/5 => ~1.2566
									// find which knob index is closest:
									float kFloat= angle / knobAngle; // e.g. 2.2 => knob #2
									float kRound= floor( kFloat+0.5 );
									float angleDiff= abs( kFloat - kRound );
									// if angleDiff < knobAngleBand? We do a subband. e.g. 0.2 => yes
									float angleThresh= knobAngleBand; // e.g. 0.2 or 0.15
									if(angleDiff < angleThresh){
										// color the knob
										float knobIdx= mod( kRound, float(KNOB_COUNT) );
										// map 0->red,1->green,2->blue,3->white,4->black for example
										// We'll do a quick if-else or a small array. For brevity, do if else:
										vec3 knobColor;
										if(knobIdx<0.5) knobColor= vec3(1,0,0);
										else if(knobIdx<1.5) knobColor= vec3(0,1,0);
										else if(knobIdx<2.5) knobColor= vec3(0,0,1);
										else if(knobIdx<3.5) knobColor= vec3(1,1,1);
										else knobColor= vec3(0,0,0);
										// pick that
										if(tC< rr.t){
											rr.t= tC;
											rr.color= knobColor;
											rr.i = i;
										}
									} else {
										// it's ring but not a knob => e.g. gray
										if(tC< rr.t){
											rr.t= tC;
											rr.color= vec3(0.6,0.6,0.6);
											rr.i = i;
										}
									}
								}
							}
							return rr;
						}


						void main(){
							ivec2 ij = ivec2(gl_FragCoord.xy); //[0..(width-1),0..(height-1)], ij and uv could be derived from eachother
							vec4 prevPixel = texelFetch(prevPic,ij,0);
							
							vec2 st = uv*2.0-1.0; //[(-1)..1,(-1)..1], ij and uv could be derived from eachother
							vec3 dir = Norm( camForward + st.x*camRight + st.y*camUp );
							
							RingResult rRing = findNearestBillboard( camPos, dir );
							float ringDistance = rRing.t; //FIXME is this the right distance to compare by minDepth?
							//FIXME bug with chkSeparateRingsAsTexture. sometimes they display, sometimes they dont: makes every pixel replace prevPic (cuz 2025-8-27 they're all const depth 0 or 1 or something cuz i never set .w depth in them): ringDistance = -1.2;
							//ringDistance = -1.2;
							
							//if did not hit ring, then ringDistance will be big so prevPixel will display in front of newPixel.
							vec4 newPixel = vec4(rRing.color,ringDistance);

							//vec4 q = TODO;

							outColor = minDepth(prevPixel,newPixel);
						}`,
					prevPic: rgbd,
					horizon: opt.horizon,
					//tSmall: tSmall,
					
					bellRadii: bellR, //bellRadii: isPhysicsElseGraphics ? bellRVars : bellR,
					//bellStrengths: isPhysicsElseGraphics ? bellSelfVars : bellSelf,
					bellX: bellX, //bellX: isPhysicsElseGraphics ? bellXVars : bellX,
					bellY: bellY, //bellY: isPhysicsElseGraphics ? bellYVars : bellY,
					bellZ: bellZ, //bellZ: isPhysicsElseGraphics ? bellZVars : bellZ,
					//bellPositions: gpuPos,
					
					//ballXYZ: isPhysicsElseGraphics ? ballXYZVars : ballXYZ, //Var's for gradient else floats
					//ballX: isPhysicsElseGraphics ? ballXVars : ballX, //Var's for gradient else floats
					//ballY: isPhysicsElseGraphics ? ballYVars : ballY,
					//ballZ: isPhysicsElseGraphics ? ballZVars : ballZ,
					
					//prevent GLSL loop unrolling by using uniform int instead of constant cuz compiler is being slow
					uBellCount: opt.NEAR_BELL5_TOTAL,
					//uBallCount: opt.NEAR_BALLS_TOTAL,
					
					SignedDistanceNewtonIterations: truncated_SignedDistanceNewtonIterations(),
					DensityOfSlightAttractToVec3_mul: ns.Opt.DensityOfSlightAttractToVec3_mul.p,
					Display3dLocalMinsOfGradientMagLessThan: ns.Opt.Display3dLocalMinsOfGradientMagLessThan.p,
					
					numBalls: balls.length,
					camPos: camPos,
					camForward: camFwd,
					camRight: camRight,
					camUp: camUp,
					//horizon: opt.horizon,
					//isRaymarch: opt.isRaymarch,
					//closeEnuf: opt.closeEnufToZero,
					circleBandPx: opt.circleBandPx,
					knobAngleBand: opt.knobAngleBand,
					//selectedBellI: selectedBellI,
					color1: opt.color1,
					color2: opt.color2,
					color3: opt.color3,
					//mouseY: Controls.mouseY/rect.height*2-1, //range -1 to 1
					//mouseX: Controls.mouseX/rect.width*2-1,
				}).outColor;
			}//END if(Dom('chkLevelEditor').checked)
			
			//Do this in last shader, the one where circle is painted around mouse,
			//just make whole thing darker there if so.
			//if(densityAtXYZ(camPos) > 0.){ //camera is in solid volume (not open area).
			//	//c = c*.4; //darken color
			//	outColor *= ${opt.brightMultiplierInIsosurface}; //darken color
			//}
			let densityAtCam = cpuDensityAtXYZ(camPos);
			if(opt.brightMultiplierInIsosurface != 1 && densityAtCam>0){
				//adjust whole screen contrast (brightness multiplier) when cam is inside solid volume
				//nd the multiplier would have an effect (is not 1).
				//console.error('if(opt.brightMultiplierInIsosurface != 1){ FIXME check if(densityAtXYZ(camPos) > 0.), but how do i know that from CPU here?');
				rgbd = Lamgl({ //using prevPic/rgbd, add circle around mouse cursor. TODO merge this into ring graphics
					sh: rgbd.sh, //same rect size
					//use default: sv: svSource, //very small
					sf:`uniform sampler2D prevPic;
						out vec4 outColor;
						void main(){
							ivec2 ij = ivec2(gl_FragCoord.xy);
							vec4 p = texelFetch(prevPic,ij,0);
							outColor = p*${Lamgl.jsNumToGlslFloat(opt.brightMultiplierInIsosurface)}; //darken color
						}`,
					prevPic: rgbd.free(1), //garbcol after using 1 more time here
				}).outColor;
			}
			
			if(opt.doMouseOverlayEtc) rgbd = Lamgl({ //using prevPic/rgbd, add circle around mouse cursor. TODO merge this into ring graphics
				sh: rgbd.sh, //same rect size
				sv: svSource, //very small
				// --- fragment shader: draw ring, keep rgb of min depth ----------------
				sf:`#version 300 es
					precision highp float;
					uniform sampler2D prevPic;
					uniform float mouseX;	// −1..1
					uniform float mouseY;	// −1..1
					in vec2 uv;
					out vec4 outColor;

					vec4 minDepth(vec4 a,vec4 b){return(b.w<a.w)?b:a;}

					void main(){
						ivec2 ij = ivec2(gl_FragCoord.xy);
						vec4 p = texelFetch(prevPic,ij,0);

						float bifractionY=uv.y*2.-1.;	// range -1..1
						float bifractionX=uv.x*2.-1.;
						float distanceToMouse=length(vec2(mouseY-bifractionY,mouseX-bifractionX));
						//bool inCircle=distanceToMouse<.12;
						bool inCircle = distanceToMouse>.09 && distanceToMouse < .1;

						vec4 q = inCircle?vec4(.9,.8,.03,p.w-1.):p;

						outColor = minDepth(p,q);
					}`,
				prevPic: rgbd.free(1), //garbcol after using 1 more time here
				mouseX: lamglOrVargradientglParam.mouseX,
				mouseY: lamglOrVargradientglParam.mouseY
			}).outColor;
			
			if(ballCacheVec4_seeInsideAllNewtonIters){ //display these sparse points over everything, regardless if they are in 3d in front or or behind whats already there.
				let numVoxels = ballCacheVec4_seeInsideAllNewtonIters.sh[0]*ballCacheVec4_seeInsideAllNewtonIters.sh[1];
				console.log('About to paintVoxels for ballCacheVec4_seeInsideAllNewtonIters, numVoxels='+numVoxels);
				//free(1) uses doSharedTextureOptimization tho it might be incomplete code
				//as doSharedTextureOptimization may have only been tested on dense "in vec2 XY;"
				//instead of gl_VertexID/sparsePoints. So if that throws, just finish that code.
				rgbd = paintVoxels(ballCacheVec4_seeInsideAllNewtonIters, rgbd.free(1));
				//rgbd = paintVoxels(what, rgbd.free(1)); //test if paintVoxels works by painting just 1 point per ball where it thinks its closest to isosurface
				ballCacheVec4_seeInsideAllNewtonIters.free(); //This is not the texture it modifies during painting over, so dont need to free(1) it, tho that would have worked too. I do it here so its clear which one is using doSharedTextureOptimization. 
			}
			
			
			let now = opt.logShaderTiming ? Lamgl.time() : 0;
			let timeMakePic = now-timeMakePicStart;
			if(opt.logShaderTiming) console.log('timeMakePic(s)='+timeMakePic);
			let timeDisplayPicStart = now;
			//map.outColor.display(); //to canvas Lamgl.glCanv which it puts on screen if not already in the dom tree
			rgbd.display(); //to canvas Lamgl.glCanv which it puts on screen if not already in the dom tree
			let timeDisplayPic = opt.logShaderTiming ? (Lamgl.time()-timeDisplayPicStart) : 0;
			if(opt.logShaderTiming) console.log('timeDisplayPic='+timeDisplayPic);
			
			//map.outColor.free(); //return to Lamgl.texPool pool of WebGLTexture (outcolor.mem)
			rgbd.free(); //return to Lamgl.texPool pool of WebGLTexture (rgbd.mem)
		}
	}
	let live = Dom('liveDisplay');
	if(live && IsVisible('overlayDown')){
		B = ballNearestZYX(camPos[2],camPos[1],camPos[0]);
		live.innerHTML = ('FPS='+(update_estimateFPS()|0)+' opt.NEAR_BALLS_TOTAL='+opt.NEAR_BALLS_TOTAL+' opt.NEAR_BELL5_TOTAL='+opt.NEAR_BELL5_TOTAL+' loadingTimeSecs='+bootDuration+' numBalls='+allBalls().length+
		' camPos=,'+camPos).replaceAll(',','<br>')+'<br>'+
		'B.speed='+Math.hypot(B.X.v,B.Y.v,B.Z.v)+'<br>'+
		'B.X='+B.X+'<br>'+
		'B.Y='+B.Y+'<br>'+
		'B.Z='+B.Z+'<br>'+
		'B.X.prevGr='+B.X.prevGr+'<br>'+
		'B.Y.prevGr='+B.Y.prevGr+'<br>'+
		'B.Z.prevGr='+B.Z.prevGr+'<br>'+
		'opt.physicsCyclesPerVideoFrame='+opt.physicsCyclesPerVideoFrame+'<br>'
	}
	if(!did_bootLamglDomEvents){ //after first tensor.display()
		did_bootLamglDomEvents = true;
		bootLamglDomEvents();
		bootDuration = Lamgl.time()-bellsackStartLoadingTime;
		console.log('Object.values(Lamgl.cacheStats)='+JSON.stringify(Object.values(Lamgl.cacheStats)));
		console.log('Bellsack booted in '+bootDuration+' seconds.');
	}
	if(IsNewEventSystemY2025M11){
		//VarVM.nextState(dt) is a redesign meant to replace calling anyVar.nextState(dt) in lamglLoopBody, but to use
		//it we have to Var.makeDirty() any time we modify the Var by its primitive fields such as .dp .dv .kv .mn .mx 
		//and you never should directly modify .p .v cuz nextState does that, but i have done it anyways some places.
		VarVM.nextState(dt);
	}
};

var isVar = v=>(v instanceof Var);

var isVarList = list=>{
	return list.length!==undefined && isVar(list[0]);
};

var varListToPositions = list=>{
	let ret = new Float32Array(list.length);
	for(let i=0; i<list.length; i++) ret[i] = list[i].p;
	return ret;
};

//Wrapper of Lamgl for physics, using nearly the same params
//as for calling Lamgl directly for physics.
//Returns a js Map (not {}) of Var to number that should be
//added by caller into eachVar.gr (gradient).
//wraps Lamgl, takes same params as Lamgl, but some values in the param {} can be
//list of Var instance, like [V.Bellsack.Room1.Ball.B3.X, V.Bellsack.Room1.Ball.B3.Y,
//for multiple balls and X Y Z of them all, but just the positions someVar.p],
//and for the set of all Var's given, which may occur in multiple parts of the {} map
//as {varNameA:[Var, Var, Var, Var...], varNameB:[...], otherLamglParams...},
//which is d Var's in total, it calls GPU (thru Lamgl) with d+1 GPU threads,
//by using "uniform vec2 XY;" which gets auto filled in by the two triangles
//way of filling a rectangle. Just give it height of 1 and X from 0 to width (inclusive),
//and 0 to width-1 each has epsilon added, and width is the last one with someVar.p as is.
//So it computes float[d] gradient that way (vec4 per pixel out, just uses 1 float each),
//and puts that in a Map of Var to number, and returns that Map, without changing the param.
//VarGradientGL has to work for ANY code string that Lamgl works for, by just
//substituting any of the Float32Array's (in the {} param of Lamgl/VarGradientGL)
//with js [] list of Var.
/*part of a conversation with GPT-o3 2025-7-10[[
bellsack174.html File
focus on changing sv and sf. they can NOT stay the same cuz caller does not include
the mutable versions of the Var arrays in the code. Caller includes code for them being
uniform float arrays. Those arrays need to be changed to mutable, and add a mutable
array of concat(sameName,'_const') and rename the params in Lamgl to concat(sameName,'_const')
which receive the Float32Array form of it, and add into the code, 1 loop per such array
concat(sameName,'_const')/sameName, to copy from concat(sameName,'_const')[i] to sameName[i]
the value or the value plus epsilon depending if its the dimension to be perturbed. Use
gl_VertexID and int gradientOffset = 0; [gradientOffset++] to loop over them. The highest
gl_VertexID will not have epsilon added to any dim cuz its index is not any of those indexs
in the arrays, its the last one for neutralSample. Use Lamgl.glvars(map) of the map param
of VarGradientGL(map) which will look in map.sv (vertex shader code string) and map.sf
(fragment shader code string) and return a list of Lamgl.GLVar instances that includes
all inputs and outputs but not those passing from vertex shader to fragment shader as thats
not relevant to caller of Lamgl. So when you call VarGradientGL on the param you would have
called Lamgl on except som of the values in the map/{} param are js [] list of Var, it runs
numVars+1 GPU threads and gets numVars+1 vec4s (4x as many floats) back from GPU, and
computes gradient of numVars dimensions, subtracting neutralSample then dividing by epsilon,
and returns a Map of Var to gradient, without modifying the param map.
]]
<<<<Example GLVars:
let glvars = vm.glvars(map);
		if(opt.logGlvars) console.log('glvars=[[['+glvars.join('\n')+']]]');
glvars=[[[[GLVar memType=in glType=vec2 name=XY shaderType=sv]
[GLVar memType=out glType=vec4 name=outColor shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camPos shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camForward shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camRight shaderType=sf]
[GLVar memType=uniform glType=vec3 name=camUp shaderType=sf]
[GLVar memType=uniform glType=float name=horizon shaderType=sf]
[GLVar memType=uniform glType=float name=isRaymarch shaderType=sf]
[GLVar memType=uniform glType=float name=closeEnuf shaderType=sf]
[GLVar memType=uniform glType=float name=circleBandPx shaderType=sf]
[GLVar memType=uniform glType=float name=knobAngleBand shaderType=sf]
[GLVar memType=uniform glType=int name=selectedBellI shaderType=sf]
[GLVar memType=uniform glType=float name=mouseY shaderType=sf]
[GLVar memType=uniform glType=float name=mouseX shaderType=sf]
[GLVar memType=uniform glType=vec3 name=bellPositions shaderType=sf]
[GLVar memType=uniform glType=float name=bellRadii shaderType=sf]
[GLVar memType=uniform glType=float name=bellStrengths shaderType=sf]
[GLVar memType=uniform glType=vec3 name=ballXYZ shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color1 shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color2 shaderType=sf]
[GLVar memType=uniform glType=vec3 name=color3 shaderType=sf]]]]
>>>>
*/
/*var VarGradientGL = map=>{
	console.log('VarGradientGL');
	let lamglParam = {}; //VarGradientGL takes mostly same params as Lamgl
	let numVars = 0;
	let epsilon = DefaultEpsilon;
	for(let key in map){
		let val = map[key];
		if(isVarList(val)){
			lamglParam[key] = varListToPositions(val);
			numVars += val.length;
		}else{
			lamglParam[key] = val;
		}
	}
	let gpuThreads = numVars+1; //measure gradient in numVars dimensions by numVars+1 samples
	let correctSh = [1, gpuThreads, 4]; //[height,width,4]
	if(map.sh){
		//throw if its not that same size
		if(!Lamgl.testNearEqualFloatArrays(map.sh, correctSh, 'VarGradientGL sh'));
	}else{
		//derive sh from number of var's
		lamglParam.sh = correctSh;
	}
	let lamglReturn = Lamgl(lamglParam);
	let lamglReturnedArray = Object.values(lamglReturn);
	if(lamglReturnedArray.length != gpuThreads){
		Err('lamglReturnedArray.length ('+lamglReturnedArray.length+') != gpuThreads ('+gpuThreads+')');
	}
	let neutralSample = lamglReturnedArray[numVars];
	//for(let v=0; v<neutralSample.
	let ret = new Map();
	//TODO fill ret with key of Var and val of
	//[todo should it be the literal values in lamglReturnedArray, with V (Var tree root) being neutralSample,
	//or should it be the gradient directly? Cuz ]
	
	

	


	//FIXME can this be done without changing map.sv and map.sf?

	//call Lamgl
	
	//return Map of Var to number.
	
	//TODO https://chatgpt.com/c/686ba7cf-f7d8-800a-ac0a-8649383cc06c
	
	Err('TODO whatever first float (of vec4) map.sf code returns, use that as loss. Do not give sh. Derive it from the number of Var in [] in the {} param, PLUS ONE. d+1 for gradient calculation. Then it returns Map of Var to addToGradient aka add to eachVar.gr . This will require the sf code string be slightly modified by caller differently than the graphics code which calls Lamgl directly.');
	
};*/
//Err('TODO VarGradientGL');
// Wrapper of Lamgl that evaluates a scalar loss at (d+1) nearby
// points and returns \partial loss / \partial p for every Var.
// Usage is identical to Lamgl(map) except that any param value may
// be a list of Var objects; their .p is packed into uniforms and the
// gradient for each Var is returned.

//TODO move VarGradientGL and funcs it calls into the Var (class Var) script (second of 3 scripts),
//move it out of Bellsack (third of 3 scripts), cuz its general enuf.
//map is params for Lamgl, some of which are transformed before giving to Lamgl.
//par is params specific to VarGradientGL, especially {sfRetGrad:true} to mean sf returns gradient
//directly instead of returning loss and calling 1 extra gpu thread for the neutral sample.
const VarGradientGL = (map,par)=>{
	//Dont need funcName here, do it in lamglLoopBody instead,
	//doing 1 Lamgl call of physicsCacheNearestVec4PerBall code
	//and 1 VarGradientGL call of physicsUseNearestVec4PerBall code.
	//Its gradient of 2 different loss functions that do the same thing,
	//one of them optimized by using the vec4 per ball cache from the Lamgl call before it.
	//let funcName = map.funcName || 'physicsSimple'; //or 'physicsUseNearestVec4PerBall' as optimization.
	//funcName wont be 'graphicsMain' or 'physicsCacheNearestVec4PerBall' here, cuz those dont return gradient.
	const epsilon = (typeof DefaultEpsilon === "number" ? DefaultEpsilon : 1e-3);

	/* ── 1.	Collect Vars, build flat Float32Arrays ─────────────────── */
	const lamglParam = {};
	const varLists	 = [];	 // [[Var,Var,…] in the order we encounter]

	for (const k in map) {
		const v = map[k];
		if (Array.isArray(v) && v.length && v[0] instanceof Var) {
			const arr = new Float32Array(v.length);
			for (let i = 0; i < v.length; ++i) arr[i] = v[i].p;
			//lamglParam[k] = arr;
			//varname_const is uniform float array. varname is mutable float array its copied
			//and maybe perturbed into. Caller of VarGradientGL should not write _const.
			//Thats generated. Use uniform float varname[size];gl_VertexID
			lamglParam[k+'_const'] = arr;
			varLists.push({ name: k, vars: v });
		} else {
			//breaks map.sf which is also a string: if(typeof(v) != 'string'){ //exclude funcName
				lamglParam[k] = v;
			//}
		}
	}

	const d = varLists.reduce((n, o) => n + o.vars.length, 0);
	const gpuThreads = par.sfRetGrad ? d : d+1; //+1 neutral sample where no dimension/var index is perturbed.

	/* ── 2.	Patch the fragment shader to apply ε on a per‑thread basis */
	const glvars	 = Lamgl.glvars(map);
	lamglParam.sh = [1, gpuThreads, 4];		 // 1×(d+1) vec4	 (loss in .r)
	//map.sh should not exist since it will be generated. Give it in graphics call but not physics call.
	if(lamglParam.width !== undefined){
		Err('Param {} of VarGradientGL already had width but width must be generated.');
	}
	lamglParam.width = gpuThreads;
	const perturbed = perturbGlsl(
		map.sf,
		glvars.filter(gv => varLists.some(o => o.name === gv.name)),
		d,
		epsilon,
	);

	lamglParam.sf = perturbed;

	//── 3.	Run GPU pass ─────────────────────────────────────────────
	const out = Lamgl(lamglParam);
	const firstOut = out[Object.keys(out)[0]];	 // assume single out tex
	//console.log('firstOut='+firstOut);
	const floats = par.testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu ?		new Float32Array(firstOut.size()) : firstOut.get(); // Float32Array length 4*(d+1)
	//const floats = new Float32Array(firstOut.size()); //FIXME this ignores GPU output, for a test 2025-7-16
	//console.log('VarGradientGL, firstOut, floats.length='+floats.length);
	firstOut.free();
	//ballCacheVec4, if exists, should have ballCacheVec4.fr of 1 to auto garbcol in Lamgl(lamglParam).

	const neutral = par.sfRetGrad ? 0 : floats[d*4];			 // .r of last texel

	//── 4.	Map back to individual Vars ──────────────────────────────
	const ret = new Map();
	let idx = 0;
	for(const block of varLists){
		for(const v of block.vars){
			//is gradient of that var/dimension if par.sfRetGrad else is loss to take gradient of
			const raw = floats[idx*4];
			const grad = par.sfRetGrad ? raw : ((raw-neutral)/epsilon);
			ret.set(v, grad);
			++idx;
		}
	}

	return ret;
};

var reversedList = list=>{
	let ret = [...list];
	ret.reverse();
	return ret;
};

/* --------------------------------------------------------------------
	 Helper – inlines ε‑perturbation into the original fragment shader.
	 We rely on GLVar.charPtrFrom / charPtrTo to replace each uniform
	 declaration with two pieces:	 uniform TYPE name_const[…];
									 TYPE	 name[…];
	 Then at the top of main() we apply a concise loop per uniform array
	 using a shared EPSILON constant, rather than unrolling manually.
	 ----------------------------------------------------------------- */
var perturbGlsl = (src, glvars, d, eps)=>{
	// Only perturb uniform arrays
	glvars = glvars.filter(g => g.memType === 'uniform' && g.sh.length > 0);
	// Sort descending so earlier replacements don't shift later indices
	glvars.sort((a, b) => b.charPtrFrom - a.charPtrFrom);

	let patched = src;

	// Inject shared EPSILON right after version line
	//const epsStr = Lamgl.jsNumToGlslFloat(eps);
	//patched = patched.replace(/(#version .*)/, `$1#define EPSILON ${epsStr} // auto-generated perturbation scale
//`);

	// Duplicate each uniform array declaration
	for (const g of glvars) {
		const decl = patched.slice(g.charPtrFrom, g.charPtrTo);
		const arraySuffix = g.sh.length ? `[${g.sh[0]}]` : "";
		//const replacement =
		//	`uniform ${g.glType} ${g.name}_const${arraySuffix};
//` +
//			`${g.glType} ${g.name}${arraySuffix};`;
		const replacement =
			`uniform ${g.glType} ${g.name}_const${arraySuffix};\n` +
			`${g.glType} ${g.name}${arraySuffix};\n`;	 // ← add newline to keep declarations separate
		patched = patched.slice(0, g.charPtrFrom)
				+ replacement
				+ patched.slice(g.charPtrTo);
	}

	// Inject compact loops at top of main()
	const mainIdx = patched.indexOf("void main()");
	const braceIdx = patched.indexOf("{", mainIdx);
	if (mainIdx < 0 || braceIdx < 0) {
		throw new Error("perturbGlsl: couldn't locate main() to inject loops");
	}
	const setupLines = [];
	setupLines.push('ID = int(uv.x*float(width)); //range 0 to width-1');
	let offset = 0;
	let glvarsReversed = reversedList(glvars);
	//for (const g of glvars){ //ballsZ ballsY ballsX loops generated in in main()
	for (const g of glvarsReversed){ //ballsX ballsY ballsZ
		//const size = g.sh[0];
		//setupLines.push(`// perturb ${g.name}`);
		//setupLines.push(`for(int i=0;i<${size};++i){`);
		//setupLines.push(`	${g.name}[i] = ${g.name}_const[i] + float(gl_VertexID == ${offset} + i) * EPSILON;`);
		//setupLines.push(`}`);
		const size = g.sh[0];
		setupLines.push(
			`for(int i=0;i<${size};++i){ ${g.name}[i] = ` +
			`${g.name}_const[i] + float(ID == ${offset} + i) * EPSILON; }`
		);
		offset += size;
	}
	
	// Merge injection into single line for clarity
	//patched = patched.slice(0, braceIdx + 1) + "\n" + setupLines.join("\n") + "\n" + patched.slice(braceIdx + 1);
	patched = patched.slice(0, braceIdx + 1) + "\n" + setupLines.join("\n") + "\n" + patched.slice(braceIdx + 1);
	/* now that we’ve finished position-sensitive replacements,
	inject the shared EPSILON define (this won’t disturb charPtr
	offsets used above) */
	if(!src.includes('EPSILON')){
		const epsStr = Lamgl.jsNumToGlslFloat(eps);
		patched = patched.replace(/(#version .*)\n/, `$1\n#define EPSILON ${epsStr} // auto-generated perturbation scale\n`);
	}

	return patched;
};

function renderLoop(t){
	let dt= 0.016; // approximate
	updateFromGamepad(dt);
	//updateNearBells();
	//FIXME todo update selectedBellI so ring knobs work when mouse drag

	// camera basis
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));
	
	
	if(opt.doLamglLoopBody){
		lamglLoopBody();
	}
	
	/*
	// set uniforms
	gl.viewport(0,0, canvas.width, canvas.height);
	gl.clearColor(0,0,0,1);
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.useProgram(program);

	gl.uniform3fv(loc_bellPos, gpuPos);
	gl.uniform1fv(loc_bellRad, gpuRad);
	gl.uniform1fv(loc_bellStr, gpuStr);

	gl.uniform3f(loc_camPos, camPos[0], camPos[1], camPos[2]);
	gl.uniform3f(loc_camFwd, fwd[0], fwd[1], fwd[2]);
	gl.uniform3f(loc_camRight, rig[0], rig[1], rig[2]);
	gl.uniform3f(loc_camUp, upv[0], upv[1], upv[2]);

	gl.uniform1f(loc_horizon, opt.horizon);
	gl.uniform1f(loc_isRay, (opt.isRaymarch?1.0:0.0));
	gl.uniform1f(loc_closeE, opt.closeEnufToZero);
	gl.uniform1f(loc_circPx, opt.circleBandPx);
	gl.uniform1f(loc_knobAng, opt.knobAngleBand);
	gl.uniform1i(loc_selectedBellI, selectedBellI);

	gl.uniform3fv(loc_col1, opt.color1);
	gl.uniform3fv(loc_col2, opt.color2);
	gl.uniform3fv(loc_col3, opt.color3);

	gl.bindVertexArray(vao);
	gl.drawArrays(gl.TRIANGLES,0,6);
	gl.bindVertexArray(null);
	*/

	requestAnimationFrame(renderLoop);
}
//requestAnimationFrame(renderLoop);

window.startBellsack = ()=>{
	console.log('startBellsack');
	
	/*2025-7-22-314p. its likely alot faster than that but bottlenecked by other things, cuz i had it running 150 bells and 80 balls at about the same FPS.
	{"horizon":60,"isRaymarch":1,"raytraceStep":0.1,"marchMaxSteps":200,"closeEnufToZero":0.001,"circleBandPx":4,"knobAngleBand":0.15,"TOTAL_BELLS":10000,"TOTAL_BALLS":2000,"NEAR_BELL5_TOTAL":50,"NEAR_BALLS_TOTAL":50,"KNOB_COUNT":5,"displayCenterForwardOfCam":0,"displayTerrain":true,"color1":[1,0.2,0.2],"color2":[0.2,1,0.2],"color3":[0.2,0.2,1],"doLamglLoopBody":true,"logGlvars":false,"logGlvarsDetail":false,"logShaderCodeEveryTime":false,"doPhysics":true,"oneBitPerDimGradient":false,"oneBitPerDimGradientVal":1,"signedDistanceNewtonIterations":32}
	estimateNumFlopsMapPerPhysicsCall(opt) = 2.06115 billion, which happens about 60 times per second.
	*/
	called_estimateNumFlopsMapPerPhysicsCall = estimateNumFlopsMapPerPhysicsCall(opt);
	console.log('opt=\n'+JSON.stringify(opt)+'\nestimateNumFlopsMapPerPhysicsCall(opt) = '+(estimateNumFlopsMapPerPhysicsCall(opt)/1e9)+' billion, which happens about 60 times per second.');
	
	console.log('Adding ExampleVarListener to v/V aka root Var. Try V.dp += 1000; V.makeDirty(); then wait for VarVM.nextState(dt) to be called so V.p should rise by dt*1000 then call ExampleEventListener(V,V,{}).');
	V.listen(ExampleVarListener); //when root changes look for that on browser console. Root doesnt normally change.
	document.body.addEventListener('keydown', event=>{
		if(event.key == 'Escape'){
			Dom('chkMainOverlayDiv').click();
			/*Controls.pause = Controls.pause ? 0 : 1; //toggle
			if(!Controls.pause){
				console.log('Unpause');
				requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
			}*/
		}
		if(event.key == 'Pause'){
			console.log('pause/unpause');
			Dom('pauseBellsack').click();
		}
	});
	console.log('Putting ns.Opt.IsGraphicsDebug.p fieldEditor in dom. As of 2025-11-13 that has not been tested in Bellsack but some of that code has in  Blob Monsters Game.');
	//ns.Opt.IsGraphicsDebug.set(0); //turn IsGraphicsDebug off by default
	ns.Opt.IsGraphicsDebug.set(1); //turn IsGraphicsDebug on by default
	ns.Opt.IsGraphicsDebug.fieldEditor('p',true).putInDom(Dom('graphicsDebugDiv'));
	//ns.Opt.SignedDistanceNewtonIterations.p
	ns.Opt.SignedDistanceNewtonIterations.if0(16);
	ns.Opt.SignedDistanceNewtonIterations.fieldEditor('p',true).putInDom(Dom('newtonIterationsDiv'));
	//ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.if0(opt.closeEnufToZero);
	
	//ns.Opt.SignedDistanceSpeed.if0(.1);
	ns.Opt.SignedDistanceSpeed.if0(.3);
	//ns.Opt.SignedDistanceSpeed.if0(.9);
	ns.Opt.SignedDistanceSpeed.fieldEditor('p',true).putInDom(Dom('SignedDistanceSpeedDiv'));
	
	ns.Opt.DensityOfSlightAttractToVec3_mul.if0(.1);
	ns.Opt.DensityOfSlightAttractToVec3_mul.fieldEditor('p',true).putInDom(Dom('DensityOfSlightAttractToVec3_mulDiv'));
	
	//ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.if0(opt.closeEnufToZero*1.17); //FIXME? want .0035 not .003
	ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.if0(opt.closeEnufToZero*100); //so high it doesnt display it much if ever
	ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.fieldEditor('p',true).putInDom(Dom('DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThanDiv'));
	console.log('startBellsack: '+ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.path()+'.p = '+ns.Opt.DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThan.p);
	ns.Opt.AddToDensityForTesting.set(0); //0 is normal, not testing. Slide it if u wanna test, and watch isosurface move
	ns.Opt.AddToDensityForTesting.fieldEditor('p',true).putInDom(Dom('AddToDensityForTestingDiv'));
	
	//ns.Opt.Display3dLocalMinsOfGradientMagLessThan.if0(.01); //they often do not display in middle of saddlering
	//ns.Opt.Display3dLocalMinsOfGradientMagLessThan.if0(.05); //tends to display in middle of saddlering
	ns.Opt.Display3dLocalMinsOfGradientMagLessThan.set(0); //turn this code off by value of 0. runs faster in theory. and the saddlering blobs in mid air dont appear even tho they still exist.
	ns.Opt.Display3dLocalMinsOfGradientMagLessThan.fieldEditor('p',true).putInDom(Dom('Display3dLocalMinsOfGradientMagLessThanDiv'));
	
	requestAnimationFrame(renderLoop);
};

/***************************************************************
 * 13) Quicksave / Quickload
 ***************************************************************/

/*function doQuicksave(slot){
	let c= { pos:[...camPos], quat:[...camQ] };
	let arr=[];
	for(let b of allBells){
	arr.push([b.x,b.y,b.z,b.radius,b.strength]);
	}
	let obj={ camera:c, bellcurves:arr };
	let s= JSON.stringify(obj);
	localStorage.setItem("bellsack_qs_"+slot, s);
	alert("Saved slot "+slot+", len="+s.length);
}
function doQuickload(slot){
	let s= localStorage.getItem("bellsack_qs_"+slot);
	if(!s){
	alert("No data in slot "+slot);
	return;
	}
	let obj= JSON.parse(s);
	camPos[0]= obj.camera.pos[0];
	camPos[1]= obj.camera.pos[1];
	camPos[2]= obj.camera.pos[2];
	camQ[0]	= obj.camera.quat[0];
	camQ[1]	= obj.camera.quat[1];
	camQ[2]	= obj.camera.quat[2];
	camQ[3]	= obj.camera.quat[3];

	allBells=[];
	spatialGrid= new SpatialGrid(10);
	for(let row of obj.bellcurves){
	let bc= new BellCurve(row[0],row[1],row[2],row[3],row[4],false);
	allBells.push(bc);
	spatialGrid.insert(bc);
	}
	alert("Loaded slot "+slot+", got "+allBells.length+" bells");
}*/

/***************************************************************
 * 14) Quaternions & small vector ops
 ***************************************************************/

/*
TODO remove Math.hypot and only do that in normalize(quat), for speed.

are u saying that in those ops, (2.0*(x*z+w*y))**2 + (2.0*(y*z-w*x))**2 + (1.0- 2.0*(x*x+y*y))**2 will remain constant
ChatGPT said:

Yes — as long as the quaternion [x, y, z, w] is unit-length, that expression:
(2*(x*z + w*y))² +
(2*(y*z - w*x))² +
(1 - 2*(x² + y²))²
will always equal 1 (aside from tiny floating-point error).

fn = (x,y,z,w)=>((2.0*(x*z+w*y))**2 + (2.0*(y*z-w*x))**2 + (1.0- 2.0*(x*x+y*y))**2)
(x,y,z,w)=>((2.0*(x*z+w*y))**2 + (2.0*(y*z-w*x))**2 + (1.0- 2.0*(x*x+y*y))**2)
x = 1;
1
y = 3
3
z = 5.5
5.5
w = -9.2
-9.2
len = Math.hypot(x,y,z,w)
11.175419455215092
x /= len; y /= len; z /= len; w /= len;
-0.8232353189845372
fn(x,y,z,w)
1

A unit quaternion rotates space using this 3×3 orthonormal matrix:
R = [
		1 − 2(y² + z²)		 ,	2(xy − wz)			,	2(xz + wy)
		2(xy + wz)				 ,	1 − 2(x² + z²)	,	2(yz − wx)
		2(xz − wy)				 ,	2(yz + wx)			,	1 − 2(x² + y²)
]

Your xx,yy,zz come from the 3rd column:
xx = 2(xz + wy)
yy = 2(yz − wx)
zz = 1 − 2(x² + y²)

If q = [x,y,z,w] is unit-length, then R is orthonormal → each column is a unit vector → xx² + yy² + zz² = 1.
*/


function calculateForwardVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*(x*z+ w*y);
	const yy= 2.0*(y*z- w*x);
	const zz= 1.0- 2.0*(x*x+ y*y);
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,0,1];
	return [xx/ln, yy/ln, zz/ln];
}
function calculateUpVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*( x*y- w*z );
	const yy= 1.0- 2.0*( x*x+ z*z );
	const zz= 2.0*( y*z+ w*x );
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,1,0];
	return [xx/ln, yy/ln, zz/ln];
}
function cross(a,b){
	return [
	a[1]*b[2]-a[2]*b[1],
	a[2]*b[0]-a[0]*b[2],
	a[0]*b[1]-a[1]*b[0]
	];
}
function normalize(v){
	const ln= Math.hypot(v[0],v[1],v[2]);
	if(ln<1e-9) return [0,0,0];
	return [v[0]/ln, v[1]/ln, v[2]/ln];
}
function multiplyQuaternions(q1,q2){
	const[x1,y1,z1,w1]=q1;
	const[x2,y2,z2,w2]=q2;
	return [
	w1*x2 + x1*w2 + y1*z2 - z1*y2,
	w1*y2 - x1*z2 + y1*w2 + z1*x2,
	w1*z2 + x1*y2 - y1*x2 + z1*w2,
	w1*w2 - x1*x2 - y1*y2 - z1*z2
	];
}
function createQuaternion(axis,angle){
	const ha= angle*0.5;
	const s = Math.sin(ha);
	return [ axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(ha)];
}
function normalizeQuaternion(q){
	const ln= Math.hypot(q[0],q[1],q[2],q[3]);
	if(ln<1e-9) return [0,0,0,1];
	return [q[0]/ln, q[1]/ln, q[2]/ln, q[3]/ln];
}

//css display:flex for example, or '' for normal.
var IdToDefaultDisplay = id=>{
	if(id=='overlayRight') return 'flex';
	return '';
};

var ToggleVisible = id=>{
	let d = Dom(id);
	let wasVisible = d.style.display!='none';
	d.style.display = (wasVisible?'none':'');
};

//returns undefined (instead of creating the path as usual) if it does not exist
var getVarByPath = path=>{
	const parts = path.split('.');
	let vr = V; //TODO rename V to v?
	if(parts[0]=='ns' || parts[0]=='NS'){ //ns/namespace refers to something like V.Bellsack.Room55
		vr = NS;//TODO rename NS to ns?
	}
	for (let i=1; i<parts.length; i++){
		if(vr) vr = vr.pu[parts[i]];
	}
	return vr;
};

var varToEditorText = vr=>('Json$'+JSON.stringify(vr.toMap({excludeBig:false, flatPu:true, fromRoot:true}), null, '\t'));

//null to unselect
function selectVar(vr){
	let varPathTxt = document.getElementById('varPathTxt');
	let mainTextarea = document.getElementById('mainTextarea');
	if(vr){
		let nextPath = vr.path(); //string like 'V.Bellsack.Room1.Hello.World'
		if(varPathTxt.value != nextPath){ //avoid infinite loop, dont trigger event unless actually changed
			varPathTxt.value = nextPath;
		}
		let txt = varToEditorText(vr);
		//let maxLen = 100000; //FIXME
		let maxLen = 1000000; //FIXME
		//let maxLen = 5000000; //FIXME
		if(txt.length > maxLen) txt = 'Err$...FIXME was length '+txt.length+'...'+txt.substring(0,maxLen-3)+'\n...FIXME was length '+txt.length+'...';
		mainTextarea.value = txt;
	}else{ //unselect
		varPathTxt.value = mainTextarea.value = '';
	}
};


var IsVisible = id=>(Dom(id).style.display!='none');

//window.onload = startBellsack;
window.addEventListener('DOMContentLoaded', startBellsack, { once:true });
</script>
</head><body>

<input type=checkbox id=chk_overlayLeft checked disabled style="display:none">


<nobr id=nobr_chkMainOverlayDiv style="position:absolute;left:75px;top:0px;z-index:1000000000;color:#aaa">
	<input type=checkbox id=chkMainOverlayDiv oninput="ToggleVisible('mainOverlayDiv'); ['overlayLeft','overlayTop','overlayRight','overlayDown'].forEach(id=>{ if(Dom('chk_'+id).checked) ToggleVisible(id); }); Dom('nobr_chkMainOverlayDiv').style.backgroundColor = IsVisible('mainOverlayDiv') ? '#040' : '';"><label for=chkMainOverlayDiv>Bellsack (Esc)</label>
</nobr>
<h2 style="position:absolute;left:3px;top:-28px;z-index:1000000000;color:#444">🎮+🖱️</h2>
<div id=mainOverlayDiv style="display:none;opacity:.7">

<!-- === overlay layer – place this right after your <canvas> === -->
<div id="overlayGrid"
     style="position:fixed; inset:0; z-index:1000;
            display:grid;
            grid-template-columns:auto 1fr auto;   /* L | C | R  */
            grid-template-rows:auto 1fr auto;      /* T | C | B  */
            grid-template-areas:
               'left top    top'
               'left center right'
               'left bottom bottom';
            pointer-events:none;">                <!-- let clicks reach canvas -->

  <!-- left panel (full height) -->
  <div id="overlayLeft"
	style="display:none;grid-area:left;background:rgba(0,255,0,1);pointer-events:auto;">
	
<table style="height:100%; table-layout:fixed;">
	<tr style="height:1px;"><td>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opensource/<a href=https://www.apache.org/licenses/LICENSE-2.0>Apache2</a><br>
&nbsp;Like IPFS, not responsible for P2P user content.
<br style="clear:both">
	</td></tr><tr style="height:1px;"><td>
		<label style="float:left;background-color:#0a0">SHOW:&nbsp;</label>
		<nobr style="background-color:#8f8"><input type=checkbox id=chk_play oninput="ToggleVisible('panelPlay');" checked><label for=chk_play><b>PLAY </b></label></nobr>
		<nobr style="background-color:red;"><input type=checkbox id=chk_overlayTop oninput="ToggleVisible('overlayTop');"><label for=chk_overlayTop><b>TOP </b></label></nobr>
		<nobr style="background-color:yellow;"><input type=checkbox id=chk_overlayRight oninput="ToggleVisible('overlayRight');"><label for=chk_overlayRight><b>RIGHT </b></label></nobr>
		<nobr style="background-color:#44f;"><input type=checkbox id=chk_overlayDown oninput="ToggleVisible('overlayDown');"><label for=chk_overlayDown><b>DOWN </b></label></nobr>
		<br style="clear:both">
		<label style="float:left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
		<nobr style="background-color:lightgreen;"><input type=checkbox id=chk_panelLogin oninput="ToggleVisible('panelLogin');"><label for=chk_panelLogin><b>LOGIN</b></label></nobr>
		<nobr style="background-color:lightgreen;"><input type=checkbox id=chk_panelTool oninput="ToggleVisible('panelTool');"><label for=chk_panelTool><b>TOOL</b></label></nobr>
		<nobr style="background-color:lightgreen;"><input type=checkbox checked id=chk_panelSaveOpen oninput="ToggleVisible('panelSave'); ToggleVisible('panelOpen');"><label for=chk_panelSaveOpen><b>FILE</b></label></nobr>
		<nobr style="background-color:lightgreen;"><input type=checkbox checked id=chk_panelOption oninput="ToggleVisible('panelOption');"><label for=chk_panelOption><b>OPTION</b></label></nobr>
		<br style="clear:both">
		<label style="float:left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
		<nobr style="background-color:lightgreen;"><input type=checkbox id=chk_panelVarUI oninput="ToggleVisible('panelVarUI');"><label for=chk_panelVarUI><b>VarUI</b></label></nobr>
		<nobr style="background-color:lightgreen;"><input type=checkbox disabled checked id=chk_panelCode oninput="ToggleVisible('panelCode');"><label for=chk_panelCode><b>CODE</b></label></nobr>
	</td></tr><tr style="height:1px;"><td>
		<div id=panelPlay style="display:">
			<label style="float:left;background-color:#0a0"">PLAY:&nbsp;&nbsp;&nbsp;</label>
			<input type=button value="restart game" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
			<input type=button value="restart level editor" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
			<br style="clear:both">
			<label style="float:left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
			<input type=button value="join game (browser)" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
			<input type=button value="host game (Tomcat)" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
		</div>
	</td></tr><tr style="height:1px;"><td>
		<div id=panelLogin style="display:none">
			Unlimited usernames. Password instant creates
			<br style="clear:both">
			username (by <a href=https://en.wikipedia.org/wiki/EdDSA>ed25519</a>) and is not uploaded.
			<br style="clear:both">
			If lose password, cant recover cuz end-to-end.
			<br style="clear:both">
			Hackers get unlimited tries, use long password.
			<br style="clear:both">
			Same user/pass work at many URLs/Tomcats.
			<br style="clear:both">
			Dont need to login to make "P2P user content".
			<br style="clear:both">
			Some features may only be available logged in.
			<br style="clear:both">
			<label style="float:left;background-color:#0a0"">PASSWORD:&nbsp;&nbsp;&nbsp;</label>
			<input disabled type=password id=userPassword style="background-color:black;color:white;width:210px" value="TODO"></input>
			<br>
			<label style="float:left;background-color:#0a0"">USERNAME:&nbsp;&nbsp;&nbsp;</label>
			<input disabled type=text id=userPubKey style="background-color:black;color:white;width:210px" value="Username/password is optional. TODO doesnt work yet."></input>
		</div>
	</td></tr><tr style="height:1px;"><td>
		<div id=panelSave style="display:">
			<label style="float:left;background-color:#0a0"">SAVE:&nbsp;&nbsp;&nbsp;</label>
			<input type=button value="QuickSave (cookie) 1" onclick="quicksave('1');" style="float:left">
			<input type=button value="2" onclick="quicksave('2');" style="float:left">
			<input type=button value="3" onclick="quicksave('3');" style="float:left">
			<input type=button value="4" onclick="quicksave('4');" style="float:left">
			<input type=button value="5" onclick="quicksave('5');" style="float:left">
			<input type=button value="6" onclick="quicksave('6');" style="float:left">
			<br style="clear:both">
			<label style="float:left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
			<input type=button value="7" onclick="quicksave('7');" style="float:left">
			<input type=button value="8" onclick="quicksave('8');" style="float:left">
			<input type=button value="9" onclick="quicksave('9');" style="float:left">
			<input type=button value="X" onclick="alert('TODO');" title="delete cookies, including those saved by Quicksave (cookie) 1 to 9." style="float:left">
			<input type=button value="to (text box)" onclick="setVarPathTxt(''); document.getElementById('mainTextarea').value = State();" style="float:left">
			<input type=button value="Save (file) " onclick="console.log('save file clicked'); let filename = prompt('Filename?','blobMonstersGame_'+time()+'.json'); if(filename) saveFile(filename, 'application/json', State());" style="float:left">
		</div>
	</td></tr style="height:1px;"><tr><td>
		<div id=panelOpen style="display:">
			<label style="float:left;background-color:#0a0"">OPEN:&nbsp;&nbsp;</label>
			<input type=button value="QuickLoad (cookie) 1" onclick="quickload('1');" style="float:left">
			<input type=button value="2" onclick="quickload('2');" style="float:left">
			<input type=button value="3" onclick="quickload('3');" style="float:left">
			<input type=button value="4" onclick="quickload('4');" style="float:left">
			<input type=button value="5" onclick="quickload('5');" style="float:left">
			<input type=button value="6" onclick="quickload('6');" style="float:left">
			<br style="clear:both">
			<label style="float:left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</label>
			<input type=button value="7" onclick="quickload('7');" style="float:left">
			<input type=button value="8" onclick="quickload('8');" style="float:left">
			<input type=button value="9" onclick="quickload('9');" style="float:left">
			<input type=button value="   from (text box)" onclick="console.log('load from text box clicked'); Load(document.getElementById('mainTextarea').value);" style="float:left">
			<input id=openFileInput type=file value="Open (file)" onclick="console.log('open file clicked. FIXME the events should be hooked in thru window.onload search for openFileInput.');" style="position: absolute; left: -9999px">
			<input type=button id=openFileInputB for="openFileInput" style="float:left" onclick="document.getElementById('openFileInput').click();" value="Open (file)"></input>
		</div>
	</td></tr><tr style="height:1px;"><td id=checkboxesDom>
		<div id=panelOption style="display:">
			<label style="float:left;background-color:#0a0"">OPTION:</label>
			<input type=checkbox id=pauseBellsack><label for=pauseBellsack onchange="if(this.checked){ console.log('Unpause pauseBellsack, calling lamglLoopBody(); FIXME what if it was already scheduled and u get 2 of them running at once?'); lamglLoopBody(); }">pause</label>
			<input type="checkbox" id="chkLevelEditor" checked><label for="chkLevelEditor" title="level editor: mouse drag ring knobs to reshape 3d curves balls roll on. display level editor to change the curvy shapes">level editor</label>
		</div>
	</td></tr><tr style="height:1px;"><td>
		<div id=panelTool style="display:none">
			<label style="float:left;background-color:#0a0"">TOOL:&nbsp;&nbsp;&nbsp;</label>
			<div id=paintControlsDiv style="padding:2px;float:left"></div>
			<select id=chooseTool name="cars" id="cars" size=4 style="background-color:#0a0";color:white;padding:6px;float:left">
				<option selected value="toolPlay">Play Game (FIXME)</option>
				<option value="toolSelect">Select (FIXME)</option>
				<option value="toolHold">Hold Still While Coding (FIXME)</option>
				<option value="toolPaint">Paint Walls/OpenArea (FIXME)</option>
			</select>
		</div>
	</td></tr><tr style="height:1px;"><td>
		<div id=panelVarUI style="display:none">
			<label style="float:left;background-color:#0a0"">VarUI:&nbsp;&nbsp;&nbsp;</label>
			<div id=paintControlsDiv style="padding:2px;float:left">TODO put VarUI here</div>
		</div>
	</td></tr><tr style="height:1px;"><td>
		<label style="float:left;background-color:#0a0"">CODE:&nbsp;&nbsp;</label>
		<input type=text id=varPathTxt style="background-color:black;color:white;width:210px" value=""
			oninput="let path = this.value.trim(); let vr = getVarByPath(path); if(vr){ selectVar(vr); }else{ document.getElementById('mainTextarea').value = ''; }"></input>
	</td></tr><tr style="height:100%"><td>
<textarea id="mainTextarea"
  style="width:100%;height:100%;
         box-sizing:border-box;
         overflow-y:auto;overflow-x:hidden;
         white-space:pre-wrap;word-wrap:break-word;resize:horizontal;
         background-color:black;color:white;tab-size:2"
	onkeydown="let e = event; let ta = this; console.log('key='+e.key); if(e.key==='Tab'){ e.preventDefault(); const start=ta.selectionStart; const end=ta.selectionEnd; ta.value=ta.value.substring(0,start)+'\t'+ta.value.substring(end); ta.selectionStart=ta.selectionEnd=start+1; };">
TODO using addExampleWavyBells, ns.Cw.Sak$123hashOfCode456.Wave1234 c being code/species (1 ghost per species), and balls stay as they are. Split later into multi species per 3 shaders, like 1-10 species per shader and 1-10 such groups compiled together, so can up to 100 species of terrain on screen at once.

TODO ns.Cw.Sak$435hash7343.Instance500.Ptrs$fn for diffeqfuncs andor potenfuncs, but shapefunc goes in ns.Cw.Sak$435hash7343
</textarea>
	</td></tr></table>	  

    <!--textarea style="resize:horizontal; width:180px; height:300px;"></textarea-->
  </div>

  <!-- top panel (full width after left) -->
  <div id="overlayTop"
       style="display:none;grid-area:top;
              background:#f22;
              padding:4px; overflow:auto; pointer-events:auto;
			  max-height:45vh;overflow-y:auto;">
Play BellSack. MOVE: left joystick and 2 triggers. TURN: right joystick.
<input type=button value="Privacy" onclick="alert('Privacy: If u want privacy dont share stuff. If u do share it, it might get around to anyone anywhere. But my tools do not suprise you by you think its running local but actually spying on u. Ur in control of all data streams in and out locally, in theory, cuz as of 2025-9-3 its still running locally even if you found it on a webpage, no servers peers or ajax yet (TODO). Type V (enter) on the browser console (try pushing F12 or its in the browser menu somewhere, to open browser console). You\'ll see the data of the Var tree such as V.Bellsack.Room234.Other.Stuff.Blah.Blah but as json. Type V (TODO going to rename V to v lowercase?) on console and go from there.');">
<input type=button value="Other Info" onclick="alert('What im going for in my Var*.js (which bellsack uses) across internet is it never publishes without your permission, you\'re running locally except whichever Var objects you choose to stream to the world, but once someone gets a copy its like IPFS no take backs snitches (shares spreads broadcasts publishes uploads etc) to the max as in anyone anywhere in the world might (unreliable, may publish or not, as common in peer to peer) get it by asking the network for whatever string hashes to a given hash. Hashes occur in V.Bellsack.Room234.Other.Stuff.Blah.Blah.p is the position of V.Bellsack.Room234.Other.Stuff.Blah.Blah even if you have never typed that before. Its a sparse high dimensional vector system with mutable .p position and .v velocity for each tree node. Its a file system for vectors kind of. Player created content will go in that tree, including new GPU code of a limited kind to compute high dimensional scalar fields really fast and many in parallel. I sometimes run 100k GPU threads in Lamgl, and up to about 1000 GPU threads during physics calculations but bigger loops and more loops in loops in physics shaders so fewer threads. This html file is optimized to use GPU SIMD efficiently by use of WebGL2 GLSL ES 300 GPU shaders which I can eval new shaders by any code string I want at any time in .01 to 20 seconds depending how complex a shader it is. This html file works in desktop computers using their GPU, but doesnt work or is incredibly slow on mobile browsers (todo maybe later?). It should in theory work on most operating systems, anywhere WebGL2 GLSL ES 300 works.');">
<br>
EDIT TERRAIN: mouse drag the 5 colored knobs per circle/bell. Save/load: TODO V/Var tree.<br>
	ADD BALL: LB/RB on gamepad (above analog triggers).<br>
	
	<hr>
	FIXME the 3 multiprobe checkboxes are not working yet 2025-12-4-9aET.<br>
	<input type="checkbox" id="chkIsBallCacheOptimization" checked><label for="chkIsBallCacheOptimization" title="an optimization of VarGradientGL that caches the closest 3d point on the isosurface to each ball and d(loss)/d(density) together as a vec4 so it doesnt have to keep doing that hundreds of times per ball, once per surface dimension (+1 for neutral sample), and instead do it once and use the cache. This requires an extra Lamgl call, so 2 Lamgl calls per physics cycle instead of 1. See this in lamglLoopBody. This should in theory be MANY times faster. In theory it makes loss function compute the same thing in glsl but faster, except for approximating it by 1st derivative. Experimental as of 2025-7-26+.">isBallCacheOptimization</label>
	
	<nobr><input type="checkbox" id="multiprobe_isosurfaceBallPhysics" checked><label for="multiprobe_isosurfaceBallPhysics" title="multiple samples per ball during physics, an attempt to solve the saddlering bug by calling nearestPointOnIsosurface for example 17 times (each in a different GPU thread) per ball instead of 1, and keep whichever scores highest by sortVal. This is not for multiprobe in debugGraphicsOnBallThatUsesSignedDistancePerPixel or cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache since those have their own checkboxes to do multiprobe vs single. Those other multiprobe checkboxes just do a loop about size 17, instead of 17 times more GPU threads as this one does.">multiprobe_isosurfaceBallPhysics</label></nobr>
	<br><br>
	
	<nobr><input type="checkbox" id="debugGraphicsOnBallThatUsesSignedDistancePerPixel"><label for="debugGraphicsOnBallThatUsesSignedDistancePerPixel" checked>debugGraphicsOnBallThatUsesSignedDistancePerPixel<br>(2025-12-4 only works when NOT graphicsDebug, tho it used to work in graphicsDebug)</label><nobr><br>
	<nobr><input type="checkbox" id="multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel" disabled><label for="multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel" title="multiple samples per pixel on a ball when debugGraphicsOnBallThatUsesSignedDistancePerPixel uses signedDistance to compute color. Else 1 sample per pixel. Only on balls either way. Does a loop approx size 17, instead of 17 times more GPU threads.">multiprobe_debugGraphicsOnBallThatUsesSignedDistancePerPixel</label></nobr>
	<br><br>
	
	<nobr><input type="checkbox" id="cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache"><label for="cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache" title="After computing ballCacheVec4.xyz (vec3) nearest point on isosurface to ball center (not perturbed) by nearestPointOnIsosurfaceFromXYZ, this checkbox makes it do another nearestPointOnIsosurfaceFromXYZ from there for each perturb, instead of the usual linear interpolation. Linear interpolation being faster than (by calling densityAtXYZ much fewer times than a newton loop) is the whole point of the optimization. But to test the optimization in case its not finding the isosurface, you can use this checkbox.">cheatTheOptimizationIn_nearestPointOnIsosurfaceFromXYZ_estimateUsingBallCache</label>
	<nobr><input type="checkbox" id="multiprobe_cheatTheOptimizationIn" disabled><label for="multiprobe_cheatTheOptimizationIn" title="multiple samples per dimension_ball pair when it calls signedDistance. This makes it run a loop in 1 GPU thread per such pair.">multiprobe_cheatTheOptimizationIn</label></nobr><br>
	
	<nobr><input type="checkbox" id="physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters" checked><label for="physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters" title="a slow debug graphics that uses the endItersEarly param in  nearestPointOnIsosurfaceFromXYZ(vec3,vec3,int endItersEarly) for every possible int endItersEarly ranging 0 to SignedDistanceNewtonIterations inclusive (so theres SignedDistanceNewtonIterations+1 times more GPU threads and returned vec4s than physicsCacheNearestVec4PerBall). This is to track down physics bugs why its not finding isosurface even with multiprobe, why balls are going thru isosurface where it doesnt find isosurface, that happens 2025-12-15 and has been that way for months getting gradually better. Its time to fix it once and for all asap.">physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters</label></nobr>
	
	<nobr><input type="checkbox" id="physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters_cheaperFasterUse1PerBallForBasicDisplayTest" checked><label for="physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters_cheaperFasterUse1PerBallForBasicDisplayTest">physicsCacheNearestVec4PerBall_seeInsideAllNewtonIters_cheaperFasterUse1PerBallForBasicDisplayTest</label></nobr>
	
	<hr>
	
	<input type=button value="(for graphicsDebug) Turn off few kinds of debug graphics in opt {}" onclick="Dom('graphicsDebug').checked = Dom('debugGraphicsOnBallThatUsesSignedDistancePerPixel').checked = false; opt.graphicsDebug_distanceToBall_displayRadius = opt.graphicsDebug_ballCacheVec4_displayRadius = 0;">
	<br>
	<nobr><input type="checkbox" id="chkBallCacheOptimizationIgnoresBallBallCollisions"><label for="chkBallCacheOptimizationIgnoresBallBallCollisions">chkBallCacheOptimizationIgnoresBallBallCollisions</label></nobr>
	
	
	<!--nobr><input type="checkbox" id="graphicsDebug" checked><label for="graphicsDebug" checked>graphicsDebug</label></nobr-->
	hypothesis_saddleringBugHappensCuzTheresLocalminOf(densityAtXYZ)NearCenter!!!
	Saddlering bug is back. So many terrain shapes can happen so fixing it in some breaks it in others. think I know why. Local-mins. The isosurface is densityAtXYZ(vec3)=0. Positive density is inside. Negative is open area. In mid air theres probably gradientAtXYZ(vec3)=vec3(0,0,0).
	<br style="clear:both">
	<div id=graphicsDebugDiv style="float:left">graphicsDebugDiv</div>
	<br style="clear:both">
	<div id=newtonIterationsDiv style="float:left">newtonIterationsDiv</div>
	<br style="clear:both">
	<div id=SignedDistanceSpeedDiv style="float:left">SignedDistanceSpeedDiv</div>
	<br style="clear:both">
	<div id=DensityOfSlightAttractToVec3_mulDiv style="float:left">DensityOfSlightAttractToVec3_mul</div>
	<br style="clear:both">
	<div id=DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThanDiv style="float:left">DisplayErrorsOnSurfaceInBrightGreenIfAbsMoreThanDiv</div>
	<br style="clear:both">
	<div id=AddToDensityForTestingDiv style="float:left">AddToDensityForTestingDiv</div>
	<br style="clear:both">
	<div id=Display3dLocalMinsOfGradientMagLessThanDiv style="float:left">Display3dLocalMinsOfGradientMagLessThanDiv</div>
	<br style="clear:both">
	<input type=button onclick="Lamgl.doBasicTests();" value="Lamgl.doBasicTests()">
	<input type=button onclick="doTestDisplay();" value="Lamgl.testDisplay">
	<br>
	<input type="checkbox" id="testDisplayIsSparseXY" checked><label for="testDisplayIsSparseXY" title="sparse points by gl_VertexID in vertex shader code string, else dense points by 2 triangles that fill the display rectangle using 'in vec2 XY;'.">testDisplayIsSparseXY</label>
	<input type=checkbox checked id=continueTestDisplay><label for=continueTestDisplay title="video test else 1 pic">continueTestDisplay</label>
	<input type=checkbox id=testDisplayLogsBigTensor><label for=testDisplayLogsBigTensor title="only works if you choose this before starting testDisplay, FIXME">testDisplayLogsBigTensor</label>
	<br>
	<input type="checkbox" id="chkSeparateRingsAsTexture"><label for="chkSeparateRingsAsTexture" title="use with 'level editor' checkbox. If unchecked its the old way from before 2025-8-27/Bellsack306(which did it both ways at once, wasting compute power, duplicating the rings by computing them 2 different ways). If checked, its the way after, to compute rings as a tensor/texture so the main display shader (graphicsMain/graphicsDebug) is smaller, do it in more Lamgl calls in smaller pieces. Hopefully this will be fast enuf cuz I need it to scale up in species.">chkSeparateRingsAsTexture</label>
	<input type="checkbox" id="chkDoPhysics" checked><label for="chkDoPhysics" title="do physics (if unchecked you can still move around)">physics</label>
	<input type="checkbox" id="chkOnlyBallPhysics" checked><label for="chkOnlyBallPhysics" title="if physics checkbox is checked, then this chooses which Vars/dimensions it applies to, only balls or ALSO terrain. TODO make sure opt.nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3 is true if using this else it wont be very accurate and balls will fall thru isosurface.">only ball physics (2025-11-13 this checkbox has no effect if IsNewEventSystemY2025M11 is checked)</label>
	<br>
	<input type="checkbox" id="ballCacheOptimizationUsesFastGradientAlongLineElse4Samples" checked><label for="ballCacheOptimizationUsesFastGradientAlongLineElse4Samples">ballCacheOptimizationUsesFastGradientAlongLineElse4Samples</label><br>
	<input type="checkbox" id="testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu"><label for="testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu">testIfFirstoutgetIsBottleneckByUsingEmptyFloatArrayInsteadOfReadingFromGpu</label><br>
	<input type="checkbox" id="addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform"><label for="addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform"
	>addExtraStepCopyingBallCacheFromTextureToCpuToGlUniform</label><br>
	<input type="checkbox" id="nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3" checked><label for="nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3" title="Makes finding nearest point to ball on isosurface more accurate by solving a differential equation, but slower cuz its got to call gradientAtXYZ (which calls densityAtXYZ 4 times) in the newton loop body instead of just densityAtXYZ.">nearestPointOnIsosurfaceFromXYZ_does_ gradientAtXYZ_including_densityOfSlightAttractToVec3</label>
	<nobr><input type="checkbox" id="holdBallsOnIsosurface"><label for="holdBallsOnIsosurface">holdBallsOnIsosurface</label></nobr>
	<nobr><input type="checkbox" id="displayBallCacheVec3AsSecondBall" checked><label for="displayBallCacheVec3AsSecondBall">displayBallCacheVec3AsSecondBall</label></nobr>
	<nobr><input type="checkbox" id="whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector"><label for="whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector">whenFindingNearestPointOnIsosurfaceGraduallyIncreaseInfluenceOfNormalVector</label></nobr>
	<nobr><input type="checkbox" id="IsNewEventSystemY2025M11"><label for="IsNewEventSystemY2025M11">IsNewEventSystemY2025M11</label></nobr>
	<nobr><input type="checkbox" id="findSurfaceByGradientsAlongRay"><label for="findSurfaceByGradientsAlongRay">findSurfaceByGradientsAlongRay</label></nobr>
	<nobr><input type="checkbox" id="holdABallInFrontOfCamera"><label for="holdABallInFrontOfCamera">holdABallInFrontOfCamera</label></nobr>
	<!--input type="checkbox" id="chk_nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3" checked><label for="chk_nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3">nearestPointOnIsosurfaceFromXYZ_does_gradientAtXYZ_including_densityOfSlightAttractToVec3 (use with isBallCacheOptimization)</label-->
  </div>

  <!-- bottom panel (full width after left) -->
  <div id="overlayDown"
       style="display:none;grid-area:bottom;
              background-color:#22f;
              padding:4px; overflow:auto; pointer-events:auto;">
	<label id=liveDisplay></label>
  </div>

  <!-- right panel between top & bottom -->
  <div id="overlayRight" style="position:relative;display:none;grid-area:right; background:rgba(255,255,0,1); padding:4px; overflow:auto; pointer-events:auto; flex-direction:row; width:300px; min-width:100px; padding:0; overflow:hidden;"
	onmouseleave="this._rsz=0; document.body.style.cursor='';"
  >
<table style="width:100%; height:100%; border:0; border-collapse:collapse; table-layout:fixed;">
  <tr>
    <!-- Left resizer column -->
    <td id="overlayRightResizer"
        style="width:6px; cursor:ew-resize; background:yellow"
        onmousedown="var r=this,o=document.getElementById('overlayRight');r.isResizing=true;r.sx=event.clientX;r.sw=o.offsetWidth;document.body.style.cursor='ew-resize';document.onmousemove=function(e){if(!r.isResizing)return;var w=r.sw-(e.clientX-r.sx);if(w<100)w=100;o.style.width=w+'px';o.style.minWidth=w+'px';};document.onmouseup=function(){r.isResizing=false;document.body.style.cursor='';document.onmousemove=document.onmouseup=null;};"
		
        onmouseup="this.isResizing=false; document.body.style.cursor='';"
        onmousemove="if(this.isResizing){
          document.body.style.cursor='ew-resize';
          var newW=Math.max(80,window.innerWidth-event.clientX);
          this.parentElement.parentElement.parentElement.parentElement.style.minWidth=newW+'px';
        }">
    </td>

    <!-- Right content cell with textarea -->
    <td style="width:100%; height:100%; padding:0;">
      <div style="height:100%; width:100%;">
<textarea style="background-color:#ffd;height:100%; width:100%;
                         box-sizing:border-box;
                         overflow:auto;
                         resize:horizontal;
                         white-space:pre-wrap;word-wrap:break-word;">
You can delete all this text if you want. Put anything here. Use it for copy/paste. Its erased each time the page reloads.

;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opensource/<a href=https://www.apache.org/licenses/LICENSE-2.0>Apache2</a><br>
(TODO ed25519 with separate opensource license?)<br>
&nbsp;Like IPFS, not responsible for P2P user content.

TODO put all checkboxes<br>
numboxes etc as someVar.fieldEditor('p')<br>
and use new event system both directions.<br>
Use it to tune Bellsack so the balls<br>
bounce and roll right.<br>
						 
						 
						 
<h2><font color=#3388ff>Adding Sak like Sak.trySakEval('Sak$2+3') cuz gonna have lambdas in V/Var tree code stored in .big,
	and you call them thru .ob (todo put that in Proxy to fill in ob from .getOb(),
	like: const poten = ns.Odos$hashXYZ.ob(ns.Odos$hashXYZ.Lone.Lone.B509);
	where ns means room such as v.Bellsack.Room5 and TODO rename V to v cuz its a built in so shouldnt start with capital.
	And get this text etc off the canvas u cant grab knobs on the rings to adjust shapes thru it.
	or Sak.trySakEval('Sak$x=>(x*x+1)')(10) evals to 101 and if u call it again it reuses that same js compiled x=>(x*x+1).
	</font></h2>
	Bellsack183 has moving balls by VarGradientGL physics, not doing the more<br> detailed collisions yet, not tuned well yet, but at least its moving.<br>
	Bellack is now running on Lamgl, an javascript function that calls GPU statelessly with immutable tensors.<br>
	TODO implement <a href=https://github.com/benrayfield/jsutils/blob/master/src/bellsack/BellsackDesignDocument.txt>https://github.com/benrayfield/jsutils/blob/master/src/bellsack/BellsackDesignDocument.txt</a><br>
	Terrain is randomly generated. Reload it if you dont see the game world.<br>
	TODO cache gradientAtXYZ(cachedSurfaceXYZ) in second output texture in bellCacheVec4 step, to make it<br>
	about 2x maybe 4x or 5x faster cuz of fewer calls of densityAtXYZ(vec3).
	
	2025-11-26[[
	Its been live on the website for months u can try it. Its a weird math thing. I defined a scalar-field f that depends on another scalar field g. g(vec3)=>float. f(vec3)=>float. normal scalar field stuff. But heres the weird part, I use both g and gradient of g. For g I just use abs(g(vec3)) so its lowest where g(vec3) is 0. But for gradient of g, I compare it to a certain direction of gradient I want, that being isosurface shapes that if it were a curvy mirror would reflect back to the center of a ball if a light was shined from there. Surface is perpendicular to the direction to ball center. And I made a loss term for the cosine distance of those angles. This guarantees the global-minimum of loss occurs at every closest point on the isosurface, BUT it also allows other points on the isosurface to be global mins. that i dont want to find. so im optimizing some combos of code experimentally. Things are appearing in mid air in 3d in my game engine that shouldnt be there. but they are cuz a gradient can be 0 when density is nonzero. gradient of density. its a local min. My way of estimating the closest point on the curvy surface, to any given vec3 point, works enuf to get by, is practically useful, but gamers gonna say my game sucks if i have balls bouncing off invisible things in mid air aka localmins of the 3d density field.
	]]
	<br><br>
	TODO
	In theory I can do wavefunction-wavefunction collisions, 2 reshaping blobs, viewing a 3d cross-section of each similar to Miegakure is a 3d cross-section of a 4d world,	that could act like hardbody game physics objects or reshape by many dimensional torque/position/velocity.
	Lambda Rick 🏴‍☠️/acc
	@benrayfield
	1m
	Signed-distance between 2 isosurfaces is minimum signedDistance (to the other isosurface) from each point in its volume. Bellsack does ball-wavefunction physics, an isosurface where wavefunction(position)=0. Computes signedDistance between 3d point and nearest point on isosurface.
	Use harmonySeach of sparse points to choose where to place the n balls to run normal physics. like how i did it in dagball (theres a checkbox for it that makes Circ/terrain bounce on Circ/terrain) but a different way of choosing where the balls jump around.
	<br>
	TODO bellsackHeavyBallsVsLightBalls
	
	
TODO use this data format and put the spring pr ps cv accelMul (var fields that arent .p and .v) into the big: string lists,
but start with upgrading the existing ball and bell5 to this incomplete but pretty close to what i want format.
Also make sure to use my 64 base64 digits (which are ascending order in ascii and utf8 and are all valid in js var names)
$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz.
so the ids will be Prefix$fortyThreeChars instead of Prefix$64chars, so ids will be 21 chars shorter.
and make sure to only use \n to join .big, but can put a bigJoin: '' if u want the .big to not put \n joining them.
TODO make some Var's have mutid like in Dagball so it automaticly holds .p as sums max to 1 of all those with the same mutid,
like if you make a new version of it, its hash id (path part) is new, but same mutid in that .big "mutid: jacksBall".

TODO get rid of readFields, and derive that.
Keep join and Jo$'s.
Do NOT parse complete javascript/sak/glsl in the "func:" just to be able
to do const ghost = ns.Odos$hash.Lone.Lone; then to make a list of [ghost.Thing, ghost.OtherThing, etc].
Just write it out all the way [ns.Odos$hash.Lone.Lone.Thing, ns.Odos$hash.Lone.Lone.OtherThing, etc]
despite that it takes more code size. It makes it easier to automate. And u only gotta send the code
once per edit of the code, not when you move Cx Cy ManaRefillRate etc cuz those dont send .big again.
...
TODO figure out how to do the 3d circle thats a constraint on a set of balls
that at lowest poten stays on the circle, any circle at any 3d center and 3d rotation
and radius within some range, that the lets say 7 balls have that 3d positional relation to eachother,
cuz thats what the PotenNearPairs$ as computed by SPARSE gradient each physics cycle.
How does it know what vars to do on sparse gradient? By parsing it for ns... vars,
and the func returns float poten.
Try 3 lists one for Cx one list for Cy one list for Cz and maybe another for Cr.
...
Or maybe it is ok, not too much extra code, to do the "ghost = ns.Odos$hash.Lone.Lone" thing.
Just add a little more parsing above Sak.tokenize(big.join('\n')).

Gotta know which vars are read.

Write diffeq only by make some func dv(theVar,addToDv) dp(...) kv(...) mnx(...)
which will do it by 

Only refer to dag vars by ns.[stuff....] so its easy to parse.

Very important: when u edit an Odos$... while certain PotenNearPairs$ are recursiveEditSelected,
it will auto edit those PotenNearPairs$ too, to replace the Odos$... with its new hash
so the game rules about pairs of things still apply to the code you just edited.
It doesnt break the game world if your new code still works.
Others who did not take those edits or have that selected still have the old version
and both versions can work together in any combos.

TODO also add .pr .ps springs into .big "spring: Cy ..." "spring: ManaRefillRate ..." etc
but could also do it by making more Var instances for Pr Ps,
like .ManaRefillRate.Pr.p .ManaRefillRate.Ps.p .

{
	p:1,v:0,
	Bellsack:{
		p:1,v:0,
		Room1:{
			p:1,v:0,
			Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8:{
				p:1,v:0,
				big:[
					"Odos$",
					"comment: Example Odos$ bell5",
					"readFields: Cx Cy Cz Cr",
					"join: Cz Jo$exampleJoinMandelbulbAndBell5",
					"func: (wv,X,Y,Z)=>{",
					"	float dx = X.p - wv.Cx.p;",
					"	float dy = Y.p - wv.Cy.p;",
					"	float dz = Z.p - wv.Cz.p;",
					"	float dist2 = dx*dx + dy*dy + dz*dz;",
					"	return wv.p * exp(-dist2/(2.*wv.Cr.p*wv.Cr.p));",
					"}"
				],
				Lone:{p:1,v:0,
					Lone:{p:1,v:0,
						B500:{p:1,v:0,Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:0.6}},
						B501:{p:1,v:0,Cx:{p:2},Cy:{p:1},Cz:{p:-1},Cr:{p:0.7}},
						B502:{p:1,v:0,Cx:{p:-2},Cy:{p:3},Cz:{p:1},Cr:{p:0.5}}
					}
				},
				Terrain:{p:1,v:0,
					Terrain:{p:1,v:0,
						T900:{p:1,v:0,Cx:{p:1},Cy:{p:-1},Cz:{p:0},Cr:{p:5.0}},
						T901:{p:1,v:0,Cx:{p:-3},Cy:{p:2},Cz:{p:1},Cr:{p:4.0}}
					}
				}
			},

			Odos$mandelbulb1234567890abcdef:{
				p:1,v:0,
				big:[
					"Odos$",
					"comment: Example Odos$ mandelbulb",
					"readFields: Cx Cy Cz Iter Scale",
					"join: this Jo$exampleJoinMandelbulbAndBell5",
					"func: (wv,X,Y,Z)=>{",
					"	// Mandelbulb density approx placeholder",
					"	float r = sqrt(X.p*X.p+Y.p*Y.p+Z.p*Z.p);",
					"	return wv.p * cos(r*wv.Scale.p);",
					"}"
				],
				Shared:{p:1,v:0,
					Wave1:{p:1,v:0,Cx:{p:1},Cy:{p:2},Cz:{p:3},Iter:{p:8},Scale:{p:1.2}},
					Wave2:{p:1,v:0,Cx:{p:-1},Cy:{p:-2},Cz:{p:-3},Iter:{p:6},Scale:{p:0.8}},
					Wave3:{p:1,v:0,Cx:{p:0},Cy:{p:1},Cz:{p:2},Iter:{p:7},Scale:{p:1.0}}
				}
			},

			PotenNearPairs$ffe2185ff8a79b2d17d5f8507b63e7e4b8ed22b2219cea9b2478bf239ad4c95b:{
				p:1,v:0,
				big:[
					"PotenNearPairs$",
					"comment: Example PotenNearPairs$ gravity",
					"aOdos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"aNonzeroFields: Cr",
					"aReadFields: X Y Z Cr",
					"bOdos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"bNonzeroFields: Cr",
					"bReadFields: X Y Z Cr",
					"func: (a,b,Cc)=>{",
					"	float dx=a.Cx.p-b.Cx.p;",
					"	float dy=a.Cy.p-b.Cy.p;",
					"	float dz=a.Cz.p-b.Cz.p;",
					"	float dist2=dx*dx+dy*dy+dz*dz;",
					"	float r=sqrt(dist2);",
					"	if(r<Cc) r=Cc;",
					"	return -(a.p*b.p)/r;",
					"}"
				],
				Gravity01:{p:1,v:0,Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:64},Cc:{p:0.5}},
				Gravity02:{p:1,v:0,Cx:{p:1},Cy:{p:1},Cz:{p:1},Cr:{p:48},Cc:{p:0.8}}
			},

			PotenOnes$b14bc8aed218e5ff4a6a3c5333219789a05906cd242dc1cf53c972cf22a38354:{
				p:1,v:0,
				big:[
					"PotenOnes$",
					"comment: Example PotenOnes$ centering",
					"odos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"nonzeroFields: Cr",
					"readFields: X Y Z",
					"join: Cx Jo$GripA",
					"func: (g)=>{",
					"	float r2=g.Cx.p*g.Cx.p+g.Cy.p*g.Cy.p+g.Cz.p*g.Cz.p;",
					"	return 0.01*r2;",
					"}"
				],
				Centering01:{p:1,v:0,Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:64}},
				Centering02:{p:1,v:0,Cx:{p:2},Cy:{p:0},Cz:{p:2},Cr:{p:64}}
			},

			DiffeqOnes$9ae455f3e0d0c527b7fdfd892a1e080006de40a4bd0dc146e8904de1c65ca410:{
				p:1,v:0,
				big:[
					"DiffeqOnes$",
					"comment: Example DiffeqOnes$ decay",
					"odos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"nonzeroFields: Cr",
					"readFields: Cr",
					"func: (g)=>{",
					"	g.Cr.dV(-0.1*g.Cr.p);",
					"}"
				],
				Decay01:{p:1,v:0,Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:32}},
				Decay02:{p:1,v:0,Cx:{p:1},Cy:{p:0},Cz:{p:1},Cr:{p:24}}
			},

			DiffeqNearPairs$312f8d32ad5db671cebf00f194d587340a07dd2bc13fe7000d8bcfc28e8e1184:{
				p:1,v:0,
				big:[
					"DiffeqNearPairs$",
					"comment: Example DiffeqNearPairs$ repulsion",
					"aOdos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"aReadFields: Cx Cy Cz",
					"bOdos: Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
					"bReadFields: Cx Cy Cz",
					"func: (a,b)=>{",
					"	float dx=a.Cx.p-b.Cx.p;",
					"	float dy=a.Cy.p-b.Cy.p;",
					"	float dz=a.Cz.p-b.Cz.p;",
					"	float dist2=dx*dx+dy*dy+dz*dz;",
					"	if(dist2<1.0){",
					"		a.Cx.dP(0.1*dx);",
					"		b.Cx.dP(-0.1*dx);",
					"	} ",
					"}"
				],
				Repulse01:{p:1,v:0,Cx:{p:0},Cy:{p:0},Cz:{p:0},Cr:{p:64},Cc:{p:1}},
				Repulse02:{p:1,v:0,Cx:{p:2},Cy:{p:0},Cz:{p:2},Cr:{p:48},Cc:{p:1}}
			},

			PotenGlobal$8a68212192db797a9e1eb25633abdc59a7eb5cbd0b02aa2e71c41160e91c5b7b:{
				p:1,v:0,
				big:[
					"PotenGlobal$",
					"comment: Example PotenGlobal$ constant",
					"func: ()=>{",
					"	return 1.0;",
					"}"
				],
				Global01:{p:1,v:0},
				Global02:{p:1,v:0}
			},

			User$a0806124028e1699222a37c8d46b5ed7ca4f2f931fa3dbcdcaf6eaa0fed9e665:{
				p:1,v:0,
				big:[
					"User$",
					"comment: Example User$",
					"pubkey: ed25519:abcdef123456"
				],
				Profile:{p:1,v:0},
				Inventory:{p:1,v:0}
			},

			Jo$exampleJoinMandelbulbAndBell5:{p:1,v:0},
			Jo$GripA:{p:1,v:0}
		}
	}
}

----------

"PotenNearPairs$",
"comment: Example PotenNearPairs$ gravity",
"dag: a ns.Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
"dag: b ns.Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
"aOdos: a",
"aNonzeroFields: Cr",
"aReadFields: Cx Cy Cz Cr",
"bOdos: b",
"bNonzeroFields: Cr",
"bReadFields: Cx Cy Cz Cr",
"func: (a,b,Cc)=>{",
"  float dx=a.Cx.p-b.Cx.p;",
"  float dy=a.Cy.p-b.Cy.p;",
"  float dz=a.Cz.p-b.Cz.p;",
"  float dist2=dx*dx+dy*dy+dz*dz;",
"  float r=sqrt(dist2);",
"  if(r<Cc) r=Cc;",
"  return -(a.p*b.p)/r;",
"}"

TODO remove dag: and aReadFields: and bReadFields cuz all those can be derived.
make it just what person would type in textarea editing this code.

"aOdos: ns.Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8", and if ur gonna use Var instances in the func, give the whole path starting with ns, even if its long, cuz i dont want to have to do detailed parsing. i can get the js tokens from Sak.tokenize(string) and check for ns . Thing . OtherThing etc

"PotenNearPairs$",
"comment: Example PotenNearPairs$ gravity",
"aOdos: ns.Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
"aNonzeroFields: Cr",
"bOdos: ns.Odos$0658b7aa936e77579e2e183d6af4f27131a22c4aef0c11aad97422ae4bf714e8",
"bNonzeroFields: Cr",
"func: (a,b,Cc)=>{",
"    float dx=a.Cx.p-b.Cx.p;",
"    float dy=a.Cy.p-b.Cy.p;",
"    float dz=a.Cz.p-b.Cz.p;",
"    float dist2=dx*dx+dy*dy+dz*dz;",
"    float r=sqrt(dist2);",
"    if(r<Cc) r=Cc;",
"    return -(a.p*b.p)/r;",
"}"

ok. so the rule is we only take paths that start with ns dot "ns." "ns ." etc.
after tokenizing and removing whitespace it will be 'ns','.','Something....'
</div>
</textarea>
      </div>
    </td>
  </tr>
</table>

</div>

</body>
</html>