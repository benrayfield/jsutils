<!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>BellSack 3d game engine opensource MIT</title>
<style>
	body {
		margin: 0; padding: 0; background: #222;
		display: flex;
		justify-content: center;
		align-items: center;
		font-family: sans-serif;
	}
	canvas {
		background: black;
	}
</style>
<script>
"use strict";
const Err = str=>{throw new Error(str);};
const Todo = str=>{throw new Error('TODO: '+str);};

/* prompt that generated gptBellRaymarch3d_001_opensourceMITLicensed.html which is opensource MIT licensed by Ben F Rayfield 2025-3-25.

write a html that demonstrates this kind of raymarching with a target FPS of 60 and low resolution canvas

Post
Conversation
Lambda Rick /acc
@benrayfield
·
41m
A weighted set of 3d bellcurves (x y z radius strength) defines a smooth 2d surface at every x y z where sum=0 of all bellcurves touching there.
Lambda Rick /acc
@benrayfield
·
27m
200 such 3d bell curves could be stored in a GPU shader that runs in a browser. u get a few thousand float32s to do whatever u want with, so it could be programmed to make each GPU thread do its own gradient descent recursively
Lambda Rick /acc
@benrayfield
·
25m
it could be raymarched
Lambda Rick /acc
@benrayfield
it could raymarch and reflect on saddlepoint shaped curved mirrors
ChatGPT said:

<!DOCTYPE html>...
*/

/*
Isosurface: Now using sphere shaped pic for raytracing. This'll allow me to scale up BellSack game engine by using many of these together. Distant objects will change slower but u'll see them at 60 FPS. Voxels will copy across sphere pics like net routers (bellsack072_uvsphereRaytracingWorkedFirstTime.html)

The plan is each voxel will be a vec4: [x y z time+color/4096], where time is in units of 1/60 second (video frames), and to update near things every 1 time (instantly), farther things every 8 time, even farther away things every 64 times (about 1 second), very far things 8 secs.
so in that way, if theres 4 speeds of deleting old voxels, in each direction theres a mat4 (float[4][4]) aka 4 voxels, but its sparse, each sphere pic (UVSphere class) only has 1 vec4 (float[4]) per angle

Even though there could potentially be a billion voxels on screen, they should all display updated positions every 1/60 second. The camera can move without changing those voxels. They're still the same [x y z time+color/4096]. We just select a different set of voxels to view.

The game should support unlimited players at once all seeing eachother. Balls rolling around could be updated faster than the terrain but thats for future research.

It wont store a billion voxels as game content but it can generate them by sum of bellcurves that define the curvy surface. Its very compressed like that, an equation, and the voxels it generates only go in GPU memory on the sphere pic surfaces.
but if u happen to have a bunch of voxels [x y z time+color/4096] u could just copy them into the GPU. It doesnt check where they came from. Its gonna be each 2 sphere pics, fork 1 GPU thread for each voxel on one's surface, and paint it onto the other sphere pic where angles go.
maybe even more than a billion. If u scaled this up and put a google-earth-like model in it, that u couldnt even load the whole thing into 1 computer but copied voxels across computers as needed, u could zoom around the earth and it wouldnt have a loading delay. just low res

3 object types...
ball x y z color.
roundbell x y z stdDev strength
afbell with 3x3 too.
have some of each, sharing vars like x y z.
divide into sparse volumes, maybe cubes or spheres, that contain everything which touches them as its all an isosurface, and that guarantees it doesnt look diff shapes from diff positions. it will fit together.
get that working in 1 tile first, make sparse display later. make small part of skatepark and roll balls on it like monkeyball.
a few things to try:
** or: vec4 ray in and out of cube shaped volume, direction being stored in 1 float as which pixel index or as uv direction 2k by 4k. remember, gl_Position can be written at runtime per voxel, not stuck to polygon.
** or:paint cube volumes in order of descending distance of camera to nearest 3d point in them, as theyre convex.
** or: a grid of cubes and store log number of polygon models or voxel models, of that cube, displaying 
** uvsphere with vec4[256][128] as each vec4 is a voxel: x y z time12color12 each with expire time of 1 8 64 or 512 video frames. each uvsphere sorts byTime or byDistance to sphere center per angle similar to my statvoxel software does bydistance. bytime order 1 first, then 8 in background, then 64 .. 512 in backg of backg... so nearer stuff updates faster on screen. leafFunc(vec3,gluniformmodelparams) generates the isosurface, balls, etc the other 2 funcs by time or by distance, take 2 uvspheres and return 1 uvsphere merged. store a gl texture for each uvsphere. each uvsphere has a mintime as it ignored any voxels older than that. each uvsphere has a comparator of vec4 voxel. uvsphere..
++++ Each player has 1 main ball. play as massively multiplayer monkeyball on skayeparklike curves.
----- My game engine is a ~30kB html file that does all graphics by raytracing  a 3d sum-of-bellcurves based surface, and now i gotta split it into multiple gpu calls cuz i dont want it computing more than 1000 float32s of input at a time its slow to read gl textures. Rabbitholes!!

TODO: each UVSphere has 2 WebGLTexture's that are around 128x256 pixels and vec4 per pixel, a rectangle wrapped around a sphere of all 3d directions from a 3d point. I have this displaying and i can move around with a gamepad and mouse in it and edit the shapes I see through it. I have a working 3d editor of an isosurface. To update a uvsphere b, it reads its previous state and reads the state of another uvsphere c. Each pixel in c paints itself somewhere on b but which of the 2 incoming voxels (current and incoming) are chosen by b.comparator(voxelA,voxelB), such as b keeps whichever voxel in a certain direction is closer to the center of b.
*/



/***************************************************************
 * 1) Config
 ***************************************************************/

const opt = {
	type: 'bellsack_opt', //options {}
	//horizon: 60.0,					// how far to search for surfaces
	horizon: 60.0,					// how far to search for surfaces
	////isRaymarch: true,			 // variable-step or fixed-step
	isRaymarch: false,
	//raytraceStep: .2,
	raytraceStep: .1,
	//marchMaxSteps: 50,		 // maximum steps
	//marchMaxSteps: 200,		 // maximum steps
	//marchMaxSteps: 40,		 // maximum steps
	marchMaxSteps: 100,		 // maximum steps
	closeEnufToZero: 0.01, // tolerance for crossing
	//closeEnufToZero: 0.00001, // tolerance for crossing
	//circleBandPx: 1.5,			// ring thickness in screen px
	//circleBandPx: 7,
	circleBandPx: 4,
	//circleBandPx: 0,
	knobAngleBand: 0.15,		// how wide an angle for each knob (approx)
	//TOTAL_BELLS: 100000,
	TOTAL_BELLS: 10000,
	NEAR_TOTAL: 192,
	KNOB_COUNT: 5,
	//displayCenterForwardOfCam: 0,
	displayCenterForwardOfCam: 4,
	displayTerrain: true, //normal
	//displayTerrain: false, //test
	//removed balls 2025-4-2 cuz focusing on making UVSpheres sparse, then will finish balls. doBalls: true, //experimental as of 2025-3-28
	//doBalls:false,
	flipTurnX: false, //gamepad right joystick turns
	flipTurnY: true, //gamepad right joystick turns
	doPassA: true, //normal. paint isosurface onto cameraUvsphere.texA
	//doPassA: false, //test
	doPassB: true, //normal. paint cameraUvsphere.texA onto canvas
	//doPassB: false, //test
};

// region to place random bellcurves
//const WORLD_SIZE = 70;
const WORLD_SIZE = 30;
//const WORLD_SIZE = 40;
//const WORLD_SIZE = 25;

/***************************************************************
 * 2) Large set of bellcurves + a spatial grid
 ***************************************************************/

function pickRandomColor() {
	let r = Math.floor(128 + 128 * Math.random());
	let g = Math.floor(128 + 128 * Math.random());
	let b = Math.floor(128 + 128 * Math.random());
	return 'rgb('+r+','+g+','+b+')';
}

var xyzLenSq = xyz=>(xyz[0]**2 + xyz[1]**2 + xyz[2]**2);

//returns the max len of the 3 vectors.
var radius3x3ToRadius = radius3x3=>{
	return Math.sqrt(Math.max(xyzLenSq(radius3x3[0]),xyzLenSq(radius3x3[1]),xyzLenSq(radius3x3[2])))
};

//
class BellCurve {
	constructor(x, y, z, radiusOr3x3, strength, isSelected){
		this.x = x;
		this.y = y;
		this.z = z;
	if(typeof(radiusOr3x3)==='number'){
		this.type = 'bellsack_robell'; //weighted round 3d bellcurve
		this.radius = radiusOr3x3;
		this.radius3x3 = [[radiusOr3x3,0,0],[0,radiusOr3x3,0],[0,0,radiusOr3x3]];
	}else{
		this.type = 'bellsack_afbell'; //weighted affine transformed 3d bellcurve
		this.radius = radius3x3ToRadius(radiusOr3x3);
		this.radius3x3 = radiusOr3x3;
	}
		//this.radius = typeof(radiusOr3x3)==='number' ? radiusOr3x3 : radius3x3ToRadius(radiusOr3x3);
		this.strength = strength;
		// We'll store an integer color in [0..255] x 3 for convenience
		// or store it as random floats in [0..1], or just store a string and parse it in JS.
		// We'll store as random floats 0..1 so we can pass them to GPU if we want.
		// But for big sets we might skip it. For demonstration, let's store them anyway:
		this.colorR = 0.5 + 0.5 * Math.random();
		this.colorG = 0.5 + 0.5 * Math.random();
		this.colorB = 0.5 + 0.5 * Math.random();
	this.isSelected = !!isSelected;
	}
}

class SpatialGrid{
	constructor(cellSize){
		this.type = 'bellsack_spatialgrid_fixme';
		this.bellList = []; //FIXME remove this when get SpatialGrid working
	}
	insert(bc) {
		this.bellList.push(bc);
	}
	queryNearby(cx,cy,cz, range){
		let ret = [];
		let rangeSq = range**2;
		for(let bell of this.bellList){
			if((bell.x-cx)**2 + (bell.y-cy)**2 + (bell.z-cz)**2 <= rangeSq){
				ret.push(bell);
			}
		}
		return ret;
	}
}

let allBells=[];
let spatialGrid=null;

function buildWorld(){
	spatialGrid=new SpatialGrid(10);
	for(let i=0; i<opt.TOTAL_BELLS; i++){
		let x= (Math.random()-0.5)*WORLD_SIZE;
		let y= (Math.random()-0.5)*WORLD_SIZE;
		let z= (Math.random()-0.5)*WORLD_SIZE;
		let r= 0.2+ 0.3*Math.random();
		let s= Math.random()*2.0-1.0;
		let bc= new BellCurve(x,y,z,r,s,false);
		allBells.push(bc);
		spatialGrid.insert(bc);
	}
	console.log("Created", allBells.length, "bellcurves in", WORLD_SIZE, "^3 region");
}
buildWorld();

/***************************************************************
 * 3) WebGL Setup
 ***************************************************************/

let canvas = null, gl = null; //set these in window.onload

/***************************************************************
 * 4) compileShader & createProgram
 ***************************************************************/

function compileShader(gl, type, src){
	let s=gl.createShader(type);
	gl.shaderSource(s, src);
	gl.compileShader(s);
	if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
		console.error("Shader compile error:", gl.getShaderInfoLog(s));
		throw new Error("Shader compile fail");
	}
	return s;
}
function createProgram(gl, vsSrc, fsSrc){
	let vs= compileShader(gl, gl.VERTEX_SHADER, vsSrc);
	let fs= compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
	let p= gl.createProgram();
	gl.attachShader(p, vs);
	gl.attachShader(p, fs);
	gl.linkProgram(p);
	if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
		console.error("Program link error:", gl.getProgramInfoLog(p));
		throw new Error("Program link fail");
	}
	return p;
}

/***************************************************************
 * 5) Single-Pass FS: Raymarch + Billboard Circles + GPU knobs
 ***************************************************************/

const vsSource=`#version 300 es
in vec2 position;
out vec2 uv;
void main(){
	uv = position * 0.5 + 0.5;
	gl_Position = vec4(position, 0,1);
}
`;

// We'll define NEAR_TOTAL = opt.NEAR_TOTAL
// We'll do a ring search for each bell & also a local tangent-plane transform
// to see if it's near 1 of the 5 knob angles, coloring them differently.
const fsSource=`#version 300 es
precision highp float;

in vec2 uv;
out vec4 outColor;

uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform float horizon;
uniform float isRaymarch;
uniform float closeEnuf;
uniform float circleBandPx;
uniform float knobAngleBand;	// how large an angle difference to consider a knob
uniform int selectedBellI; //-1 if none. 0 to NEAR_TOTAL-1 if selected.

uniform vec3 bellPositions[${opt.NEAR_TOTAL}];
uniform float bellRadii[${opt.NEAR_TOTAL}];
uniform float bellStrengths[${opt.NEAR_TOTAL}];

// We'll do no per-bell color for now, just ring vs knob vs surface. 
// If you want each bell to have a random color, you'd need arrays for that.
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;

const int MARCH_MAX_STEPS = ${opt.marchMaxSteps};
const int NEAR_TOTAL = ${opt.NEAR_TOTAL};
const int KNOB_COUNT = ${opt.KNOB_COUNT};

float sumOfBellcurves(in vec3 p){
	float val=0.0;
	for(int i=0;i<NEAR_TOTAL;i++){
		vec3 d = p - bellPositions[i];
		float dist2= dot(d,d);
		val += bellStrengths[i]* exp(-dist2/(2.0 * bellRadii[i]* bellRadii[i]));
	}
	return val;
}

// step function
float stepFunction(float val, float lastVal){
	// if isRaymarch>0.5 => variable step
	float doVar= step(0.5, isRaymarch);
	float fixedSz = ${opt.raytraceStep}; //float fixedSz= 0.2;
	float raw= 2.0* abs(val);
	float minimal=0.001;
	float stDist= max(raw, minimal);
	return mix(fixedSz, stDist, doVar);
	
	//return abs(val);
	//return stDist;
	//return val; //FIXME
}

// find the implicit surface
float findSurface(in vec3 origin, in vec3 dir, out vec3 outPos){
	float t=0.0;
	float val=0.0, lastVal=0.0;
	bool found=false;
	for(int i=0;i<MARCH_MAX_STEPS;i++){
		if(t> horizon) break;
		vec3 p= origin + dir*t;
		val= sumOfBellcurves(p);
		if(i>0 && (sign(val)!=sign(lastVal) || abs(val)< closeEnuf)){
			found= true;
			// approximate crossing
			float dt= ( stepFunction(val,lastVal)*abs(lastVal) ) / ( abs(val)+ abs(lastVal)+ 1e-9 );
			t= t- stepFunction(val,lastVal)+ dt;
			outPos= origin + dir*t;
			break;
		}
		lastVal= val;
		float stSz= stepFunction(val,lastVal);
		t+= stSz;
	}
	if(!found) return 999999.0;
	return t;
}

// For billboard ring & knobs. 
// We'll store bestRingT, bestRingColor, etc.
struct RingResult {
	float t;
	vec3 color;
	int i; //index 0 to NEAR_TOTAL-1 of the ring
};

RingResult findNearestBillboard(in vec3 origin, in vec3 dir){
	RingResult rr;
	rr.t= 999999.0;
	rr.color= vec3(0.0);
	rr.i = -2;

	// We'll define a stable planeRight, planeUp for the knob angles
	// We'll pick worldUp= (0,1,0) unless dot(worldUp, camForward)>0.9 => pick (1,0,0).
	vec3 worldUp= vec3(0,1,0);
	float d= abs(dot(worldUp, normalize(camForward)));
	if(d>0.9){
		worldUp= vec3(1,0,0);
	}
	vec3 planeRight= normalize( cross(camForward, worldUp) );
	vec3 planeUp	 = normalize( cross(planeRight, camForward) );

	for(int i=0; i<NEAR_TOTAL; i++){
		// skip if it's dummy
		if(bellPositions[i].x>9000.0) continue;
		// plane intersection
		float denom= dot(dir, normalize(camForward));
		if(abs(denom)<1e-9) continue;
		float tC= dot( (bellPositions[i]-origin), normalize(camForward))/ denom;
		if(tC<0.01 || tC> horizon) continue;

		// dist3D from the plane point to bell center
		vec3 planePt= origin + dir* tC;
		float distCenter= distance(planePt, bellPositions[i]);

		// approximate how many px is "1 px" at distance tC
		float pxScale= 0.003 * tC;
		float band= circleBandPx * pxScale;

		// ring check
		float ringDiff= abs(distCenter - bellRadii[i]);
		if(ringDiff < band){
			// we have found a ring. Possibly a knob.
			// local 2D coords in plane: localX= dot(planeRight, (planePt-center)), localY= dot(planeUp, (planePt-center))
			vec3 localVec= planePt - bellPositions[i];
			float localX= dot(localVec, planeRight);
			float localY= dot(localVec, planeUp);
			float angle= atan(localY, localX); // in [-pi, pi]
			if(angle<0.0) angle += 6.2831853; // so [0..2pi)
			float knobAngle= 6.2831853 / float(KNOB_COUNT); // 2pi/5 => ~1.2566
			// find which knob index is closest:
			float kFloat= angle / knobAngle; // e.g. 2.2 => knob #2
			float kRound= floor( kFloat+0.5 );
			float angleDiff= abs( kFloat - kRound );
			// if angleDiff < knobAngleBand? We do a subband. e.g. 0.2 => yes
			float angleThresh= knobAngleBand; // e.g. 0.2 or 0.15
			if(angleDiff < angleThresh){
				// color the knob
				float knobIdx= mod( kRound, float(KNOB_COUNT) );
				// map 0->red,1->green,2->blue,3->white,4->black for example
				// We'll do a quick if-else or a small array. For brevity, do if else:
				vec3 knobColor;
				if(knobIdx<0.5) knobColor= vec3(1,0,0);
				else if(knobIdx<1.5) knobColor= vec3(0,1,0);
				else if(knobIdx<2.5) knobColor= vec3(0,0,1);
				else if(knobIdx<3.5) knobColor= vec3(1,1,1);
				else knobColor= vec3(0,0,0);
				// pick that
				if(tC< rr.t){
					rr.t= tC;
					rr.color= knobColor;
			rr.i = i;
				}
			} else {
				// it's ring but not a knob => e.g. gray
				if(tC< rr.t){
					rr.t= tC;
			rr.color= vec3(0.6,0.6,0.6);
			rr.i = i;
				}
			}
		}
	}
	return rr;
}

// shading the surface
vec3 shadeSurface(in vec3 p){
	float eps= 0.001;
	float base= sumOfBellcurves(p);
	vec3 grad= vec3(0);
	for(int k=0;k<3;k++){
		vec3 offset= vec3(0);
		offset[k]= eps;
		float val2= sumOfBellcurves(p+ offset);
		grad[k]= (val2 - base)/ eps;
	}
	vec3 N= normalize(grad);
	vec3 L= normalize(vec3(1,1,1));
	float bright= 1.8/(1.0+ exp(-2.5* dot(N,L)));
	float weirdBright = .5+.5*sin(bright*10.);
	float wx= dot(N,vec3(1,0,0))*0.5 +0.5;
	float wy= dot(N,vec3(0,1,0))*0.5 +0.5;
	float wz= dot(N,vec3(0,0,1))*0.5 +0.5;
	float sumw= wx+wy+wz +1e-9;
	vec3 angleColor= (color1*wx + color2*wy + color3*wz)/ sumw;
	//return angleColor* bright;
	//return bright;
	//return angleColor;
	//return vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	//float smul = 8.;
	float smul = 2.5;
	vec3 stable3dColor = vec3(.5+.5*sin(p[0]*smul),.5+.5*sin(p[1]*smul),.5+.5*sin(p[2]*smul));
	vec3 abc = vec3(bright)*-.31+angleColor*.54+weirdBright*.54;
	return abc*.03+stable3dColor*.7+bright*-.3;
}

//This main() is opt.doPassB
void main(){

		//outColor= vec4(0.,.3,0.,1.0);
		//commentedout 2025-4-2-1157aET but it didnt change anything, still the cameraUvsphere is displayed around.
		float pi = 3.1415926535897932384626433832795;
		// Keep negative signs so your old orientation/controls stay consistent
		float theta = -2.0 * pi * uv.x; // range ~ [-2π..0], if uv.x in [0..1]
		float phi	 = -pi * uv.y;			 // range ~ [-π..0],	if uv.y in [0..1]

		// Convert spherical coords (theta, phi) to Cartesian
		// Add a small sign flip on cos(phi) so center matches your prior camera
		vec3 dir = vec3(
				sin(phi)*cos(theta),
				-cos(phi),
				sin(phi)*sin(theta)
		);

		// 1) find ring
		RingResult rRing= findNearestBillboard(camPos, dir);

		// 2) find surface
		vec3 surfPos= vec3(0);
		float tSurf= findSurface(camPos, dir, surfPos);

		// pick whichever is near
		if(rRing.t < tSurf){
			vec3 color = rRing.color;
			outColor= vec4(color,1.0);
		}else if(tSurf< 999999.0){
			vec3 c = shadeSurface(surfPos);
			outColor= vec4(c,1.0);
		} else {
			outColor= vec4(0.5,0.5,0.5,1.0);
		}
}
`;

/***************************************************************
 * 6) Create & link
 ***************************************************************/


//these vars set in createAndLink() which is delayed until window.onload. Reorganizing this messy code, too many global vars.
let vs=null, fs=null, program=null, loc_bellPos=null, loc_bellRad=null, loc_bellStr=null, loc_camPos=null;
let loc_camFwd=null, loc_camRight=null, loc_camUp=null, loc_horizon=null, loc_isRay=null, loc_closeE=null;
let loc_circPx=null, loc_knobAng=null, loc_selectedBellI=null, loc_col1=null, loc_col2=null, loc_col3=null;
let quadVBO=null, quadData=null, vao=null, posLoc=null;

let createAndLink = ()=>{
	vs=compileShader(gl,gl.VERTEX_SHADER,vsSource);
	fs=compileShader(gl,gl.FRAGMENT_SHADER,fsSource);
	program= gl.createProgram();
	gl.attachShader(program,vs);
	gl.attachShader(program,fs);
	gl.linkProgram(program);
	if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
		console.error("link err:",gl.getProgramInfoLog(program));
		throw new Error("link fail");
	}
	gl.useProgram(program);

	// uniform locs
	loc_bellPos = gl.getUniformLocation(program,"bellPositions");
	loc_bellRad = gl.getUniformLocation(program,"bellRadii");
	loc_bellStr = gl.getUniformLocation(program,"bellStrengths");

	loc_camPos	 = gl.getUniformLocation(program,"camPos");
	loc_camFwd	 = gl.getUniformLocation(program,"camForward");
	loc_camRight = gl.getUniformLocation(program,"camRight");
	loc_camUp		= gl.getUniformLocation(program,"camUp");

	loc_horizon	= gl.getUniformLocation(program,"horizon");
	loc_isRay		= gl.getUniformLocation(program,"isRaymarch");
	loc_closeE	 = gl.getUniformLocation(program,"closeEnuf");
	loc_circPx	 = gl.getUniformLocation(program,"circleBandPx");
	loc_knobAng	= gl.getUniformLocation(program,"knobAngleBand");
	loc_selectedBellI	 = gl.getUniformLocation(program,"selectedBellI");

	loc_col1		 = gl.getUniformLocation(program,"color1");
	loc_col2		 = gl.getUniformLocation(program,"color2");
	loc_col3		 = gl.getUniformLocation(program,"color3");

	// VAO
	quadVBO= gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER,quadVBO);
	quadData= new Float32Array([
		-1,-1, 1,-1, -1,1,
		-1,1, 1,-1, 1,1
	]);
	gl.bufferData(gl.ARRAY_BUFFER,quadData,gl.STATIC_DRAW);

	vao= gl.createVertexArray();
	gl.bindVertexArray(vao);
	posLoc= gl.getAttribLocation(program,"position");
	gl.enableVertexAttribArray(posLoc);
	gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
	gl.bindVertexArray(null);
}

/***************************************************************
 * 7) Searching up to NEAR_TOTAL
 ***************************************************************/

let nearBells=[];
let selectedBellI = -1; //index in nearBells, copied into GPU for display
let gpuPos= new Float32Array(opt.NEAR_TOTAL*3);
let gpuRad= new Float32Array(opt.NEAR_TOTAL);
let gpuStr= new Float32Array(opt.NEAR_TOTAL);

function updateNearBells(){
	let rng= 200;
	let cpx= camPos[0], cpy= camPos[1], cpz= camPos[2];
	if(opt.displayCenterForwardOfCam){
	let fwd = calculateForwardVector(camQ);
	cpx += fwd[0]*opt.displayCenterForwardOfCam
	cpy += fwd[1]*opt.displayCenterForwardOfCam;
	cpz += fwd[2]*opt.displayCenterForwardOfCam;
	}
	let cands= spatialGrid.queryNearby(cpx,cpy,cpz, rng);
	//FIXME 2025-3-27 this is returning all 100k bells cuz cell size is 10.
	cands.sort((a,b)=>{
		let da=(a.x-cpx)**2+(a.y-cpy)**2+(a.z-cpz)**2;
		let db=(b.x-cpx)**2+(b.y-cpy)**2+(b.z-cpz)**2;
		return da-db;
	});
	nearBells= cands.slice(0,opt.NEAR_TOTAL);
	//let prev_selectedBellI = selectedBellI;
	selectedBellI = -1; //none
	for(let i=0;i<nearBells.length; i++){
		gpuPos[i*3+0]= nearBells[i].x;
		gpuPos[i*3+1]= nearBells[i].y;
		gpuPos[i*3+2]= nearBells[i].z;
		gpuRad[i]		= nearBells[i].radius;
		gpuStr[i]		= nearBells[i].strength;
	if(nearBells[i].isSelected){
		if(selectedBellI != -1){
			throw new Error('Found second selected bell. max 1.');
		}
		selectedBellI = i;
	}
	}
	//if(prev_selectedBellI != selectedBellI) console.log('selectedBellI='+selectedBellI);
	console.log('selectedBellI='+selectedBellI);
}

/***************************************************************
 * 8) Camera + Gamepad
 ***************************************************************/

let camPos=[0,0,5];
let camQ	=[0,0,0,1];

function updateFromGamepad(dt){
	let gps= navigator.getGamepads();
	if(!gps) return;
	let gp= gps[0];
	if(!gp) return;
	let lx= gp.axes[0], ly= gp.axes[1];
	let rx= gp.axes[2], ry= gp.axes[3];
	const dead= 0.06;
	//const dead= 0; //FIXME
	let lLen= Math.hypot(lx,ly);
	if(lLen>dead){
		let leftover= lLen- dead;
		lx*= leftover/lLen;
		ly*= leftover/lLen;
	} else { lx=0; ly=0; }
	let rLen= Math.hypot(rx,ry);
	if(rLen>dead){
		let leftover2= rLen- dead;
		rx*= leftover2/rLen;
		ry*= leftover2/rLen;
	} else { rx=0; ry=0; }
	if(opt.flipTurnY) ry *= -1; //flip y in turning joystick
	let turnSpd = 2;
	rx *= turnSpd;
	ry *= turnSpd;
	rotateCamera(rx,ry,dt);
	
	if(opt.flipTurnX) rx *= 1; //flip x in turning joystick

	let fwdVal= gp.buttons[7]?.value - gp.buttons[6]?.value;
	let upDown= -ly;
	let leftRight= lx;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));
	//let moveSpd=2.0;
	let moveSpd=2.0;
	camPos[0]+= (fwd[0]*fwdVal + upv[0]*upDown + rig[0]*leftRight)* moveSpd* dt;
	camPos[1]+= (fwd[1]*fwdVal + upv[1]*upDown + rig[1]*leftRight)* moveSpd* dt;
	camPos[2]+= (fwd[2]*fwdVal + upv[2]*upDown + rig[2]*leftRight)* moveSpd* dt;
}

function rotateCamera(rx, ry, dt){
	const threshold= 0.001;
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));

	let combined=[0,0,0,1];
	if(Math.abs(rx)> threshold){
		let yawAngle= -rx*2.0* dt;
		let yawQ= createQuaternion(upv,yawAngle);
		combined= multiplyQuaternions(yawQ,combined);
	}
	if(Math.abs(ry)> threshold){
		let pitchAngle= -ry*2.0* dt;
		let pitchQ= createQuaternion(rig,pitchAngle);
		combined= multiplyQuaternions(combined,pitchQ);
	}
	camQ= multiplyQuaternions(combined, camQ);
	camQ= normalizeQuaternion(camQ);
}

/***************************************************************
 * 9) CPU overlay of ring+knobs is removed. 
 *		But user wants to “click + drag” to update the 5 numbers per bell?
 *		That now means we have no 2D or “visible overlay.” 
 *		We'll do a trivial approach:
 *		If user clicks => we do a “nearest billboard ring.” 
 *		Then if it’s near a knob => store which bell & knob. 
 *		Drag changes that param.	But we cannot see them, 
 *		because we removed the CPU overlay.
 ***************************************************************/

// For demonstration, we'll still handle mouse so user can drag (like a big invisible UI).
// We'll do the same findKnobAt approach in JS, but that means we replicate the plane intersection logic in JS 
// or we do readPixels but that’s more complicated. 
// We'll replicate the plane logic + local tangent-plane transform here. 
// If you truly want *perfect* matching, you'd do a readback from a picking buffer or do an extra pass, but that’s advanced.

// We'll do a minimal approach, scanning the same nearBells.	
// If found ring & knob => we set dragState. Then as user drags => we adjust radius, or strength, or x,y,z, etc.

var bootEventsOnCanvas = ()=>{
	let dragState=null;
	let mousedown = e=>{
		let rect= canvas.getBoundingClientRect();
		let mx= e.clientX- rect.left;
		//FIXME findKnobAt is flipped in y, +y is up. let my= e.clientY- rect.top;
		//let my= rect.y-e.clientY; //cuz flipped. FIXME
		let my= e.clientY- rect.top;
		my = rect.height-1-my; //cuz flipped. FIXME.
		let k= findKnobAt(mx,my);
		if(k){
		for(let bc of allBells) bc.isSelected = false; //unselect all
			//if(dragState) dragState.bc.isSelected = false; //unselect prev selection
			dragState={
				bc: k.bc,
				knobIndex: k.knobIndex,
				startY: my,
				startVal: getParamVal(k.bc,k.knobIndex)
			};
		dragState.bc.isSelected = true; //select next
		}
	};
	canvas.addEventListener("mousedown", mousedown);
	canvas.addEventListener("mousemove", e=>{
		//mousedown(e); //FIXME
		if(!dragState) return;
		let rect= canvas.getBoundingClientRect();
		let my= e.clientY-rect.top; //FIXME
		my = rect.height-1-my; //FIXME cuz flipped y between cpu and gpu
		let dy= my- dragState.startY;
		let newVal= dragState.startVal+ (-dy*0.02);
		setParamVal(dragState.bc, dragState.knobIndex, newVal);
	});
	canvas.addEventListener("mouseup", e=>{
		for(let bc of allBells) bc.isSelected = false; //unselect all
	});
	canvas.addEventListener("mouseup", e=>{
		dragState=null;
	});
};

var selectedKnob = null;

// We replicate the plane logic for ring & knob detection in JS. 
// See the approach used in the fragment code, but we do it once for every bell. 
// Then we pick whichever is closest in tC. If ringDiff < band => we also do knob angle check.
function findKnobAt(mx,my){
	console.log('findKnobAt mx='+mx+' my='+my);
	let camForward = calculateForwardVector(camQ);
	let camUp= calculateUpVector(camQ);
	let camRight= cross(camForward, camUp);
	camRight = normalize(camRight);
	console.log('camForward='+camForward);

	// transform pixel -> st => [-1..1], st => build ray
	let width= canvas.width, height= canvas.height;
	//let stx= (mx/(float(width))) *2.0 -1.0; 
	let stx= (mx/width) *2.0 -1.0; 
	//let sty= (my/(float(height)))*2.0 -1.0;
	let sty= (my/height)*2.0 -1.0;
	// but we are in JS, so do
	let stxF= (mx/width)*2 -1;
	let styF= (my/height)*2-1;
	let dir= normalize( vecAdd( camForward, vecAdd( scale(camRight,stxF), scale(camUp,styF) ) ) );

	// define plane normal= camForward
	let n= normalize(camForward);
	let bestT= 999999;
	let bestBell=null;
	let bestKnob=-1;

	// define stable planeRight, planeUp
	let wUp= [0,1,0];
	let d= Math.abs(dot(wUp, n));
	if(d>0.9){
		wUp= [1,0,0];
	}
	let pRight= normalize( cross(n, wUp) );
	let pUp	 = normalize( cross(pRight, n) );

	for(let i=0; i< nearBells.length; i++){
		let bc= nearBells[i];
		if(bc.x>9000) continue;
		let denom= dot(dir, n);
		if(Math.abs(denom)<1e-9) continue;
		let c= [bc.x, bc.y, bc.z];
		let diff= vecSub(c, camPos);
		let tC= dot(diff,n)/ denom;
		
	
	
	
	//if(tC<0.01 || tC> opt.horizon) continue; //commentedout 2025-3-28 for testing
	if(tC<0.01 || tC> opt.horizon) continue;
	
	
	
	
		// planePt
		let planePt= vecAdd( camPos, scale(dir, tC) );
		let distC= length( vecSub(planePt, c) );
		// ring diff
		let pxScale= 0.003* tC;
		let band= opt.circleBandPx* pxScale;
		let ringDiff= Math.abs(distC- bc.radius);
		if(ringDiff < band){
			// might be a knob
			// local2D
			let localVec= vecSub(planePt, c);
			let localX= dot(localVec, pRight);
			let localY= dot(localVec, pUp);
			let angle= Math.atan2(localY, localX);
			if(angle<0) angle+= 2*Math.PI;
			let knobAng= 2*Math.PI/ opt.KNOB_COUNT; 
			let kFloat= angle/ knobAng;
			let kRound= Math.floor(kFloat+0.5);
			let angleDiff= Math.abs( kFloat- kRound );
			if(angleDiff < opt.knobAngleBand){
				// it's a knob
				if(tC< bestT){
					bestT= tC;
					bestBell= bc;
					bestKnob= kRound % opt.KNOB_COUNT;
				}
			} else {
				// ring
				// maybe store a separate best ring, but user only wants to drag knobs.
				// so if it’s ring only => no knob => no drag
				// skip
			}
		}
	}
	if(!bestBell) return null;
	selectedKnob={bc: bestBell, knobIndex: bestKnob};
	console.log('selectedKnob='+JSON.stringify(selectedKnob));
	setParamVal(selectedKnob.bc, selectedKnob.knobIndex,
	getParamVal(selectedKnob.bc, selectedKnob.knobIndex)+.001);
	return selectedKnob;
}

// minimal vector utilities in JS:
function vecAdd(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];}
function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];}
function dot(a,b){ return a[0]*b[0]+ a[1]*b[1]+ a[2]*b[2];}
function cross(a,b){
	return [
		a[1]*b[2]- a[2]*b[1],
		a[2]*b[0]- a[0]*b[2],
		a[0]*b[1]- a[1]*b[0]
	];
}
function scale(a,s){return [a[0]*s, a[1]*s, a[2]*s];}
function length(a){ return Math.hypot(a[0],a[1],a[2]);}
function normalize(a){
	let L= length(a);
	if(L<1e-9) return [0,0,0];
	return [a[0]/L, a[1]/L, a[2]/L];
}

/***************************************************************
 * 11) Editing the 5 knobs means x,y,z,radius,str
 ***************************************************************/

function getParamVal(bc,k){
	switch(k){
		case 0: return bc.x;
		case 1: return bc.y;
		case 2: return bc.z;
		case 3: return bc.radius;
		case 4: return bc.strength;
	}
}
function setParamVal(bc,k,v){
	console.log('setParamVal k='+k+' v='+v+' bc='+bc);
	switch(k){
		case 0: bc.x= v; break;
		case 1: bc.y= v; break;
		case 2: bc.z= v; break;
		case 3: bc.radius= Math.max(0.01,v); break;
		case 4: bc.strength= v; break;
	}
}

/***************************************************************
 * 12) Render loop
 ***************************************************************/

function updateUVSpheresSparsely(){
	// Invoke the GPU-based update each frame. This does no CPU voxel storage.
	cameraUvsphere.updateFromBalls(allBalls);
	console.log('TODO updateUVSpheresSparsely');
};

//1) Add a second fragment shader + Program for drawing the sphere to the canvas
//In JavaScript near your other shaders, define something like:
const vsFullQuad = `#version 300 es
//in mat3 rotate3x3;
//uniform vec3 centerPosition;
uniform mat3 rotate3x3;
in vec2 position; //position in some affine transform of 2d canvas coordinates
//TODO Transform vec2 position by the usual perspective calculation, to a unit vec3 as a 3d angle,
//then rotate that, then back to uv
//out vec2 uv;
out vec3 dir;              // We want to pass a 3D direction to FS
//This main() is opt.doPassA
void main(){
	//vec3 rotatedPosition = position*rotate3x3;
	//uv = (position * 0.5) + 0.5;	// map [-1..1] to [0..1]
	//gl_Position = vec4(position+vec2(.21,.52), 0, 1);
	//gl_Position = vec4(position, 0, 1);+  // 1) create a 3D vector from 2D: 
	//gl_Position = vec4(centerPosition, 1);
	gl_Position = vec4(position, 0, 1); //is this affine transformed canvas 2d coordinates?
	
	//    e.g. (x,y,1) if you want a pinhole perspective
	vec3 base = vec3(position, 1.0); 

	// 2) multiply by your rotate3x3 uniform
	vec3 rotated = rotate3x3 * base;

	// Optionally, we can store that as dir for the fragment shader:
	dir = normalize(rotated); // pass a direction?
}`;

// Then build a small Program for it:
let progDrawSphere=null;
let loc_drawSphere_sphereTex=null;

function throwErrorOnGLError(gl) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
        const errorString = {
            [gl.INVALID_ENUM]: "INVALID_ENUM",
            [gl.INVALID_VALUE]: "INVALID_VALUE",
            [gl.INVALID_OPERATION]: "INVALID_OPERATION",
            [gl.INVALID_FRAMEBUFFER_OPERATION]: "INVALID_FRAMEBUFFER_OPERATION",
            [gl.OUT_OF_MEMORY]: "OUT_OF_MEMORY",
            [gl.CONTEXT_LOST_WEBGL]: "CONTEXT_LOST_WEBGL"
        }[error] || "Unknown Error";
        
        throw new Error("WebGL Error: " + errorString);
    }
}


function buildDrawSphereProg(){
		let vs = compileShader(gl, gl.VERTEX_SHADER, vsFullQuad);
		let fs = compileShader(gl, gl.FRAGMENT_SHADER, fsDrawSphereToCanvas);
		let p	= gl.createProgram();
		gl.attachShader(p, vs);
		gl.attachShader(p, fs);
		gl.linkProgram(p);
		if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
				console.error("DrawSphereProgram link error:", gl.getProgramInfoLog(p));
				throw new Error("Program link fail");
		}
		// we can detach+delete vs,fs after linking
		gl.deleteShader(vs);
		gl.deleteShader(fs);

		// get uniform loc
		let loc_sphereTex = gl.getUniformLocation(p, "sphereTex");
		let loc_timeUint12 = gl.getUniformLocation(p, "timeUint12");
		
		let loc_rotate3x3 = gl.getUniformLocation(p, "rotate3x3");

		// build a VAO for the full screen quad (like you already do)
		let vbo = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
		const quadData = new Float32Array([
				-1,-1,	1,-1, -1, 1,
				-1, 1,	1,-1,	1, 1
		]);
		gl.bufferData(gl.ARRAY_BUFFER, quadData, gl.STATIC_DRAW);

		let vao = gl.createVertexArray();
		gl.bindVertexArray(vao);
		let posLoc = gl.getAttribLocation(p, "position");
		gl.enableVertexAttribArray(posLoc);
		gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
		gl.bindVertexArray(null);

		return {
				program: p,
				vao: vao,
				loc_sphereTex: loc_sphereTex,
				loc_rotate3x3: loc_rotate3x3,
				loc_timeUint12: loc_timeUint12,
		};
}

const fsDrawSphereToCanvas = `#version 300 es
precision highp float;

//in vec2 uv;						// [0..1] from the vertex shader
in vec3 dir; //3d direction of length 1.
out vec4 outColor;
uniform float timeUint12;  //range 0 to 4095, normally in units of video frames since it started
uniform sampler2D sphereTex; // the cameraUvsphere.texA
// If you need gamma-correction or other adjustments, do them here. 
// For now, just sample directly:
/*void main(){
		outColor = texture(sphereTex, uv);
}*/
void main(){
	// Convert direction vector to spherical coordinates
	float pi = 3.14159265359;
    float u = 0.5 + atan(dir.z, dir.x) / (2.0 * pi);
    //float v = 0.5 - asin(dir.y) / 3.14159265359;
	float v = 0.5 - atan(dir.y, sqrt(dir.x * dir.x + dir.z * dir.z)) / pi;
	vec2 uv = vec2(u, v);
	
	vec4 texColor = texture(sphereTex, uv);
	//texColor.x += mod(timeUint12,30.)/30.; //make it change amount of red over time as a test
	if (int(gl_FragCoord.x) % 16 == 0 && int(gl_FragCoord.y) % 2 == 0) {
		outColor = vec4(0.0, 0.0, 1.0, 1.0);	// Make every other pixel blue
	} else {
		outColor = texColor;	// Original texture color
	}
}
`;

var drawSphereProg = null;
var fbo = null; //Global framebuffer

// Then each frame, or whenever your camera rotates, build a mat3:
function buildRotate3x3(camQ){
	let camForward = calculateForwardVector(camQ);	
	let camUp = calculateUpVector(camQ);
	let camRight = cross(camForward, camUp);
	camRight = normalize(camRight);
    /*// produce a 3×3 from e.g. your (camFwd, camRight, camUp)
    // or build from angles
    return new Float32Array([
        // r00, r01, r02,
        // r10, r11, r12,
        // r20, r21, r22
    ]);*/
	// Construct the rotation matrix columns from the camera basis vectors.
    // Note: WebGL expects column-major order for matrices.
    return new Float32Array([
        camRight[0], camUp[0], -camForward[0], // Column 1
        camRight[1], camUp[1], -camForward[1], // Column 2
        camRight[2], camUp[2], -camForward[2]  // Column 3
    ]);
}

var timeUint12 = 0;

function renderLoop(t){
	let dt= 0.016; // approximate
	timeUint12 = (timeUint12+1)&0xfff; //in units of video frames. Use this with colorUint12/4096 in fourth number in a vec4.
	if(!drawSphereProg){
	
		//must call this so vec4 (float[4]) can be use as input texture. as output texture u dont need it.
		var ext = gl.getExtension('EXT_color_buffer_float'); //load extension
		if(ext) console.log('Loaded EXT_color_buffer_float');
		else consoleerror('FAIL EXT_color_buffer_float');
	
		if(cameraUvsphere) Err('already had a cameraUvsphere');
		//if (!cameraUvsphere){
		// Just pick some size for demonstration; you can change as needed.
		//cameraUvsphere = new UVSphere(gl, [0, 0, 0], 128, 256, 0);
		//let h = 32;
		//let w = 64;
		let h = 128;
		let w = 256;
		let floats = new Float32Array(h*w*4);
		for(let i=0; i<floats.length; i++){ //test data to start, so can see SOMETHING when it boots, todo
			floats[i] = Math.random(); //FIXME
		}
		cameraUvsphere = new UVSphere(gl, [0, 0, 0], h, w, 0, floats);
		//cameraUvsphere = new UVSphere(gl, [0, 0, 0], canvas.height, canvas.width, 0);
		cameraUvsphere.isCamera = true;
		uvspheres.push(cameraUvsphere);
		//}
	
		/*2025-4-2-2pET when brought back fbo.
		Created 10000 bellcurves in 30 ^3 region bellsack069.html:189:10
		selectedBellI=-1 bellsack069.html:582:10
		Uncaught Error: WebGL Error: INVALID_FRAMEBUFFER_OPERATION
			throwErrorOnGLError file:///S:/q/q52x/w/gptBellRaymarch3d/bellsack069.html:913
			renderLoop file:///S:/q/q52x/w/gptBellRaymarch3d/bellsack069.html:1113
		bellsack069.html:913:15
		WebGL warning: clear: Framebuffer not complete. (status: 0x8cd6) COLOR_ATTACHMENT0: Attachment has an effective format of RGBA32F, which is not renderable.
		WebGL warning: clear: Framebuffer must be complete.
		WebGL warning: drawArraysInstanced: Framebuffer not complete. (status: 0x8cd6) COLOR_ATTACHMENT0: Attachment has an effective format of RGBA32F, which is not renderable.
		WebGL warning: drawArraysInstanced: Framebuffer must be complete.
		WebGL warning: clear: Framebuffer not complete. (status: 0x8cd6) COLOR_ATTACHMENT0: Attachment has an effective format of RGBA32F, which is not renderable.
		WebGL warning: clear: Framebuffer must be complete. 
		// Initialize the global framebuffer
		fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		// Attach the first texture you're going to use
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, cameraUvsphere.texA, 0);
		*/
		// Initialize the global framebuffer
		fbo = gl.createFramebuffer();
		throwErrorOnGLError(gl);
		
		// Check framebuffer status after setup
		if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
			console.error("Framebuffer is not complete");
			throw new Error("Framebuffer setup failed");
		}else{
			console.log('fbo framebuffer complete');
		}
		
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		throwErrorOnGLError(gl);
		// Attach the first texture you're going to use
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, cameraUvsphere.texA, 0);
		throwErrorOnGLError(gl);
			
		drawSphereProg = buildDrawSphereProg();
		throwErrorOnGLError(gl);
	}
	//TODO use drawSphereProg.
	//2 passes, first one to fill in cameraUvsphere and the second to display parts of it on the rectangle canvas.
	
	updateFromGamepad(dt);
	//updateUVSpheresSparsely(); //FIXME this is just doing .flip() but other code isnt filled in. was making it flash 2025-4-2.
	updateNearBells();
	//if(opt.doBalls){
	//	updateBalls(dt);
	//}

	// camera basis
	let fwd= calculateForwardVector(camQ);
	let upv= calculateUpVector(camQ);
	let rig= cross(fwd, upv); rig= normalize(rig);
	upv= normalize(cross(rig, fwd));
	
	
	/*GPT-4.5 thinks this is the problem causing framebuffer not ready in doPassA 2025-4-2-310pET[[[
		Your current WebGL error:

		"WebGL warning: drawArraysInstanced: Texture level 0 would be read by TEXTURE_2D unit 0, but written by framebuffer attachment COLOR_ATTACHMENT0, which would be illegal feedback."

		happens because you're attempting to simultaneously read from and write to the same texture (cameraUvsphere.texA). WebGL explicitly forbids this because it creates undefined behavior (a feedback loop).

		Why is this happening?
		In your current setup, you're performing two passes:

		First Pass (pass A):
		Writes (renders) into cameraUvsphere.texA by attaching it to the framebuffer (fbo) as COLOR_ATTACHMENT0.

		Second Pass (pass B):
		Reads (samples) from cameraUvsphere.texA to render it to the default framebuffer (the canvas).

		The problem occurs because after enabling both passes dynamically, the framebuffer with cameraUvsphere.texA attached as a color buffer remains bound when you try to read from the same texture again in a subsequent draw call. This is exactly the condition WebGL forbids.

		How to fix it:
		You must unbind cameraUvsphere.texA from the framebuffer (fbo) before pass B tries to sample it. In other words, after you've finished writing to cameraUvsphere.texA in pass A, unbind it completely from the framebuffer before reading it.

		Add this after your first pass draw call and before the second pass:

		javascript
		Copy
		Edit
		// after pass A drawing...
		gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind framebuffer after rendering to texture
	]]]
	*/
	if(opt.doPassA){
		/*it works but strangley stopped giving the framebuffer not ready error when just checked this.
		var ext = gl.getExtension('EXT_color_buffer_float');
		if(!ext){
			console.error('Failed to enable EXT_color_buffer_float extension');
		}else{
			console.log('OK EXT_color_buffer_float');
		}*/
		// First Pass: Render to cameraUvsphere.texA
		gl.viewport(0, 0, cameraUvsphere.width, cameraUvsphere.height);
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		gl.clearColor(0, 0, 0, 1);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		gl.useProgram(program); // Use the main program that handles raymarching or similar effects
		
		// FIX: Unbind texture (cameraUvsphere.texA) from any active texture unit
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, null);

		// Set uniforms for the first pass
		gl.uniform3fv(loc_bellPos, gpuPos);
		gl.uniform1fv(loc_bellRad, gpuRad);
		gl.uniform1fv(loc_bellStr, gpuStr);
		gl.uniform3f(loc_camPos, camPos[0], camPos[1], camPos[2]);
		gl.uniform3f(loc_camFwd, fwd[0], fwd[1], fwd[2]);
		gl.uniform3f(loc_camRight, rig[0], rig[1], rig[2]);
		gl.uniform3f(loc_camUp, upv[0], upv[1], upv[2]);
		gl.uniform1f(loc_horizon, opt.horizon);
		gl.uniform1f(loc_isRay, (opt.isRaymarch ? 1.0 : 0.0));
		gl.uniform1f(loc_closeE, opt.closeEnufToZero);
		gl.uniform1f(loc_circPx, opt.circleBandPx);
		gl.uniform1f(loc_knobAng, opt.knobAngleBand);
		gl.uniform1i(loc_selectedBellI, selectedBellI);
		gl.uniform3fv(loc_col1, [1.0, 0.2, 0.2]);
		gl.uniform3fv(loc_col2, [0.2, 1.0, 0.2]);
		gl.uniform3fv(loc_col3, [0.2, 0.2, 1.0]);

		// Draw scene into cameraUvsphere's texture
		gl.bindVertexArray(vao);
		gl.drawArrays(gl.TRIANGLES, 0, 6);
		gl.bindVertexArray(null);
		
		//Unbind framebuffer after rendering to texture, so its not an input and output at same time
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}
	


	if(opt.doPassB){
		// Second Pass: Draw from cameraUvsphere.texA to canvas
		//gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Bind to default framebuffer
		gl.viewport(0, 0, canvas.width, canvas.height);
		gl.clear(gl.COLOR_BUFFER_BIT);
		let R = buildRotate3x3(camQ);
		gl.useProgram(drawSphereProg.program); // Use the program for drawing the sphere texture
		gl.uniformMatrix3fv(drawSphereProg.loc_rotate3x3, false, R);
		
		gl.uniform1f(drawSphereProg.loc_timeUint12, timeUint12);
		
		throwErrorOnGLError(gl);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, cameraUvsphere.texA);
		gl.uniform1i(drawSphereProg.loc_sphereTex, 0);

		// Draw the full-screen quad to the canvas
		gl.bindVertexArray(drawSphereProg.vao);
		gl.drawArrays(gl.TRIANGLES, 0, 6);
		//gl.bindVertexArray(null);
	}

	// Request the next frame
	//requestAnimationFrame(renderLoop);

	
	/*
	// set uniforms
	gl.viewport(0,0, canvas.width, canvas.height);
	gl.clearColor(0,0,0,1);
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.useProgram(program);

	gl.uniform3fv(loc_bellPos, gpuPos);
	gl.uniform1fv(loc_bellRad, gpuRad);
	gl.uniform1fv(loc_bellStr, gpuStr);

	gl.uniform3f(loc_camPos, camPos[0], camPos[1], camPos[2]);
	gl.uniform3f(loc_camFwd, fwd[0], fwd[1], fwd[2]);
	gl.uniform3f(loc_camRight, rig[0], rig[1], rig[2]);
	gl.uniform3f(loc_camUp, upv[0], upv[1], upv[2]);

	gl.uniform1f(loc_horizon, opt.horizon);
	gl.uniform1f(loc_isRay, (opt.isRaymarch?1.0:0.0));
	gl.uniform1f(loc_closeE, opt.closeEnufToZero);
	gl.uniform1f(loc_circPx, opt.circleBandPx);
	gl.uniform1f(loc_knobAng, opt.knobAngleBand);
	gl.uniform1i(loc_selectedBellI, selectedBellI);

	gl.uniform3fv(loc_col1, [1.0,0.2,0.2]);
	gl.uniform3fv(loc_col2, [0.2,1.0,0.2]);
	gl.uniform3fv(loc_col3, [0.2,0.2,1.0]);

	gl.bindVertexArray(vao);
	gl.drawArrays(gl.TRIANGLES,0,6);
	gl.bindVertexArray(null);
	*/

	requestAnimationFrame(renderLoop);
	
}

/***************************************************************
 * 13) Quicksave / Quickload
 ***************************************************************/


/***************************************************************
 * 14) Quaternions & small vector ops
 ***************************************************************/

function calculateForwardVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*(x*z+ w*y);
	const yy= 2.0*(y*z- w*x);
	const zz= 1.0- 2.0*(x*x+ y*y);
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,0,1];
	return [xx/ln, yy/ln, zz/ln];
}
function calculateUpVector(q){
	const[x,y,z,w]=q;
	const xx= 2.0*( x*y- w*z );
	const yy= 1.0- 2.0*( x*x+ z*z );
	const zz= 2.0*( y*z+ w*x );
	const ln= Math.hypot(xx,yy,zz);
	if(ln<1e-9) return [0,1,0];
	return [xx/ln, yy/ln, zz/ln];
}
function cross(a,b){
	return [
		a[1]*b[2]-a[2]*b[1],
		a[2]*b[0]-a[0]*b[2],
		a[0]*b[1]-a[1]*b[0]
	];
}
function normalize(v){
	const ln= Math.hypot(v[0],v[1],v[2]);
	if(ln<1e-9) return [0,0,0];
	return [v[0]/ln, v[1]/ln, v[2]/ln];
}
function multiplyQuaternions(q1,q2){
	const[x1,y1,z1,w1]=q1;
	const[x2,y2,z2,w2]=q2;
	return [
		w1*x2 + x1*w2 + y1*z2 - z1*y2,
		w1*y2 - x1*z2 + y1*w2 + z1*x2,
		w1*z2 + x1*y2 - y1*x2 + z1*w2,
		w1*w2 - x1*x2 - y1*y2 - z1*z2
	];
}
function createQuaternion(axis,angle){
	const ha= angle*0.5;
	const s = Math.sin(ha);
	return [ axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(ha)];
}
function normalizeQuaternion(q){
	const ln= Math.hypot(q[0],q[1],q[2],q[3]);
	if(ln<1e-9) return [0,0,0,1];
	return [q[0]/ln, q[1]/ln, q[2]/ln, q[3]/ln];
}

var makeGLTexture = (gl, height, width, optionalFloat32Array)=>{
	let t = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, t);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	let floats = optionalFloat32Array || null;
	//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
	gl.texImage2D(
		gl.TEXTURE_2D,
		0,
		gl.RGBA32F,
		width,
		height,
		0,
		gl.RGBA,
		gl.FLOAT,
		floats
	);
	return t;
};

//a rectangular GL texture wrapped around a sphere, all angles.
//At each angle there is a vec4 which is: [x y z tc] were tc is time+color/4096,
//where time and color are integers ranging 0 to 4095, time in units of video frames,
//so thats about 68 seconds.
//It stores 2 textures and swaps them so it can merge its previous self and another UVSphere
//into its next version. You cant read and write the same GL texture in the same GPU shader call.
//A UVSphere has no radius as its just a 3d point and 2 vec4's (1 per buffer) per angle,
//but TODO it might still be displayed that way in some debug modes.
class UVSphere{
	constructor(gl, pos, height, width, minTime, optionalFloat32Array){
		this.type = 'bellsack_uvsphere';
		this.gl = gl;
		this.pos = pos; //[x,y,z] or Float32Array.of(x,y,z)
		this.height = height;
		this.width = width;
		this.texA = makeGLTexture(gl,height,width,optionalFloat32Array);
		this.texB = makeGLTexture(gl,height,width);
		this.minTime = minTime;
	}
	flip(){ //swap the 2 GL textures like double buffering
		[this.texA, this.texB] = [this.texB, this.texA];
	}
	updateFromUVSphere(fromUVSphere, isCompareByTimeElseDistance){
		if(isCompareByTimeElseDistance){
			this.updateFromTextureSortByDistance(fromUVSphere);
		}else{
			this.updateFromTextureSortByTime(fromUVSphere);
		}
	}
	//after update, this.texA is newest.
	//updateFromTexture(fromUvsphere, newMinTime, isCompareByTimeElseDistance){
	//voxelsTexture could be another UVSphere.texA or unordered list of them.
	updateFromTextureSortByTime(voxelsTexture){
		/*flip();
		//read this.texB and fromUvsphere.texA. Write this.texA.
		Todo();
		*/
		
		this.flip();

		// Create the shared pipeline once
		if (!sphereUpdatePipeline) {
			sphereUpdatePipeline = new SphereUpdatePipeline(this.gl);
		}

		sphereUpdatePipeline.run(
			this.texA,						// outTex
			this.texB,						// oldTex
			voxelsTexture.texA,	 // fromTex
			this.pos,						 // sphereCenter (unused in time mode)
			/* isCompareByTimeElseDistance= */ true
		);
	}
	//param is a GL Texture that every vec4 in is used individually, regardless of order,
	updateFromTextureSortByDistance(voxelsTexture){
		/*flip();
		//read this.texB and fromUvsphere.texA. Write this.texA.
		Todo();
		*/
		this.flip();

		if (!sphereUpdatePipeline) {
			sphereUpdatePipeline = new SphereUpdatePipeline(this.gl);
		}

		sphereUpdatePipeline.run(
			this.texA,
			this.texB,
			voxelsTexture.texA,
			this.pos,
			/* isCompareByTimeElseDistance= */ false
		);
	}
	//param is list of Ball.
	updateFromBalls(ballsList){
		/*flip();
		//read this.texB and fromUvsphere.texA. Write this.texA.
		Todo();
		*/
		this.flip();
		// TODO: create or update a "temp" texture from the balls,
		// then call sphereUpdatePipeline.run(...) to merge with this.texB.
		console.log("TODO: updateFromBalls using GPU pass to draw ball shapes, then merge them.");
	}
	updateFromBells(roundBellsList, afBellsList, maxDistance){
		this.flip();
		// TODO: create a "temp" texture of the bell shapes,
		// then run the pipeline with distance or time-based logic.
		console.log("TODO: updateFromBells using GPU pass to draw bell shapes, then merge them.");
	}
	getFloats(){ //get copy of this.texA as Float32Array(this.height*this.width*4)
		const gl = this.gl;
		const fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texA.texture, 0);

		const out = new Float32Array(this.width * this.height * 4);
		gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.FLOAT, out);

		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(fbo);
		return out;
	}
	setFloats(floats){ //put copy into this.texA as Float32Array(this.height*this.width*4)
		const gl = this.gl;
		gl.bindTexture(gl.TEXTURE_2D, this.texA.texture);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,
			0, 0,
			this.width,
			this.height,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
}

var uvspheres = [];
var cameraUvsphere = null;

class Ball {
	constructor(x, y, z, radius, color){
	this.type = 'bellsack_ball';
		this.x = x;
		this.y = y;
		this.z = z;
		this.vx = 0;
		this.vy = 0;
		this.vz = 0;
		this.radius = radius;

		// Create an SVG circle
		this.svgCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
		this.svgCircle.setAttribute("fill", color); 
		this.svgCircle.setAttribute("r", radius); // Temporary placeholder; will be updated
		document.getElementById("ballOverlay").appendChild(this.svgCircle);
	}
}


function sumOfBellcurvesCPU(px, py, pz) {
	let val = 0;
	for (let bc of allBells) {
		let dx = px - bc.x, dy = py - bc.y, dz = pz - bc.z;
		let dist2 = dx*dx + dy*dy + dz*dz;
		val += bc.strength * Math.exp(-dist2 / (2.0 * bc.radius * bc.radius));
	}
	return val;
}

function isOccluded(cx, cy, cz, bx, by, bz) {
	let dx = bx - cx, dy = by - cy, dz = bz - cz;
	let dist = Math.hypot(dx, dy, dz);
	let steps = Math.floor(dist);
	dx /= dist; dy /= dist; dz /= dist;
	for (let i=0; i<steps; i+=2) {
		let val = sumOfBellcurvesCPU(cx+dx*i, cy+dy*i, cz+dz*i);
		if (val <= 0) return true;
	}
	return false;
}

window.onload = ()=>{
	console.log('window.onload start.');
	canvas = document.getElementById("glCanvas");
	gl = canvas.getContext("webgl2");
	if(!gl){
		alert("WebGL2 not found!");
	}
	createAndLink();
	bootEventsOnCanvas();
	console.log('window.onload about to requestAnimationFrame(renderLoop)');
	requestAnimationFrame(renderLoop);
	console.log('window.onload end.');
};

</script>
<script>
const Lamgl = (() => {
	/* LamGL is opensource MIT by Ben F Rayfield, a GPU API that runs in browsers.
	It comes after TinyGLSL, upgrades to do calculations in GPU memory without copying to CPU. Stores tensors
	in WebGLTexture's. Call GPU as a single function Lamgl({...})=>{...}.
	https://github.com/benrayfield/jsutils/blob/master/src/lamgl/Lamgl_028.html

	Opensource MIT by Ben F Rayfield. LamGL, open browser console. TODO hook in VarTree.html/VarTree.jsp
	which code to call LamGL will be in the tree (.big fields). All this together will remake BellSack and
	scale it up to 30 species near each area and swapping in/out species as you move around the massively
	multiplayer 3d world. LOOK IN BROWSER CONSOLE FOR "test pass" or errors.

	Avoid these bugs in WebGL2 GLSL ES 300:
	-- If you texelFetch the same address twice in the same GPU thread, you'll get all 0s.
	[This is a known bug-like behavior (especially on certain GPUs and drivers, notably Intel and some mobile chipsets), and it boils down to this: In WebGL2 / GLSL ES 300, if you call texelFetch() multiple times with the same coordinates and sampler in the same shader invocation — even if in different scopes — you may get all 0.0s as the result on the second+ calls. This isn't defined behavior by the spec, but it's a real-world GPU driver optimization bug.]--GPT.
	-- Some GLSL optimizers are buggy so u have to make sure some code happens like this sometimes:
		//*1.0000001 avoid returning all 0s, force it to to do some calculation
		//thats not from the textures, cuz the glsl optimizer is buggy.
		dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.0000001

	2025-5-4 did this just reach 1 teraflop/sec when turned off observed_testMatmulAC4?
	testMatmulAC4 secs=0.10042023658752441 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=2.6731211269955195 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.047499895095825195 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.651285238808727 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.04397988319396973 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=6.103596383284764 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.05035996437072754 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.330334509847906 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.049179792404174805 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=5.4582470335359305 observed_testMatmulAC4.length=262144 Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00036025047302246094 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=745.1356100877723 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002598762512207031 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1032.9356943510313 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00028014183044433594 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=958.2126866745737 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.0002799034118652344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=959.0288814673117 observed_testMatmulAC4.length=undefined Lamgl_038.html:1408:13
	testMatmulAC4 secs=0.00024008750915527344 gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)=1118.073393090987 observed_testMatmulAC4.length=undefined
	...
	something dont seem right here. maybe its just that im not refilling the input matrixs so it doesnt have to move them around GPU memory as much, but its saying 21 teraflops when i raised to multiplying 2 1024x1024 matrixs: secs=0.00009989738464355469 gigaflopPerSec=21496.89559604
		
	2025-5-4-950aET about doBasicTests matmul tests only[[
	Are you recompiling the shader every call?
	no
	let program = vm.cache('program'+cacheKeySuffix, function(){...
	lazyevals it once

	 Are you recreating textures or framebuffers every call?
	I was but i just fixed that (see .free() in finally block in new code im not giving u yet) and its a little faster but still taking 40ms.

	Are you doing gl.readPixels() after every run?
	yes.its for testing but i guess i shouldnt do that in the speed test

	Are you uploading data from CPU to GPU every time?
	no. it stays in the 2 input textures/tensors.

	 Are you allocating a new canvas or GL context?
	no

	Are you doing unnecessary conversions (e.g., CPU reshape / flatten)?
	no, not in the loop, only before it, and those tests in the loop are still slow. I expect the first 1 to be slow but not those after it.

	Are you launching too many threads or using poor loop structure?
	TinyGLSL is fast even with a million GPU threads. im only using 512*512/4=64k gpu threads which should be ok.
	]]

	The shit i gotta do for pointer-arithmetic to write a GPU memory address with a vec4 value (i do have random-access swarming many vec4 sized particles: gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
	i can read alot faster than i can write in GPU. i read as much as the 3d cube volume of matrix multiplying 2 2d squares or any 3 lengths of a 3d rectangle of compute returning a 2d matrix. they're all tensors.
	cuz i dont gotta do that affine transform shit to read. only to write. to read i just texelFetch an ivec2, which can be generated in simple easy to optimize ways or loaded at runtime and i can jump pointer arithmetic n levels deep at each point depending on reading shared GPU mem.
	im gonna turn this into something like codeblocks in a massively multiplayer way, and i'm not giving up GPU flops for it but i am giving up some IO bandwidth between CPU vs GPU cuz of browser layers etc. But imagine u can call pure-functions on eachother in an ocean of builders. (but not codeblocks specificly im optimizing for DAG which has immutable forest of childs, like in wikibinator203's tree drag and drop).
	float32 (even with the +1 in first shader and -1 in last shader, to fix an optimizer bug built into the drivers or browser or hardware etc) can exactly do int25 and uint24, if ur careful not to overflow it, so u might need to multiply 2 int12s or something like that.
	*/
    const vm = function(){}; //Proxy of this (Lamgl) can only be called as function if this is a function
	//VM = vm;
	
	const Todo = vm.Todo = str => { throw new Error(str || 'TODO'); };
	const Err = vm.Err = str => { throw new Error(str || '(Err with no message)'); };

    vm.jsType = x => (ArrayBuffer.isView(x) ? x.constructor.name : typeof(x));

    vm.call = (param,optionalSh)=>{
		//if(typeof(param) == 'object'){
		if(param.sv || param.sf){
			return vm.callGPU(param);
		}else{
			return vm.wrap(param,optionalSh);
		}
    };
	
	vm.callGPU = map=>{
		let gl = vm.Gl();
		let sv = map.sv || '//FIXME no sv'; //vertex shader code
		let sf = map.sf || '//FIXME no sf'; //fragment shader code
		
		console.log('sv='+map.sv);
		console.log('sf='+map.sf);
		
		let sh = map.sh; //[height, width, 4] or maybe [zSize, height, width, 4] etc
		/*
		//TODO zSize for 3d pics?
		let h = map.h; //height, unless map.n is a [] list like [height width 4] or [zSize height width 4] etc.
		let w = map.w; //width, unless that
		let q = map.q || 4; //floats per GPU thread (or maybe per texture?)
		let sh = map.sh || [h, w, q]; //shape of tensor
		//in case there is zSize or what should it be called?
		if(!h) h = sh[n.length-3];
		if(!w) w = sh[n.length-2];
		if(!q) w = sh[n.length-1];
		*/
		
		let cacheKeySuffix = '_SV['+sv+']_SF['+sf+']_SH['+vm.Str(sh)+']';
		
		let glvars = vm.glvars(map);
		console.log('glvars=[[['+glvars.join('\n')+']]]');
		
		//If a memsIn's Tensor has fr/free of 1, then it uses an optimization of
		//its WebGLTexture being both in and out (in memsIn and memsOut)
		//since its, kind of in this higher level, garbage collected and reused at once,
		//based on that Tensor is immutable and Mem/WebGLTexture is mutable.
		//During this, mem.tensor should be null, and at end, create new Tensor(mem)
		//for each memsOut. Creating a tensor just wraps the Mem, doesnt copy contents,
		//and is still backed by GPU memory.
		let memsIn = []; //contains nulls where u dont use them
		let memsOut = []; //contains nulls where u dont use them
		//for each index in mems*, memsIn or memsOut or both have it.
		
		let tensorsToDecrementFreeAtEnd = [];
		
		for(let i=0; i<glvars.length; i++){
			let glvar = glvars[i];
			console.log('glvars looping, i='+i+' '+glvar);
			let isIn = glvar.isIn(), isOut = glvar.isOut();
			if(isIn){
				if(isOut) Err('Cant be both in and out: '+glvar);
				console.log('START isIn, glvar='+glvar);
				let tensorIn = map[glvar.name];
				if(!tensorIn) Err('No tensorIn for '+glvar);
				tensorsToDecrementFreeAtEnd.push(tensorIn);
				memsIn[i] = tensorIn.mem; //read-only and immutable
				console.log('END isIn, glvar='+glvar+', memsIn['+i+'] = '+tensorIn+' of name '+glvar.name+' texture='+ tensorIn.mem.mut);
			}else if(isOut){ //isOut
				console.log('START isOut, glvar='+glvar);
				
				
				//Cant do it as "const canReuseTexture = firstStateTensor.fr === 1;" cuz requires checking if
				//firstStateTensor exists cuz its an optional param. for each output, it optionally is also a param
				//for the starting state of the output memory, which gl_Position can sparsely write on top of.
				let firstStateTensor = map[glvar.name]; //if this doesnt exist, start with an empty state.
				//the optimization this whole LamGL software is based on,
				//that allows it to be completely stateless/immutable Tensors
				//that share and reuse GPU memory without copying back to CPU
				//except as needed after 1 or many GPU calls.
				let doSharedTextureOptimization = false;
				console.log('doSharedTextureOptimization='+doSharedTextureOptimization);
				if(firstStateTensor){
					console.log('isOut: map.'+glvar.name+' exists so using it as the starting state (firstStateTensor) of that texture/GPUMemory. If its .fr/free is 1, will do the optimization to reuse that texture, else will copy it first.');
					doSharedTextureOptimization = firstStateTensor.fr==1;
					//TODO firstStateTensor.useFree() at end. cant free it yet.
				}
				
				/*if(firstStateTensor && doSharedTextureOptimization){ //use 1 texture as if it was 2
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else if(firstStateTensor){ //use 2 textures, copy-on-write
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					memsOut[i] = firstStateTensor.copy().mem;
				}else{ //no firstStateTensor, start with empty memory
					memsOut[i] = vm.gpuMalloc(map.sh); // assumes `map.sh` is the desired shape
				}*/
				
				if(firstStateTensor){
					if(doSharedTextureOptimization){
						//garbage collect immutable tensor so can reuse texture/mem
						firstStateTensor.tensor = null;
						memsOut[i] = firstStateTensor.mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=TRUE, memsOut['+i+'] = '+firstStateTensor+' of name '+glvar.name);
					}else{
						//firstStateTensor.fr is big enuf its not garbage collected,
						//so this (after copy) is the last we use it in this call of callGPU.
						//Instead, we copy it to another texture/mem and use that as output,
						//including that its a mutable texture during writing it,
						//as it has its previous contents and wherever gl_Position
						//sparsely writes voxels over it.
						//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
						//depending on if its a 2d or 3d texture),
						//and write 1-8 vec4s there, 1 vec4 written to each output texture,
						//and gl has a limit of at most 8 output textures (normally just 1).
						//firstStateTensor.useFree(); //decrement firstStateTensor.fr
						tensorsToDecrementFreeAtEnd.push(firstStateTensor);
						//new GPU mem. starts with high .fr
						memsOut[i] = firstStateTensor.copy().mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=FALSE, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					}
				}else{
					memsOut[i] = vm.gpuMallocMem(sh);
					console.log('no firstStateTensor, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					if(memsOut[i].tensor) Err('gpuMallocMem gave Mem with a tensor');
				}
				
				/*
				Todo('there might be 3 cases, do optimization, dont do optimization, where there is .fr>1 so still gotta copy, and where there is .fr==1 so reuse it (the optimization). some combo of those');
				if(doSharedTextureOptimization){ //use 1 texture as if it was 2
					Todo('this might be wrong, check [there might be 3 cases]');
					//garbage collect immutable tensor so can reuse texture/mem
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else{ //use 2 textures, copy-on-write
					Todo('this might be wrong, check [there might be 3 cases]');
					//firstStateTensor.fr is big enuf its not garbage collected,
					//so this (after copy) is the last we use it in this call of callGPU.
					//Instead, we copy it to another texture/mem and use that as output,
					//including that its a mutable texture during writing it,
					//as it has its previous contents and wherever gl_Position
					//sparsely writes voxels over it.
					//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
					//depending on if its a 2d or 3d texture),
					//and write 1-8 vec4s there, 1 vec4 written to each output texture,
					//and gl has a limit of at most 8 output textures (normally just 1).
					//firstStateTensor.useFree(); //decrement firstStateTensor.fr
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					//new GPU mem. starts with high .fr
					memsOut[i] = firstStateTensor.copy().mem;
				}
				*/
				
				console.log('END isOut, glvar='+glvar+', memsOut['+i+'] = Tensor '+glvar.name+', GPU texture ='+memsOut[i].mut);
			}else Err('Is not in or out: '+glvar+' FIXME what if its an input of fragment shader (sf) which comes after vertex shader (sv).');
		}
		console.log('Got '+memsIn.filter(x=>!!x).length+' ins and '+memsOut.filter(x=>!!x).length+' outs, excluding nulls/undefineds in memsIn and memsOut lists.');
		//Todo();
		
		//todo remove this double loop. also, does doSharedTextureOptimization allow them to be both in and out in some cases?
		console.log('--- Checking input/output GPU memory overlap ---');
		for (let i = 0; i < memsIn.length; i++) {
			const memIn = memsIn[i];
			if (!memIn) continue;
			for (let j = 0; j < memsOut.length; j++) {
				const memOut = memsOut[j];
				if (!memOut) continue;
				if (memIn.mut === memOut.mut) {
					console.warn(`ERR, ⚠️ memsIn[${i}] and memsOut[${j}] share the SAME WebGLTexture!`, memIn.mut);
				}else{
					console.warn(`OK memsIn[${i}] and memsOut[${j}]`);
				}
			}
		}
		console.log('--- End check ---');

		
		let program = vm.cache('program'+cacheKeySuffix, function(){
			let vertexShader = vm.cache('vertexShader'+cacheKeySuffix, function(){
				sv = vm.preprocessShaderString(sv); //add line numbers etc
				let v = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(v, sv);
				gl.compileShader(v);
				if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+sv);
				}
				return v;
			});
			console.log('vertexShader='+vertexShader);
			let fragmentShader = vm.cache('fragmentShader'+cacheKeySuffix, function(){
				sf = vm.preprocessShaderString(sf); //add line numbers etc
				const f = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(f, sf);
				gl.compileShader(f);
				if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(f)+'\n\nFRAGMENTSHADERCODE:\n'+sf);
				}
				return f;
			});
			console.log('fragmentShader='+fragmentShader);
			const p = gl.createProgram();
			gl.attachShader(p, vertexShader);
			gl.attachShader(p, fragmentShader);
			gl.linkProgram(p);
			if(!vm.skip_gl_getProgramParameter_LINK_STATUS && !gl.getProgramParameter(p, gl.LINK_STATUS)){
				Err(gl.getProgramInfoLog(p));
			}
			return p;
		});
		console.log('program='+program);
		
	
		
		let ret = {};
		
		//nTextures are outputs, not inputs. 1-8 textures of float or vec4 per pixel each.
		
		/*if(nTextures.length > 1){
			//Specify the draw buffers for multiple render targets
			const attachments = nTextures.map((_, index) => gl.COLOR_ATTACHMENT0 + index);
			gl.drawBuffers(attachments);
		}*/
		let texturesOut = [];
		for(let mem of memsOut) if(mem) texturesOut.push(mem.mut);
		
		//vm.cacheFramebuffer = true;
		vm.cacheFramebuffer = false;
		console.log('vm.cacheFramebuffer='+vm.cacheFramebuffer);
		
		let framebufferMaker = function(){
			const f = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, f);
			for(let i=0; i<texturesOut.length; i++){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, texturesOut[i], 0);
			}
			return f;
		};
		let framebuffer = vm.cacheFramebuffer ?
			vm.cache('framebuffer'+cacheKeySuffix, framebufferMaker)
			: framebufferMaker();
		
				
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		//gl.clearColor(0, 0, 0, 0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		gl.viewport(0, 0, width, height);
		gl.useProgram(program);
		
		if(texturesOut.length){
			const attachments = texturesOut.map((_,i)=>(gl.COLOR_ATTACHMENT0+i));
			gl.drawBuffers(attachments); 
			//gl.drawBuffers(texturesOut);
		}
		
		
		// === Bind sampler2D uniforms ===
		let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;    // only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}

		
		
		//=== run shader for every pixel/voxel using gl_VertexID ===
		let numVerts = 1;
		for(let d = 0; d < sh.length - 1; d++){   // multiply all dims except the last (==4)
			numVerts *= sh[d];
		}
		gl.drawArrays(gl.POINTS, 0, numVerts);    // no VBO needed – gl_VertexID drives the math

		//=== wrap each output Mem in an immutable Tensor and expose it ===
		for(let i=0; i<glvars.length; i++){
			if(glvars[i].isOut() && memsOut[i]){
				let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);
				memsOut[i].tensor = t;            // back-link for texture pooling
				ret[glvars[i].name] = t;          // e.g. ret.result
			}
		}

		
		//for(let i=0; i<nTextures.length; i++){
		//}
		
		
		

		//gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		
		/*for(let i=0; i<nTextures.length; i++){ //1-8 textures out
			let colorAttachmentI = gl.COLOR_ATTACHMENT0+i;
			gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachmentI, gl.TEXTURE_2D, nTextures[i], 0);
		}*/

		/*if(floatsOutPerPixel == 1){
			//copy from GPU (texture or renderbuffer) to CPU (outarr)
			gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RED, gl.FLOAT, outarr); //getting gl.RED only uses EXT_color_buffer_float (which may exist only in desktop browsers not mobile?)
			//console.log('outarr[2345]='+outarr[2345]);
		}else if(floatsOutPerPixel == 4){
			//copy from GPU (texture or renderbuffer) to CPU (outarr)
			gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, outarr);
		}else{
			console.log('Experimental floatsOutPerPixel='+floatsOutPerPixel+' gl.readPixels '+nTextures.length+' times...');
			let pixelData = new Float32Array(outarr.length/nTextures.length);
			let numPixels = canvasHeight*canvasWidth;
			if(pixelData.length != numPixels*4) Err('Sizes dont match');
			// Iterate over each texture
			for(let i=0; i<nTextures.length; i++){
				let colorAttachmentI = gl.COLOR_ATTACHMENT0+i;
				gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachmentI, gl.TEXTURE_2D, nTextures[i], 0);
				gl.readBuffer(colorAttachmentI);
				gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, pixelData);

				//Interleave the pixel data into outarr
				for(let p = 0; p < numPixels; p++){
					//Start index in outarr for this pixel
					let baseIndex = p * floatsOutPerPixel;
					//Index in pixelData where the current texture's data starts for this pixel
					let textureBaseIndex = p * 4;  // 4 floats per pixel per texture

					//Copy the data from pixelData to the correct position in outarr
					for(let j=0; j<4; j++) {  // 4 floats from the current texture
						outarr[baseIndex + i * 4 + j] = pixelData[textureBaseIndex + j];
					}
				}
			}
			//gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, outarr);
			//throw 'floatsOutPerPixel='+floatsOutPerPixel+' but must be 1 or 4';
		}*/
		
		
		
		
		/*let nextTextureUnit = 0;
		for(let uniformName in bigMem){
			let tensor = bigMem[uniformName];
			//let tex = texturesToUseOnce[uniformName];
			let tex = texturesToUseOnce[uniformName] = gl.createTexture();
			//TODO let tex = texturesToUseOnce[uniformName] = TinyGlsl.cache(
			//TODO 	'tex_'+uniformName+cacheKeySuffix,
			//TODO 	()=>{
			//TODO 		let tex = gl.createTexture();
					if(!tex) Err('No texture for uniformName='+uniformName);
					console.log('uniformName='+uniformName+' tensor='+tensor);
					// Now query the shader program for a uniform with the same name.
					let loc = gl.getUniformLocation(program, uniformName);
					console.log('loc='+loc);
			
					if(loc !== null){
						// Bind this texture to the next available texture unit.
						gl.activeTexture(gl.TEXTURE0+nextTextureUnit);
						console.log('loc='+loc);
						//console.log('tensor.g='+tensor.g);
						console.log('tex='+tex+' (not tensor.g cuz thats for future upgrades in TinyGlsl.tensor({...call...}))');
						//gl.bindTexture(gl.TEXTURE_2D, tensor.g);
						gl.bindTexture(gl.TEXTURE_2D, tex);
						// For texelFetch we need exact texel values, so set filtering to NEAREST.
						// Even though texelFetch ignores filtering, these parameters are required to make
						// the texture complete in WebGL.
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						// Set wrapping mode to CLAMP_TO_EDGE to prevent unintended repeats.
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						// Tell the shader that the sampler uniform should use this texture unit.
						console.log('nextTextureUnit='+nextTextureUnit);
						gl.uniform1i(loc, nextTextureUnit);
						// Optionally, if your shader wants the texture's dimensions, pass them as a vec2
						// using a uniform named uniformName+"Size".
						//let sizeLoc = gl.getUniformLocation(program, uniformName + "Size");
						//console.log('sizeLoc='+sizeLoc);
						//if (sizeLoc !== null){
						//	gl.uniform2i(sizeLoc, tensor.sh[1], tensor.sh[0]); // width, height
						//	console.log('gl.uniform2i '+sizeLoc+' '+tensor.sh[1]+' '+tensor.sh[0]);
						//}
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,                // level
							gl.RGBA32F,       // internal format (32-bit floats per channel)
							tensor.sh[1],     // width (second element of shape)
							tensor.sh[0],     // height (first element of shape)
							0,                // border
							gl.RGBA,          // format
							gl.FLOAT,         // type
							tensor.c          // data from the CPU array
						);
						nextTextureUnit++;
					}
					//TODO return tex;
				//TODO }
			//TODO );
		}*/
		
		/*Consider 2 cases, if its done by 2 triangles forming a rectangle covering an area,
		vs only by gl_VertexID (drawArrays).
		
		list the GL objects needed either way:
		* canvas
		* gl
		* program
		* vertexShader
		* fragmentShader
		* nTextures
		* framebuffer (attachments is optional)
		//* loc_locationOfUniformAndOtherParams
		//* float32arrayInCpu_someToReadFrom_someToWriteTo
		
		
		list the extra GL objects needed for the 2 triangles (but not if only gl_VertexID):
		* positionBuffer
		("You can skip this entirely by using gl_VertexID to generate full-screen geometry. This is how you're doing it in LamGL’s test shader, which is ideal." --GPT4o)
		
		*/
		
		
		
		//Todo();
		/*
		vm.cache('sv'
		
		
	
		vm.cache = function(key, lazyVal){
		Todo();
		*/
		
		//unbind input textures that were binded in the loop
		//containing "if (!glvar.isInTex()) continue;    // only bind texture inputs"
		for (let i = 0; i < nextTextureUnit; i++){
			gl.activeTexture(gl.TEXTURE0 + i);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		// === Unbind framebuffer output ===
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		// === Optional: reset active texture to 0 for consistency ===
		gl.activeTexture(gl.TEXTURE0);
		gl.useProgram(null);
		gl.bindVertexArray(null); //even tho its not using a vertex array
		
		/*todo? let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;    // only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}*/
		
		for(let tensor of tensorsToDecrementFreeAtEnd){
			//decrement tensor.fr and if its 0 return its texture/mem to pool
			tensor.useFree();
		}
		
		return ret;
	};
	
	vm.preprocessShaderString = code=>{
		return vm.addLineNumbers(code);
	};
	
	//This is for lines like "out vec4 result; //comment".
	//TODO? eltype is element type, like 'vec4' or 'float' or 'int',
	//regardless of its an array/texture vs one primitive.
	vm.GLVar = function(memType, glType, name){
		this.memType = memType;
		this.glType = glType;
		this.name = name;
	};
	
	/*vm.GLVar.prototype.isIn = function(){
		
	};
	
	vm.GLVar.prototype.isInTex = function(){
		
	};
	
	vm.GLVar.prototype.isOutTex = function(){
		return this.memType=='out';
	};
	
	vm.GLVar.prototype.isOut = function(){
		return this.isOutTex();
	};*/
	
	vm.GLVar.prototype.isIn = function(){
		// Treat uniforms and varying inputs (from vertex shader) as inputs
		return this.memType === 'uniform' || this.memType === 'in';
	};

	vm.GLVar.prototype.isInTex = function(){
		// A sampler2D, samplerCube, etc., in a uniform is a texture input
		return this.memType === 'uniform' && this.glType.startsWith('sampler');
	};

	vm.GLVar.prototype.isOutTex = function(){
		// Fragment outputs (out vec4 ...) are the only texture outputs
		return this.memType === 'out';
	};

	vm.GLVar.prototype.isOut = function(){
		// Alias to isOutTex for now, but leaves room to generalize later
		return this.isOutTex();
	};

	
	vm.GLVar.prototype.toString = function(){
		return '[GLVar memType='+this.memType+' glType='+this.glType+' name='+this.name+']';
	};
	
	//returns [] list of GLVar's in the order they should be used in gl.
	//map.sv is string of vertex shader code, sf fragement shader,
	//(todo if one of those is not given use or generate some default?).
	/*vm.glvars = map=>{
		Todo();
	};*/
	vm.glvars = map => {
		const glvars = [];

		const parseShaderVars = (shaderSrc, isVertexShader) => {
			const lines = shaderSrc.split('\n');
			for (let line of lines) {
				line = line.trim();

				// Ignore comments
				if (line.startsWith('//')) continue;

				let isIn = false;
				let memType = null, glType = null, name = null;

				// Handle uniform
				let matchUniform = line.match(/^uniform\s+(\w+)\s+(\w+);/);
				if (matchUniform) {
					glType = matchUniform[1];
					name = matchUniform[2];
					memType = 'uniform';
					isIn = true;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle in/out (varyings, fragment outputs, etc.)
				let matchIO = line.match(/^(in|out)\s+(\w+)\s+(\w+);/);
				if (matchIO) {
					let qualifier = matchIO[1];
					glType = matchIO[2];
					name = matchIO[3];
					memType = qualifier;
					isIn = (qualifier === 'in');
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle layout(...) out vec4 NAME;
				let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+(\w+);/);
				if (matchLayoutOut) {
					glType = matchLayoutOut[1];
					name = matchLayoutOut[2];
					memType = 'out';
					isIn = false;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}
			}
		};

		if (map.sv) parseShaderVars(map.sv, true);
		if (map.sf) parseShaderVars(map.sf, false);

		return glvars;
	};
	
	//vm.Str = 
	
	//TODO make a way to call Lamgl({...}) that takes a string of js code that generates
	//the Float32Array or Mem/texture contents in CPU.
	//Maybe name it sj (j for javascript) like sv (vertex shader) and sf (fragment shader).
	//A tensor could be more general, in cpu mem or gpu mem.
	
	vm.wrap = (wrapMe,optionalSh)=>{
		if(wrapMe instanceof Float32Array){
			let sh = optionalSh || [wrapMe.length>>2, 4]; //FIXME what if its not a multiple of 4?
			let mem = vm.gpuMallocMem(sh);
			mem.set(wrapMe); //copy from CPU (Float32Array wrapMe) to GPU (WebGLTexture in mem.mut)
			return new vm.Tensor(mem);
		}else Err('wrapMe is a '+typeof(wrapMe));
	};
	
		//immutable, normally exists in a Mem. Is same shape as that mem.
	vm.Tensor = function(mem,optionalFr){
		this.mem = mem;
		this.sh = mem.sh;
		//countdown until garbcol. Each time its read in GPU,
		//this is decremented. When it reaches 0, vm.gpuFree(this)
		//is called to return that GPU memory to the pool.
		this.fr = optionalFr || vm.defaultFr;
	};
	
	vm.Tensor.prototype.toString = function(){
		return '[Tensor sh='+JSON.stringify(this.sh)+']';
	};
	
	//return a Float32Array copy of the WebGLTexture in the mem backing this Tensor
	vm.Tensor.prototype.get = function(){
		return this.mem.get();
	};
	
	//Returns this Tensor with fr set.
	//Like, vm.gpuMalloc([300,500,4]).free(1) is a Tensor that will free
	//its WebGLTexture (back to the vm.texPool) after the next GPU call.
	//if optionalFr is not given or is 0, frees now.
	//If its 1, frees on the next use (1 more GPU call),
	//fr decreases by 1 each GPU call.
	vm.Tensor.prototype.free = function(optionalFr){
		this.fr = optionalFr|0;
		if(!this.fr){
			vm.gpuFreeMem(this.mem); //free the WebGLTexture but not the js object
		}
		return this;
	};
	
	//use 1 more fr in the countdown, toward garbage collecting the WebGLTexture at this.fr==0,
	//but only back into the vm.texPool pool, not deleting it out of the GPU
	//(todo also that if its not used for a while and the GPU memory is needed).
	vm.Tensor.prototype.useFree = function(){
		if(this.fr){
			this.fr--;
			if(!this.fr){
				vm.gpuFree(this); //free the WebGLTexture but not the js object
			}
		}
	};
	
	//For if sh.length==2, not sure if we even have 1d textures in this version of webgl. Get flattened index.
	vm.Tensor.prototype.ii = function(x, w){
		return x*this.sh[0]+w;
	};

	//For if sh.length==3 like a 2d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iii = function(y, x, w){
		return (y*this.sh[0]+x)*this.sh[1]+w;
	};

	//For if sh.length==4 like a 3d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iiii = function(z, y, x, w){
		return z*this.sh[0]+(y*this.sh[1]+x)*this.sh[2]+w
	};
	
	//vm.texPool[vm.shKey(sh)] is a [] of unused vm.Mem instances of that sh/shape.
	//See vm.gpuMallocMem and vm.gpuFreeMem.
	vm.texPool = {};
	
	vm.verifyShEndsWithVec4 = sh=>{
		if(sh[sh.length-1] != 4) Err('Last dimension is not 4: '+Str(sh));
	};
	
	//returns a Tensor wrapping a Mem wrapping a WebGLTexture,
	//instead of that Mem. Tensor is immutable. Mem is mutable.
	//The Tensor contains whatever data was in WebGLTexture (malloc, not calloc).
	vm.gpuMallocTensor = sh=>(new vm.Tensor(vm.gpuMallocMem(sh)));
	
	vm.gpuMallocMem_usesCache = true; //normal
	//vm.gpuMallocMem_usesCache = false; //test
	console.log('vm.gpuMallocMem_usesCache='+vm.gpuMallocMem_usesCache);
	
	//Example: vm.gpuMalloc([300,500,4]) returns a Mem.
	//allocate a texture of a chosen sh/shape from pool, in GPU mem.
	//Returns a Mem instance wrapping a WebGLTexture of 2d or 3d,
	//normally with 4 floats per pixel (vec4) as sh[sh.length-1] is normaly 4.
	//This is specificly a malloc, not calloc, as it doesnt clear the mem.
	//Only the first use of a WebGLTexture is cleared,
	//but after that it can be returned to the pool and reallocated without clearing,
	//but it should be written before read again.
	vm.gpuMallocMem = sh=>{
		vm.verifyShEndsWithVec4(sh);
		let k = vm.shKey(sh);
		//list of Mem's whose mem.sh contents equal.
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		if(vm.gpuMallocMem_usesCache && list.length){
			console.log('gpuMallocMem returning from cache, sh='+vm.Str(sh));
			return list.pop();
		}else{
			let tex = null;
			if(sh.length==3 && sh[2]==4){
				//2d WebGLTexture with vec4 per pixel
				console.log('gpuMallocMem makeGLTexture2dVec4, sh='+vm.Str(sh));
				tex = vm.makeGLTexture2dVec4(sh[0], sh[1]);
			}else if(sh.length==3 && sh[2]==4){
				Todo('new 3d WebGLTexture (vec4 per pixel) of that sh='+Str(sh));
			}else{
				Todo('new WebGLTexture of that sh='+Str(sh));
			}
			return new vm.Mem(tex, sh);
			//return new vm.Tensor(new vm.Mem(tex, sh));
		}
	};
	
	//Example:  mem is what a vm.gpuMalloc returned.
	//FIXME: Does not check if its already freed or if its already in texPool,
	//so only call once after each gpuMallocMem.
	vm.gpuFreeMem = mem=>{
		console.log('gpuFreeMem this='+this);
		mem.tensor.mem = null; //breaks the tensor, cant use it anymore
		mem.tensor = null;
		let k = vm.shKey(mem.sh);
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		list.push(mem);
	};
	
	vm.shKey = sh=>sh.join('_');
	
	//mutable. wraps WebGLTexture and maybe Float32Array.
	//shape is [z,y,x,4] or [y,x,4] or [y,x,1] or [500] etc.
	vm.Mem = function(mutableMem, shape){
		this.mut = mutableMem;
		this.sh = shape;
		this.tensor = null; //this Mem is in the pool when this.tensor is null.
	};
	
	vm.mulAll = function(vec){
		let ret = 1;
		for(let num of vec) ret *= num;
		return ret;
	};
	
	vm.Mem.prototype.size = function(){
		return vm.mulAll(this.sh);
	};
	
	//copy gpu to cpu
	vm.Mem.prototype.get = function(optionalFloat32Array){
		let size = this.size();
		let ret = optionalFloat32Array || new Float32Array(size);
		vm.copyTextureToFloat32Array(this.mut,this.sh,ret); //GPU
		return ret;
	};
	
	/*vm.copyTextureToFloat32Array = (tex,floatsOut)=>{
		Todo();
	};*/
	vm.copyTextureToFloat32Array = (tex, sh, floatsOut) => {
		if(sh.length != 3) Todo('sh.length=='+sh.length);
		const gl = vm.Gl();

		// Assume the texture is 2D and in RGBA32F format
		// Find the dimensions from floatsOut.length and assume vec4 per pixel
		let totalFloats = floatsOut.length;
		let height = sh[0];
		let width = sh[1];
		let pixels = totalFloats/sh[2];
		
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		//let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		
		/*let pixels = totalFloats / 4;
		let width = Math.ceil(Math.sqrt(pixels));
		let height = Math.ceil(pixels / width); //TODO choose width and height better
		*/

		// Create a temporary framebuffer and attach the texture to it
		const framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.viewport(0, 0, width, height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

		let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			// Clean up before erroring out
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.deleteFramebuffer(framebuffer);
			Err('Framebuffer not complete: ' + status);
		}

		// Read pixels from the framebuffer into the Float32Array
		gl.readPixels(
			0, 0, width, height,
			gl.RGBA, gl.FLOAT,
			floatsOut
		);

		// Clean up
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(framebuffer);
	};
	
	//vm.skip_gl_getProgramParameter_LINK_STATUS = false; //2024-5-9-640pET defaulting this to false (dont skip) cuz of I turned SKLT=F (dont skip) by clicking the button and this neuralnet nnet_1715286589.548.dagball compiled in about .1 second when I changed {nodes 12} to {nodes 13}.
	//skip_gl_getProgramParameter_LINK_STATUS: true, //normal as of 2024-5-9 cuz it made compiling GLSL alot faster, probably some thread thing it didnt have to wait on, considering theres multiple off-screen canvases.
	//skip_gl_getProgramParameter_LINK_STATUS: false, //normal before 2024-5-9, but TODO experimentally trying skipping it cuz this line takes .1 to 20 seconds and is likely causing threads to wait on eachother
	//skip_gl_getProgramParameter_LINK_STATUS: true, //for testing, or maybe it will work out this way?
	
	//copy cpu to gpu
	vm.Mem.prototype.set = function(float32Array){
		vm.copyFloat32ArrayToTexture(float32Array,this.mut,this.sh);
	};
	
	// --- CPU → GPU upload ----------------------------------------------
	vm.copyFloat32ArrayToTexture = (src, tex, sh) => {
		// sh is the tensor shape that texture represents, e.g. [h, w, 4]
		if (!sh || sh.length !== 3 || sh[2] !== 4) {
			Err('copyFloat32ArrayToTexture: shape must be [height,width,4]');
		}
		const gl     = vm.Gl();
		const height = sh[0];
		const width  = sh[1];

		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,                 // level
			0, 0,              // x-offset, y-offset
			width, height,     // size
			gl.RGBA,           // format
			gl.FLOAT,          // type
			src                // the Float32Array with 4*width*height values
		);
	};

	
	vm.webglType = 'webgl2'; //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	vm.glslVersionString = '#version 300 es'; //WebGL2 GLSL ES 300
	
	vm.gl = null; //the only GL instance, normally WebGL2 GLSL ES 300
	vm.glCanv = null;
	vm.glCanvasHeight = 1; //1x1 canvas, cuz gonna use gl_VertexID instead of 2 triangles that form a rectangle covering the canvas
	vm.glCanvasWidth = 1;
	vm.Gl = ()=>{
		if(!vm.gl){
			let c = document.createElement("canvas");
			c.setAttribute("height", ''+vm.glCanvasHeight);
			c.setAttribute("width", ''+vm.glCanvasWidth);
			c.addEventListener('webglcontextlost', function(event){
				//event.preventDefault();
				//activeContexts.delete(context);
				console.log('TinyGLSL says canvas event webglcontextlost, event='+event);
				if(TinyGlsl.do_clearAllCache_whenWebglContextLost){
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost STARTING TinyGlsl.clearAllCache()...');
					TinyGlsl.clearAllCache();
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost DONE TinyGlsl.clearAllCache().');
				}
			}, false);
			vm.glCanv = c;
			
			let gl = vm.glCanv.getContext(vm.webglType);
			let glErr = gl.getError();
			if(glErr) Err('after canvas.getContext(TinyGlsl.webglType), gl.getError()='+glErr);
			if(!gl.getExtension('EXT_color_buffer_float')){ //this turns the extension on. its not just checking if it exists.
				Err('EXT_color_buffer_float not supported so cant return 1 or 4 floats per pixel instead of bytes');
			}
			let isContextLost = gl.isContextLost();
			console.log('creating gl context, gl.isContextLost()=='+isContextLost);
			if(isContextLost) Err('gl.isContextLost()=='+isContextLost+
				', see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/isContextLost');
			console.log('Returning new webgl context '+gl);
			vm.gl = gl;
		}
		return vm.gl;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.makeGLTexture2dVec4 = (height, width, optionalFloat32Array)=>{
		let gl = vm.Gl();
		let t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		let floats = optionalFloat32Array || null;
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
		gl.texImage2D(
			gl.TEXTURE_2D,
			0,
			gl.RGBA32F,
			width,
			height,
			0,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		return t;
	};
	
	vm.defaultFr = 1<<30;
	
	vm.vm = vm; //so Lamgl.vm is vm. Lamgl is a Proxy

    let Str = vm.Str = value => {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';
		if(value instanceof Float32Array) return 'Float32Array.of('+value.join(', ')+')';
		if(value.length) return JSON.stringify(value);
        if (typeof value === 'symbol') return value.toString();
        if (typeof value === 'function') return '[Function]';
		if (value instanceof WebGLTexture) return 'WebGLTexture';
		if (value instanceof vm.Tensor) return value.toString();
        if (typeof value === 'object'){
			//if(value.length) return String(value);
			//else{
				let s = '{';
				for(let key in value){
					console.log('key='+key);
					if(s.length>1) s += ',';
					s += key+': '+Str(value[key]);
				}
				return s+'}';
			//}
		}
		if(value.toString){
			return value.toString();
		}
        try {
            return 'THING';
        } catch (e) {
            return Object.prototype.toString.call(value);
        }
    };
	
	vm.timeOffset_ = performance.timing.navigationStart;
	//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
	vm.time = ()=>((vm.timeOffset_+performance.now())*.001);

    const Lamgl = vm.Lamgl = new Proxy(vm, {
        apply: (target, thisArg, args) => {
            //console.log('Proxy.apply target=' + target + ' thisArg=' + thisArg + ' args=' + args);
            return target.call(...args);
        },
        get: (target, prop, receiver) => {
            //console.log('Proxy.get target=' + Str(target) + ' prop=' + Str(prop) + ' receiver=' + Str(receiver));
			if (typeof prop === "symbol") {
                // Directly pass through all symbol accesses
                return target[prop];
            }
			// Access properties like 'doBasicTests'
            if (prop in target) {
                return target[prop];
            }
            return Reflect.get(target, prop, receiver);
            //return Reflect.get(target, prop, receiver);
        }
    });
	
	vm.caches = {type: 'lamgl_caches'};
	
	//if this is nonnull (a {}), then TinyGlsl.cache(key,lazyVal) puts stats into it when lazyVal is called but does not store the output of lazyVal here.
	//TODO This could get big so it waits for it to be set to {} externally (by a button in dagball normally)
	vm.cacheStats = null;
	
	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	vm.cache = function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = Lamgl.caches[key];
		if(val === undefined){
			//putTid: put a .tid field that is dagball.timeId() so can be deleted in same order as created (or reverse order?) Or might help in choosing the order in some cases?
			let startTime;
			if(Lamgl.cacheStats){
				startTime = Lamgl.time();
			}
			//val = Lamgl.caches[key] = Lamgl.putTid(lazyVal());
			val = Lamgl.caches[key] = lazyVal();
			if(Lamgl.cacheStats){
				let now = Lamgl.time();
				Lamgl.cacheStats[key] = Lamgl.cacheStats[key] || {};
				let duration = now-startTime;
				Lamgl.cacheStats[key].count = (Lamgl.cacheStats[key].count|0)+1;
				Lamgl.cacheStats[key].lastDurationEndTime = now;
				Lamgl.cacheStats[key].lastDuration = duration;
			}
		}
		return val;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.float32ArrayTranspose = (matBC,sizeB,sizeC)=>{
		let matCB = new Float32Array(sizeC*sizeB);
		for(let b=0; b<sizeB; b++) for(let c=0; c<sizeC; c++){
			matCB[c*sizeB+b] = matBC[b*sizeC+c];
		}
		return matCB;
	};
	
	vm.testNearEqualFloatArrays = (a,b,epsilon,comment)=>{
		if(a.length != b.length) Err('TEST FAIL Array lengths differ '+a.length+' '+b.length+', '+comment);
		for(let i=0; i<a.length; i++){
			let diff = Math.abs(a[i]-b[i]);
			if(diff > epsilon) Err('TEST FAIL at i='+i+' '+a[i]+' != '+b[i]+', diff='+diff+', epsilon='+epsilon+', '+comment);
		}
		console.log('Test pass, '+comment);
	};

    vm.doBasicTests = () => {
        console.log('START Lamgl.doBasicTests()');
		
		let testA = Lamgl({
			sh: [1, 1, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				void main(){
					gl_Position = vec4(0.,0.,0.,1.0);
					gl_PointSize = 1.0;
				}`,
            sf: `#version 300 es
				precision highp float;
				out vec4 result;
                void main(){
					result = vec4(2.,3.+4.,44.,55.);
                }`,
        });
		let correctA = Float32Array.of(2.,7.,44.,55.);
		let observedA = testA.result.get();
		//console.log('testA='+JSON.stringify(testA));
		console.log('testA='+Str(testA));
		console.log('correctA='+Str(correctA));
		console.log('observedA='+Str(observedA));
		vm.testNearEqualFloatArrays(observedA,correctA,0, 'one vec4');
		
		
		console.log('doBasicTests, Lamgl='+Lamgl);
		let arr = Lamgl(Float32Array.of(2,3,4,5.67,100,200,300,400),[1,2,4]);
		console.log('doBasicTests, arr='+arr);
        let testD = Lamgl({
			sh: [128, 128, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				flat out int vID;
				void main(){
					int idy = gl_VertexID>>7;
					int idx = gl_VertexID&127;
					//x and y go in range -1 to 1, +.5 so its in center of pixel and doesnt get dropped
					gl_Position = vec4((float(idx)+.5)/128.*2.-1., (float(idy)+.5)/128.*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					vID = gl_VertexID; //so sf can get it
				}`,
            sf: `#version 300 es
                precision highp float;
                layout(location = 0) out vec4 result;
				flat in int vID;
				uniform sampler2D someArray;
				//todo sampler2d or something called someArray
                void main(){
                    //result = vec4(gl_VertexID, 0., 0., 1.);
					float f = texelFetch(someArray, ivec2(vID&1,0), 0).x;
					result = vec4(float(vID), 7., f, 1.);
                }`,
			someArray: arr,
        });
		let correctD = new Float32Array(128*128*4);
		for(let y=0; y<128; y++) for(let x=0; x<128; x++){
			let i = (y*128+x)*4;
			let gl_VectorID = i/4;
			correctD[i] = gl_VectorID;
			correctD[i+1] = 7;
			correctD[i+2] = x&1 ? 100 : 2; //from Float32Array.of(2,3,4,5.67,100,200,300,400)
			correctD[i+3] = 1;
		}
		let observedD = testD.result.get();
		console.log('testD='+Str(testD));
		console.log('correctD='+Str(correctD));
		console.log('observedD='+Str(observedD));
		vm.testNearEqualFloatArrays(correctD,observedD,0, 'testD');
        
		
		
		/** from TinyGLSL
		let tenThousandFloatsOut = TinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), null, 1000, 10);
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		*/
		
		let tenThousandFloatsOut = Lamgl({
			sh:[100, 25, 4],
			sv:`#version 300 es
				precision highp float;
				flat out vec4 tempColor;
				float outFunc(int i){
					return float(i)*float(i); //ret = float(id)*float(id); like in TinyGLSL
				}
				const int height = 100;
				const int width = 25;
				void main(){
					int idy = gl_VertexID/width;
					int idx = gl_VertexID%width;
					gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					int i = gl_VertexID<<2;
					tempColor = vec4(outFunc(i), outFunc(i+1), outFunc(i+2), outFunc(i+3));
				}`,
			sf:`#version 300 es
                precision highp float;
				flat in vec4 tempColor;
				layout(location = 0) out vec4 result;
				void main(){
					result = tempColor; //copy from sv
				}`
		}).result.get();
		console.log('tenThousandFloatsOut='+[...tenThousandFloatsOut].map((x,i)=>('['+i+']='+x)).join(', '));
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		
		
		console.log('START test testMatmulAC');
		/*from TinyGLSL
		//testMatmulAC4 and testMatmulAC
		let sizeA = 512;
		let sizeB = 512;
		let sizeC = 512;
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');	
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			let testMatmulAC4_timeStart = TinyGlsl.time();
			let matCB = matBC; //FIXME
			let observed_testMatmulAC4 = null;
			try{
				observed_testMatmulAC4 = TinyGlsl.simple(
					'',
					`int sizeA = ${sizeA};
					int sizeBOver4 = ${sizeB/4};
					int sizeC = ${sizeC};
					int offsetMatAB = idx;
					int offsetMatBC = idy;
					for(int b=0; b<sizeBOver4; b++){
						ret0 += texelFetch(matAB,ivec2(b,offsetMatAB),0) *
							texelFetch(matCB,ivec2(b,offsetMatBC),0);
						//ret7 = vec4(7.);
					}`,
					Float32Array.of(0),
					{	matAB: TG(matAB,[sizeA,sizeB/4,4]),
						matCB: TG(matCB,[sizeC,sizeB/4,4])
					},
					sizeA,
					sizeC/4, //sizeC/32,
					4 //32
				);
				console.log('testMatmulAC4 test code incompletely written. todo fix it.');
				for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
			}finally{
				let secs = TinyGlsl.time()-testMatmulAC4_timeStart;
				console.log('testMatmulAC4 secs='+secs+' observed_testMatmulAC4.length='+observed_testMatmulAC4.length);
			}
		}*/
		let sizeA = 1024;
		let sizeB = 1024;
		let sizeC = 1024;
		let flopsPerMatmul = sizeA*sizeB*sizeC*2; //*2 cuz its add and multiply.
		
		/*let sizeA = 8;
		let sizeB = 8;
		let sizeC = 8;
		*/
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');
		let matABTensor = Lamgl(matAB,[sizeA,sizeB/4,4]);
		let matCBTensor = Lamgl(matCB,[sizeC,sizeB/4,4]);
		console.log('matABTensor='+matABTensor);
		console.log('matCBTensor='+matCBTensor);
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			let copyToCpuInMatmulTest = repeat_testMatmulAC4<5 || repeat_testMatmulAC4==9; //so we see its speed without that in later loops
			console.log('r='+repeat_testMatmulAC4+' copyToCpuInMatmulTest='+copyToCpuInMatmulTest);
			/*console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			console.log('matABTensor.get()[55]='+matABTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			console.log('matCBTensor.get()[55]='+matCBTensor.get()[55]); //TODO optimize: remove this its doing an extra gpu call
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163 Lamgl_036.html:1212:12
			matABTensor.get()[55]=129 Lamgl_036.html:1211:12
			matCBTensor.get()[55]=28163
			so the data is still in them.
			*/
			let testMatmulAC4_timeStart = vm.time();
			let observed_testMatmulAC4 = null;
			let observed_testMatmulAC4_map = null;
			try{
				let testMatmulAC4_sh = [sizeA, sizeC/4, 4];
				observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						flat out vec4 tempColor;
						void main(){
							int idy = gl_VertexID / width; // row (A)
							int idx = gl_VertexID % width; // column block (C/4)
							/*tempColor = vec4(
								dotProd(idy, idx*4+0),
								dotProd(idy, idx*4+1),
								dotProd(idy, idx*4+2),
								dotProd(idy, idx*4+3)
							);*/
							vec4 sums = vec4(1.); //vec4 sums = vec4(0);
							for (int b=0; b<sizeBOver4; b++){
								vec4 mul = texelFetch(matAB,ivec2(b,idy),0);
								sums += vec4(
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+0),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+1),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+2),0)),
									//*1.0000001 avoid returning all 0s, force it to to do some calculation
									//thats not from the textures, cuz the glsl optimizer is buggy.
									//dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.000001
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))
								);
							}
							tempColor = sums;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1.,
								(float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							//gl_PointSize = 1.0;
							gl_PointSize = 1.;
							//float sum1 = 0.;
							//float sum2 = 0.;
							//float sum3 = 0.;
							/*for (int b1=0; b1<sizeBOver4; b1++){
								vec4 ba = texelFetch(matAB,ivec2(b1,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b1,idx*4+1),0);
								sum1 += dot(ba, bc);
							}
							float sum2 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+2),0);
								sum2 += dot(ba, bc);
							}
							float sum3 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+3),0);
								sum3 += dot(ba, bc);
							}*/
							//tempColor = vec4(sum0, sum1, sum2, sum3);
						}`,
					sf: `#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main() {
							//result = tempColor;
							//result = tempColor/1.000001; //undo *1.0000001 (glsl optimizer bug)
							result = tempColor-1.; //undo +1 (glsl optimizer bug)
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});

				
				console.log('observed_testMatmulAC4_map='+observed_testMatmulAC4_map);
				if(copyToCpuInMatmulTest){
					observed_testMatmulAC4 = observed_testMatmulAC4_map.result.get();
					//FIXME what kind of transpose-like op goes here? let observed_testMatmulAC = vm.float32ArrayTranspose(observed_testMatmulAC4,size
					/*let cor = [...correct_testMatmulAC];
					for(let i=0; i<1000; i++){
						let ind = cor.indexOf(observed_testMatmulAC[i]);
						console.log('i='+i+' ind='+ind);
					}*/
					let cor = [...correct_testMatmulAC];
					let obs4 = [...observed_testMatmulAC4];
					for(let i=0; i<Math.min(100,correct_testMatmulAC.length); i++){
						console.log('i='+i+' cor='+correct_testMatmulAC[i]+'@'+obs4.indexOf(correct_testMatmulAC[i])+' obs4='+observed_testMatmulAC4[i]+'@'+cor.indexOf(observed_testMatmulAC4[i]));
					}
					let epsilon = (.3*sizeB)**2; //FIXME?
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, epsilon, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					//let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
					/*
					console.log('testMatmulAC4 test code incompletely written. todo fix it.');
					for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
					let numNonzero_observed_testMatmulAC4 = 0;
					for(let i=0; i<observed_testMatmulAC4.length; i++) if(observed_testMatmulAC4[i]) numNonzero_observed_testMatmulAC4++;
					console.log('numNonzero_observed_testMatmulAC4='+numNonzero_observed_testMatmulAC4);
					vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
					*/
				}
			}finally{
				let secs = vm.time()-testMatmulAC4_timeStart;
				let flopPerSec = flopsPerMatmul/secs;
				console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4+' testMatmulAC4 secs='+secs+' gigaflopPerSec(TODO get this up to 100 like in TinyGLSL)='+(flopPerSec/1e9)+' observed_testMatmulAC4.length='+(observed_testMatmulAC4?observed_testMatmulAC4.length:'undefined'));
				if(observed_testMatmulAC4_map) for(let k in observed_testMatmulAC4_map){
					let val = observed_testMatmulAC4_map[k];
					if(val instanceof vm.Tensor){
						val.free(); //return WebGLTexture to pool
					}
				}
			}
		}
		
		
        console.log('END Lamgl.doBasicTests()');
    };

    return vm.Lamgl;
	//console.log('Lamgl='+Lamgl);
	//console.log('Lamgl.doBasicTests='+Lamgl.doBasicTests);
	//requestAnimationFrame(() => { Lamgl.doBasicTests(); });
})();
</script>
</head><body>
	<table><tr><td style="color:#cccccc">
		Play BellSack. MOVE: left joystick and 2 triggers. TURN: right joystick.<br>
		EDIT TERRAIN: mouse drag the 5 colored knobs per circle/bell.<br>
		Save/load: TODO. Opensource MIT
		<input type=button onclick="Lamgl.doBasicTests()" value="Lamgl.doBasicTests()">
	</td></tr><tr><td>
		<canvas id="glCanvas" width="640" height="480"></canvas>
	</td></tr><tr><td>
		<div id=ballOverlay style="color:#cccccc">balls...</div>
	</td></tr></table><br>
</body>
</html>