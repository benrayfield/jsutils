<!DOCTYPE html><html><head><script>
/*Releasing LamGL (028) opensource MIT, my newest GPU API that runs in browsers.
It comes after TinyGLSL, upgrades to do calculations in GPU memory without copying to CPU. Stores tensors
in WebGLTexture's. Call GPU as a single function Lamgl({...})=>{...}.
https://github.com/benrayfield/jsutils/blob/master/src/lamgl/Lamgl_028.html

Avoid these bugs in WebGL2 GLSL ES 300:
-- If you texelFetch the same address twice in the same GPU thread, you'll get all 0s.
-- Some GLSL optimizers are buggy so u have to make sure some code happens like this sometimes:
	//*1.0000001 avoid returning all 0s, force it to to do some calculation
	//thats not from the textures, cuz the glsl optimizer is buggy.
	dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.0000001
*/
const Todo = str => { throw new Error(str || 'TODO'); };
const Err = str => { throw new Error(str || '(Err with no message)'); };
let VM = null; //FIXME get this from Lamgl.vm
const Lamgl = (() => {
    const vm = function(){}; //Proxy of this (Lamgl) can only be called as function if this is a function
	VM = vm;

    vm.jsType = x => (ArrayBuffer.isView(x) ? x.constructor.name : typeof(x));

    vm.call = (param,optionalSh)=>{
		//if(typeof(param) == 'object'){
		if(param.sv || param.sf){
			return vm.callGPU(param);
		}else{
			return vm.wrap(param,optionalSh);
		}
    };
	
	vm.callGPU = map=>{
		let gl = vm.Gl();
		let sv = map.sv || '//FIXME no sv'; //vertex shader code
		let sf = map.sf || '//FIXME no sf'; //fragment shader code
		
		console.log('sv='+map.sv);
		console.log('sf='+map.sf);
		
		let sh = map.sh; //[height, width, 4] or maybe [zSize, height, width, 4] etc
		/*
		//TODO zSize for 3d pics?
		let h = map.h; //height, unless map.n is a [] list like [height width 4] or [zSize height width 4] etc.
		let w = map.w; //width, unless that
		let q = map.q || 4; //floats per GPU thread (or maybe per texture?)
		let sh = map.sh || [h, w, q]; //shape of tensor
		//in case there is zSize or what should it be called?
		if(!h) h = sh[n.length-3];
		if(!w) w = sh[n.length-2];
		if(!q) w = sh[n.length-1];
		*/
		
		let cacheKeySuffix = '_SV['+sv+']_SF['+sf+']_SH['+vm.Str(sh)+']';
		
		let glvars = vm.glvars(map);
		console.log('glvars=[[['+glvars.join('\n')+']]]');
		
		//If a memsIn's Tensor has fr/free of 1, then it uses an optimization of
		//its WebGLTexture being both in and out (in memsIn and memsOut)
		//since its, kind of in this higher level, garbage collected and reused at once,
		//based on that Tensor is immutable and Mem/WebGLTexture is mutable.
		//During this, mem.tensor should be null, and at end, create new Tensor(mem)
		//for each memsOut. Creating a tensor just wraps the Mem, doesnt copy contents,
		//and is still backed by GPU memory.
		let memsIn = []; //contains nulls where u dont use them
		let memsOut = []; //contains nulls where u dont use them
		//for each index in mems*, memsIn or memsOut or both have it.
		
		let tensorsToDecrementFreeAtEnd = [];
		
		for(let i=0; i<glvars.length; i++){
			let glvar = glvars[i];
			console.log('glvars looping, i='+i+' '+glvar);
			let isIn = glvar.isIn(), isOut = glvar.isOut();
			if(isIn){
				if(isOut) Err('Cant be both in and out: '+glvar);
				console.log('START isIn, glvar='+glvar);
				let tensorIn = map[glvar.name];
				if(!tensorIn) Err('No tensorIn for '+glvar);
				tensorsToDecrementFreeAtEnd.push(tensorIn);
				memsIn[i] = tensorIn.mem; //read-only and immutable
				console.log('END isIn, glvar='+glvar+', memsIn['+i+'] = '+tensorIn+' of name '+glvar.name+' texture='+ tensorIn.mem.mut);
			}else if(isOut){ //isOut
				console.log('START isOut, glvar='+glvar);
				
				
				//Cant do it as "const canReuseTexture = firstStateTensor.fr === 1;" cuz requires checking if
				//firstStateTensor exists cuz its an optional param. for each output, it optionally is also a param
				//for the starting state of the output memory, which gl_Position can sparsely write on top of.
				let firstStateTensor = map[glvar.name]; //if this doesnt exist, start with an empty state.
				//the optimization this whole LamGL software is based on,
				//that allows it to be completely stateless/immutable Tensors
				//that share and reuse GPU memory without copying back to CPU
				//except as needed after 1 or many GPU calls.
				let doSharedTextureOptimization = false;
				if(firstStateTensor){
					console.log('isOut: map.'+glvar.name+' exists so using it as the starting state (firstStateTensor) of that texture/GPUMemory. If its .fr/free is 1, will do the optimization to reuse that texture, else will copy it first.');
					doSharedTextureOptimization = firstStateTensor.fr==1;
					//TODO firstStateTensor.useFree() at end. cant free it yet.
				}
				
				/*if(firstStateTensor && doSharedTextureOptimization){ //use 1 texture as if it was 2
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else if(firstStateTensor){ //use 2 textures, copy-on-write
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					memsOut[i] = firstStateTensor.copy().mem;
				}else{ //no firstStateTensor, start with empty memory
					memsOut[i] = vm.gpuMalloc(map.sh); // assumes `map.sh` is the desired shape
				}*/
				
				if(firstStateTensor){
					if(doSharedTextureOptimization){
						//garbage collect immutable tensor so can reuse texture/mem
						firstStateTensor.tensor = null;
						memsOut[i] = firstStateTensor.mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=TRUE, memsOut['+i+'] = '+firstStateTensor+' of name '+glvar.name);
					}else{
						//firstStateTensor.fr is big enuf its not garbage collected,
						//so this (after copy) is the last we use it in this call of callGPU.
						//Instead, we copy it to another texture/mem and use that as output,
						//including that its a mutable texture during writing it,
						//as it has its previous contents and wherever gl_Position
						//sparsely writes voxels over it.
						//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
						//depending on if its a 2d or 3d texture),
						//and write 1-8 vec4s there, 1 vec4 written to each output texture,
						//and gl has a limit of at most 8 output textures (normally just 1).
						//firstStateTensor.useFree(); //decrement firstStateTensor.fr
						tensorsToDecrementFreeAtEnd.push(firstStateTensor);
						//new GPU mem. starts with high .fr
						memsOut[i] = firstStateTensor.copy().mem;
						console.log('yes firstStateTensor, doSharedTextureOptimization=FALSE, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					}
				}else{
					memsOut[i] = vm.gpuMallocMem(sh);
					console.log('no firstStateTensor, memsOut['+i+'] = COPY '+firstStateTensor+' of name '+glvar.name);
					if(memsOut[i].tensor) Err('gpuMallocMem gave Mem with a tensor');
				}
				
				/*
				Todo('there might be 3 cases, do optimization, dont do optimization, where there is .fr>1 so still gotta copy, and where there is .fr==1 so reuse it (the optimization). some combo of those');
				if(doSharedTextureOptimization){ //use 1 texture as if it was 2
					Todo('this might be wrong, check [there might be 3 cases]');
					//garbage collect immutable tensor so can reuse texture/mem
					firstStateTensor.tensor = null;
					memsOut[i] = firstStateTensor.mem;
				}else{ //use 2 textures, copy-on-write
					Todo('this might be wrong, check [there might be 3 cases]');
					//firstStateTensor.fr is big enuf its not garbage collected,
					//so this (after copy) is the last we use it in this call of callGPU.
					//Instead, we copy it to another texture/mem and use that as output,
					//including that its a mutable texture during writing it,
					//as it has its previous contents and wherever gl_Position
					//sparsely writes voxels over it.
					//Each vertex/GPUThread can choose 1 address (ivec2 or ivec3
					//depending on if its a 2d or 3d texture),
					//and write 1-8 vec4s there, 1 vec4 written to each output texture,
					//and gl has a limit of at most 8 output textures (normally just 1).
					//firstStateTensor.useFree(); //decrement firstStateTensor.fr
					tensorsToDecrementFreeAtEnd.push(firstStateTensor);
					//new GPU mem. starts with high .fr
					memsOut[i] = firstStateTensor.copy().mem;
				}
				*/
				
				console.log('END isOut, glvar='+glvar+', memsOut['+i+'] = Tensor '+glvar.name+', GPU texture ='+memsOut[i].mut);
			}else Err('Is not in or out: '+glvar+' FIXME what if its an input of fragment shader (sf) which comes after vertex shader (sv).');
		}
		console.log('Got '+memsIn.filter(x=>!!x).length+' ins and '+memsOut.filter(x=>!!x).length+' outs, excluding nulls/undefineds in memsIn and memsOut lists.');
		//Todo();
		
		//todo remove this double loop. also, does doSharedTextureOptimization allow them to be both in and out in some cases?
		console.log('--- Checking input/output GPU memory overlap ---');
		for (let i = 0; i < memsIn.length; i++) {
			const memIn = memsIn[i];
			if (!memIn) continue;
			for (let j = 0; j < memsOut.length; j++) {
				const memOut = memsOut[j];
				if (!memOut) continue;
				if (memIn.mut === memOut.mut) {
					console.warn(`ERR, ⚠️ memsIn[${i}] and memsOut[${j}] share the SAME WebGLTexture!`, memIn.mut);
				}else{
					console.warn(`OK memsIn[${i}] and memsOut[${j}]`);
				}
			}
		}
		console.log('--- End check ---');

		
		let program = vm.cache('program'+cacheKeySuffix, function(){
			let vertexShader = vm.cache('vertexShader'+cacheKeySuffix, function(){
				sv = vm.preprocessShaderString(sv); //add line numbers etc
				let v = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(v, sv);
				gl.compileShader(v);
				if(!gl.getShaderParameter(v, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(v)+'\n\nVERTEXSHADERCODE:\n'+sv);
				}
				return v;
			});
			console.log('vertexShader='+vertexShader);
			let fragmentShader = vm.cache('fragmentShader'+cacheKeySuffix, function(){
				sf = vm.preprocessShaderString(sf); //add line numbers etc
				const f = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(f, sf);
				gl.compileShader(f);
				if(!gl.getShaderParameter(f, gl.COMPILE_STATUS)){
					throw new Error(gl.getShaderInfoLog(f)+'\n\nFRAGMENTSHADERCODE:\n'+sf);
				}
				return f;
			});
			console.log('fragmentShader='+fragmentShader);
			const p = gl.createProgram();
			gl.attachShader(p, vertexShader);
			gl.attachShader(p, fragmentShader);
			gl.linkProgram(p);
			if(!vm.skip_gl_getProgramParameter_LINK_STATUS && !gl.getProgramParameter(p, gl.LINK_STATUS)){
				Err(gl.getProgramInfoLog(p));
			}
			return p;
		});
		console.log('program='+program);
		
	
		
		let ret = {};
		
		//nTextures are outputs, not inputs. 1-8 textures of float or vec4 per pixel each.
		
		/*if(nTextures.length > 1){
			//Specify the draw buffers for multiple render targets
			const attachments = nTextures.map((_, index) => gl.COLOR_ATTACHMENT0 + index);
			gl.drawBuffers(attachments);
		}*/
		let texturesOut = [];
		for(let mem of memsOut) if(mem) texturesOut.push(mem.mut);
		
		let framebuffer = vm.cache('framebuffer'+cacheKeySuffix, function(){
			const f = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, f);
			for(let i=0; i<texturesOut.length; i++){
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, texturesOut[i], 0);
			}
			return f;
		});
		
				
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		//gl.clearColor(0, 0, 0, 0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		gl.viewport(0, 0, width, height);
		gl.useProgram(program);
		
		if(texturesOut.length){
			const attachments = texturesOut.map((_,i)=>(gl.COLOR_ATTACHMENT0+i));
			gl.drawBuffers(attachments); 
			//gl.drawBuffers(texturesOut);
		}
		
		
		// === Bind sampler2D uniforms ===
		let nextTextureUnit = 0;
		for (let i = 0; i < glvars.length; i++) {
			const glvar = glvars[i];
			if (!glvar.isInTex()) continue;    // only bind texture inputs

			const mem = memsIn[i];
			if (!mem) continue;

			gl.activeTexture(gl.TEXTURE0 + nextTextureUnit);
			gl.bindTexture(gl.TEXTURE_2D, mem.mut);

			const loc = gl.getUniformLocation(program, glvar.name);
			if (loc !== null) {
				gl.uniform1i(loc, nextTextureUnit);
			}
			nextTextureUnit++;
		}

		
		
		//=== run shader for every pixel/voxel using gl_VertexID ===
		let numVerts = 1;
		for(let d = 0; d < sh.length - 1; d++){   // multiply all dims except the last (==4)
			numVerts *= sh[d];
		}
		gl.drawArrays(gl.POINTS, 0, numVerts);    // no VBO needed – gl_VertexID drives the math

		//=== wrap each output Mem in an immutable Tensor and expose it ===
		for(let i=0; i<glvars.length; i++){
			if(glvars[i].isOut() && memsOut[i]){
				let t = memsOut[i].tensor || new vm.Tensor(memsOut[i]);
				memsOut[i].tensor = t;            // back-link for texture pooling
				ret[glvars[i].name] = t;          // e.g. ret.result
			}
		}

		
		//for(let i=0; i<nTextures.length; i++){
		//}
		
		
		

		//gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		
		/*for(let i=0; i<nTextures.length; i++){ //1-8 textures out
			let colorAttachmentI = gl.COLOR_ATTACHMENT0+i;
			gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachmentI, gl.TEXTURE_2D, nTextures[i], 0);
		}*/

		/*if(floatsOutPerPixel == 1){
			//copy from GPU (texture or renderbuffer) to CPU (outarr)
			gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RED, gl.FLOAT, outarr); //getting gl.RED only uses EXT_color_buffer_float (which may exist only in desktop browsers not mobile?)
			//console.log('outarr[2345]='+outarr[2345]);
		}else if(floatsOutPerPixel == 4){
			//copy from GPU (texture or renderbuffer) to CPU (outarr)
			gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, outarr);
		}else{
			console.log('Experimental floatsOutPerPixel='+floatsOutPerPixel+' gl.readPixels '+nTextures.length+' times...');
			let pixelData = new Float32Array(outarr.length/nTextures.length);
			let numPixels = canvasHeight*canvasWidth;
			if(pixelData.length != numPixels*4) Err('Sizes dont match');
			// Iterate over each texture
			for(let i=0; i<nTextures.length; i++){
				let colorAttachmentI = gl.COLOR_ATTACHMENT0+i;
				gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachmentI, gl.TEXTURE_2D, nTextures[i], 0);
				gl.readBuffer(colorAttachmentI);
				gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, pixelData);

				//Interleave the pixel data into outarr
				for(let p = 0; p < numPixels; p++){
					//Start index in outarr for this pixel
					let baseIndex = p * floatsOutPerPixel;
					//Index in pixelData where the current texture's data starts for this pixel
					let textureBaseIndex = p * 4;  // 4 floats per pixel per texture

					//Copy the data from pixelData to the correct position in outarr
					for(let j=0; j<4; j++) {  // 4 floats from the current texture
						outarr[baseIndex + i * 4 + j] = pixelData[textureBaseIndex + j];
					}
				}
			}
			//gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.FLOAT, outarr);
			//throw 'floatsOutPerPixel='+floatsOutPerPixel+' but must be 1 or 4';
		}*/
		
		
		
		
		/*let nextTextureUnit = 0;
		for(let uniformName in bigMem){
			let tensor = bigMem[uniformName];
			//let tex = texturesToUseOnce[uniformName];
			let tex = texturesToUseOnce[uniformName] = gl.createTexture();
			//TODO let tex = texturesToUseOnce[uniformName] = TinyGlsl.cache(
			//TODO 	'tex_'+uniformName+cacheKeySuffix,
			//TODO 	()=>{
			//TODO 		let tex = gl.createTexture();
					if(!tex) Err('No texture for uniformName='+uniformName);
					console.log('uniformName='+uniformName+' tensor='+tensor);
					// Now query the shader program for a uniform with the same name.
					let loc = gl.getUniformLocation(program, uniformName);
					console.log('loc='+loc);
			
					if(loc !== null){
						// Bind this texture to the next available texture unit.
						gl.activeTexture(gl.TEXTURE0+nextTextureUnit);
						console.log('loc='+loc);
						//console.log('tensor.g='+tensor.g);
						console.log('tex='+tex+' (not tensor.g cuz thats for future upgrades in TinyGlsl.tensor({...call...}))');
						//gl.bindTexture(gl.TEXTURE_2D, tensor.g);
						gl.bindTexture(gl.TEXTURE_2D, tex);
						// For texelFetch we need exact texel values, so set filtering to NEAREST.
						// Even though texelFetch ignores filtering, these parameters are required to make
						// the texture complete in WebGL.
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						// Set wrapping mode to CLAMP_TO_EDGE to prevent unintended repeats.
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						// Tell the shader that the sampler uniform should use this texture unit.
						console.log('nextTextureUnit='+nextTextureUnit);
						gl.uniform1i(loc, nextTextureUnit);
						// Optionally, if your shader wants the texture's dimensions, pass them as a vec2
						// using a uniform named uniformName+"Size".
						//let sizeLoc = gl.getUniformLocation(program, uniformName + "Size");
						//console.log('sizeLoc='+sizeLoc);
						//if (sizeLoc !== null){
						//	gl.uniform2i(sizeLoc, tensor.sh[1], tensor.sh[0]); // width, height
						//	console.log('gl.uniform2i '+sizeLoc+' '+tensor.sh[1]+' '+tensor.sh[0]);
						//}
						gl.texImage2D(
							gl.TEXTURE_2D,
							0,                // level
							gl.RGBA32F,       // internal format (32-bit floats per channel)
							tensor.sh[1],     // width (second element of shape)
							tensor.sh[0],     // height (first element of shape)
							0,                // border
							gl.RGBA,          // format
							gl.FLOAT,         // type
							tensor.c          // data from the CPU array
						);
						nextTextureUnit++;
					}
					//TODO return tex;
				//TODO }
			//TODO );
		}*/
		
		/*Consider 2 cases, if its done by 2 triangles forming a rectangle covering an area,
		vs only by gl_VertexID (drawArrays).
		
		list the GL objects needed either way:
		* canvas
		* gl
		* program
		* vertexShader
		* fragmentShader
		* nTextures
		* framebuffer (attachments is optional)
		//* loc_locationOfUniformAndOtherParams
		//* float32arrayInCpu_someToReadFrom_someToWriteTo
		
		
		list the extra GL objects needed for the 2 triangles (but not if only gl_VertexID):
		* positionBuffer
		("You can skip this entirely by using gl_VertexID to generate full-screen geometry. This is how you're doing it in LamGL’s test shader, which is ideal." --GPT4o)
		
		*/
		
		
		
		//Todo();
		/*
		vm.cache('sv'
		
		
	
		vm.cache = function(key, lazyVal){
		Todo();
		*/
		
		for(let tensor of tensorsToDecrementFreeAtEnd){
			//decrement tensor.fr and if its 0 return its texture/mem to pool
			tensor.useFree();
		}
		
		return ret;
	};
	
	vm.preprocessShaderString = code=>{
		return vm.addLineNumbers(code);
	};
	
	//This is for lines like "out vec4 result; //comment".
	//TODO? eltype is element type, like 'vec4' or 'float' or 'int',
	//regardless of its an array/texture vs one primitive.
	vm.GLVar = function(memType, glType, name){
		this.memType = memType;
		this.glType = glType;
		this.name = name;
	};
	
	/*vm.GLVar.prototype.isIn = function(){
		
	};
	
	vm.GLVar.prototype.isInTex = function(){
		
	};
	
	vm.GLVar.prototype.isOutTex = function(){
		return this.memType=='out';
	};
	
	vm.GLVar.prototype.isOut = function(){
		return this.isOutTex();
	};*/
	
	vm.GLVar.prototype.isIn = function(){
		// Treat uniforms and varying inputs (from vertex shader) as inputs
		return this.memType === 'uniform' || this.memType === 'in';
	};

	vm.GLVar.prototype.isInTex = function(){
		// A sampler2D, samplerCube, etc., in a uniform is a texture input
		return this.memType === 'uniform' && this.glType.startsWith('sampler');
	};

	vm.GLVar.prototype.isOutTex = function(){
		// Fragment outputs (out vec4 ...) are the only texture outputs
		return this.memType === 'out';
	};

	vm.GLVar.prototype.isOut = function(){
		// Alias to isOutTex for now, but leaves room to generalize later
		return this.isOutTex();
	};

	
	vm.GLVar.prototype.toString = function(){
		return '[GLVar memType='+this.memType+' glType='+this.glType+' name='+this.name+']';
	};
	
	//returns [] list of GLVar's in the order they should be used in gl.
	//map.sv is string of vertex shader code, sf fragement shader,
	//(todo if one of those is not given use or generate some default?).
	/*vm.glvars = map=>{
		Todo();
	};*/
	vm.glvars = map => {
		const glvars = [];

		const parseShaderVars = (shaderSrc, isVertexShader) => {
			const lines = shaderSrc.split('\n');
			for (let line of lines) {
				line = line.trim();

				// Ignore comments
				if (line.startsWith('//')) continue;

				let isIn = false;
				let memType = null, glType = null, name = null;

				// Handle uniform
				let matchUniform = line.match(/^uniform\s+(\w+)\s+(\w+);/);
				if (matchUniform) {
					glType = matchUniform[1];
					name = matchUniform[2];
					memType = 'uniform';
					isIn = true;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle in/out (varyings, fragment outputs, etc.)
				let matchIO = line.match(/^(in|out)\s+(\w+)\s+(\w+);/);
				if (matchIO) {
					let qualifier = matchIO[1];
					glType = matchIO[2];
					name = matchIO[3];
					memType = qualifier;
					isIn = (qualifier === 'in');
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}

				// Handle layout(...) out vec4 NAME;
				let matchLayoutOut = line.match(/^layout\s*\(.*?\)\s*out\s+(\w+)\s+(\w+);/);
				if (matchLayoutOut) {
					glType = matchLayoutOut[1];
					name = matchLayoutOut[2];
					memType = 'out';
					isIn = false;
					glvars.push(new vm.GLVar(memType, glType, name, isIn));
					continue;
				}
			}
		};

		if (map.sv) parseShaderVars(map.sv, true);
		if (map.sf) parseShaderVars(map.sf, false);

		return glvars;
	};
	
	//vm.Str = 
	
	//TODO make a way to call Lamgl({...}) that takes a string of js code that generates
	//the Float32Array or Mem/texture contents in CPU.
	//Maybe name it sj (j for javascript) like sv (vertex shader) and sf (fragment shader).
	//A tensor could be more general, in cpu mem or gpu mem.
	
	vm.wrap = (wrapMe,optionalSh)=>{
		if(wrapMe instanceof Float32Array){
			let sh = optionalSh || [wrapMe.length>>2, 4]; //FIXME what if its not a multiple of 4?
			let mem = vm.gpuMallocMem(sh);
			mem.set(wrapMe); //copy from CPU (Float32Array wrapMe) to GPU (WebGLTexture in mem.mut)
			return new vm.Tensor(mem);
		}else Err('wrapMe is a '+typeof(wrapMe));
	};
	
		//immutable, normally exists in a Mem. Is same shape as that mem.
	vm.Tensor = function(mem,optionalFr){
		this.mem = mem;
		this.sh = mem.sh;
		//countdown until garbcol. Each time its read in GPU,
		//this is decremented. When it reaches 0, vm.gpuFree(this)
		//is called to return that GPU memory to the pool.
		this.fr = optionalFr || vm.defaultFr;
	};
	
	vm.Tensor.prototype.toString = function(){
		return '[Tensor sh='+JSON.stringify(this.sh)+']';
	};
	
	//return a Float32Array copy of the WebGLTexture in the mem backing this Tensor
	vm.Tensor.prototype.get = function(){
		return this.mem.get();
	};
	
	//Returns this Tensor with fr set.
	//Like, vm.gpuMalloc([300,500,4]).free(1) is a Tensor that will free
	//its WebGLTexture (back to the vm.texPool) after the next GPU call.
	//if optionalFr is not given or is 0, frees now.
	//If its 1, frees on the next use (1 more GPU call),
	//fr decreases by 1 each GPU call.
	vm.Tensor.prototype.free = function(optionalFr){
		this.fr = optionalFr|0;
		if(!this.fr){
			vm.gpuFree(this); //free the WebGLTexture but not the js object
		}
		return this;
	};
	
	vm.Tensor.prototype.free = function(optionalFr){
		Todo();
	};
	
	//use 1 more fr in the countdown, toward garbage collecting the WebGLTexture at this.fr==0,
	//but only back into the vm.texPool pool, not deleting it out of the GPU
	//(todo also that if its not used for a while and the GPU memory is needed).
	vm.Tensor.prototype.useFree = function(){
		if(this.fr){
			this.fr--;
			if(!this.fr){
				vm.gpuFree(this); //free the WebGLTexture but not the js object
			}
		}
	};
	
	//For if sh.length==2, not sure if we even have 1d textures in this version of webgl. Get flattened index.
	vm.Tensor.prototype.ii = function(x, w){
		return x*this.sh[0]+w;
	};

	//For if sh.length==3 like a 2d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iii = function(y, x, w){
		return (y*this.sh[0]+x)*this.sh[1]+w;
	};

	//For if sh.length==4 like a 3d texture of vec4 per pixel. Get flattened index.
	vm.Tensor.prototype.iiii = function(z, y, x, w){
		return z*this.sh[0]+(y*this.sh[1]+x)*this.sh[2]+w
	};
	
	vm.texPool = {};
	
	vm.verifyShEndsWithVec4 = sh=>{
		if(sh[sh.length-1] != 4) Err('Last dimension is not 4: '+Str(sh));
	};
	
	//returns a Tensor wrapping a Mem wrapping a WebGLTexture,
	//instead of that Mem. Tensor is immutable. Mem is mutable.
	//The Tensor contains whatever data was in WebGLTexture (malloc, not calloc).
	vm.gpuMallocTensor = sh=>(new vm.Tensor(vm.gpuMallocMem(sh)));
	
	//Example: vm.gpuMalloc([300,500,4]) returns a Mem.
	//allocate a texture of a chosen sh/shape from pool, in GPU mem.
	//Returns a Mem instance wrapping a WebGLTexture of 2d or 3d,
	//normally with 4 floats per pixel (vec4) as sh[sh.length-1] is normaly 4.
	//This is specificly a malloc, not calloc, as it doesnt clear the mem.
	//Only the first use of a WebGLTexture is cleared,
	//but after that it can be returned to the pool and reallocated without clearing,
	//but it should be written before read again.
	vm.gpuMallocMem = sh=>{
		vm.verifyShEndsWithVec4(sh);
		let k = vm.shKey(sh);
		//list of Mem's whose mem.sh contents equal.
		let list = vm.texPool[k] || (vm.texPool[k] = []);
		if(list.length){
			return list.pop();
		}else{
			let tex = null;
			if(sh.length==3 && sh[2]==4){
				//2d WebGLTexture with vec4 per pixel
				tex = vm.makeGLTexture2dVec4(sh[0], sh[1]);
			}else if(sh.length==3 && sh[2]==4){
				Todo('new 3d WebGLTexture (vec4 per pixel) of that sh='+Str(sh));
			}else{
				Todo('new WebGLTexture of that sh='+Str(sh));
			}
			return new vm.Mem(tex, sh);
			//return new vm.Tensor(new vm.Mem(tex, sh));
		}
	};
	
	//Example:  mem is what a vm.gpuMalloc returned.
	vm.gpuFreeMem = mem=>{
		Todo();
	};
	
	vm.shKey = sh=>sh.join('_');
	
	//mutable. wraps WebGLTexture and maybe Float32Array.
	//shape is [z,y,x,4] or [y,x,4] or [y,x,1] or [500] etc.
	vm.Mem = function(mutableMem, shape){
		this.mut = mutableMem;
		this.sh = shape;
		this.tensor = null; //this Mem is in the pool when this.tensor is null.
	};
	
	vm.mulAll = function(vec){
		let ret = 1;
		for(let num of vec) ret *= num;
		return ret;
	};
	
	vm.Mem.prototype.size = function(){
		return vm.mulAll(this.sh);
	};
	
	//copy gpu to cpu
	vm.Mem.prototype.get = function(optionalFloat32Array){
		let size = this.size();
		let ret = optionalFloat32Array || new Float32Array(size);
		vm.copyTextureToFloat32Array(this.mut,this.sh,ret); //GPU
		return ret;
	};
	
	/*vm.copyTextureToFloat32Array = (tex,floatsOut)=>{
		Todo();
	};*/
	vm.copyTextureToFloat32Array = (tex, sh, floatsOut) => {
		if(sh.length != 3) Todo('sh.length=='+sh.length);
		const gl = vm.Gl();

		// Assume the texture is 2D and in RGBA32F format
		// Find the dimensions from floatsOut.length and assume vec4 per pixel
		let totalFloats = floatsOut.length;
		let height = sh[0];
		let width = sh[1];
		let pixels = totalFloats/sh[2];
		
		//FIXME sh.length-4 is zSize in 3d texture. should i reverse this?
		//let height = sh[sh.length-3], width = sh[sh.length-2], floatsPerPixel = sh[sh.length-1];
		
		/*let pixels = totalFloats / 4;
		let width = Math.ceil(Math.sqrt(pixels));
		let height = Math.ceil(pixels / width); //TODO choose width and height better
		*/

		// Create a temporary framebuffer and attach the texture to it
		const framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.viewport(0, 0, width, height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

		let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			// Clean up before erroring out
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.deleteFramebuffer(framebuffer);
			Err('Framebuffer not complete: ' + status);
		}

		// Read pixels from the framebuffer into the Float32Array
		gl.readPixels(
			0, 0, width, height,
			gl.RGBA, gl.FLOAT,
			floatsOut
		);

		// Clean up
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(framebuffer);
	};
	
	vm.skip_gl_getProgramParameter_LINK_STATUS = false; //2024-5-9-640pET defaulting this to false (dont skip) cuz of I turned SKLT=F (dont skip) by clicking the button and this neuralnet nnet_1715286589.548.dagball compiled in about .1 second when I changed {nodes 12} to {nodes 13}.
	//skip_gl_getProgramParameter_LINK_STATUS: true, //normal as of 2024-5-9 cuz it made compiling GLSL alot faster, probably some thread thing it didnt have to wait on, considering theres multiple off-screen canvases.
	//skip_gl_getProgramParameter_LINK_STATUS: false, //normal before 2024-5-9, but TODO experimentally trying skipping it cuz this line takes .1 to 20 seconds and is likely causing threads to wait on eachother
	//skip_gl_getProgramParameter_LINK_STATUS: true, //for testing, or maybe it will work out this way?
	
	//copy cpu to gpu
	vm.Mem.prototype.set = function(float32Array){
		vm.copyFloat32ArrayToTexture(float32Array,this.mut,this.sh);
	};
	
	// --- CPU → GPU upload ----------------------------------------------
	vm.copyFloat32ArrayToTexture = (src, tex, sh) => {
		// sh is the tensor shape that texture represents, e.g. [h, w, 4]
		if (!sh || sh.length !== 3 || sh[2] !== 4) {
			Err('copyFloat32ArrayToTexture: shape must be [height,width,4]');
		}
		const gl     = vm.Gl();
		const height = sh[0];
		const width  = sh[1];

		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texSubImage2D(
			gl.TEXTURE_2D,
			0,                 // level
			0, 0,              // x-offset, y-offset
			width, height,     // size
			gl.RGBA,           // format
			gl.FLOAT,          // type
			src                // the Float32Array with 4*width*height values
		);
	};

	// --- modify the setter so the helper receives the shape -------------
	vm.Mem.prototype.set = function (float32Array) {
		vm.copyFloat32ArrayToTexture(float32Array, this.mut, this.sh);
	};

	
	vm.webglType = 'webgl2'; //If you change this from 'webgl2' to 'webgl', some features wont be there and it will break.
	vm.glslVersionString = '#version 300 es'; //WebGL2 GLSL ES 300
	
	vm.gl = null; //the only GL instance, normally WebGL2 GLSL ES 300
	vm.glCanv = null;
	vm.glCanvasHeight = 1; //1x1 canvas, cuz gonna use gl_VertexID instead of 2 triangles that form a rectangle covering the canvas
	vm.glCanvasWidth = 1;
	vm.Gl = ()=>{
		if(!vm.gl){
			let c = document.createElement("canvas");
			c.setAttribute("height", ''+vm.glCanvasHeight);
			c.setAttribute("width", ''+vm.glCanvasWidth);
			c.addEventListener('webglcontextlost', function(event){
				//event.preventDefault();
				//activeContexts.delete(context);
				console.log('TinyGLSL says canvas event webglcontextlost, event='+event);
				if(TinyGlsl.do_clearAllCache_whenWebglContextLost){
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost STARTING TinyGlsl.clearAllCache()...');
					TinyGlsl.clearAllCache();
					console.log('TinyGlsl.do_clearAllCache_whenWebglContextLost DONE TinyGlsl.clearAllCache().');
				}
			}, false);
			vm.glCanv = c;
			
			let gl = vm.glCanv.getContext(vm.webglType);
			let glErr = gl.getError();
			if(glErr) Err('after canvas.getContext(TinyGlsl.webglType), gl.getError()='+glErr);
			if(!gl.getExtension('EXT_color_buffer_float')){ //this turns the extension on. its not just checking if it exists.
				Err('EXT_color_buffer_float not supported so cant return 1 or 4 floats per pixel instead of bytes');
			}
			let isContextLost = gl.isContextLost();
			console.log('creating gl context, gl.isContextLost()=='+isContextLost);
			if(isContextLost) Err('gl.isContextLost()=='+isContextLost+
				', see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/isContextLost');
			console.log('Returning new webgl context '+gl);
			vm.gl = gl;
		}
		return vm.gl;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.makeGLTexture2dVec4 = (height, width, optionalFloat32Array)=>{
		let gl = vm.Gl();
		let t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		let floats = optionalFloat32Array || null;
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, floats);
		gl.texImage2D(
			gl.TEXTURE_2D,
			0,
			gl.RGBA32F,
			width,
			height,
			0,
			gl.RGBA,
			gl.FLOAT,
			floats
		);
		return t;
	};
	
	vm.defaultFr = 1<<30;
	
	vm.vm = vm; //so Lamgl.vm is vm. Lamgl is a Proxy

    let Str = vm.Str = value => {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';
		if(value instanceof Float32Array) return 'Float32Array.of('+value.join(', ')+')';
		if(value.length) return JSON.stringify(value);
        if (typeof value === 'symbol') return value.toString();
        if (typeof value === 'function') return '[Function]';
		if (value instanceof WebGLTexture) return 'WebGLTexture';
		if (value instanceof vm.Tensor) return value.toString();
        if (typeof value === 'object'){
			//if(value.length) return String(value);
			//else{
				let s = '{';
				for(let key in value){
					console.log('key='+key);
					if(s.length>1) s += ',';
					s += key+': '+Str(value[key]);
				}
				return s+'}';
			//}
		}
		if(value.toString){
			return value.toString();
		}
        try {
            return 'THING';
        } catch (e) {
            return Object.prototype.toString.call(value);
        }
    };
	
	vm.timeOffset_ = performance.timing.navigationStart;
	//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
	vm.time = ()=>((vm.timeOffset_+performance.now())*.001);

    const Lamgl = vm.Lamgl = new Proxy(vm, {
        apply: (target, thisArg, args) => {
            //console.log('Proxy.apply target=' + target + ' thisArg=' + thisArg + ' args=' + args);
            return target.call(...args);
        },
        get: (target, prop, receiver) => {
            //console.log('Proxy.get target=' + Str(target) + ' prop=' + Str(prop) + ' receiver=' + Str(receiver));
			if (typeof prop === "symbol") {
                // Directly pass through all symbol accesses
                return target[prop];
            }
			// Access properties like 'doBasicTests'
            if (prop in target) {
                return target[prop];
            }
            return Reflect.get(target, prop, receiver);
            //return Reflect.get(target, prop, receiver);
        }
    });
	
	vm.caches = {type: 'lamgl_caches'};
	
	//if this is nonnull (a {}), then TinyGlsl.cache(key,lazyVal) puts stats into it when lazyVal is called but does not store the output of lazyVal here.
	//TODO This could get big so it waits for it to be set to {} externally (by a button in dagball normally)
	vm.cacheStats = null;
	
	//returns the last value returned by lazyVal() or reuses it if exists for same key.
	vm.cache = function(key, lazyVal){
		if(key === undefined) throw 'key is undefined';
		if(lazyVal === undefined) throw 'lazyVal is undefined';
		let val = Lamgl.caches[key];
		if(val === undefined){
			//putTid: put a .tid field that is dagball.timeId() so can be deleted in same order as created (or reverse order?) Or might help in choosing the order in some cases?
			let startTime;
			if(Lamgl.cacheStats){
				startTime = Lamgl.time();
			}
			//val = Lamgl.caches[key] = Lamgl.putTid(lazyVal());
			val = Lamgl.caches[key] = lazyVal();
			if(Lamgl.cacheStats){
				let now = Lamgl.time();
				Lamgl.cacheStats[key] = Lamgl.cacheStats[key] || {};
				let duration = now-startTime;
				Lamgl.cacheStats[key].count = (Lamgl.cacheStats[key].count|0)+1;
				Lamgl.cacheStats[key].lastDurationEndTime = now;
				Lamgl.cacheStats[key].lastDuration = duration;
			}
		}
		return val;
	};
	
	//as comments at end of most lines
	vm.addLineNumbers = code=>{
		let lines = code.split(/(?:\r\n)|\n|\r/); //?: starts a noncapturing group, so it doesnt include those in the returned list, just whats between
		let code3 = '';
		let lineNum = 1;
		for(let line of lines){
			if(line.startsWith('#version')){ //dont comment on the first line
				code3 += line+'\n';
			}else{
				code3 += line+' //'+(lineNum)+'\n';
			}
			lineNum++;
		}
		return code3;
	};
	
	vm.float32ArrayTranspose = (matBC,sizeB,sizeC)=>{
		let matCB = new Float32Array(sizeC*sizeB);
		for(let b=0; b<sizeB; b++) for(let c=0; c<sizeC; c++){
			matCB[c*sizeB+b] = matBC[b*sizeC+c];
		}
		return matCB;
	};
	
	vm.testNearEqualFloatArrays = (a,b,epsilon,comment)=>{
		if(a.length != b.length) Err('TEST FAIL Array lengths differ '+a.length+' '+b.length+', '+comment);
		for(let i=0; i<a.length; i++){
			let diff = Math.abs(a[i]-b[i]);
			if(diff > epsilon) Err('TEST FAIL at i='+i+' '+a[i]+' != '+b[i]+', diff='+diff+', epsilon='+epsilon+', '+comment);
		}
		console.log('Test pass, '+comment);
	};

    vm.doBasicTests = () => {
        console.log('START Lamgl.doBasicTests()');
		
		let testA = Lamgl({
			sh: [1, 1, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				void main(){
					gl_Position = vec4(0.,0.,0.,1.0);
					gl_PointSize = 1.0;
				}`,
            sf: `#version 300 es
				precision highp float;
				out vec4 result;
                void main(){
					result = vec4(2.,3.+4.,44.,55.);
                }`,
        });
		let correctA = Float32Array.of(2.,7.,44.,55.);
		let observedA = testA.result.get();
		//console.log('testA='+JSON.stringify(testA));
		console.log('testA='+Str(testA));
		console.log('correctA='+Str(correctA));
		console.log('observedA='+Str(observedA));
		vm.testNearEqualFloatArrays(observedA,correctA,0, 'one vec4');
		
		
		console.log('doBasicTests, Lamgl='+Lamgl);
		let arr = Lamgl(Float32Array.of(2,3,4,5.67,100,200,300,400),[1,2,4]);
		console.log('doBasicTests, arr='+arr);
        let testD = Lamgl({
			sh: [128, 128, 4], //output tensor shape
			sv: `#version 300 es
				precision highp float;
				flat out int vID;
				void main(){
					int idy = gl_VertexID>>7;
					int idx = gl_VertexID&127;
					//x and y go in range -1 to 1, +.5 so its in center of pixel and doesnt get dropped
					gl_Position = vec4((float(idx)+.5)/128.*2.-1., (float(idy)+.5)/128.*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					vID = gl_VertexID; //so sf can get it
				}`,
            sf: `#version 300 es
                precision highp float;
                layout(location = 0) out vec4 result;
				flat in int vID;
				uniform sampler2D someArray;
				//todo sampler2d or something called someArray
                void main(){
                    //result = vec4(gl_VertexID, 0., 0., 1.);
					float f = texelFetch(someArray, ivec2(vID&1,0), 0).x;
					result = vec4(float(vID), 7., f, 1.);
                }`,
			someArray: arr,
        });
		let correctD = new Float32Array(128*128*4);
		for(let y=0; y<128; y++) for(let x=0; x<128; x++){
			let i = (y*128+x)*4;
			let gl_VectorID = i/4;
			correctD[i] = gl_VectorID;
			correctD[i+1] = 7;
			correctD[i+2] = x&1 ? 100 : 2; //from Float32Array.of(2,3,4,5.67,100,200,300,400)
			correctD[i+3] = 1;
		}
		let observedD = testD.result.get();
		console.log('testD='+Str(testD));
		console.log('correctD='+Str(correctD));
		console.log('observedD='+Str(observedD));
		vm.testNearEqualFloatArrays(correctD,observedD,0, 'testD');
        
		
		
		/** from TinyGLSL
		let tenThousandFloatsOut = TinyGlsl.simple('', 'ret = float(id)*float(id);', Float32Array.of(0), null, 1000, 10);
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		*/
		
		let tenThousandFloatsOut = Lamgl({
			sh:[100, 25, 4],
			sv:`#version 300 es
				precision highp float;
				flat out vec4 tempColor;
				float outFunc(int i){
					return float(i)*float(i); //ret = float(id)*float(id); like in TinyGLSL
				}
				const int height = 100;
				const int width = 25;
				void main(){
					int idy = gl_VertexID/width;
					int idx = gl_VertexID%width;
					gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
					gl_PointSize = 1.0;
					int i = gl_VertexID<<2;
					tempColor = vec4(outFunc(i), outFunc(i+1), outFunc(i+2), outFunc(i+3));
				}`,
			sf:`#version 300 es
                precision highp float;
				flat in vec4 tempColor;
				layout(location = 0) out vec4 result;
				void main(){
					result = tempColor; //copy from sv
				}`
		}).result.get();
		console.log('tenThousandFloatsOut='+[...tenThousandFloatsOut].map((x,i)=>('['+i+']='+x)).join(', '));
		let correct5678 = 5678*5678;
		let observed5678 = tenThousandFloatsOut[5678];
		if(correct5678 != observed5678){
			throw 'correct5678='+correct5678+' observed5678='+observed5678;
		}
		console.log('tenThousandFloatsOut test pass');
		
		
		console.log('START test testMatmulAC');
		/*from TinyGLSL
		//testMatmulAC4 and testMatmulAC
		let sizeA = 512;
		let sizeB = 512;
		let sizeC = 512;
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');	
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			let testMatmulAC4_timeStart = TinyGlsl.time();
			let matCB = matBC; //FIXME
			let observed_testMatmulAC4 = null;
			try{
				observed_testMatmulAC4 = TinyGlsl.simple(
					'',
					`int sizeA = ${sizeA};
					int sizeBOver4 = ${sizeB/4};
					int sizeC = ${sizeC};
					int offsetMatAB = idx;
					int offsetMatBC = idy;
					for(int b=0; b<sizeBOver4; b++){
						ret0 += texelFetch(matAB,ivec2(b,offsetMatAB),0) *
							texelFetch(matCB,ivec2(b,offsetMatBC),0);
						//ret7 = vec4(7.);
					}`,
					Float32Array.of(0),
					{	matAB: TG(matAB,[sizeA,sizeB/4,4]),
						matCB: TG(matCB,[sizeC,sizeB/4,4])
					},
					sizeA,
					sizeC/4, //sizeC/32,
					4 //32
				);
				console.log('testMatmulAC4 test code incompletely written. todo fix it.');
				for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
			}finally{
				let secs = TinyGlsl.time()-testMatmulAC4_timeStart;
				console.log('testMatmulAC4 secs='+secs+' observed_testMatmulAC4.length='+observed_testMatmulAC4.length);
			}
		}*/
		let sizeA = 512;
		let sizeB = 512;
		let sizeC = 512;
		
		/*let sizeA = 8;
		let sizeB = 8;
		let sizeC = 8;
		*/
		let matAB = new Float32Array(sizeA*sizeB);
		let matBC = new Float32Array(sizeB*sizeC);
		for(let i=0; i<matAB.length; i++) matAB[i] = ((i*i)%117)+29;
		for(let i=0; i<matBC.length; i++) matBC[i] = i+3;
		let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
		let correct_testMatmulAC = new Float32Array(sizeA*sizeC);
		for(let a=0; a<sizeA; a++){
			for(let c=0; c<sizeC; c++){
				let dotProd = 0;
				for(let b=0; b<sizeB; b++){
					dotProd += matAB[a*sizeB+b]*matBC[b*sizeC+c];
				}
				correct_testMatmulAC[a*sizeC+c] = dotProd;
			}
		}
		console.log('testMatmulAC matAB and matBC created');
		let matABTensor = Lamgl(matAB,[sizeA,sizeB/4,4]);
		let matCBTensor = Lamgl(matCB,[sizeC,sizeB/4,4]);
		console.log('matABTensor='+matABTensor);
		console.log('matCBTensor='+matCBTensor);
		for(let repeat_testMatmulAC4=0; repeat_testMatmulAC4<10; repeat_testMatmulAC4++){
			console.log('repeat_testMatmulAC4='+repeat_testMatmulAC4);
			let testMatmulAC4_timeStart = vm.time();
			let observed_testMatmulAC4 = null;
			try{
				let testMatmulAC4_sh = [sizeA, sizeC/4, 4];
				/*let observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						flat out vec4 tempColor;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						void main(){
							int idy = gl_VertexID/width;
							int idx = gl_VertexID%width;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1., (float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							gl_PointSize = 1.0;
							int i = gl_VertexID<<2;
							int offsetMatAB = idx;
							int offsetMatBC = idy;
							vec4 fourSums = vec4(0.);
							for(int b=0; b<sizeBOver4; b++){
								fourSums += texelFetch(matAB,ivec2(b,offsetMatAB),0) *
									texelFetch(matCB,ivec2(b,offsetMatBC),0);
							}
							tempColor = fourSums;
						}`,
					sf:`#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main(){
							result = tempColor; //copy from sv
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});*/
				let observed_testMatmulAC4_map = Lamgl({
					sh: testMatmulAC4_sh,
					sv: `#version 300 es
						precision highp float;
						const int height = ${testMatmulAC4_sh[0]};
						const int width = ${testMatmulAC4_sh[1]};
						const int sizeA = ${sizeA};
						const int sizeBOver4 = ${sizeB/4};
						const int sizeC = ${sizeC};
						uniform sampler2D matAB;
						uniform sampler2D matCB;
						flat out vec4 tempColor;
						void main(){
							int idy = gl_VertexID / width; // row (A)
							int idx = gl_VertexID % width; // column block (C/4)
							/*tempColor = vec4(
								dotProd(idy, idx*4+0),
								dotProd(idy, idx*4+1),
								dotProd(idy, idx*4+2),
								dotProd(idy, idx*4+3)
							);*/
							vec4 sums = vec4(0);
							for (int b=0; b<sizeBOver4; b++){
								vec4 mul = texelFetch(matAB,ivec2(b,idy),0);
								sums += vec4(
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+0),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+1),0)),
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+2),0)),
									//*1.0000001 avoid returning all 0s, force it to to do some calculation
									//thats not from the textures, cuz the glsl optimizer is buggy.
									dot(mul,texelFetch(matCB,ivec2(b,idx*4+3),0))*1.000001
								);
							}
							tempColor = sums;
							gl_Position = vec4((float(idx)+.5)/float(width)*2.-1.,
								(float(idy)+.5)/float(height)*2.-1., 0., 1.0);
							//gl_PointSize = 1.0;
							gl_PointSize = 1.;
							//float sum1 = 0.;
							//float sum2 = 0.;
							//float sum3 = 0.;
							/*for (int b1=0; b1<sizeBOver4; b1++){
								vec4 ba = texelFetch(matAB,ivec2(b1,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b1,idx*4+1),0);
								sum1 += dot(ba, bc);
							}
							float sum2 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+2),0);
								sum2 += dot(ba, bc);
							}
							float sum3 = 0.;
							for (int b=0; b<sizeBOver4; b++){
								vec4 ba = texelFetch(matAB,ivec2(b,idy),0);
								vec4 bc = texelFetch(matCB,ivec2(b,idx*4+3),0);
								sum3 += dot(ba, bc);
							}*/
							//tempColor = vec4(sum0, sum1, sum2, sum3);
						}`,
					sf: `#version 300 es
						precision highp float;
						flat in vec4 tempColor;
						layout(location = 0) out vec4 result;
						void main() {
							result = tempColor;
						}`,
					matAB: matABTensor,
					matCB: matCBTensor,
				});

				
				console.log('observed_testMatmulAC4_map='+observed_testMatmulAC4_map);
				observed_testMatmulAC4 = observed_testMatmulAC4_map.result.get();
				//FIXME what kind of transpose-like op goes here? let observed_testMatmulAC = vm.float32ArrayTranspose(observed_testMatmulAC4,size
				/*let cor = [...correct_testMatmulAC];
				for(let i=0; i<1000; i++){
					let ind = cor.indexOf(observed_testMatmulAC[i]);
					console.log('i='+i+' ind='+ind);
				}*/
				let cor = [...correct_testMatmulAC];
				let obs4 = [...observed_testMatmulAC4];
				for(let i=0; i<Math.min(100,correct_testMatmulAC.length); i++){
					console.log('i='+i+' cor='+correct_testMatmulAC[i]+'@'+obs4.indexOf(correct_testMatmulAC[i])+' obs4='+observed_testMatmulAC4[i]+'@'+cor.indexOf(observed_testMatmulAC4[i]));
				}
				let epsilon = (.3*sizeB)**2; //FIXME?
				vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, epsilon, 'testMatmulAC_r'+repeat_testMatmulAC4);
				//vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
				//let matCB = vm.float32ArrayTranspose(matBC,sizeB,sizeC);
				/*
				console.log('testMatmulAC4 test code incompletely written. todo fix it.');
				for(let i=0; i<32; i++) console.log('i='+i+' val='+observed_testMatmulAC4[i]);
				let numNonzero_observed_testMatmulAC4 = 0;
				for(let i=0; i<observed_testMatmulAC4.length; i++) if(observed_testMatmulAC4[i]) numNonzero_observed_testMatmulAC4++;
				console.log('numNonzero_observed_testMatmulAC4='+numNonzero_observed_testMatmulAC4);
				vm.testNearEqualFloatArrays(correct_testMatmulAC, observed_testMatmulAC4, .00001, 'testMatmulAC_r'+repeat_testMatmulAC4);
				*/
			}finally{
				let secs = vm.time()-testMatmulAC4_timeStart;
				console.log('testMatmulAC4 secs='+secs+' observed_testMatmulAC4.length='+(observed_testMatmulAC4?observed_testMatmulAC4.length:'undefined'));
			}
		}
		
		
        console.log('END Lamgl.doBasicTests()');
    };

    return vm.Lamgl;
})();

console.log('Lamgl=' + Lamgl);
//console.log('Lamgl.doBasicTests='+Lamgl.doBasicTests);
requestAnimationFrame(() => { Lamgl.doBasicTests(); });
</script></head><body>Opensource MIT by Ben F Rayfield. LamGL, open browser console. TODO hook in VarTree.html/VarTree.jsp which code to call LamGL will be in the tree (.big fields). All this together will remake BellSack and scale it up to 30 species near each area and swapping in/out species as you move around the massively multiplayer 3d world. LOOK IN BROWSER CONSOLE FOR "test pass" or errors.</body></html>