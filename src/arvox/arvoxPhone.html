<!DOCTYPE html>
<html><head>
<meta charset="UTF-8" /> 
<script>

//webcamjs_mitLicense_1.0.24.js from https://raw.githubusercontent.com/benrayfield/jsutils/master/src/arvox/webcamjs_mitLicense_1.0.24.js



// WebcamJS v1.0.24
// Webcam library for capturing JPEG/PNG images in JavaScript
// Attempts getUserMedia, falls back to Flash
// Author: Joseph Huckaby: http://github.com/jhuckaby
// Based on JPEGCam: http://code.google.com/p/jpegcam/
// Copyright (c) 2012 - 2017 Joseph Huckaby
// Licensed under the MIT License

(function(window) {
var _userMedia;

// declare error types

// inheritance pattern here:
// https://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript
function FlashError() {
	var temp = Error.apply(this, arguments);
	temp.name = this.name = "FlashError";
	this.stack = temp.stack;
	this.message = temp.message;
}

function WebcamError() {
	var temp = Error.apply(this, arguments);
	temp.name = this.name = "WebcamError";
	this.stack = temp.stack;
	this.message = temp.message;
}

IntermediateInheritor = function() {};
IntermediateInheritor.prototype = Error.prototype;

FlashError.prototype = new IntermediateInheritor();
WebcamError.prototype = new IntermediateInheritor();

var Webcam = {
	version: '1.0.24',
	
	// globals
	protocol: location.protocol.match(/https/i) ? 'https' : 'http',
	loaded: false,   // true when webcam movie finishes loading
	live: false,     // true when webcam is initialized and ready to snap
	userMedia: true, // true when getUserMedia is supported natively

	iOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,

	params: {
		width: 0,
		height: 0,
		dest_width: 0,         // size of captured image
		dest_height: 0,        // these default to width/height
		image_format: 'jpeg',  // image format (may be jpeg or png)
		jpeg_quality: 90,      // jpeg image quality from 0 (worst) to 100 (best)
		enable_flash: true,    // enable flash fallback,
		force_flash: false,    // force flash mode,
		flip_horiz: false,     // flip image horiz (mirror mode)
		fps: 30,               // camera frames per second
		upload_name: 'webcam', // name of file in upload post data
		constraints: null,     // custom user media constraints,
		swfURL: '',            // URI to webcam.swf movie (defaults to the js location)
		flashNotDetectedText: 'ERROR: No Adobe Flash Player detected.  Webcam.js relies on Flash for browsers that do not support getUserMedia (like yours).',
		noInterfaceFoundText: 'No supported webcam interface found.',
		unfreeze_snap: true,    // Whether to unfreeze the camera after snap (defaults to true)
		iosPlaceholderText: 'Click here to open camera.',
		user_callback: null,    // callback function for snapshot (used if no user_callback parameter given to snap function)
		user_canvas: null       // user provided canvas for snapshot (used if no user_canvas parameter given to snap function)
	},

	errors: {
		FlashError: FlashError,
		WebcamError: WebcamError
	},
	
	hooks: {}, // callback hook functions
	
	init: function() {
		// initialize, check for getUserMedia support
		var self = this;
		
		// Setup getUserMedia, with polyfill for older browsers
		// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
		this.mediaDevices = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ? 
			navigator.mediaDevices : ((navigator.mozGetUserMedia || navigator.webkitGetUserMedia) ? {
				getUserMedia: function(c) {
					return new Promise(function(y, n) {
						(navigator.mozGetUserMedia ||
						navigator.webkitGetUserMedia).call(navigator, c, y, n);
					});
				}
		} : null);
		
		window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
		this.userMedia = this.userMedia && !!this.mediaDevices && !!window.URL;
		
		if (this.iOS) {
			this.userMedia = null;
		}
		
		// Older versions of firefox (< 21) apparently claim support but user media does not actually work
		if (navigator.userAgent.match(/Firefox\D+(\d+)/)) {
			if (parseInt(RegExp.$1, 10) < 21) this.userMedia = null;
		}
		
		// Make sure media stream is closed when navigating away from page
		if (this.userMedia) {
			window.addEventListener( 'beforeunload', function(event) {
				self.reset();
			} );
		}
	},
	
	exifOrientation: function(binFile) {
		// extract orientation information from the image provided by iOS
		// algorithm based on exif-js
		var dataView = new DataView(binFile);
		if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
			console.log('Not a valid JPEG file');
			return 0;
		}
		var offset = 2;
		var marker = null;
		while (offset < binFile.byteLength) {
			// find 0xFFE1 (225 marker)
			if (dataView.getUint8(offset) != 0xFF) {
				console.log('Not a valid marker at offset ' + offset + ', found: ' + dataView.getUint8(offset));
				return 0;
			}
			marker = dataView.getUint8(offset + 1);
			if (marker == 225) {
				offset += 4;
				var str = "";
				for (n = 0; n < 4; n++) {
					str += String.fromCharCode(dataView.getUint8(offset+n));
				}
				if (str != 'Exif') {
					console.log('Not valid EXIF data found');
					return 0;
				}
				
				offset += 6; // tiffOffset
				var bigEnd = null;

				// test for TIFF validity and endianness
				if (dataView.getUint16(offset) == 0x4949) {
					bigEnd = false;
				} else if (dataView.getUint16(offset) == 0x4D4D) {
					bigEnd = true;
				} else {
					console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");
					return 0;
				}

				if (dataView.getUint16(offset+2, !bigEnd) != 0x002A) {
					console.log("Not valid TIFF data! (no 0x002A)");
					return 0;
				}

				var firstIFDOffset = dataView.getUint32(offset+4, !bigEnd);
				if (firstIFDOffset < 0x00000008) {
					console.log("Not valid TIFF data! (First offset less than 8)", dataView.getUint32(offset+4, !bigEnd));
					return 0;
				}

				// extract orientation data
				var dataStart = offset + firstIFDOffset;
				var entries = dataView.getUint16(dataStart, !bigEnd);
				for (var i=0; i<entries; i++) {
					var entryOffset = dataStart + i*12 + 2;
					if (dataView.getUint16(entryOffset, !bigEnd) == 0x0112) {
						var valueType = dataView.getUint16(entryOffset+2, !bigEnd);
						var numValues = dataView.getUint32(entryOffset+4, !bigEnd);
						if (valueType != 3 && numValues != 1) {
							console.log('Invalid EXIF orientation value type ('+valueType+') or count ('+numValues+')');
							return 0;
						}
						var value = dataView.getUint16(entryOffset + 8, !bigEnd);
						if (value < 1 || value > 8) {
							console.log('Invalid EXIF orientation value ('+value+')');
							return 0;
						}
						return value;
					}
				}
			} else {
				offset += 2+dataView.getUint16(offset+2);
			}
		}
		return 0;
	},
	
	fixOrientation: function(origObjURL, orientation, targetImg) {
		// fix image orientation based on exif orientation data
		// exif orientation information
		//    http://www.impulseadventure.com/photo/exif-orientation.html
		//    link source wikipedia (https://en.wikipedia.org/wiki/Exif#cite_note-20)
		var img = new Image();
		img.addEventListener('load', function(event) {
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			
			// switch width height if orientation needed
			if (orientation < 5) {
				canvas.width = img.width;
				canvas.height = img.height;
			} else {
				canvas.width = img.height;
				canvas.height = img.width;
			}

			// transform (rotate) image - see link at beginning this method
			switch (orientation) {
				case 2: ctx.transform(-1, 0, 0, 1, img.width, 0); break;
				case 3: ctx.transform(-1, 0, 0, -1, img.width, img.height); break;
				case 4: ctx.transform(1, 0, 0, -1, 0, img.height); break;
				case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;
				case 6: ctx.transform(0, 1, -1, 0, img.height , 0); break;
				case 7: ctx.transform(0, -1, -1, 0, img.height, img.width); break;
				case 8: ctx.transform(0, -1, 1, 0, 0, img.width); break;
			}

			ctx.drawImage(img, 0, 0);
			// pass rotated image data to the target image container
			targetImg.src = canvas.toDataURL();
		}, false);
		// start transformation by load event
		img.src = origObjURL;
	},
	
	attach: function(elem) {
		// create webcam preview and attach to DOM element
		// pass in actual DOM reference, ID, or CSS selector
		if (typeof(elem) == 'string') {
			elem = document.getElementById(elem) || document.querySelector(elem);
		}
		if (!elem) {
			return this.dispatch('error', new WebcamError("Could not locate DOM element to attach to."));
		}
		this.container = elem;
		elem.innerHTML = ''; // start with empty element
		
		// insert "peg" so we can insert our preview canvas adjacent to it later on
		var peg = document.createElement('div');
		elem.appendChild( peg );
		this.peg = peg;
		
		// set width/height if not already set
		if (!this.params.width) this.params.width = elem.offsetWidth;
		if (!this.params.height) this.params.height = elem.offsetHeight;
		
		// make sure we have a nonzero width and height at this point
		if (!this.params.width || !this.params.height) {
			return this.dispatch('error', new WebcamError("No width and/or height for webcam.  Please call set() first, or attach to a visible element."));
		}
		
		// set defaults for dest_width / dest_height if not set
		if (!this.params.dest_width) this.params.dest_width = this.params.width;
		if (!this.params.dest_height) this.params.dest_height = this.params.height;
		
		this.userMedia = _userMedia === undefined ? this.userMedia : _userMedia;
		// if force_flash is set, disable userMedia
		if (this.params.force_flash) {
			_userMedia = this.userMedia;
			this.userMedia = null;
		}
		
		// check for default fps
		if (typeof this.params.fps !== "number") this.params.fps = 30;

		// adjust scale if dest_width or dest_height is different
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		if (this.userMedia) {
			// setup webcam video container
			var video = document.createElement('video');
			video.setAttribute('autoplay', 'autoplay');
			video.style.width = '' + this.params.dest_width + 'px';
			video.style.height = '' + this.params.dest_height + 'px';
			
			if ((scaleX != 1.0) || (scaleY != 1.0)) {
				elem.style.overflow = 'hidden';
				video.style.webkitTransformOrigin = '0px 0px';
				video.style.mozTransformOrigin = '0px 0px';
				video.style.msTransformOrigin = '0px 0px';
				video.style.oTransformOrigin = '0px 0px';
				video.style.transformOrigin = '0px 0px';
				video.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			}
			
			// add video element to dom
			elem.appendChild( video );
			this.video = video;
			
			// ask user for access to their camera
			var self = this;
			this.mediaDevices.getUserMedia({
				"audio": false,
				"video": this.params.constraints || {
					mandatory: {
						minWidth: this.params.dest_width,
						minHeight: this.params.dest_height
					}
				}
			})
			.then( function(stream) {
				// got access, attach stream to video
				video.onloadedmetadata = function(e) {
					self.stream = stream;
					self.loaded = true;
					self.live = true;
					self.dispatch('load');
					self.dispatch('live');
					self.flip();
				};
				// as window.URL.createObjectURL() is deprecated, adding a check so that it works in Safari.
				// older browsers may not have srcObject
				if ("srcObject" in video) {
				  	video.srcObject = stream;
				}
				else {
				  	// using URL.createObjectURL() as fallback for old browsers
				  	video.src = window.URL.createObjectURL(stream);
				}
			})
			.catch( function(err) {
				// JH 2016-07-31 Instead of dispatching error, now falling back to Flash if userMedia fails (thx @john2014)
				// JH 2016-08-07 But only if flash is actually installed -- if not, dispatch error here and now.
				if (self.params.enable_flash && self.detectFlash()) {
					setTimeout( function() { self.params.force_flash = 1; self.attach(elem); }, 1 );
				}
				else {
					self.dispatch('error', err);
				}
			});
		}
		else if (this.iOS) {
			// prepare HTML elements
			var div = document.createElement('div');
			div.id = this.container.id+'-ios_div';
			div.className = 'webcamjs-ios-placeholder';
			div.style.width = '' + this.params.width + 'px';
			div.style.height = '' + this.params.height + 'px';
			div.style.textAlign = 'center';
			div.style.display = 'table-cell';
			div.style.verticalAlign = 'middle';
			div.style.backgroundRepeat = 'no-repeat';
			div.style.backgroundSize = 'contain';
			div.style.backgroundPosition = 'center';
			var span = document.createElement('span');
			span.className = 'webcamjs-ios-text';
			span.innerHTML = this.params.iosPlaceholderText;
			div.appendChild(span);
			var img = document.createElement('img');
			img.id = this.container.id+'-ios_img';
			img.style.width = '' + this.params.dest_width + 'px';
			img.style.height = '' + this.params.dest_height + 'px';
			img.style.display = 'none';
			div.appendChild(img);
			var input = document.createElement('input');
			input.id = this.container.id+'-ios_input';
			input.setAttribute('type', 'file');
			input.setAttribute('accept', 'image/*');
			input.setAttribute('capture', 'camera');
			
			var self = this;
			var params = this.params;
			// add input listener to load the selected image
			input.addEventListener('change', function(event) {
				if (event.target.files.length > 0 && event.target.files[0].type.indexOf('image/') == 0) {
					var objURL = URL.createObjectURL(event.target.files[0]);

					// load image with auto scale and crop
					var image = new Image();
					image.addEventListener('load', function(event) {
						var canvas = document.createElement('canvas');
						canvas.width = params.dest_width;
						canvas.height = params.dest_height;
						var ctx = canvas.getContext('2d');

						// crop and scale image for final size
						ratio = Math.min(image.width / params.dest_width, image.height / params.dest_height);
						var sw = params.dest_width * ratio;
						var sh = params.dest_height * ratio;
						var sx = (image.width - sw) / 2;
						var sy = (image.height - sh) / 2;
						ctx.drawImage(image, sx, sy, sw, sh, 0, 0, params.dest_width, params.dest_height);

						var dataURL = canvas.toDataURL();
						img.src = dataURL;
						div.style.backgroundImage = "url('"+dataURL+"')";
					}, false);
					
					// read EXIF data
					var fileReader = new FileReader();
					fileReader.addEventListener('load', function(e) {
						var orientation = self.exifOrientation(e.target.result);
						if (orientation > 1) {
							// image need to rotate (see comments on fixOrientation method for more information)
							// transform image and load to image object
							self.fixOrientation(objURL, orientation, image);
						} else {
							// load image data to image object
							image.src = objURL;
						}
					}, false);
					
					// Convert image data to blob format
					var http = new XMLHttpRequest();
					http.open("GET", objURL, true);
					http.responseType = "blob";
					http.onload = function(e) {
						if (this.status == 200 || this.status === 0) {
							fileReader.readAsArrayBuffer(this.response);
						}
					};
					http.send();

				}
			}, false);
			input.style.display = 'none';
			elem.appendChild(input);
			// make div clickable for open camera interface
			div.addEventListener('click', function(event) {
				if (params.user_callback) {
					// global user_callback defined - create the snapshot
					self.snap(params.user_callback, params.user_canvas);
				} else {
					// no global callback definied for snapshot, load image and wait for external snap method call
					input.style.display = 'block';
					input.focus();
					input.click();
					input.style.display = 'none';
				}
			}, false);
			elem.appendChild(div);
			this.loaded = true;
			this.live = true;
		}
		else if (this.params.enable_flash && this.detectFlash()) {
			// flash fallback
			window.Webcam = Webcam; // needed for flash-to-js interface
			var div = document.createElement('div');
			div.innerHTML = this.getSWFHTML();
			elem.appendChild( div );
		}
		else {
			this.dispatch('error', new WebcamError( this.params.noInterfaceFoundText ));
		}
		
		// setup final crop for live preview
		if (this.params.crop_width && this.params.crop_height) {
			var scaled_crop_width = Math.floor( this.params.crop_width * scaleX );
			var scaled_crop_height = Math.floor( this.params.crop_height * scaleY );
			
			elem.style.width = '' + scaled_crop_width + 'px';
			elem.style.height = '' + scaled_crop_height + 'px';
			elem.style.overflow = 'hidden';
			
			elem.scrollLeft = Math.floor( (this.params.width / 2) - (scaled_crop_width / 2) );
			elem.scrollTop = Math.floor( (this.params.height / 2) - (scaled_crop_height / 2) );
		}
		else {
			// no crop, set size to desired
			elem.style.width = '' + this.params.width + 'px';
			elem.style.height = '' + this.params.height + 'px';
		}
	},
	
	reset: function() {
		// shutdown camera, reset to potentially attach again
		if (this.preview_active) this.unfreeze();
		
		// attempt to fix issue #64
		this.unflip();
		
		if (this.userMedia) {
			if (this.stream) {
				if (this.stream.getVideoTracks) {
					// get video track to call stop on it
					var tracks = this.stream.getVideoTracks();
					if (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();
				}
				else if (this.stream.stop) {
					// deprecated, may be removed in future
					this.stream.stop();
				}
			}
			delete this.stream;
			delete this.video;
		}

		if ((this.userMedia !== true) && this.loaded && !this.iOS) {
			// call for turn off camera in flash
			var movie = this.getMovie();
			if (movie && movie._releaseCamera) movie._releaseCamera();
		}

		if (this.container) {
			this.container.innerHTML = '';
			delete this.container;
		}
	
		this.loaded = false;
		this.live = false;
	},
	
	set: function() {
		// set one or more params
		// variable argument list: 1 param = hash, 2 params = key, value
		if (arguments.length == 1) {
			for (var key in arguments[0]) {
				this.params[key] = arguments[0][key];
			}
		}
		else {
			this.params[ arguments[0] ] = arguments[1];
		}
	},
	
	on: function(name, callback) {
		// set callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (!this.hooks[name]) this.hooks[name] = [];
		this.hooks[name].push( callback );
	},
	
	off: function(name, callback) {
		// remove callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (this.hooks[name]) {
			if (callback) {
				// remove one selected callback from list
				var idx = this.hooks[name].indexOf(callback);
				if (idx > -1) this.hooks[name].splice(idx, 1);
			}
			else {
				// no callback specified, so clear all
				this.hooks[name] = [];
			}
		}
	},
	
	dispatch: function() {
		// fire hook callback, passing optional value to it
		var name = arguments[0].replace(/^on/i, '').toLowerCase();
		var args = Array.prototype.slice.call(arguments, 1);
		
		if (this.hooks[name] && this.hooks[name].length) {
			for (var idx = 0, len = this.hooks[name].length; idx < len; idx++) {
				var hook = this.hooks[name][idx];
				
				if (typeof(hook) == 'function') {
					// callback is function reference, call directly
					hook.apply(this, args);
				}
				else if ((typeof(hook) == 'object') && (hook.length == 2)) {
					// callback is PHP-style object instance method
					hook[0][hook[1]].apply(hook[0], args);
				}
				else if (window[hook]) {
					// callback is global function name
					window[ hook ].apply(window, args);
				}
			} // loop
			return true;
		}
		else if (name == 'error') {
			if ((args[0] instanceof FlashError) || (args[0] instanceof WebcamError)) {
				message = args[0].message;
			} else {
				message = "Could not access webcam: " + args[0].name + ": " + 
					args[0].message + " " + args[0].toString();
			}

			// default error handler if no custom one specified
			alert("Webcam.js Error: " + message);
		}
		
		return false; // no hook defined
	},

	setSWFLocation: function(value) {
		// for backward compatibility.
		this.set('swfURL', value);
	},
	
	detectFlash: function() {
		// return true if browser supports flash, false otherwise
		// Code snippet borrowed from: https://github.com/swfobject/swfobject
		var SHOCKWAVE_FLASH = "Shockwave Flash",
			SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
        	FLASH_MIME_TYPE = "application/x-shockwave-flash",
        	win = window,
        	nav = navigator,
        	hasFlash = false;
        
        if (typeof nav.plugins !== "undefined" && typeof nav.plugins[SHOCKWAVE_FLASH] === "object") {
        	var desc = nav.plugins[SHOCKWAVE_FLASH].description;
        	if (desc && (typeof nav.mimeTypes !== "undefined" && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {
        		hasFlash = true;
        	}
        }
        else if (typeof win.ActiveXObject !== "undefined") {
        	try {
        		var ax = new ActiveXObject(SHOCKWAVE_FLASH_AX);
        		if (ax) {
        			var ver = ax.GetVariable("$version");
        			if (ver) hasFlash = true;
        		}
        	}
        	catch (e) {;}
        }
        
        return hasFlash;
	},
	
	getSWFHTML: function() {
		// Return HTML for embedding flash based webcam capture movie		
		var html = '',
			swfURL = this.params.swfURL;
		
		// make sure we aren't running locally (flash doesn't work)
		if (location.protocol.match(/file/)) {
			this.dispatch('error', new FlashError("Flash does not work from local disk.  Please run from a web server."));
			return '<h3 style="color:red">ERROR: the Webcam.js Flash fallback does not work from local disk.  Please run it from a web server.</h3>';
		}
		
		// make sure we have flash
		if (!this.detectFlash()) {
			this.dispatch('error', new FlashError("Adobe Flash Player not found.  Please install from get.adobe.com/flashplayer and try again."));
			return '<h3 style="color:red">' + this.params.flashNotDetectedText + '</h3>';
		}
		
		// set default swfURL if not explicitly set
		if (!swfURL) {
			// find our script tag, and use that base URL
			var base_url = '';
			var scpts = document.getElementsByTagName('script');
			for (var idx = 0, len = scpts.length; idx < len; idx++) {
				var src = scpts[idx].getAttribute('src');
				if (src && src.match(/\/webcam(\.min)?\.js/)) {
					base_url = src.replace(/\/webcam(\.min)?\.js.*$/, '');
					idx = len;
				}
			}
			if (base_url) swfURL = base_url + '/webcam.swf';
			else swfURL = 'webcam.swf';
		}
		
		// if this is the user's first visit, set flashvar so flash privacy settings panel is shown first
		if (window.localStorage && !localStorage.getItem('visited')) {
			this.params.new_user = 1;
			localStorage.setItem('visited', 1);
		}
		
		// construct flashvars string
		var flashvars = '';
		for (var key in this.params) {
			if (flashvars) flashvars += '&';
			flashvars += key + '=' + escape(this.params[key]);
		}
		
		// construct object/embed tag
		html += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" type="application/x-shockwave-flash" codebase="'+this.protocol+'://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="'+this.params.width+'" height="'+this.params.height+'" id="webcam_movie_obj" align="middle"><param name="wmode" value="opaque" /><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+swfURL+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><embed id="webcam_movie_embed" src="'+swfURL+'" wmode="opaque" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+this.params.width+'" height="'+this.params.height+'" name="webcam_movie_embed" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'"></embed></object>';
		
		return html;
	},
	
	getMovie: function() {
		// get reference to movie object/embed in DOM
		if (!this.loaded) return this.dispatch('error', new FlashError("Flash Movie is not loaded yet"));
		var movie = document.getElementById('webcam_movie_obj');
		if (!movie || !movie._snap) movie = document.getElementById('webcam_movie_embed');
		if (!movie) this.dispatch('error', new FlashError("Cannot locate Flash movie in DOM"));
		return movie;
	},
	
	freeze: function() {
		// show preview, freeze camera
		var self = this;
		var params = this.params;
		
		// kill preview if already active
		if (this.preview_active) this.unfreeze();
		
		// determine scale factor
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		// must unflip container as preview canvas will be pre-flipped
		this.unflip();
		
		// calc final size of image
		var final_width = params.crop_width || params.dest_width;
		var final_height = params.crop_height || params.dest_height;
		
		// create canvas for holding preview
		var preview_canvas = document.createElement('canvas');
		preview_canvas.width = final_width;
		preview_canvas.height = final_height;
		var preview_context = preview_canvas.getContext('2d');
		
		// save for later use
		this.preview_canvas = preview_canvas;
		this.preview_context = preview_context;
		
		// scale for preview size
		if ((scaleX != 1.0) || (scaleY != 1.0)) {
			preview_canvas.style.webkitTransformOrigin = '0px 0px';
			preview_canvas.style.mozTransformOrigin = '0px 0px';
			preview_canvas.style.msTransformOrigin = '0px 0px';
			preview_canvas.style.oTransformOrigin = '0px 0px';
			preview_canvas.style.transformOrigin = '0px 0px';
			preview_canvas.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
		}
		
		// take snapshot, but fire our own callback
		this.snap( function() {
			// add preview image to dom, adjust for crop
			preview_canvas.style.position = 'relative';
			preview_canvas.style.left = '' + self.container.scrollLeft + 'px';
			preview_canvas.style.top = '' + self.container.scrollTop + 'px';
			
			self.container.insertBefore( preview_canvas, self.peg );
			self.container.style.overflow = 'hidden';
			
			// set flag for user capture (use preview)
			self.preview_active = true;
			
		}, preview_canvas );
	},
	
	unfreeze: function() {
		// cancel preview and resume live video feed
		if (this.preview_active) {
			// remove preview canvas
			this.container.removeChild( this.preview_canvas );
			delete this.preview_context;
			delete this.preview_canvas;
			
			// unflag
			this.preview_active = false;
			
			// re-flip if we unflipped before
			this.flip();
		}
	},
	
	flip: function() {
		// flip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(-1)';
			sty.mozTransform = 'scaleX(-1)';
			sty.msTransform = 'scaleX(-1)';
			sty.oTransform = 'scaleX(-1)';
			sty.transform = 'scaleX(-1)';
			sty.filter = 'FlipH';
			sty.msFilter = 'FlipH';
		}
	},
	
	unflip: function() {
		// unflip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(1)';
			sty.mozTransform = 'scaleX(1)';
			sty.msTransform = 'scaleX(1)';
			sty.oTransform = 'scaleX(1)';
			sty.transform = 'scaleX(1)';
			sty.filter = '';
			sty.msFilter = '';
		}
	},
	
	savePreview: function(user_callback, user_canvas) {
		// save preview freeze and fire user callback
		var params = this.params;
		var canvas = this.preview_canvas;
		var context = this.preview_context;
		
		// render to user canvas if desired
		if (user_canvas) {
			var user_context = user_canvas.getContext('2d');
			user_context.drawImage( canvas, 0, 0 );
		}
		
		// fire user callback if desired
		user_callback(
			user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
			canvas,
			context
		);
		
		// remove preview
		if (this.params.unfreeze_snap) this.unfreeze();
	},
	
	snap: function(user_callback, user_canvas) {
		// use global callback and canvas if not defined as parameter
		if (!user_callback) user_callback = this.params.user_callback;
		if (!user_canvas) user_canvas = this.params.user_canvas;
		
		// take snapshot and return image data uri
		var self = this;
		var params = this.params;
		
		if (!this.loaded) return this.dispatch('error', new WebcamError("Webcam is not loaded yet"));
		// if (!this.live) return this.dispatch('error', new WebcamError("Webcam is not live yet"));
		if (!user_callback) return this.dispatch('error', new WebcamError("Please provide a callback function or canvas to snap()"));
		
		// if we have an active preview freeze, use that
		if (this.preview_active) {
			this.savePreview( user_callback, user_canvas );
			return null;
		}
		
		// create offscreen canvas element to hold pixels
		var canvas = document.createElement('canvas');
		canvas.width = this.params.dest_width;
		canvas.height = this.params.dest_height;
		var context = canvas.getContext('2d');
		
		// flip canvas horizontally if desired
		if (this.params.flip_horiz) {
			context.translate( params.dest_width, 0 );
			context.scale( -1, 1 );
		}
		
		// create inline function, called after image load (flash) or immediately (native)
		var func = function() {
			// render image if needed (flash)
			if (this.src && this.width && this.height) {
				context.drawImage(this, 0, 0, params.dest_width, params.dest_height);
			}
			
			// crop if desired
			if (params.crop_width && params.crop_height) {
				var crop_canvas = document.createElement('canvas');
				crop_canvas.width = params.crop_width;
				crop_canvas.height = params.crop_height;
				var crop_context = crop_canvas.getContext('2d');
				
				crop_context.drawImage( canvas, 
					Math.floor( (params.dest_width / 2) - (params.crop_width / 2) ),
					Math.floor( (params.dest_height / 2) - (params.crop_height / 2) ),
					params.crop_width,
					params.crop_height,
					0,
					0,
					params.crop_width,
					params.crop_height
				);
				
				// swap canvases
				context = crop_context;
				canvas = crop_canvas;
			}
			
			// render to user canvas if desired
			if (user_canvas) {
				var user_context = user_canvas.getContext('2d');
				user_context.drawImage( canvas, 0, 0 );
			}
			
			// fire user callback if desired
			user_callback(
				user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
				canvas,
				context
			);
		};
		
		// grab image frame from userMedia or flash movie
		if (this.userMedia) {
			// native implementation
			context.drawImage(this.video, 0, 0, this.params.dest_width, this.params.dest_height);
			
			// fire callback right away
			func();
		}
		else if (this.iOS) {
			var div = document.getElementById(this.container.id+'-ios_div');
			var img = document.getElementById(this.container.id+'-ios_img');
			var input = document.getElementById(this.container.id+'-ios_input');
			// function for handle snapshot event (call user_callback and reset the interface)
			iFunc = function(event) {
				func.call(img);
				img.removeEventListener('load', iFunc);
				div.style.backgroundImage = 'none';
				img.removeAttribute('src');
				input.value = null;
			};
			if (!input.value) {
				// No image selected yet, activate input field
				img.addEventListener('load', iFunc);
				input.style.display = 'block';
				input.focus();
				input.click();
				input.style.display = 'none';
			} else {
				// Image already selected
				iFunc(null);
			}			
		}
		else {
			// flash fallback
			var raw_data = this.getMovie()._snap();
			
			// render to image, fire callback when complete
			var img = new Image();
			img.onload = func;
			img.src = 'data:image/'+this.params.image_format+';base64,' + raw_data;
		}
		
		return null;
	},
	
	configure: function(panel) {
		// open flash configuration panel -- specify tab name:
		// "camera", "privacy", "default", "localStorage", "microphone", "settingsManager"
		if (!panel) panel = "camera";
		this.getMovie()._configure(panel);
	},
	
	flashNotify: function(type, msg) {
		// receive notification from flash about event
		switch (type) {
			case 'flashLoadComplete':
				// movie loaded successfully
				this.loaded = true;
				this.dispatch('load');
				break;
			
			case 'cameraLive':
				// camera is live and ready to snap
				this.live = true;
				this.dispatch('live');
				break;

			case 'error':
				// Flash error
				this.dispatch('error', new FlashError(msg));
				break;

			default:
				// catch-all event, just in case
				// console.log("webcam flash_notify: " + type + ": " + msg);
				break;
		}
	},
	
	b64ToUint6: function(nChr) {
		// convert base64 encoded character to 6-bit integer
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		return nChr > 64 && nChr < 91 ? nChr - 65
			: nChr > 96 && nChr < 123 ? nChr - 71
			: nChr > 47 && nChr < 58 ? nChr + 4
			: nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
	},

	base64DecToArr: function(sBase64, nBlocksSize) {
		// convert base64 encoded string to Uintarray
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length,
			nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
			taBytes = new Uint8Array(nOutLen);
		
		for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
			nMod4 = nInIdx & 3;
			nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
			if (nMod4 === 3 || nInLen - nInIdx === 1) {
				for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
					taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
				}
				nUint24 = 0;
			}
		}
		return taBytes;
	},
	
	upload: function(image_data_uri, target_url, callback) {
		// submit image data to server using binary AJAX
		var form_elem_name = this.params.upload_name || 'webcam';
		
		// detect image format from within image_data_uri
		var image_fmt = '';
		if (image_data_uri.match(/^data\:image\/(\w+)/))
			image_fmt = RegExp.$1;
		else
			throw "Cannot locate image format in Data URI";
		
		// extract raw base64 data from Data URI
		var raw_image_data = image_data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
		
		// contruct use AJAX object
		var http = new XMLHttpRequest();
		http.open("POST", target_url, true);
		
		// setup progress events
		if (http.upload && http.upload.addEventListener) {
			http.upload.addEventListener( 'progress', function(e) {
				if (e.lengthComputable) {
					var progress = e.loaded / e.total;
					Webcam.dispatch('uploadProgress', progress, e);
				}
			}, false );
		}
		
		// completion handler
		var self = this;
		http.onload = function() {
			if (callback) callback.apply( self, [http.status, http.responseText, http.statusText] );
			Webcam.dispatch('uploadComplete', http.status, http.responseText, http.statusText);
		};
		
		// create a blob and decode our base64 to binary
		var blob = new Blob( [ this.base64DecToArr(raw_image_data) ], {type: 'image/'+image_fmt} );
		
		// stuff into a form, so servers can easily receive it as a standard file upload
		var form = new FormData();
		form.append( form_elem_name, blob, form_elem_name+"."+image_fmt.replace(/e/, '') );
		
		// send data to server
		http.send(form);
	}
	
};

Webcam.init();

if (typeof define === 'function' && define.amd) {
	define( function() { return Webcam; } );
} 
else if (typeof module === 'object' && module.exports) {
	module.exports = Webcam;
} 
else {
	window.Webcam = Webcam;
}

}(window));


</script><script>
//This code is opensource MIT license, by Ben F Rayfield 2021-7+, or someone may have forked after that.














"use strict";


//2 canvases of same size. webcam goes in a <video> dom object which is copied to canvasIn, then preprocessing (flip horizontal, etc),
//then Sim.io(dt,byteRectIn,byteRectOut) reads canvasIn, does physics/energy calculations, and writes canvasOut,
//then repeat many times per second for realtime augmented reality using webcam.
//ODO Sim.io use GPU.js optimization for springs and nonlinear color pull on voxel near those pixels.
var canvasInContext = null;
var canvasOutContext = null;
var canvasInImageData = null;
var canvasOutImageData = null;
var canvasInPixels = null;
var canvasOutPixels = null;
var canvasIn = null;
var canvasOut = null;
var byteRectIn = null;
var byteRectOut = null;

const timeOffset_ = performance.timing.navigationStart;

//TODO test this vs Date.now()*.001. It seems to match that very close but often has more digits.
//utc seconds. TODO more precise time, like java.lang.System.nanoTime
//in practice has microsecond precision and in theory could have nanosecond precision,
//but only relative to System.currentTimeMillis() which in practice has .01 second precision
//in time sync between it and remote computers, so if you use the 2 together,
//you can use a double for the timing of sound amplitudes, gamepad movements, and dates.
//Is there something like that in browser javascript?
//Maybe https://developer.mozilla.org/en-US/docs/Web/API/Performance/now ?
//This line of code compares them: console.log(''+(performance.timing.navigationStart + performance.now())*.001+'\n'+(Date.now()*.001));

//utc seconds, with a little more precision than Date.now()*.001
var time = ()=>((timeOffset_+performance.now())*.001);

var updateCanvasObjects = function(){
	canvasIn = document.getElementById('canvasIn');
	canvasOut = document.getElementById('canvasOut');
	if((canvasIn.width != canvasOut.width) || (canvasIn.height != canvasOut.height)) throw 'Diff size canvases, canvasIn and canvasOut';
	canvasInContext = canvasIn.getContext('2d');
	canvasOutContext = canvasOut.getContext('2d');
	canvasInImageData = canvasInContext.getImageData(0, 0, canvasIn.width, canvasIn.height);
	canvasOutImageData = canvasOutContext.getImageData(0, 0, canvasOut.width, canvasOut.height);
	canvasInPixels = canvasInImageData.data;
	canvasOutPixels = canvasOutImageData.data;
	byteRectIn = new ByteRect(canvasInPixels, canvasIn.height, canvasIn.width);
	byteRectOut = new ByteRect(canvasOutPixels, canvasOut.height, canvasOut.width);
	//console.log('updateCanvasObjects done.');
};

const AX = 0; //affineTransform X
const AY = 1; //affineTransform Y
const AZ = 2; //affineTransform Z
const AS = 3; //affineTransform S. TODO rename to M for Move or P for position.

const AXX = AX*4+AX; //affineTransform X-&gt;X (FIXME or is it <- ?)
const AXY = AX*4+AY;
const AXZ = AX*4+AZ;
const AXS = AX*4+AS;
const AYX = AY*4+AX;
const AYY = AY*4+AY;
const AYZ = AY*4+AZ;
const AYS = AY*4+AS;
const AZX = AZ*4+AX;
const AZY = AZ*4+AY;
const AZZ = AZ*4+AZ;
const AZS = AZ*4+AS;
const ASX = AS*4+AX;
const ASY = AS*4+AY;
const ASZ = AS*4+AZ;
const ASS = AS*4+AS; //TODO rename S to O for offset or P for position, or something like that. its not scale. its for position.

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3; //ALPHA isnt used in voxels, so another const also equals alpha's constant.


//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

ByteRect.prototype.copy = function(){
	let newBytes = new Uint8Array(this.bytes.length);
	copyBytes(this.bytes, newBytes);
	return new ByteRect(newBytes, this.height, this.width);
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

//TODO bilinear interpolation for smoother color?
ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[betweenInt(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)];
};

ByteRect.prototype.readBrightnessSafe = function(y, x){
	let i = between(0, (Math.round(y)*this.width+Math.round(x))*4, this.bytes.length-4);
	return (this.bytes[i+RED]+this.bytes[i+GREEN]+this.bytes[i+BLUE])/3;
};

/** same as readBrightnessSafe but as Float32Array whose length is this.bytes.length/4. a copy, not backing. */
ByteRect.prototype.brightnessFloats = function(y, x){
	let ret = new Float32Array(this.bytes.length/4);
	let i = 0;
	for(let j=0; j<this.bytes.length; j+=4){
		ret[i++] = (this.bytes[j+RED]+this.bytes[j+GREEN]+this.bytes[j+BLUE])/3;
	}
	return ret;
};

ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.writeSafeBright = function(y, x, brightByte){
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = brightByte;
	this.bytes[index+GREEN] = brightByte;
	this.bytes[index+BLUE] = brightByte;
	this.bytes[index+ALPHA] = 255;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.loopAve = function(loopSize, firstByteIndex, addByteIndex){
	let sum = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		sum += this.bytes[i];
		i += addByteIndex;
	}
	return sum/loopSize;
};

ByteRect.prototype.loopFractionOfBytesThatAreAtLeastVal = function(loopSize, firstByteIndex, addByteIndex, brightnessIsAtLeastThisByteVal){
	let count = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		if(brightnessIsAtLeastThisByteVal <= this.bytes[i]) count++;
		i += addByteIndex;
	}
	return count/loopSize;
};

ByteRect.prototype.loopWriteByte = function(loopSize, firstByteIndex, addByteIndex, writeByteVal){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i] = writeByteVal;
		i += addByteIndex;
	}
};

ByteRect.prototype.loopWriteBlack = function(loopSize, firstByteIndex, addByteIndex){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i+RED] = 0;
		this.bytes[i+GREEN] = 0;
		this.bytes[i+BLUE] = 0;
		i += addByteIndex;
	}
};

/** stdDev of looping over bytes (a row or column and colorDim).
optionalAve is from loopAve or as optional param it computes that.
*/
ByteRect.prototype.loopDev = function(loopSize, firstByteIndex, addByteIndex, optionalAve){
	if(optionalAve === undefined) optionalAve = this.loopAve(byteRect, firstByteIndex, addByteIndex);
	let sumOfSquares = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		let diff = this.bytes[i]-optionalAve;
		sumOfSquares += diff*diff;
		i += addByteIndex;
	}
	return Math.sqrt(sumOfSquares/loopSize);
};

/** ave brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowAve = function(y, colorDim){
	return this.loopAve(this.width, y*this.width*4+colorDim, 4);
};

/** stdDev of brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowDev = function(y, colorDim, optionalAve){
	return this.loopDev(this.width, y*this.width*4+colorDim, 4, optionalAve);
};

/** ave brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colAve = function(x, colorDim){
	return this.loopAve(this.height, x*4+colorDim, this.width*4);
};

/** stdDev of brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colDev = function(x, colorDim, optionalAve){
	return this.loopDev(this.height, x*4+colorDim, this.width*4, optionalAve);
};

ByteRect.prototype.setRowAndColordimToByte = function(y, colorDim, byteVal){
	this.loopWriteByte(this.width, y*this.width*4+colorDim, 4, byteVal);
};

ByteRect.prototype.setColAndColordimToByte = function(x, colorDim, byteVal){
	this.loopWriteByte(this.height, x*4+colorDim, this.width*4, byteVal);
};

ByteRect.prototype.rowFractionOfBytesThatAreAtLeastVal = function(y, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.width, y*this.width*4+colorDim, 4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.colFractionOfBytesThatAreAtLeastVal = function(x, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.height, x*4+colorDim, this.width*4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.setRowToBlack = function(y){
	this.loopWriteBlack(this.width, y*this.width*4, 4);
};

ByteRect.prototype.setColToBlack = function(x){
	this.loopWriteBlack(this.height, x*4, this.width*4);
};

//centerY, centerX, and radius can be scalars. Does bounds checking
var paintDonut = function(byteRect, centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
	if(minRadius > maxRadius) throw 'minRadius='+minRadius+' maxRadius='+maxRadius;
	var minYI = Math.max(0, Math.min(Math.floor(centerY-maxRadius), byteRect.height-1));
	var maxYI = Math.max(0, Math.min(Math.ceil(centerY+maxRadius), byteRect.height-1));
	var minXI = Math.max(0, Math.min(Math.floor(centerX-maxRadius), byteRect.width-1));
	var maxXI = Math.max(0, Math.min(Math.ceil(centerX+maxRadius), byteRect.width-1));
	var minRadiusSq = minRadius*minRadius;
	var maxRadiusSq = maxRadius*maxRadius;
	for(var y=minYI; y<=maxYI; y++){
		var i = byteRect.index(y, minXI, 0);
		for(var x=minXI; x<=maxXI; x++){
			var dy = y-centerY;
			var dx = x-centerX;
			let sq = dy*dy + dx*dx;
			if((minRadiusSq <= sq) && (sq <= maxRadiusSq)){
				//TODO optimize by skipping parts where this isnt true, in the loop before getting here.
				byteRect.bytes[i+RED] = redByte;
				byteRect.bytes[i+GREEN] = greenByte;
				byteRect.bytes[i+BLUE] = blueByte;
				byteRect.bytes[i+ALPHA] = 255;
			}
			i += 4;
		}
	}
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

ByteRect.prototype.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
	let circle = 2*Math.PI;
	let numPoints = Math.ceil(radius*circle*1.5);
	let anglePerPoint = 2*Math.PI/numPoints;
	for(let i=0; i<numPoints; i++){
		let angle = anglePerPoint*i;
		let x = cx+radius*Math.cos(angle);
		let y = cy+radius*Math.sin(angle);
		this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
	}
};


var bytesToFloats = function(bytes){
	let floats = new Float32Array(bytes.length);
	for(let i=0; i<bytes.length; i++) floats[i] = bytes[i];
	return floats;
};

var floatsToBytes = function(floats){
	let bytes = new Uint8Array(floats.length);
	for(let i=0; i<bytes.length; i++) bytes[i] = floats[i];
	return bytes;
};

var floatsAsMonochromeToPic = function(floats, height, width){
	if(floats.length != height*width) throw 'floats.length='+floats.length+' height='+height+' width='+width+' are diff sizes';
	let ret = new ByteRect(new Uint8Array(floats.length*4), height, width);
	let outb = ret.bytes;
	let j = 0;
	for(let i=0; i<ret.bytes.length; i+=4){
		//let bright = floats[j++];
		let bright = asByte(floats[j++]);
		outb[i+RED] = bright;
		outb[i+GREEN] = bright;
		outb[i+BLUE] = bright;
		outb[i+ALPHA] = 255; //visible
	}
	return ret;
};

var isByteRect = function(b){
	return (b.bytes && b.height && b.width);
};


var floats2dToFloats1d = function(floats2d){
	let size = 0;
	for(let i=0; i<floats2d.length; i++) size += floats2d[i].length;
	let ret = new Float32Array(size);
	let j = 0;
	for(let i=0; i<floats2d.length; i++){
		let innerFloats = floats2d[i];
		for(let k=0; k<innerFloats.length; k++){ //TODO optimize by range copy
			ret[j++] = innerFloats[k];
		}
	}
	return ret;
};

const maxPossibleColorDistanceSquared = 3*255*255;

//distance between observed red and redness of voxel (r g b in param) moving near it. sqrt of sum of square diffs.
//Since colors range 0..255, distance ranges 0..sqrt(3*255^2)=441.6729559300637.
const maxPossibleColorDistance = Math.sqrt(maxPossibleColorDistanceSquared);

//get y x velocity, given a certain color (of a voxel there), at an x, y, and rectangle_or_2d_bellcurve, to accel that voxel, and how to change its color
//View it as a 5d vector field of x y red green blue, or maybe 6d if you count the size of rectangle_or_2d_bellcurve but since it doesnt
//give a derivative for the size, maybe shouldnt include that. Also z dim (into or out of the screen) is a dim in other parts of the system but not here.
//TODO find a more efficient way to do this than 1 at a time and returning a new [5 numbers] each time, but this is early experiments.
//size param is normally 1-20 and must always be at least 1. size is 2*radius.
//r g b are 0..255. Derivatives returned are floats.
//0 <= y < byteRect.height.
//0 <= x < byteRect.width.
//OLD: If isPaintOver, then paints over the area observed, to show what its observing and the weights there.
//byteRectOutOrNull is null to not paint anything, or nonnull to paint at byteRectOutOrNull
ByteRect.prototype.yxrgbDerivs = function(size, y, x, r, g, b, byteRectOutOrNull){
	//FIXME if size is even, or x and y are not integers, then can pull a direction cuz of roundoff?
	//Or will it avoid that to compare weightedSum of x and y to the average x and y of the pixels measured
	//instead of comparing it to the param x and y?

	if(size < 1) throw 'size='+size;
	let radius = size/2;
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,this.width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,this.height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);
	//do it the simple square way for now, but bellcurve is better todo that
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = 2;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (byteRectOutOrNull ? byteRectOutOrNull.bytes : null);
	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*this.width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			sumR += rr;
			sumG += gg;
			sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
			
				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				sumYByWeight += yy*weight;
				sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	if(sumWeight > 0){
	//if(sumWeight > 10){ //FIXME
		let aveYByWeight = sumYByWeight/sumWeight;
		let aveXByWeight = sumXByWeight/sumWeight;
		dy += (aveYByWeight-aveYUnweighted)/size;
		dx += (aveXByWeight-aveXUnweighted)/size;
		let aveR = sumR/numPixels;
		let aveG = sumG/numPixels;
		let aveB = sumB/numPixels;
		dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
		dg += aveG-g;
		db += aveB-b;
	}else{
		//console.log("yxrgbDerivs.sumWeight="+sumWeight);
	}
	return Float32Array.of(dy, dx, dr, dg, db);
};

var dom = (id)=>document.getElementById(id);

var prevTime = time();

var webcamFrames = 0;
var webcamFpsObserved = 1;

//targetSum is target red+green+blue to norm each pixel to. returns new ByteRect.
var normPixelsAllToSameBrightness = function(byteRect, targetSum){
	let inb = byteRect.bytes;
	let ret = new ByteRect(new Uint8Array(inb.length), byteRect.height, byteRect.width);
	let retb = ret.bytes;
	for(let i=0; i<inb.length; i+=4){
		let sum = inb[i+RED]+inb[i+GREEN]+inb[i+BLUE];
		if(sum == 0){
			let bright = targetSum/3;
			retb[i+RED] = bright;
			retb[i+GREEN] = bright;
			retb[i+BLUE] = bright;
		}else{
			let mul = targetSum/sum;
			retb[i+RED] = inb[i+RED]*mul;
			retb[i+GREEN] = inb[i+GREEN]*mul;
			retb[i+BLUE] = inb[i+BLUE]*mul;
		}
		retb[i+ALPHA] = 255; //visible
		//FIXME? floor ceil round range as its probably a Uint8ClampedArray?
	}
	return ret;
};

var normPixelsAllToSameBrightness_mutable = function(byteRect, targetSum){
	let b = byteRect.bytes;
	for(let i=0; i<b.length; i+=4){
		let mul = targetSum/(1+b[i+RED]+b[i+GREEN]+b[i+BLUE]);
		b[i+RED] *= mul;
		b[i+GREEN] *= mul;
		b[i+BLUE] *= mul;
	}
};

var lastDatauri = null;

var take_snapshot = function(sim){
	// play sound effect
	//shutter.play();
	
	canvasInContext.drawImage(Webcam.video, 0, 0, canvasIn.width, canvasIn.height);
	updateCanvasObjects();
	let now = time();
	let dt = now-prevTime;
	prevTime = now

	webcamFrames++;
	webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
	let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
	dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;
	let pic = byteRectIn;
	let h = byteRectIn.height;
	let w = byteRectIn.width;
	normPixelsAllToSameBrightness_mutable(pic,500);
	copyBytes(pic.bytes, byteRectOut.bytes);
	canvasOutContext.putImageData(canvasOutImageData, 0, 0);
	

	// take snapshot and get image data
	if(false) Webcam.snap(
		function(data_uri){
			lastDatauri = data_uri;
			dom('theImg').src = lastDatauri;
			
			return;
			
			let video = Webcam.video;
			if(video !== undefined){
				
				canvasInContext.drawImage(video, 0, 0, canvasIn.width, canvasIn.height);
				updateCanvasObjects();
				let now = time();
				let dt = now-prevTime;
				prevTime = now

				webcamFrames++;
				webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
				let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
				dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;

				byteRectIn.flipHorizontal(); //part of preprocessing
				//TODO move color norming here, so sim.io doesnt modify byteRectIn. part of preprocessing.
				//if(sim.paintTestObjectsAsInput){
					//FIXME also paint them onto output (in sim.io(...) if !sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack ?
					//paintTestsOntoByteRectIn(now,byteRectIn);
				//}
				let pic = byteRectIn;
				
				
				
				let h = byteRectIn.height;
				let w = byteRectIn.width;
				
				//normPixelsAllToSameBrightness_mutable(pic,500);
				//normPixelsAllToSameBrightness_mutable(pic,500);
				
				//pic = normPixelsAllToSameBrightness(pic, 500);
								
				
				//if(sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
					//pic = normPixelsAllToSameBrightness(pic, 255);
					//pic = normPixelsAllToSameBrightness(pic, 500);
				//}
				
				//if(sim.isFindEdgesAndKeepTheirColor){
				//	sim.findEdgesAndKeepTheirColor_modifyByterect(pic, sim.minColorDiffFractionToBeADot);
				//}
				
				//if(sim.isFindDots){
				//	pic = sim.findDots(pic, sim.findDots_maxDotSize_param);
				//}
				
				
				
				//if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU){
				//	pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls(pic);
				//}
				//if(//sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG){
					//let allowBytesIntoGpu = sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy;
					//pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu(pic, true, allowBytesIntoGpu);
					//TODO optimize: let pic be monochrome Float32Array here (gpujs outputs that)
					//so preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu can take Float32Array as input,
					//skipping a step of copying each float into 3 equal bytes then back to float.
				//}
				
				/*if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic){
					//these lines seem to be caused by camera norming color in a grid of many small rectangles, and the
					//code to norm colors is so good that it finds them which are otherwise not much visible to the naked eye.
					sim.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic(
						pic, //modifies pic
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction
					);
				}
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu){
					pic = sim.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu(
						pic, //this can be ByteRect or  (TODO?)[Float32Array as monochrome]
						h,
						w,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction,
						true //isModifyByteRectIn
						//true //true return ByteRect (else Float32Array)
					);
				}*/
				
				//if(pic != byteRectIn){
					//copyBytes(pic.bytes, byteRectIn.bytes);
					//TODO optimize: by not creating another ByteRect?
					//TODO optimize: is bytaeRectIn from canvasIn? Does it need to be? Or just call sim.io(dt, pic, byteRectOut) to skip this copyBytes?
				//}
				//sim.io(dt, byteRectIn, byteRectOut);
				//canvasInContext.putImageData(canvasInImageData, 0, 0);
				
				copyBytes(pic.bytes, byteRectOut.bytes);
				
				canvasOutContext.putImageData(canvasOutImageData, 0, 0);
				//if((webcamFrames%10)==0) console.log("webcamFpsObserved="+webcamFpsObserved+"    frames="+webcamFrames+" time="+now);
			}
			// display results in page
			//document.getElementById('results').innerHTML =  '<img src="'+data_uri+'"/>';
		}
	);
};

var between = (min, val, max)=>Math.max(min,Math.min(val,max));

var betweenInt = (min, val, max)=>Math.round(Math.max(min,Math.min(val,max)));

var asByte = (x)=>Math.max(0,Math.min(Math.floor(x),255));

var warnIfStrangeDt = function(dt){
	//a good dt is .02 for 50 fps, or .01 is better, but anything less than .01 wont be much noticable improvement in graphics,
	//but it might improve the convergence of the physics energy equations
	//(springs, color matching, etc, all part of a single energy equation, TODO)
	//to run multiple physics/energy/puzzleSolving cycles per display/webcam cycle.
	if((dt <= 0) || (dt > .2)) console.log('dt='+dt);
};

var rand = function(min,max){
	return min+(max-min)*Math.random();
};

//0 to maxExcl-1, if 0<=maxExcl<approx_2pow53minusALittleForRoundoffSoMaybe2pow50 after that doubles cant represent all possible integers.
var randInt = (maxExcl)=>Math.floor(Math.random() * maxExcl);

/*var Slidebar = function(){
	this.getFraction = 
	<input type="range" id="vol" min="0" max="1000000" value="777777" oninput="console.log(this.valueAsNumber/1000000);">
};*/

//0..255
var randByte = ()=>Math.floor(Math.random()*256);

var onceRandomBytes = [];
var testPointEnabled = [];
for(let i=0; i<30000; i++){
	onceRandomBytes.push(randByte());
	//onceRandomBytes.push(Math.floor(Math.random()*256));
	testPointEnabled.push(true);
}

var paintTestsOntoByteRectIn = function(now, byteRect){
	let circleRadius = 15;
	let which_onceRandomBytes = 0;
	let isDisplaying = true;
	let numTestPoints = 70;
	let freq = .05; //turns of this test object per second
	/*if(Math.random()<.15){
		for(let j=0; j<numTestPoints; j++){
			if(Math.random() < .3){
				//randomly display or not display some parts of this object, to test if the voxels move there anyways cuz of springs
				isDisplaying = !isDisplaying;
			}
			testPointEnabled[j] = isDisplaying;
		}
	}*/
	for(let i=0; i<numTestPoints; i++){
		
		if(testPointEnabled[i]){
			let a = 2*Math.PI*(i/numTestPoints+now*freq);
			let yFraction = .5+.3*Math.sin(a);
			let xFraction = .5+.3*Math.cos(a);
			let red = onceRandomBytes[which_onceRandomBytes];
			let green = onceRandomBytes[which_onceRandomBytes+1];
			let blue = onceRandomBytes[which_onceRandomBytes+2];
			paintDonut(
				byteRect,
				byteRect.height*yFraction,
				byteRect.width*xFraction,
				0, //inner radius
				circleRadius,
				red,
				green,
				blue
			);
		}
		which_onceRandomBytes += 3;
	}
};

//These epsilons are meant to be multiplied by the number they're used with, like if distance between 2 voxels is 507.3
//and you want potentialEnergy derivative there, use 507.3 and 507.3*(1+EPSILON) and divide that difference by EPSILON,
//else you will (more often than not, probably) lose more precision than the EPSILON was designed for, compared to 507.3+EPSILON.
//
const EPSILON_FOR_FLOAT = Math.pow(.5,13); //float is exact for all integers in plus/minus 2^24. Browser GPU.js uses floats, unknown if its IEEE754 deterministic.
const EPSILON_FOR_DOUBLE = Math.pow(.5,27); //double is exact for all integers in plus/minus 2^53. Unknown if browser javascript is IEEE754 deterministic.
const EPSILON = EPSILON_FOR_FLOAT; //even though using doubles 2021-7-25, planning to use GPU.js which creates Float32Arrays.

/** 4x4 identityFunc affine transform */
var newIdentAftrans = function(){
	return Float32Array.of(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
	/*let a = new Float32Array(16);
	a[AXX] = 1;
	a[AYY] = 1;
	a[AZZ] = 1;
	a[ASS] = 1;
	return a;
	*/
};

var newRandAftransNearIdent = function(){
	let a = newIdentAftrans();
	for(let i=0; i<a.length; i++){
		a[i] += .1*(Math.random()*2-1);
	}
	return a;
};

var newRandAftrans = function(){
	let a = new Float32Array(16);
	for(let i=0; i<a.length; i++){
		a[i] = Math.random()*4-2; //-2 to 2. TODO unit bellcurve
	}
	return a;
};

var defaultNumAnglesOfCircle = 100;

var verifyAftrans = function(aftrans){
	if(!aftrans) throw 'aftrans='+aftrans;
	//if(!(aftrans.length)) throw 'aftrans.length='+aftrans.length;
	if(aftrans.length != 16) throw 'aftrans.length='+aftrans.length+' but must be 16 cuz 4x4';
};

const emptyArray = new Float32Array(0);

//ab is Float32Array(a*b). bc is Float32Array(b*c). Returns Float32Array(a*c).
//TODO GPU.js if its big, but might want to merge multiple kernels to happen at once for intheory lower lag.
//Theres some func to "combine kernels" in GPU.js.
//
//Dont use GPU.js every time cuz this will be called about 150 times per video frame, on small arrays,
//just to create equatorAngles+poleAngles balls to check for equatorAngles*equatorAngles*poleAngles possible rotations
//(then do a similar thing but to get about 0.1 pixel precision of 3d position and 3d angle of tennis ball used as 6d joystick).
var matmul = function(ab, bc, a, b, c){
	return matmulCpu(ab, bc, a, b, c);
};

var aftransOfAftrans = function(outerAftrans, innerAftrans){
	//FIXME is this right? Use transpose or not? Swap the order of outer and inner?
	//return matmul(outerAftrans,transpose4x4(innerAftrans),4,4,4);
	return matmul(outerAftrans,innerAftrans,4,4,4);
};

var copyBytes = function(bytesIn, bytesOut){
	for(let i=0; i<bytesOut.length; i++){
		bytesOut[i] = bytesIn[i];
	}
};


var matmulCpu = function(ab, bc, aSize, bSize, cSize){
	let ret = new Float32Array(aSize*cSize);
	for(let a=0; a<aSize; a++){
		for(let c=0; c<cSize; c++){
			//TODO this will be most of the GPU code in matmulGpu:
			let sum = 0; //double*double then cast to float differs from [float*float which is intheory what you get in GPU.js. TODO align with lazycl]
			for(let b=0; b<bSize; b++){
				sum += ab[a*bSize+b]*bc[b*cSize+c];
			}
			ret[a*cSize+c] = sum;
		}
	}
	return ret;
};

var transpose4x4 = function(aftrans){
	let a = new Float32Array(16);
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			a[4*i+j] = aftrans[4*j+i];
		}
	}
	return a;
};

var dom = id=>document.getElementById(id);


/** matrix inverse for Float32Array(16) as 4x4. Throws if matrix is not invertible (happens when it has 0s in certain places, etc) Example:
<br><br>
Float32Array(16)[40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0]
for(i in af) if(af[i] == 0) af[i] = 1
<br><br>
1
inverse4x4(af)
Float32Array(16)[0.006666666828095913, -0.013333333656191826, -0, 0.006666666828095913, -0.008333333767950535, 0.008333333767950535, -0, -0, -0.11851851642131805, 0.014814814552664757, 0.1111111119389534, -0.007407407276332378, 0.5185185074806213, 0.8518518805503845, -0.1111111119389534, -0.25925925374031067]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16)[1, 0, 0, 0, 0, 1, 0, 0, 1.3969838619232178e-7, -1.1175870895385742e-7, 1, 2.7939677238464355e-9, 0.0000017136335372924805, 0.000003874301910400391, 1.4901161193847656e-8, 1]
<br><br>
af
Float32Array(16)[38.17185974121094, -37.34263610839844, 0.567450225353241, 0.9653493165969849, 44.762725830078125, 75.62342834472656, 2.032400608062744, 1.092972755432129, 47.32026290893555, -49.86602020263672, 9.876603126525879, 0.9346176981925964, 314.396484375, 233.5746307373047, 4.626655578613281, 4.095148086547852]
aftransOfAftrans(af,inverse4x4(af))
Float32Array(16)[1, -2.8939762586333018e-8, -6.901840432504969e-9, 6.330946877852739e-9, 6.891576731504756e-8, 0.9999999403953552, -4.097648442780155e-9, 7.388507139438616e-9, 2.5632354905269494e-8, -1.2609987720679783e-8, 1, 7.609613383863234e-9, 2.213476051338148e-7, -1.2695329587586457e-7, -1.5567275468697517e-8, 1.0000001192092896]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16)[1.0000001192092896, 6.570027011321145e-8, 1.0449441312232466e-9, 1.00316499551667e-9, 1.7116050798904325e-8, 1, 6.754415915466438e-10, 4.2082873297211165e-10, 2.8648202032854897e-8, 9.683519408554275e-8, 1, 1.570354069002633e-9, -0.0000015082332538440824, -0.000004397804332256783, -1.0071694589441904e-7, 1]
<br><br>
got this from asking wolframalpha "inverse {{a, b, c, d}, {e, f, g, h}, {i, j, k, l}, {m, n, o, p}}", and it responded with the fact of math in this code.
https://www.wolframalpha.com/input/?i=inverse+%7B%7Ba%2C+b%2C+c%2C+d%7D%2C+%7Be%2C+f%2C+g%2C+h%7D%2C+%7Bi%2C+j%2C+k%2C+l%7D%2C+%7Bm%2C+n%2C+o%2C+p%7D%7D
*/
var inverse4x4 = function(aftrans){
	let a = aftrans[0];
	let b = aftrans[1];
	let c = aftrans[2];
	let d = aftrans[3];
	let e = aftrans[4];
	let f = aftrans[5];
	let g = aftrans[6];
	let h = aftrans[7];
	let i = aftrans[8];
	let j = aftrans[9];
	let k = aftrans[10];
	let l = aftrans[11];
	let m = aftrans[12];
	let n = aftrans[13];
	let o = aftrans[14];
	let p = aftrans[15];
	let W = a*f*k*p - a*f*l*o - a*g*j*p + a*g*l*n + a*h*j*o - a*h*k*n - b*e*k*p + b*e*l*o + b*g*i*p - b*g*l*m - b*h*i*o + b*h*k*m;
	let X = c*(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m);
	let Y = d*(- e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m);
	let mul = 1/(W + X + Y);
	if(mul == Infinity) throw 'Not invertible matrix';
	return Float32Array.of(
		(f*k*p - f*l*o - g*j*p + g*l*n + h*j*o - h*k*n)*mul,
		( - b*k*p + b*l*o + c*j*p - c*l*n - d*j*o + d*k*n)*mul,
		(b*g*p - b*h*o - c*f*p + c*h*n + d*f*o - d*g*n)*mul,
		( - b*g*l + b*h*k + c*f*l - c*h*j - d*f*k + d*g*j)*mul,
		( - e*k*p + e*l*o + g*i*p - g*l*m - h*i*o + h*k*m)*mul,
		(a*k*p - a*l*o - c*i*p + c*l*m + d*i*o - d*k*m)*mul,
		( - a*g*p + a*h*o + c*e*p - c*h*m - d*e*o + d*g*m)*mul,
		(a*g*l - a*h*k - c*e*l + c*h*i + d*e*k - d*g*i)*mul,
		(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m)*mul,
		( - a*j*p + a*l*n + b*i*p - b*l*m - d*i*n + d*j*m)*mul,
		(a*f*p - a*h*n - b*e*p + b*h*m + d*e*n - d*f*m)*mul,
		( - a*f*l + a*h*j + b*e*l - b*h*i - d*e*j + d*f*i)*mul,
		( - e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m)*mul,
		(a*j*o - a*k*n - b*i*o + b*k*m + c*i*n - c*j*m)*mul,
		( - a*f*o + a*g*n + b*e*o - b*g*m - c*e*n + c*f*m)*mul,
		(a*f*k - a*g*j - b*e*k + b*g*i + c*e*j - c*f*i)*mul
	);
};

/** given a Float32Array(prevCols*prevRows) viewed as [prevCols][prevRows], returns a new Float32Array to be viewed as [prevRows][prevCols]. */
var transpose = function(matrix, prevCols, prevRows){
	if(matrix.length != (prevCols*prevRows)) throw 'matrix.length='+matrix.length+' prevCols='+prevCols+' prevRows='+prevRows;
	let ret = new Float32Array(matrix.length);
	for(let pc=0; pc<prevCols; pc++){
		for(let pr=0; pr<prevRows; pr++){
			ret[pr*prevCols+pc] = matrix[pc*prevRows+pr];
		}
	}
	return ret;
};


const twoPi = 2*Math.PI;


let aftransStr = function(aftrans){
	return 'Float32Array.of('+aftrans[0]+', '+aftrans[1]+', '+aftrans[2]+', '+aftrans[3]+', '
		+aftrans[4]+', '+aftrans[5]+', '+aftrans[6]+', '+aftrans[7]+', '
		+aftrans[8]+', '+aftrans[9]+', '+aftrans[10]+', '+aftrans[11]+', '
		+aftrans[12]+', '+aftrans[13]+', '+aftrans[14]+', '+aftrans[15]+')';
};

var radiusOfAftrans4x4 = af=>Math.hypot(af[AXX],af[AXY],af[AXZ],af[AYX],af[AYY],af[AYZ],af[AZX],af[AZY],af[AZZ]);



var copyFloat32Array = function(arr){
	return Float32Array.from(arr);
};

var copyFloat32ArrayFromTo = function(from, to){
	if(from.length != to.length) throw 'Diff sizes';
	for(let i=0; i<from.length; i++) to[i] = from[i]; //TODO optimize by calling Float32Array func to do this
};

/** a dimension on a gamepad, such as right joystick horizontal (-1 to 1) or left analog trigger (0 to 1),
except the part near 0 is ignored and farther away is moved to be the new 0 so it feels smooth,
but with deadzone so if you arent holding it, it doesnt drift a little.
<br><br>
TODO fix this with better statistics, automatic calibration of center position and size of deadzone.
Statistically, theres a small range of possible joystick positions that the joystick will be in that range unusually often,
and those are either as far as it can be pushed in some direction or when person is not touching the joystick.
If, for each dimension separately, take stats in a float[10000], which is 10000 positions between -1 and 1,
and for each, decay toward the fraction of the time the joystick has been below that position (such as between -1 and .312, is the .312 position),
then can get the fraction of the time it has been in any range by subtracting the 2 ends, such as range .029 to .312 (joystick position)
happened float[indexOf(.312)]-float[indexOf(.029)] fraction of the time (which will always range 0 to 1).
The deadzone of the joystick should be a range somewhere near the middle thats a range its at more often than any other range of the same size.
Instead of decay rate (which could use DecayBell.java, todo copy that code here, for faster decay when have less data)...
Instead of that, could just add to stats whenever the joystick has moved in the last t time (such as 1 second).
<br><br>
TODO make auto joystick calibration while playing be a separate js library,
which could lead to nobody ever having to calibrate any joystick again in any system,
and it would increase precision of the joystick by making the deadzone smaller and the deadzone would vary its position instead of just its size.
*/
var controlWithDeadzone = function(name, deadZone){
	let val = control(name);
	if(Math.abs(val) < deadZone){
		return 0;
	}else{
		if(val > 0){
			return val-deadZone; //dont jump, it starts as 0 movement at border of deadzone and gradually more
		}else{
			return val+deadZone;
		}
	}
};

//returns [valA, valB] with circle of deadzone.
//Not jumpy. It doesnt jump from 0 to deadZone at deadZone. There, its 0, and gradually more.
var control2WithDeadzone = function(deadZone, nameA, nameB){
	let valA = control(nameA);
	let valB = control(nameB);
	let len = Math.hypot(valA,valB);
	if(len < deadZone) return [0, 0];
	let newLen = len-deadZone;
	let mul = newLen/len;
	return [valA*mul, valB*mul];
};

//af is normally selectedOb.aftrans such as a ball to move and rotate.
var controllerTransformsAftrans = function(controllerName, afIn, dt){
	
	//TODO optimize: can this be done by returning an aftrans thats reusable, such as to rotate all the points on the ball?
	
	let mulRotate = 6*dt;
	let mulResize = 2.5*dt;
	let mulMove = 620*dt;
	
	let af = copyFloat32Array(afIn);
	
	for(let i=12; i<16; i++) af[i] = 0; //centered at origin. Put these back after rotations.
	
	
	
	
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0', controllerName+'_dim1'); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2', controllerName+'_dim3'); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let mulSize = 1+(rb-lb)*mulResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	console.log('angleB='+angleB+' angleC='+angleC+' angleD='+angleD);
	
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*/
	
	//let dimA = AX;
	//let dimB = AY;

	let dimA = 0;
	let dimB = 0;
	let angle = 0;
	for(let kindOfRotation=0; kindOfRotation<3; kindOfRotation++){
		switch(kindOfRotation){
		case 0:
			dimA = AX;
			dimB = AZ;
			angle = angleB;
		break;case 1:
			dimA = AY;
			dimB = AZ;
			angle = angleC;
		break;case 2:
			dimA = AX;
			dimB = AY;
			angle = angleD;
		}
		for(let i=0; i<4; i++){
			//if((i == dimA) || (i == dimB)){
			
				//let indexJ = dimA*4+i; //FIXME i*4+dimA?
				//let indexK = dimB*4+i; //FIXME i*4+dimB?
				let indexJ = i*4+dimA;
				let indexK = i*4+dimB;
				let prevValJ = af[indexJ];
				let prevValK = af[indexK];
				af[indexJ] = prevValJ*Math.cos(angle) - prevValK*Math.sin(angle); //TODO optimize by reusing sin and cos
				af[indexK] = prevValJ*Math.sin(angle) + prevValK*Math.cos(angle);
			//}
		}
		
		/*
		[dimA*4+dimB] = Math.cos(angleD);
		c[dimA*4+dimB] = -Math.sin(angleD);
		c[dimA*4+dimB] = Math.sin(angleD);
		c[dimA*4+dimB] = Math.cos(angleD);
		*/
	}
	
	af[AXX] *= mulSize;
	af[AXY] *= mulSize;
	af[AXZ] *= mulSize;
	af[AYX] *= mulSize;
	af[AYY] *= mulSize;
	af[AYZ] *= mulSize;
	af[AZX] *= mulSize;
	af[AZY] *= mulSize;
	af[AZZ] *= mulSize;
	
	for(let i=12; i<16; i++) af[i] = afIn[i]; //get original position back. keep rotation.
	
	af[ASX] += o*mulMove;
	af[ASY] += p*mulMove;
	
	return af;
};


var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};

//var copySliderToObField = function(slider, ob, field){
//};

//log<base>(val), such as log<e>(e^3)==3
var logBase = function(base, val){
	return Math.log(val)/Math.log(base);
};

//TODO no escapes cuz its field names, but wouldnt hurt to have them anyways
let arrayOfFieldNamesToJsCodeUsingSingleQuotes = function(array){
	let s = '[';
	for(let i in array){
		if(i > 0) s += ', ';
		s += "'"+array[i]+"'";
	}
	return s+']';
};

//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var vars = {};

//filled by getButtonsJoysticksEtc() many times per second.
var controls = {};

/** get something in the controls map or 0 if its not there. Example: control('gamepad0_dim3') returns a number -1 to 1
for that joystick axis, if its a joystick and if there is a first (0th) gamepad.
*/
var control = function(key){
	//TODO call getButtonsJoysticksEtc again? check if its the same millisecond since called it last, and only call again if isnt.
	return controls[key] || 0;
};

//Example: let x = newVar(10); eval(x+' = x*x+5;'); eval(x) is 105.
//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var newVar = function(val){
	let id = newId();
	vars[id] = val;
	return 'vars.'+id;
};


var isFirstUseOfSimAfterWebcamStarted = true;

var mouseY = 0;
var mouseX = 0;
var mouseYFraction = 0;
var mouseXFraction = 0;

//for mouse to rotate andOr move ball. This could be any game object (that has a .aftrans and .childs etc), such as Ball or AfPoint.
//TODO move this and trySetSelectedOb into Sim
var selectedOb = null;

var sim = null; //set in window.onload

//returns true/false did it set selectedOb
var trySetSelectedOb = function(ob){
	let allowChangeIfSomethingAlreadySelected = (!sim || sim.allowChangeSelectedObIfSomethingAlreadySelected);
	if(ob && (!selectedOb || allowChangeIfSomethingAlreadySelected)){
		selectedOb = ob;
		return true;
	}
	return false;
};

let isRunningMainLoop = false; //main loop has to stop between painting the screen. Use this to avoid timers possibly running the main loop twice at once.

window.onload = function(){


	// Configure a few settings and attach camera
	Webcam.set({
		fps: 120,               // camera frames per second. FIXME? webcamjs seems to ignore this param.
		width: 160, //FIXME changing thse seems to have no effect 2021-8
		height: 120,
		//width: 320, //FIXME changing thse seems to have no effect 2021-8
		//height: 240,
		//image_format: 'png',
		flip_horiz: true,
		image_format: 'jpeg', //FIXME why does this seem to have no effect? jpeg vs png, and jpeg_quality of 90 vs 3?
		//jpeg_quality: 90
		jpeg_quality: 5
	});
	Webcam.attach('#my_camera');

	/*
	// preload shutter audio clip
	var shutter = new Audio();
	shutter.autoplay = true;
	shutter.src = navigator.userAgent.match(/Firefox/) ? 'shutter.ogg' : 'shutter.mp3';
	*/

	updateCanvasObjects();
	//replaceSim();

	


	




	//why didnt this fix it, and still need to click restart after it loads (to get voxels off edges of screen they moved too fast got stuck)?: sim.restart(); //cuz changed sim.varnames
	
	//createControlsForSimInDiv(sim, dom('controlsDiv_checkboxes'), dom('controlsDiv_sliders'), dom('controlsDiv_buttons'));
	
	let x = function(){
		if(isRunningMainLoop){
			console.log('WARNING: Already isRunningMainLoop='+isRunningMainLoop);
			return;
		}
		isRunningMainLoop = true;
		try{
			if(Webcam.live){ //FIXME also check isPaused here?
				take_snapshot(sim);
				//dom('buttonsJoysticksEtcDiv').innerHTML = "<br>"+JSON.stringify(getButtonsJoysticksEtc()).replaceAll(',',',<br>');
				//setTimeout(x, 20);
				if(isFirstUseOfSimAfterWebcamStarted){
					isFirstUseOfSimAfterWebcamStarted = false;
					adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff();
					//sim.restart();
				}
				//if(sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked){
				//	setTimeout(x, 1); //likely to get out of sync compared to requestAnimationFrame but seems to get a little higher fps than requestAnimationFrame
				//}else{
					requestAnimationFrame(x);
				//}
			}else{
				console.log('Webcam isnt on yet');
				setTimeout(x, 500);
			}
		}finally{
			isRunningMainLoop = false;
		}
	};
	x();
	
};


//Returns a map of button/joystick/etc name to number in range -1 to 1. TODO Everything not in the map means 0? Or include zeros?
//gamepad api, todo also add mouse, keyboard, etc. Any data flow from person to computer that doesnt need high bandwidth.
//sound and video need high bandwidth.
//This is called many times per second since navigator.getGamepads() only reads gamepad state once and does not start a stream of it (like browsers used to).
//
/*TODO use controller rumble. I got it to work with bluetooth xbox controller in win10 in chrome (first browser I tried) 2021-8-28 with this
gamepad.vibrationActuator.playEffect("dual-rumble", {
	duration: 1000,
	strongMagnitude: 1.0,
	weakMagnitude: 1.0
})
but it kept rumbling, maybe cuz i was in browser debugger at a breakpoint.
*/
var getButtonsJoysticksEtc = function(){
	let gamepads = navigator.getGamepads(); //may contain nulls, such as [null, null, null, null] or [aGamepad, null, null, null].
	let ret = {};
	ret.mouse0_dim0 = mouseYFraction*2-1; //TODO swap y and x order of dims?
	ret.mouse0_dim1 = mouseXFraction*2-1;
	for(let i=0; i<gamepads.length; i++){
		let gamepad = gamepads[i];
		if(gamepad){
			let s = gamepad.id;
			if(!s) s = 'gamepad';
			//s = s.trim().replaceAll(/\s|\(|\)/g,'_');
			s = s.trim().replaceAll(/\(|\)/g,'').replaceAll(/\s/g,'_');
			//let gamepadName = s+'_index'+i;
			let gamepadName = 'gamepad'+i;
			
			//let buttonOrAxisNum = 0;
			for(let a in gamepad.axes){
				//ret[gamepadName+'_'+(buttonOrAxisNum++)] = gamepad.axes[a];
				ret[gamepadName+'_dim'+a] = gamepad.axes[a];
			}
			for(let b in gamepad.buttons){
				ret[gamepadName+'_btn'+b] = gamepad.buttons[b].value; //GamepadButton {pressed: false, touched: false, value: 0}
			}
			if(gamepad.vibrationActuator){
				ret[gamepadName+'_vib0_TODO'] = 0; //TODO see how I used this in comment of getButtonsJoysticksEtc
			}
			
		}
	}
	ret.eventExists = 1; //becomes 0 after event is consumed
	return ret;
};

var domSetSize = function(dom, width, height){
	if(dom.width) dom.width = width;
	else dom.style.width = width+'px';
	if(dom.height) dom.height = height;
	else dom.style.height = height+'px';
};

var adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff = function(){
	let webcamVideo = Webcam.video;
	if(!webcamVideo) throw 'No webcam yet, webcamVideo='+webcamVideo;
	let physicalCameraAspectRatio = webcamVideo.videoWidth/webcamVideo.videoHeight; //may differ from aspectRatio on screen.
	let observedCanvasWidth = canvasOut.width;
	let newCanvasWidth = observedCanvasWidth;
	let newCanvasHeight = Math.ceil(observedCanvasWidth/physicalCameraAspectRatio);
	domSetSize(dom('canvasIn'), newCanvasWidth, newCanvasHeight);
	domSetSize(dom('canvasOut'), newCanvasWidth, newCanvasHeight);
	
};

</script>

</head><body>

<textarea id=code rows=3 cols=100></textarea><br>
<input type=button onclick="let code = document.getElementById('code').value; log.value = eval(code);" value="eval"></input>
<input type=button onclick="document.getElementById('code').value = '';" value="X"></input><br>
<textarea rows=3 cols=100 id=log></textarea><br>
canvasOut:<br>
<canvas id="canvasOut" style="transform:scaleX(-1)" width=160 height=120 onmousemove="let rect = this.getBoundingClientRect(); mouseY = event.clientY-rect.top; mouseYFraction = between(0,mouseY/this.clientHeight,1); mouseX = event.clientX-rect.left; mouseXFraction = between(0,mouseX/this.clientWidth,1); /*trySetSelectedOb(sim.whatsAtYx([mouseY,mouseX]));*/ /*if(selectedOb) selectedOb.randomizeColors();*/"></canvas><br>
<div id="fpsLabel"></div><br>
canvasIn:<br>
<canvas id="canvasIn" width=160 height=120 style="transform:scaleX(-1)"></canvas><br>
camera:<br>
<div id="my_camera"></div><br>
<img id=theImg>


</body></html>