<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" /> 
<title>2D Resizable Rectangle Simulation</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
<script>
//This software is offered by Ben F Rayfield under opensource MIT license.
console.log('Opensource MIT. This software (for now called Blob Monsters Game) is offered by Ben F Rayfield under opensource MIT license. What would cause them to sync? Those who want to play the same online game by the same rules would naturally want to be in sync while playing it, anything to the contrary adding to loss function and accelerated by negative gradient of the whole game state across the earth which is a sparse dimensional vector. Blob Monsters Game has 3 teams (red green blue), displays distance to nearest voxel of each. 9 bytes per pixel. 26 bits counts num of monsters touching this pixel. 6 bit color of voxels (24 bit color for the distance fields). 10 bits for distance up to 255. 3 bits for team masks. See game.rps.team, game.rps.tridist, game.board, and game.gob[int].m.team. The 3 teams are REDTEAM, GREENTEAM, BLUETEAM, and BLACKTEAM==0 means no gob is at that pixel.\n\nmonster = V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e is the name of some "blob monster" (object), identified by whatever JS code controls its vector & voxels it computes at that vec. To create monster: monster.p = 1; To delete: monster.p = 0; V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path(). V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path() returns "V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.sideA".\n\nIts an in-memory high dimensional vector database designed for gaming-low-lag massively multiplayer sync, where any simple javascript lambda, that takes Var objects as named params, fits into that database and can be added and deleted by changing 1 of the vars/dimensions. The JS prototype of the Var class is a Proxy, but the Var itself is a normal object so can still be optimized without touching the Proxy. I dont need await/async cuz each Var has a t (UTC time) var with enough digits for slightly better than microsecond. If it hasnt been updated in a while, thats how to mark it.');

console.warn('TODO: use Tile.toVar TO GET SAVE AND LOAD WORKING. todo quad.compress and quad.flatPack. GET testFlatPackTerrain working, like testFlipTerrainColors already works as of 2024-12-26. ... //FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them, //but 2 recursions deep 1 4 16.');

const graphicsLev = 5; //normal fast gaming computer like from 2020.
//const graphicsLev = 1; //slow computer like from 2010-2015.
console.log('graphicsLev='+graphicsLev);





/*
TODO use game.wal which is a BigTile, in sparse 128x128 pieces.
make it paint (y,x) to byte func in chosen rect. loop over all tiles that touches and paint each that way.
game.wal.paintGame(); should be called every nextState. it only paints where not already painted or out of sync.
easier is tile.dense can be painted, as long as u do it with funcs so it marks it needing sync,
so it can efficiently paint 1 pixel at a time. todo make game.wal.paintYXB(y,x,byt); and paintYXWRGB.
*/






























/* proceed with 128x128 pieces of Quad. name each by hash id. Use Square (uint53) as key of it, and pair of Quad and dense Uint8Array as val.
Make a class so can edit it and know which needs updating, replace Quad and empty the Uint8Array, or mod that array and clear the Quad.
Just keep a var thats 1 0 or -1 for if one was updated before or after or at same time as the other.


2024-12-16 ive decided to proceed with Quad, not more complex kind with isComplexFork. make terrain asap
but todo bring in some of the features of the more advanced kind, like bits to say which of 4 childs are included,
and maybe some of the symbols mean heights 0..24. Or maybe QTRANSPARENT being only 1 byte we dont need an optimization for it?
Leave quad as it is and just start using it. Make game.wal be a Quad instance of whole 2**24 X 2**24 game area
or whichever parts we know about.

/*
Square = (y, x, h)=>(h*(2**48) + y*0x1000000 + x);
SquareX = sq=>(sq&0xffffff);
SquareY = sq=>((sq/0x1000000)&0xffffff));
SquareH = sq=>((sq/(2**48))&31);
Square(100,203,5) 1407376561275083
SquareY(1407376561275083) 100
SquareX(1407376561275083) 203
SquareH(1407376561275083) 5
*/

//y and x are integers in range 0 to (2**24)-1=16777215. height ranges 0 (for 1x1 to o 24 (for 16777216x16777216).
//y and x must be multiples of 1<<height.
//const Square = (y, x, height)=>(height*(2**48) + y*0x1000000 + x);
const Square = (height, y, x)=>(height*(2**48) + y*0x1000000 + x);
const SquareSafe = (height, y, x)=>(Math.min(height&31,24)*(2**48) + (y&0xffffff)*0x1000000 + (x&0xffffff));

//SquareX(Square(y,x,height))===x
const SquareX = square=>(square&0xffffff);

//SquareY(Square(y,x,height))===y
const SquareY = square=>((square/0x1000000)&0xffffff);

//SquareH(Square(y,x,height))===height
const SquareH = square=>((square/(2**48))&31);
const SquareHSafe = square=>Math.min((square/(2**48))&31,24);

const SquareDy = (squareA,squareB)=>(SquareY(squareA)-SquareY(squareB));
const SquareDx = (squareA,squareB)=>(SquareX(squareA)-SquareX(squareB));


/**
I think i can expand the game world to 16 million X 16 million, so big that you can just pic a place at random and start building and it may on some 2d paths (or portals?) lead smoothly between worlds made by players. Thats 256 trillion pixels sparsely.

Use this for terrain only, not monsters. Put it in blocks of 1024x1024 compressed as Uint8Array, in base64 form in Var tree as .big like in Walls vs Wally func. This is searchable in compressed form to get color6 and varint poten at every node, so within 1024x1024 (game.wab will be an array of maybe 256x256 byte arrays, flyweighting the 1 byte one. Might also put dense arrays of 1024x1024 ints or shorts or maybe it fits in bytes there for those frequently used, the uncompressed form.
Make circular paint brush and paint these asap. Generate V.testnet.hash43534534564356345345345 of wall like that.
EVERYTHING goes in Var tree. Theres nothing in game state outside it, except few fields in gob.m.isSelected etc, and those can be brought into var tree asap.

i want to use a uint53 as the address of any powOf2 size square from 1x1 2x2 4x4 ... 16777216x16777216. Low 24 bits are x. Mid 24 bits are y. High 5 bits are shift. width and height both equal 1<<shift. So this can fit in a float64 as a nonnegative integer. My compressed pic data format works in any sized area like that.

renaming isFork to isComplexFork. Split Transparent into the suffix 1111 means Transparent, and the suffixes 0000 to 0100 (zero to four) mean a height 1 SimpleFork whose childs are 4 SmallLeafs or Transparent, and the "zero to four" is totalPoten.

["root",
--- ["1xxxxxxx: SmallLeaf, 1 bit of numGobsTouchingHere, 6 bits of color"],
--- ["0xxxxxxx",
--- --- ["01xxxxxx: BigLeaf, 6 bits of color, varint numGobsTouchingHere"],
--- --- ["00xxxxxx: ForkOrPointerOrTransparent - next bit is IsComplexFork",
--- --- --- ["000xxxxx - not a ComplexFork. is pointer or transparent or SimpleFork or MidFork",
--- --- --- --- ["0000xxxx Transparent or SimpleFork or MidFork"]
--- --- --- --- --- {
--- --- --- --- --- --- "00000000 Transparent. Len 1 byte. Its very important that Transparent be the byte 0 cuz of memory allocation optimizations that lazy create memory thats still all 0s."
--- --- --- --- --- --- "00000001 TextContentTypeAndRawBytesVal - a place to hook in extended opcodes or plugins or ids of other systems. Followed by varint byte len, then varint ascii (0..127) text (since varint gives 7 bits per byte) of contentType then that many bytes."
--- --- --- --- --- --- "TODO put in here a constant that takes 8 bytes, first this header byte, then 3 bytes of x, then 3 bytes of y, then 1 byte of height, as a prefix, since browsers are generally little-endian of bytes when a float64 overlaps them, but that assumes some high bit is set, which i could do by using 0x5 (0b0101) as the high 4 bits of the float64, but lets just define them as integers in this data format. This can be used to tell where and how big to make the following quadtree content, so a quadtree as a byte array (or range in it) can tell you where in the game world, of a square 16million X 16million (powOf2), and all sizes 1x1 to 16mX16m, it is.",
--- --- --- --- --- --- "00000010..00000110 SimpleFork with poten=0..4. Len 5 bytes."
--- --- --- --- --- --- "00000111..00001111 MidFork with poten=0..8 (TODO 0..7 to make room), whose childs are 4 SimpleForks. Len 21 bytes."
--- --- --- --- --- }
--- --- --- --- ["0001xxxx Pointer. If its 00010000 then its vararg. If its 00010001..00011111 then it points 1..15 bytes down from itself."]
--- --- --- ]
--- --- --- ["001xxxxx: ComplexFork, hasVarintPoten, childrenPresence, varintPoten if hasVarintPoten, recursively encode children",
--- --- --- --- ["0010xxxx Fork without varintPoten. 4 bits of childrenPresence. varintLen. 0..4 children recursively."]
--- --- --- --- ["0011xxxx Fork with varintPoten.  4 bits of childrenPresence. varintLen. varintPoten. 0..4 children recursively."]
--- --- --- ]
--- --- ]
--- ]
]
varint is (TODO swap that so ASCII is all digits except the last, for when its used as contentType. 0x8|uint7 for the high and middle 7 bits, and is (a high 0 bit and) uint7 for the last uint7.
Start the byte array with 1 int (SP aka stack pointer) that is the index of the last byte appended, and 1 Transparent byte right after that, so the int starts as 4, so as littleEndian it starts with these 5 bytes: 4 0 0 0 0, where 0 is Transparent byte.
A byte array is therefore a complete byte stream that can be appended and keep track of that itself. Only its first 4 bytes are writable more than once. You can also pop bytes as long as you make sure SP points ONLY at the highest byte of some node, not at its internal bytes.

Do not change this tree. Use it as is. Explain the tree as best you understand it.

Start by making a Uint8Array(1<<30) and 2 funcs:
pushByte(byt), increments SP, puts the byte at the new SP, and returns SP. Does not guarantee the byte is a valid start of a node. You will need to call pushByte multiple times for nodes whose local size is bigger than 1 byte.
popByte() throws if SP===4 cuz thats as empty as its gonna get. Else decrements SP and returns the byte popped. Does not zero it out.

This kind of math can sum the number of intersecting points between any 2 2d shapes, of any strangely curved 1d border, for cost of the length of those curves, not costing by area, but its so slow anyways that its just faster to use point voxels for the monsters, this for terrain.
This means the game could have huge massively multiplayer areas of destructible and editable terrain like in Worms or r/place.

*/

/**
Why am I going for 7 bit color? 2 bits of red, 2 bits of green, and 2 bits of blue is 6 bit color, like in this gif from wikipedia
showing a 4x4x4 grid of colored voxels. I need the other bit to define game world terrain, that you can or cant move into that space. I will swarm it
*/

//tile is a (2**tileHeight) side square that a Quad goes in and a Uint8Array for cache and editing it densely.
//Height technically ranges 0 to 24, but for a tile it cant be in those bigger sizes. dont go over 10 cuz thats a megapixel.
const tileHeight = 7;
const tileHeightMask = (1<<tileHeight)-1;

//{}

const Tile = function(square, optionalQuadOrDense){
	this.isPaintedOnGame = 0; //increases by every paint, decreases by every remove. normally is 0 or 1 but catches bugs if other vals.
	this.square = square; //2d size and location. 5 high bits of height. 24 mid bits of top left corner of y. 24 low bits of top left corner of x.
	if(SquareH(square)!==tileHeight) Err('tile.square differs in height from tileHeight constant');
	//this.height = tileHeight;
	this.sparse = null;
	this.dense = null;
	this.writeDirection = 0; //1 is sparse was replaced last. -1 is dense was modded last. 0 is they are in sync.
	if(optionalQuadOrDense){
		if(optionalQuadOrDense instanceof Quad){
			this.sparse = optionalQuadOrDense;
			this.writeDirection = 1;
		}else{
			this.sparse = DefaultQuadForTile;
			this.dense = optionalQuadOrDense;
			this.writeDirection = 1;
		}
	}
};

Tile.prototype.centerY = function(){
	return SquareY(square)+(1<<(tileHeight-1));
};

Tile.prototype.centerX = function(){
	return SquareX(square)+(1<<(tileHeight-1));
};

//distance to nearest y in the 1d range
Tile.prototype.yDist = function(y){
	let minY = SquareY(this.square);
	let maxY = minY+(1<<tileHeight);
	if(y < minY) return minY-y;
	if(maxY < y) return y-maxY;
	return 0;
};

//distance to nearest x in the 1d range
Tile.prototype.xDist = function(x){
	let minX = SquareX(this.square);
	let maxX = minX+(1<<tileHeight);
	if(x < minX) return minX-x;
	if(maxX < x) return x-maxX;
	return 0;
};

//distance to nearest y x point in the 2d range
Tile.prototype.yxDist = function(y,x){
	return Math.hypot(this.yDist(y),this.xDist(x));
};

//isRemove, similar to Gob.voxInGame is whats currently added into game.board and can get removed.
//TODO use dense if exists, as of 2024-12-22 this paints as Quad/sparse even if the dense version
//is available it copies it to sparse form first.
Tile.prototype.paintGame = function(optionalIsRemove, optionalGameG){
	const isRemove = !!optionalIsRemove;
	this.isPaintedOnGame += (isRemove ? -1 : 1);
	let topLeftY = SquareY(this.square);
	let topLeftX = SquareX(this.square);
	if(this.writeDirection < 0){
		this.copyDenseToSparse();
	}
	let chooseSparse = this.sparse;
	if(isRemove){
		if(!this.lastPaintedQuadOnGame) Err('no lastPaintedQuadOnGame to remove. maybe you are unpainting before painting?');
		chooseSparse = this.lastPaintedQuadOnGame;
		this.lastPaintedQuadOnGame = null;
	}else{
		this.lastPaintedQuadOnGame = this.sparse; //remember Quad, which is used as immutable, so can remove it from game.board later.
	}
	chooseSparse.paintGame(topLeftY, topLeftX, isRemove, optionalGameG);
	if(!isRemove && (this.lastPaintedQuadOnGame !== this.sparse)){
		Err('lastPaintedQuadOnGame');
	}
};

//paints or unpaints
Tile.prototype.setIsPaintedOnGame = function(isPaint, optionalGameG){
	if(!isPaint !== !this.isPaintedOnGame){ //if changing if its painted or not
		this.paintGame(!isPaint, optionalGameG);
	}else if(isPaint && ((this.lastPaintedQuadOnGame !== this.sparse) || this.writeDirection < 0)){
		//if it painted an old version, remove it and update
		//isRemove vs isPaint is confusing cuz theyre NOT of eachother. choose a direction and stick with it.
		this.paintGame(true, optionalGameG); //remove old quad this.lastPaintedQuadOnGame from game.board
		this.paintGame(false, optionalGameG); //update this.sparse quad and paint game again, creating this.lastPaintedQuadOnGame
		this.syncSparseDense();
	}
};


//tile.setSparse(forkEdit tile.sparse)
Tile.prototype.writeSparse = function(quad){
	if(quad.h !== tileHeight) Err('wrong height');
	this.writeDirection = 1; //sparse was written last
	this.sparse = quad;
};

Tile.prototype.writeDense = function(square, byt){
	if(SquareH(square)!==0) Err('must be 1x1 pixel square. todo loop if its bigger.');
	this.writeDenseRelyRelxByt(SquareDy(square,this.square), SquareDx(square,this.square), byt);
};

Tile.prototype.writeDenseRelyRelxByt = function(rely, relx, byt){
	let dense = this.lazyNewDense();
	this.writeDirection = -1; //dense was written last
	this.dense[(rely<<tileHeight)|relx] = byt;
};

Tile.prototype.copyDenseToSparse = function(){
	this.sparse = QEval((y,x)=>this.dense[(y<<tileHeight)|x], tileHeight);
	this.writeDirection = 0; //in sync
};

Tile.prototype.copySparseToDense = function(){
	let siz = 2**tileHeight;
	let dense = this.lazyNewDense();
	for(let rely=0; rely<siz; rely++) for(let relx=0; relx<siz; relx++){
		dense[(rely<<tileHeight)|relx]	= this.sparse.yx(rely, relx);
	}
	this.writeDirection = 0; //in sync
};

Tile.prototype.syncSparseDense = function(allowCreateEmptyDense){
	if(this.writeDirection == 1){ //sparse was written last
		if(this.dense || allowCreateEmptyDense) this.copySparseToDense();
		//else leave this.dense as null cuz sparse contains all the info
	}else if(this.writeDirection == -1){ //dense was written last
		this.copyDenseToSparse();
	}
};

Tile.prototype.lazyNewDense = function(){
	return this.dense || (this.dense = new Uint8Array(4**tileHeight));
};

//a sparse map of square to Tile. each tile is normally a 128x128, but any set of 128x128s can be defined.
const BigTile = function(){
	this.tiles = {}; //map of Square(tileHeight,y,x) to Tile.
	this.needSync = []; //tile objects needing sync. its ok if they go in here multiple times cuz is fast to check if they are already synced.
	//Err('too many kinds of tile, one is Quad which i like, 2 is dense byte array which im unsure if need it, and 3 is game.board which Quad can paint/unpaint at directly. and i need to store maybe a fourth or copy of one of those, to remove from game.board later, but it might have been edited. Quad is used as immutable, so could just do that.');
};

BigTile.prototype.paintGame = function(){
	for(let square in this.tiles){
		let tile = this.tiles[square];
		tile.setIsPaintedOnGame(game.shouldDisplayTile(tile));
	}
};

BigTile.prototype.tile = function(square){
	let key = TileKey(square);
	return this.tiles[key] || (this.tiles[key] = new Tile(key));
};

BigTile.prototype.tileAndMark = function(square){
	let tile = this.tile(square);
	this.needSync.push(tile);
	return tile;
};

BigTile.prototype.sync = function(){
	while(this.needSync.length) this.needSync.pop().syncSparseDense();
};

//BigTile.prototype.writeSparse = function(vox){
//	Err();
//};

var testPaintAtMouse = ()=>{
	let y = Controls.mouseY|0;
	let x = Controls.mouseX|0;
	let isWall = 1;
	//let isWall = 0;
	let color = randInt(Colors);
	game.wal.paintYXWC(y,x,isWall,color);
	let r = 30;
	for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++){
		if((dy*dy+dx*dx) <= (r*r)) game.wal.paintYXWC(y+dy,x+dx,isWall,color);
	}
};

BigTile.prototype.writeDense = function(square, byt){
	this.tile(square).writeDense(square, byt);
};

BigTile.prototype.paintYXB = function(y,x,byt){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, byt);
};

BigTile.prototype.paintYXWRGB = function(y,x,w,r,g,b){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, WRGB(w,r,g,b));
};

//y x isWall color6
BigTile.prototype.paintYXWC = function(y,x,w,c){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, WC(w,c));
};

//aligns on 128x128 in the 16m x 16m square. todo 2024-12-22 its still displaying 256k x 256k, change maxX maxY consts etc.
const TileKey = square=>Square(tileHeight, SquareY(square)&~tileHeightMask, SquareX(square)&~tileHeightMask);

//TileKey but 2d wrapped into the 8k x 8k game.board, so it puts all these in the top left 8k x 8k of the 16m x 16m space.
//This is used to detect overlap by wrapping, to remove a wall tile if collides with another tile of a different TileKey
//that happens to overlap when wrapped. We only have so much memory in game.board to display and compute the game.
const TileKeyWrap = square=>Square(tileHeight, SquareY(square)&~SizeMask, SquareX(square)&~SizeMask);

//QuadtreeByteArray: If you use 7 bit color you can make a whole bencoded searchable compressed pic with 1 byte quadtree nodes
//densely, bigger nodes for sparse that point into byte arrays with offset. Gonna be hella fast and compress terapixels,
//most of which will be oddly shaped solid areas of color. Use WRGB or WC to make a byte that has 1 bit of isWall and 6 bits of color.
//Use WEval to make a Quad by a function that says what byte where, still working on the compression part of that.
const Quad = function(height, bytes, offset=0, childs=[null,null,null,null]){
	this.h = height;
	this.B = bytes;
	this.i = offset;
	this.c = childs;
	this.length = lenAtBytes(this.B,this.i); //same as array.length, for the range this.i to this.i+this.length-1.
	if(this.length < 1){
		Err('Quad.length='+this.length);
	}
	
	//this.todoRemoveThis = QBytesStr(this.B, this.i, this.B.length); //FIXME dont know the length cuz am still testing the length parsing
};

Quad.prototype.toBigString = function(){
	if(this.h===0){
		return doubleHexDigits[this.b(0)];
	}else{
		return '['+this.C(0).toBigString()+' '+this.C(1).toBigString()+' '+this.C(2).toBigString()+' '+this.C(3).toBigString()+']';
	}
};

Quad.prototype.toString = function(){
	if(this.h < 4){
		return this.toBigString();
	}else{
		return '[Quad h='+this.h+' len='+this.length+']';
	}
};

Quad.prototype.side = function(){ //height and width of the square pic
	return 1<<this.h;
};

//a Quad includes a byte array this.B and an offset this.i and may have 4 childs recursively
//which have such arrays too. This flattens it into a new nonbacking byte array of this.length bytes.
Quad.prototype.getBytes = function(optionalBytes, optionalOffset){
	let bytes = optionalBytes || new Uint8Array(this.length);
	let offset = optionalOffset|0;
	for(let i=0; i<this.length; i++) bytes[offset++] = this.B[i]; //my header or whole quad of bytes
	if(this.c[0]) for(let child of this.c){
		child.getBytes(bytes, offset);
		offset += child.length;
	}
	return bytes;
};



var exampleQuad = function(){
	//let quad256x256OfBlueCircle = QEval((y,x,h)=>(h>0 ? QFORK : ((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : QTRANSPARENT), 8);
	//let quad256x256OfBlueCircle = QEval((y,x,h)=>(((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : 0b1111111), 8);
	//quad256x256OfBlueCircle.paintGame(DefaultSpawnY, DefaultSpawnX);
	//return QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 3);
	//quad.paintGame(DefaultSpawnY, DefaultSpawnX);
	//quad.paintGame(0,0);
	return QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 8);
};

var testQuad = function(){
	let quad = exampleQuad();
	//let voxels = quad.toVoxels(game.Y.p+1000,game.X.p+1000); //loses isWall bit, but u can paint open areas as ghostVox too with paintGame.
	quad.paintGame(game.Y.p-500, game.X.p-500); //near current view
};

//get byte (7 bit color, 1 bit isWall and 6 bit color, or other 1 byte symbols) at y x, from this quadtree,
//where y and x both range 0 to (1<<this.height)-1. All byte values under 128 are 7 bit color. 128 is transparent.
//This may also include other byte symbols, but the range 192 to 255 are quadtree 2x2 fork opcodes.
Quad.prototype.yx = function(y, x){
	const lg = !!game.QuadLogLev.p;
	let mid = 1<<(this.h-1); //half of width and half of height
	if(lg) console.log('quad.yx start, y='+y+' x='+x+' h='+this.h+' mid='+mid);
	if(this.h===0){
		let byt = this.b(0)
		if(lg) console.log('quad.yx end quad recursion the slow way, a Quad object of 1 byte cuz .h/height is 0, returning that byte='+byt);
		//first byte in a branch, end recursion. the more efficient way is to keep many branches
		//in each lowest Quad, but a Quad can be made that holds just 1 byte.
		return byt;
	}
	if(this.c[0]){ //has child Quad objects.
		if(y < mid){
			if(x < mid){
				if(lg) console.log('quad.yx recurse into top left quad (child 0), y='+y+' x='+x+' h='+this.h+' mid='+mid);
				return this.c[0].yx(y,x);
			}else{
				if(lg) console.log('quad.yx recurse into top right quad (child 1), y='+y+' x='+x+'-mid h='+this.h+' mid='+mid);
				return this.c[1].yx(y,x-mid);
			}
		}else{
			if(x < mid){
				if(lg) console.log('quad.yx recurse into bottom left quad (child 2), y='+y+'-mid x='+x+' h='+this.h+' mid='+mid);
				return this.c[2].yx(y-mid,x);
			}else{
				if(lg) console.log('quad.yx recurse into bottom right quad (child 4), y='+y+'-mid x='+x+'-mid h='+this.h+' mid='+mid);
				return this.c[3].yx(y-mid,x-mid);
			}
		}
	}else{ //no child Quad objects, but the bytes may still have childs in the other bytes in the same array.
		let ptr = this.i; //pointer into this.B byte array.
		for(let recurse=0; recurse<100; recurse++){
			/*let child0ByteIndex = firstChild(this.b,this.i);
			let child1ByteIndex = nextQuad(this.b,child0ByteIndex);
			let child2ByteIndex = nextQuad(this.b,child1ByteIndex);
			let child3ByteIndex = nextQuad(this.b,child2ByteIndex); //TODO only compute these if needed. only going into 1 of 4 childs.
			*/
			let val = this.B[ptr];
			if(lg) console.log('quad.yx bytes recurse='+recurse+' ptr='+ptr+' valHex='+QByteStr[val]+' mid='+mid+' y='+y+' x='+x+' len='+lenAtBytes(this.B,ptr)+
				'\nbytesFromPtr='+QBytesStr(this.B, ptr, this.B.length));
			if(!byteHasChilds(val)){
				if(lg) console.log('quad.yx end bytes cuz byteHasChilds, return valHex='+QByteStr[val]);
				return val;
			}
			if(y < mid){
				if(x < mid){
					if(lg) console.log('quad.yx bytes recurse into top left quad aka nthChild 0');
					ptr = nthChild(this.B, ptr, 0);
				}else{
					if(lg) console.log('quad.yx bytes recurse into top right quad aka nthChild 1');
					ptr = nthChild(this.B, ptr, 1);
					x -= mid; //skip left half horizontally
				}
			}else{
				if(x < mid){
					if(lg) console.log('quad.yx bytes recurse into bottom left quad aka nthChild 2');
					ptr = nthChild(this.B, ptr, 2);
				}else{
					if(lg) console.log('quad.yx bytes recurse into bottom right quad aka nthChild 3');
					ptr = nthChild(this.B, ptr, 3);
					x -= mid; //skip left half horizontally
				}
				y -= mid; //skip top half vertically
			}
			//divide height and width in half for next recursion into this.B byte array
			//which is bytes of pic compression by quadtree.
			mid >>= 1;
		}
		Err('Recursed too deep. Bytes are probably broken.');
	}
};

//isRemove, similar to Gob.voxInGame is whats currently added into game.board and can get removed.
Quad.prototype.paintGame = function(optionalTopLeftY, optionalTopLeftX, optionalIsRemove, optionalGameG){
	let topLeftY = optionalTopLeftY|0; //default to (0,0)
	let topLeftX = optionalTopLeftX|0;
	const isRemove = !!optionalIsRemove;
	const gameG = optionalGameG || game;
	let size = 1<<this.h; //same as width
	for(let y=0; y<size; y++){
		for(let x=0; x<size; x++){
			let byt = this.yx(y,x);
			if(byt < 128){
				let isWall = (byt>>6)&1;
				let color6 = byt&63;
				let vox = YXC(topLeftY+y, topLeftX+x, color6); //13 bits y, 13 bits x, 6 bits color. no isWall bit.
				if(isRemove){
					gameG.remVox(vox);
				}else{
					//console.log('gameG.addVox(0b'+vox.toString(2)+')');
					gameG.addVox(vox);
				}
			}
		}
	}
};

//returns Uint32Array of int voxels you can use with IY(vox) IX(vox) IC(vox) IR IG IB for red green blue,
//and which you can make those kind of voxels with YXRGB or YXC, game.addVox, game.addVoxsWithTeam,
//game.remVoxs, game.remVoxsWithTeam, game.addVox (one int at a time), game.remVox, etc.
//Should be sorted by uint32s cuz is increasing y and inner loop of increasing x.
//WARNING: this loses the isWall bit. You can put a voxel without isWall using game.ghostVox.
//Maybe I should switch from 8kX8k to 4kX4k and put a bit in there.
//If this isnt working you can put a white square of 1000x1000 voxels centered around mouse using this:
//for(let dy=0; dy<1000; dy++) for(let dx=0; dx<1000; dx++) game.addVox(YXC(Controls.mouseY+dy-500, Controls.mouseX+dx-500, 63))
//or this one puts it at center of view:
//for(let dy=0; dy<1000; dy++) for(let dx=0; dx<1000; dx++) game.addVox(YXC(game.Y.p+dy, game.X.p+dx, 63))
//This one displays a 256x256 Quad near the view: game.addVoxs(QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 8).toVoxels())
Quad.prototype.toVoxels = function(optionalTopLeftY, optionalTopLeftX){
	let topLeftY = optionalTopLeftY|0; //default to (0,0)
	let topLeftX = optionalTopLeftX|0;
	let size = 1<<this.h; //same as width
	let voxels = new Int32Array(size**2);
	let vSize = 0;
	for(let y=0; y<size; y++){
		for(let x=0; x<size; x++){
			let byt = this.yx(y,x);
			if(byt < 128){
				let isWall = (byt>>6)&1;
				let color6 = byt&63;
				let vox = YXC(topLeftY+y, topLeftX+x, color6); //13 bits y, 13 bits x, 6 bits color. no isWall bit.
				voxels[vSize++] = vox;
			}
		}
	}
	if(vSize === voxels.length){
		return voxels;
	}else{
		return voxels.slice(0, vSize);
	}
};



var lenAtBytes = (bytes, offset)=>{
	let b = bytes[offset];
	if(b < QFORKC){
		//FIXME check for QFORK and other invalid bytes?
		if(b === QFORK){
			Err('QFORK is a 1 byte opcode that means there is a 2x2 quadtree fork next but we dont know its size. It can occur in byteAtYXH(y,x,height) returning a byte but not in the bytes of a Quad directly.');
		}
		return 1; //lone byte, a leaf. FIXME use byteHasChilds(b)?
	}
	if(b < QFORKD){ //is a QFORKC, one of those 16 hex digits. theres 4 sets of 16 hex digits each. QFORKC+0 to QFORKC+15 is the lone byte one.
		return b-QFORKC; //0 to 15, length in bytes including length header
	}
	let len = 0
	while(bytes[offset] >= QFORKD){ //FIXME also verify it starts with a QFORKD+hex and ends with a QFORKF+hex, and in the middle can be 0 or more QFORKE+hex.
		len = (len<<4)|(bytes[offset++]&15)
	}
	return len;
};

//TODO rewrite these comments:
//return 192 <= bytes[offset];
//return QFORK <= bytes[offset]; //QFORK is just below the line, of things above fork and things below dont. its an opcode to fork without knowing the length yet.
var byteHasChilds = byt=>(QFORK <= byt);
//var hasChilds = (bytes, offset)=>byteHasChilds(bytes[offset]);

var hashStringToHex = function(str){
	return bytesToHex(sha256(stringToBytes(str)));
};
var hashStringToBase64 = function(str){
	return dagball.bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
};
var utf8TextEncoder = new TextEncoder('utf-8');
var utf8TextDecoder = new TextDecoder('utf-8');
var stringToBytes = function(s){ return utf8TextEncoder.encode(s); };
var bytesToString = function(bytes){ return utf8TextDecoder.decode(bytes); };
var hexDigits = '0123456789abcdef'.split('');
var mapOfHexDigitToInt = {}; //vals are 0 to 15. filled in boot.
var mapOfDoubleHexDigitsToInt = {}; //vals are 0 to 255. filled in boot.
var bytesToHex = function(bytes){ return bytesAndRangeToHex(bytes,0,bytes.length); };
var doubleHexDigits = [];
for(let i=0; i<16; i++){
	mapOfHexDigitToInt[hexDigits[i]] = i;
	for(let j=0; j<16; j++){
		let hh = hexDigits[i]+hexDigits[j];
		doubleHexDigits.push(hh);
		mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
	}
};
var bytesAndRangeToHex = function(bytes,from,toExcl){
	let s = '';
	for(let i=from; i<toExcl; i++) s += doubleHexDigits[bytes[i]];
	return s;
};


const QTRANSPARENT = 0x80;
const QWANTTOKNOW = 129;
//colors go in 0 to 127, high bit being isWall. symbols go in 128 to 191. 4 kinds of hex digit go in 192 to 255 for type safety per byte.
const QFORK = 191; //means u dont know what length header goes there but a byteAtYXH(y,x,height) func returns this to say fork and figure it out later.
//const QLASTSYMBOL = 191;

const QFORKC = 0xc0; //single byte length prefix, means including itself that theres 0-15 bytes
const QFORKD = 0xd0; //multi byte length prefix, start with these 16 hex digits
const QFORKE = 0xe0; //multi byte length prefix, use 0 or more of this kind of hex digits in the middle of QFORKD and QFORKF.
const QFORKF = 0xf0; //multi byte length prefix, end with these 16 hex digits

const QByteStr = new Array(256);
for(let byt=0; byt<256; byt++){
	QByteStr[byt] = doubleHexDigits[byt];
}
for(let byt=QFORKC; byt<QFORKC+16; byt++){
	let len = byt-QFORKC; //0..15
	//QByteStr[byt] = '['+hexDigits[len]
	QByteStr[byt] = 'x'+hexDigits[len]
}
for(let byt=QFORKD; byt<QFORKD+16; byt++){
	let len = byt-QFORKD; //0..15
	//QByteStr[byt] = '('+hexDigits[len]
	QByteStr[byt] = 'X'+hexDigits[len]
}
for(let byt=QFORKE; byt<QFORKE+16; byt++){
	let len = byt-QFORKE; //0..15
	QByteStr[byt] = '_'+hexDigits[len];
	//QByteStr[byt] = hexDigits[len];
}
for(let byt=QFORKF; byt<QFORKF+16; byt++){
	let len = byt-QFORKF; //0..15
	//QByteStr[byt] = hexDigits[len]+')'
	//QByteStr[byt] = hexDigits[len]+'):'
	QByteStr[byt] = hexDigits[len]+':'
}
//QByteStr[QTRANSPARENT] = 'QTRANSPARENT';
QByteStr[QTRANSPARENT] = 'TR';
//QByteStr[QWANTTOKNOW] = 'QWANTTOKNOW';
QByteStr[QWANTTOKNOW] = 'WA';
//QByteStr[QFORK] = 'QFORK';
QByteStr[QFORK] = 'FK';

var QBytesStr = (bytes, optionalFrom, optionalToExcl)=>{
	let from = optionalFrom|0;
	let toExcl = optionalToExcl!==undefined ? optionalToExcl : bytes.length;
	let s = '';
	for(let i=from; i<toExcl; i++){
		if(i != from) s += ' ';
		s += QByteStr[bytes[i]];
	}
	return s;
};


//given pointer at parent, returns pointer to its first child. use nextQuad after that 3 times.
var firstChild = (bytes, offset)=>{
	let b = bytes[offset];
	if(b < QFORKC){
			throw new Error('Is a lone byte, has no childs: '+b.toString(16));
	}
	if(b < QFORKD){ //is a QFORKC+hex
		return offset+1; //skip the 1 byte header to get to first child
	}
	while(bytes[offset] >= QFORKD){
		//skip variable size integer header. each byte is 1 hex digit of it.
		//D E E E F. D F. D E F. etc. QFORKD+hex QFORKD+hex QFORKF+hex.
		offset++;
	}
	return offset;
};

var nthChild = (bytes, offset, n)=>{ //n is 0..3. Returns pointer into same byte array.
	let c = firstChild(bytes,offset);
	while(n){
		c = nextQuad(bytes,c);
		n--;
	}
	return c;
};

var nextQuad = (bytes, offset)=>(offset+lenAtBytes(bytes,offset));

Quad.prototype.b = function(i){ //byteAt, viewing this tree as a list of bytes.
	if(i < 0){
		Err('Out of range, i='+i);
	}
	let j = this.i+i;
	if(j < this.B.length){
		return this.B[j];
	}
	j -= this.B.length;
	//if(this.c[0]) for(let c of this.c){
	for(let c of this.c){
		if(j < c.length){
			return c.b(j); //get byte from child recursively
		}
		j -= c.length;
	}
	Err('Out of range, i='+i);
};

//true if all my bytes are in this.B array
Quad.prototype.isFlat = function(){
	return this.length <= this.B.length-this.i;
};

Quad.prototype.isFlatPacked = function(){
	return this.i===0 && this.isFlat();
};

//copy all self's bytes into a new Quad, unless its already that way returns self. Remember to use as immutable. stays compressed.
Quad.prototype.flatPack = function(){
	if(this.isFlatPacked()){
		return this;
	}else{
		let arr = new Uint8Array(this.length);
		for(let i=0; i<arr.length; i++){
			arr[i] = this.b(i);
		}
		console.log('quad.flatPack to '+arr.length+' bytes');
		return new Quad(this.h, arr);
	}
};

const intFitsInHowManyHexDigits = i=>{ //1..8
	return ((32-Math.clz32(i)+3)>>>2);
};

//uses a loop to find this cuz length header includes its own length and is a vararg int.
//You can use the returned byte array with lenAtBytes func.
const headerBytesForChildsLength = totalChildsLength=>{
	if(totalChildsLength < 4){
		Err('Childs length must be at least 4 cuz the smallest possible child is 1 byte and theres either 0 or 4 childs');
	}
	let headerLen = 1;
	while(headerLen < intFitsInHowManyHexDigits(headerLen+totalChildsLength)){
		headerLen++;
	}
	let length = headerLen+totalChildsLength;
	if(headerLen == 1){ //if(length < 16){
		return ArraysOfOneByte[QFORKC+length]; //flyweight
	}else if(headerLen == 2){ //}else if(length < 256){
		return ArraysOfTwoBytes[((QFORKD+(length>>4))<<8)|(QFORKF+(length&15))]; //flyweight
	}else{ //at least 3 hex digits of length header
		let shiftedLen = length;
		let headerBytes = new Uint8Array(headerLen);
		for(let i=headerBytes.length-1; i>=0; i--){
			let add = QFORKE; //middle kind of hex digits
			if(i === 0) add = QFORKD; //start header with one of these kind of hex digits
			else if(i === headerBytes.length-1) add = QFORKF; //end header with one of these kind of hex digits
			let uint4PartOfLength = shiftedLen&15;
			shiftedLen >>= 4;
			headerBytes[i] = add+uint4PartOfLength;
		}
		return headerBytes;
	}
};

//make a new Quad from 4 Quads of the same height. its height/h will be 1 higher.
const Q = (a,b,c,d)=>{
	let childHeight = a.h;
	if(childHeight !== b.h || childHeight !== c.h || childHeight !== d.h){
		Err('Heights differ');
	}
	let childsLen = a.length+b.length+c.length+d.length;
	let headerBytes = headerBytesForChildsLength(childsLen);
	return new Quad(childHeight+1, headerBytes, 0, [a, b, c, d]);
	
	/*let childsLen = a.length+b.length+c.length+d.length;
	let headerLen = 1;
	while(headerLen < intFitsInHowManyHexDigits(headerLen+childsLen)){
		headerLen++;
	}
	let length = headerLen+childsLen;
	let headerBytes = new Uint8Array(headerLen);
	let shiftedLen = length;
	if(headerBytes.length == 1){ //lone byte header of 0..15 bytes including i ts own length
		headerBytes[0] = QFORKC+length;
	}else for(let i=headerBytes.length-1; i>=0; i--){ //multi byte length header including its own length
		let add = QFORKE; //middle kind of hex digits
		if(i === 0) add = QFORKD; //start header with one of these kind of hex digits
		else if(i === headerBytes.length-1) add = QFORKF; //end header with one of these kind of hex digits
		//wrong, its got to be 4 bits from headerLen: headerBytes[i] = add+i;
		let uint4PartOfLength = shiftedLen&15;
		shiftedLen >>= 4;
		headerBytes[i] = add+uint4PartOfLength;
	}
	return new Quad(a.h+1, headerBytes, 0, [a, b, c, d]);
	*/l
};

//make a byte as 1 bit of isWall, 2 bits of red, 2 bits of green, 2 bits of blue. You can get a Quad from this as QuadByte[WRGB(...)].
/*
const IR = voxel=>((voxel>>>4)&3); //get red as uint2
const IG = voxel=>((voxel>>>2)&3); //get green as uint2
const IB = voxel=>(voxel&3); //get blue as uint2
const IC = voxel=>(voxel&0x3f); //get color as uint6
*/
const WRGB = (isWall, red, green, blue)=>(((isWall&1)<<6)|((red&3)<<4)|((green&3)<<2)|(blue&3));

//make a byte as 1 bit of isWall and 6 bits of color.
const WC = (isWall, color6)=>(((isWall&1)<<6)|(color6&63));

var strongLogFirstTime_ = {};

var strongLogFirstTime = str=>{
	if(!strongLogFirstTime[str]){
		strongLogFirstTime[str] = true;
		console.error('strongLogFirstTime: '+str);
	}
};

//calls byteAtYXH(y,x,height) where y and x each range 0 to (1<<height)-1, and returns a Quad containing that.
//
//Example: QEval((y,x,h)=>(y*16+x), 2).B is these 22 bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33.
//d1 f6 means length is 0x16. c5 means length is 5. Its 4x4 pixels containing 4 2x2 pixels of 5 bytes each.
//nthChild(x.B,0,3) 17
//nthChild(x.B,0,0) 2
//nthChild(x.B,0,1) 7
//nthChild(x.B,0,2) 12
//nthChild(x.B,0,3) 17
//nthChild(x.B,12,0) 13
//nthChild(x.B,12,1) 14
//nthChild(x.B,12,2) 15
//nthChild(x.B,12,3) 16
//x.yx(0,0)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=0 x=0
//quad.yx bytes recurse=1 ptr=2 val=c5 mid=1 y=0 x=0
//quad.yx bytes recurse=2 ptr=3 val=00 mid=0 y=0 x=0
//0
//x.yx(0,1)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=0 x=1
//quad.yx bytes recurse=1 ptr=2 val=c5 mid=1 y=0 x=1
//quad.yx bytes recurse=2 ptr=4 val=01 mid=0 y=0 x=0
//1
//x.yx(3,2)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=3 x=2
//quad.yx bytes recurse=1 ptr=17 val=c5 mid=1 y=1 x=0
//quad.yx bytes recurse=2 ptr=20 val=32 mid=0 y=0 x=0
//50 (aka 16*3+2)
//
//The child 1 aka top right of the same QEval (x = QEval((y,x,h)=>(y*16+x), 3)) but at height 2 (8x8) is this:
// 02 03   04 05
// 12 13   14 15
//
// 22 23   24 25
// 32 33   34 35
//But FIXME that cant be right, it should have x range 4..7, not 2..5. Shift or mid or something is wrong.
//The y parts are correct, (y*16+x makes y the left hex digit and x the right hex digit), but not the x parts, 2024-12-11-8aET.
//
/*2024-12-11-844aET QEval and quad.yx are working for up to height 3 (8x8). (does it work for higher?)
x = QEval((y,x,h)=>(y*16+x), 3);
blobMonstersGame.html:359 QEval dy=0 dx=0 h=3 byteHere=00
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=2 byteHere=00
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33
blobMonstersGame.html:359 QEval dy=0 dx=4 h=2 byteHere=04
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:359 QEval dy=4 dx=0 h=2 byteHere=40
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:359 QEval dy=4 dx=4 h=2 byteHere=44
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
Quad {h: 3, B: Uint8Array(2), i: 0, c: Array(4), length: 1, …}
QByteStr[x.yx(6,7)]
blobMonstersGame.html:43 quad.yx start, y=6 x=7 h=3 mid=4
blobMonstersGame.html:65 quad.yx recurse into bottom right quad (child 4), y=6-mid x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=3 len=22
bytesFromPtr=d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=17 valHex=c5 mid=1 y=0 x=1 len=5
bytesFromPtr=c5 66 67 76 77
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=19 valHex=67 mid=0 y=0 x=0 len=1
bytesFromPtr=67 76 77
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=67
'67'
QByteStr[x.yx(1,5)]
blobMonstersGame.html:43 quad.yx start, y=1 x=5 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=5-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=1 len=22
bytesFromPtr=d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=2 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=6 valHex=15 mid=0 y=0 x=0 len=1
bytesFromPtr=15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=15
'15'
QByteStr[x.yx(5,1)]
blobMonstersGame.html:43 quad.yx start, y=5 x=1 h=3 mid=4
blobMonstersGame.html:62 quad.yx recurse into bottom left quad (child 2), y=5-mid x=1 h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=1 len=22
bytesFromPtr=d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=2 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=6 valHex=51 mid=0 y=0 x=0 len=1
bytesFromPtr=51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=51
'51'
*/
/*2024-12-11-850aET it appears to work for height=4 16x16 too,
but make sure for byteAtYXH not to return bytes outside range 0..127 which is pixel colors.
x = QEval((y,x,h)=>(Math.min(y,7)*16+x), 4);
blobMonstersGame.html:359 QEval dy=0 dx=0 h=4 byteHere=00
blobMonstersGame.html:389 QEval recurse h=4, making a 16x16 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=3 byteHere=00
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=2 byteHere=00
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33
blobMonstersGame.html:359 QEval dy=0 dx=4 h=2 byteHere=04
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:359 QEval dy=4 dx=0 h=2 byteHere=40
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:359 QEval dy=4 dx=4 h=2 byteHere=44
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
blobMonstersGame.html:359 QEval dy=0 dx=8 h=3 byteHere=08
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=8 h=2 byteHere=08
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 08 09 18 19 c5 0a 0b 1a 1b c5 28 29 38 39 c5 2a 2b 3a 3b
blobMonstersGame.html:359 QEval dy=0 dx=12 h=2 byteHere=0c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:359 QEval dy=4 dx=8 h=2 byteHere=48
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 48 49 58 59 c5 4a 4b 5a 5b c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:359 QEval dy=4 dx=12 h=2 byteHere=4c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 4c 4d 5c 5d c5 4e 4f 5e 5f c5 6c 6d 7c 7d c5 6e 6f 7e 7f
blobMonstersGame.html:359 QEval dy=8 dx=0 h=3 byteHere=70
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=8 dx=0 h=2 byteHere=70
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 70 71 70 71 c5 72 73 72 73 c5 70 71 70 71 c5 72 73 72 73
blobMonstersGame.html:359 QEval dy=8 dx=4 h=2 byteHere=74
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 74 75 74 75 c5 76 77 76 77 c5 74 75 74 75 c5 76 77 76 77
blobMonstersGame.html:359 QEval dy=12 dx=0 h=2 byteHere=70
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 70 71 70 71 c5 72 73 72 73 c5 70 71 70 71 c5 72 73 72 73
blobMonstersGame.html:359 QEval dy=12 dx=4 h=2 byteHere=74
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 74 75 74 75 c5 76 77 76 77 c5 74 75 74 75 c5 76 77 76 77
blobMonstersGame.html:359 QEval dy=8 dx=8 h=3 byteHere=78
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=8 dx=8 h=2 byteHere=78
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 78 79 78 79 c5 7a 7b 7a 7b c5 78 79 78 79 c5 7a 7b 7a 7b
blobMonstersGame.html:359 QEval dy=8 dx=12 h=2 byteHere=7c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 7c 7d 7c 7d c5 7e 7f 7e 7f c5 7c 7d 7c 7d c5 7e 7f 7e 7f
blobMonstersGame.html:359 QEval dy=12 dx=8 h=2 byteHere=78
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 78 79 78 79 c5 7a 7b 7a 7b c5 78 79 78 79 c5 7a 7b 7a 7b
blobMonstersGame.html:359 QEval dy=12 dx=12 h=2 byteHere=7c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 7c 7d 7c 7d c5 7e 7f 7e 7f c5 7c 7d 7c 7d c5 7e 7f 7e 7f
Quad {h: 4, B: Uint8Array(1), i: 0, c: Array(4), length: 5, …}
QByteStr[x.yx(1,15)]
blobMonstersGame.html:43 quad.yx start, y=1 x=15 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=15-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=1 x=7 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=3 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=7 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=11 valHex=1f mid=0 y=0 x=0 len=1
bytesFromPtr=1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=1f
'1f'
QByteStr[x.yx(2,15)]
blobMonstersGame.html:43 quad.yx start, y=2 x=15 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=15-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=2 x=7 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=3 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=17 valHex=c5 mid=1 y=0 x=1 len=5
bytesFromPtr=c5 2e 2f 3e 3f
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=19 valHex=2f mid=0 y=0 x=0 len=1
bytesFromPtr=2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=2f
'2f'
QByteStr[x.yx(2,12)]
blobMonstersGame.html:43 quad.yx start, y=2 x=12 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=12-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=2 x=4 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=4-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=0 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=0 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:95 quad.yx bytes recurse into bottom left quad aka nthChild 2
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=12 valHex=c5 mid=1 y=0 x=0 len=5
bytesFromPtr=c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=13 valHex=2c mid=0 y=0 x=0 len=1
bytesFromPtr=2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=2c
'2c'
QByteStr[x.yx(7,9)]
blobMonstersGame.html:43 quad.yx start, y=7 x=9 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=7 x=9-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=7 x=1 h=3 mid=4
blobMonstersGame.html:62 quad.yx recurse into bottom left quad (child 2), y=7-mid x=1 h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=3 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=3 x=1 len=22
bytesFromPtr=d1 f6 c5 48 49 58 59 c5 4a 4b 5a 5b c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:95 quad.yx bytes recurse into bottom left quad aka nthChild 2
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=12 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=16 valHex=79 mid=0 y=0 x=0 len=1
bytesFromPtr=79 c5 6a 6b 7a 7b
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=79
'79'
*/
//
//Example: Use it to paint a circle of a chosen color and QTRANSPARENT everyewhere else, then merge that into another Quad.
//This never worked: QEval((y,x,h)=>(h>0 ? QFORK : ((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : QTRANSPARENT), 8)
//(fixme dont return QFORK cuz will be called at various heights as optimization)
//returns a 256x256 compressed quadtree pic containing a blue wall circle, in theory todo verify.
//FIXME its not compressed if all 4 childs, or 16 childs etc, are the same symbol. that should have been done higher for cheaper.
const QEval = (byteAtYXH, h, optionalDy, optionalDx)=>{
	const lg = !!game.QuadLogLev.p;
	let dy = optionalDy || 0;
	let dx = optionalDx || 0;
	let byteHere = byteAtYXH(dy,dx,h);
	if(lg) console.log('QEval dy='+dy+' dx='+dx+' h='+h+' byteHere='+QByteStr[byteHere]);
	//if(h === 0 || byteHere == QTRANSPARENT){ //end recursion
	//if(h === 0 || !byteHasChilds(byteHere)){ //end recursion
	if(h === 0){ //end recursion
		console.log('QEval h=0 return val='+QByteStr[byteHere]+', inefficient cuz should use more bytes per Quad');
		return QuadByte[byteHere];
	}else if(h == 1){
		//FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them.
		if(lg) console.log('QEval h=1, inefficient cuz should use more bytes per Quad');	
		return new Quad(1, Uint8Array.of(QFORKC+5,byteAtYXH(dy,dx,1),byteAtYXH(dy,dx+1,1),byteAtYXH(dy+1,dx,1),byteAtYXH(dy+1,dy+1,1)));
	}else if(h == 2){
		//FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them,
		//but 2 recursions deep 1 4 16.
		if(lg) console.log('QEval h==2, making a 4x4 quad as 22 bytes, dy='+dy+' dx='+dx);
		let quad = new Quad(2, Uint8Array.of(
			QFORKD+1, //22 bytes in total aka 0x16
			QFORKF+6,
				QFORKC+5, //top left
					byteAtYXH(dy+0,dx+0,2),byteAtYXH(dy+0,dx+1,2),
					byteAtYXH(dy+1,dx+0,2),byteAtYXH(dy+1,dx+1,2),
																	QFORKC+5, //top right
																		byteAtYXH(dy+0,dx+2,2),byteAtYXH(dy+0,dx+3,2),
																		byteAtYXH(dy+1,dx+2,2),byteAtYXH(dy+1,dx+3,2),
				QFORKC+5, //bottom left
					byteAtYXH(dy+2,dx+0,2),byteAtYXH(dy+2,dx+1,2),
					byteAtYXH(dy+3,dx+0,2),byteAtYXH(dy+3,dx+1,2),
																	QFORKC+5, //bottom right
																		byteAtYXH(dy+2,dx+2,2),byteAtYXH(dy+2,dx+3,2),
																		byteAtYXH(dy+3,dx+2,2),byteAtYXH(dy+3,dx+3,2),
		));
		if(lg) console.log('QEval that same h==2, made these bytes: '+QBytesStr(quad.B,quad.i,quad.B.length));
		return quad;
	}else{
		if(lg) console.log('QEval recurse h='+h+', making a '+(1<<h)+'x'+(1<<h)+' quad using Q(quad,quad,quad,quad).');
		let mid = 1<<(h-1); //half of width and half of height
		let ret = Q(
			QEval(byteAtYXH,h-1,dy,dx),
			QEval(byteAtYXH,h-1,dy,dx+mid),
			QEval(byteAtYXH,h-1,dy+mid,dx),
			QEval(byteAtYXH,h-1,dy+mid,dx+mid),
		);
		//strongLogFirstTime('TODO QEval should .compress()');
		//return ret;
		return ret.compress();
		//return ret.compress().flatPack();
	}
};

/*FIXME this isnt compressing as of 2025-1-5, but im about to do it the slow way using .expand first.
//If all 4 childs are the same single byte, replace self with that byte, recursively. May occur in some childs but not others in various combos.
//Remember to use QuadByte[byteVal] as flyweight.
Quad.prototype.compress = function(){
	let firstByte = this.b(0);
	if(firstByte < QFORK){
		return this; //already a 1 byte leaf
	}else{
		Err('TODO handle compressing in leaf that has nonleaf tree in array such as a 2x2 or 4x4');
		let compressA = this.c[0].compress();
		let compressB = this.c[1].compress();
		let compressC = this.c[2].compress();
		let compressD = this.c[3].compress();
		let firstByteA = compressA.b(0);
		let firstByteB = compressB.b(0);
		let firstByteC = compressC.b(0);
		let firstByteD = compressD.b(0);
		if(firstByteA < QFORK && firstByteA==firstByteB && firstByteA==firstByteC && firstByteA==firstByteD){
			return compressA; //merge 4 duplicate leafs by forkEdit/immutable, return 1 byte leaf
		}else{
			if(compressA===this.c[0] && compressA===this.c[0] && compressA===this.c[0] && compressA===this.c[0]){
				return this; //no change, already compressed that way
			}else{
				return Q(compressA, compressB, compressC, compressD); //1-4 childs replaced by their compressed form
			}
		}
	}
};*/

//same data but viewed as (2**addToHeight) times taller and wider. each +1 to height makes it 2x2 times bigger as quadtree.
Quad.prototype.plusH = function(addToHeight){
	if(addToHeight <= 0){
		if(addToHeight < 0){
			Err('Cant reduce height');
		}
		return this;
	}
	let q;
	if(this.c[0]){ //has 4 childs as Quad objects, not just array wrapper. may be both
		q = Q(this.c[0].plusH(addToHeight), this.c[1].plusH(addToHeight), this.c[2].plusH(addToHeight), this.c[3].plusH(addToHeight));
	}else{ //array wrapper. wrap same array with a .h/height field higher which is outside the array
		q = new Quad(this.h+addToHeight, this.B, this.i)
	}
	if(this.isCompressed) q.isCompressed = true;
	if(this.isExpanded) q.isExpanded = true;
	return q;
};


//If all 4 childs are the same single byte, replace self with that byte, recursively. May occur in some childs but not others in various combos.
//Remember to use QuadByte[byteVal] as flyweight.
Quad.prototype.compress = function(){
	if(this.isCompressed){
		return this;
	}
	let q = this.expand(); //slow but simple way to not have to deal with wrapping arrays
	let firstByte = q.b(0);
	if(firstByte < QFORK){
		return q; //already a 1 byte leaf
	}else{
		//Err('TODO handle compressing in leaf that has nonleaf tree in array such as a 2x2 or 4x4');
		let compressA = q.c[0].compress(); //.c will be filled cuz .expand()
		let compressB = q.c[1].compress();
		let compressC = q.c[2].compress();
		let compressD = q.c[3].compress();
		let firstByteA = compressA.b(0);
		let firstByteB = compressB.b(0);
		let firstByteC = compressC.b(0);
		let firstByteD = compressD.b(0);
		if(firstByteA < QFORK && firstByteA==firstByteB && firstByteA==firstByteC && firstByteA==firstByteD){
			//cant do this cuz Quad knows its own height: return compressA; //merge 4 duplicate leafs by forkEdit/immutable, return 1 byte leaf
			//this doesnt compress it cuz length is still big: let ret = Q(compressA, compressA, compressA, compressA); //since Quad is used as immutable, reuse 1 child 4 times. height/.h is 1 higher
			//ret.isCompressed = true;
			//return ret;
			return compressA.plusH(1); //+1 height is 2x2 bigger
		}else{
			if(compressA===q.c[0] && compressB===q.c[1] && compressC===q.c[2] && compressD===q.c[3]){
				q.isCompressed = true;
				return q; //no change, already compressed that way
			}else{
				let ret = Q(compressA, compressB, compressC, compressD); //4 childs replaced by their compressed form
				ret.isCompressed = true;
				return ret;
			}
		}
	}
};

Quad.prototype.isLeaf = function(){
	return this.length===1;
};

//this.c will contain. If this is only a wrapper of a range of byte array,
//reuses that array and makes a Quad view into it for all 4 childs then returns the one of them you asked for.
Quad.prototype.fillChilds = function(){
	//if(this.h===0){
	if(this.isLeaf()){
		Err('leaf cant have childs');
	}else if(!this.c[0]){
		let i = this.i;
		this.c[0] = new Quad(this.h-1, this.B, i=firstChild(this.B,i));
		for(let childIndex=1; childIndex<4; childIndex++){
			this.c[childIndex] = new Quad(this.h-1, this.B, i=nextQuad(this.B,i));
		}
	}
};

//get or create child. If this is only a wrapper of a range of byte array,
//reuses that array and makes a Quad view into it for all 4 childs then returns the one of them you asked for.
Quad.prototype.C = function(childIndex){
	if(!this.c[childIndex]){
		this.fillChilds(); //throws if this.h===0 aka is a leaf of 1 (powOf2 size square) pixel/voxel.
	}
	return this.c[childIndex];
};

//Expand to all reachable quads from here recursively with at most 1 pixel each, very slow,
//but can be useful for debugging compression problems etc. Shares array if expands a wrapper of array.
//Idempotent, but remember to use Quad as immutable.
Quad.prototype.expand = function(){
	//if(this.isExpanded || this.h == 0){
	if(this.isExpanded || this.length == 1){ //is leaf. .h/height can be 0 or positive and still have only 1 byte, if its compressed.
		return this;
	}else{
		let ret = Q(this.C(0).expand(), this.C(1).expand(), this.C(2).expand(), this.C(3).expand());
		ret.isExpanded = true;
		return ret;
	}
};

//FIXME the single byte prefix that says 0 more bytes are coming, is that multibyte too? its never used.
//Should I define lenAtBytes to be 1+integerOfTheBytes so that cant happen? There could still be invalid combos.
//var isMultiByte = byt=>(byt>=160);

//dont modify these after this boot loop
const QuadByte = new Array(256); //reuseable 1 byte literals, though not all of them are valid cuz some are a multi byte sequence.
const QuadByteArray = new Uint8Array(256);
const ArraysOfOneByte = new Array(256);
for(let i=0; i<256; i++) QuadByteArray[i] = i; //fill whole array before Quad sees it, in case of bugs
for(let i=0; i<256; i++){
	if(byteHasChilds(i)){
		QuadByte[i] = null; //would be invalid Quad
	}else{
		QuadByte[i] = new Quad(0, QuadByteArray, i);
	}
	ArraysOfOneByte[i] = Uint8Array.of(i);
}
const ArraysOfTwoBytes = new Array(0x10000);  
for(let ii=0; ii<0x10000; ii++){
	ArraysOfTwoBytes[ii] = Uint8Array.of(ii>>8,ii&255);
}
const QuadTransparent = QuadByte[QTRANSPARENT];



//throw new Error('TODO QuadtreeByteArray, see existing code in conversation.');


/*Opensource MIT license. View Source in browser to get the complete source code which is just 1 html file. Play my experimental Blob Monsters Game 023 at https://humanai.net/experiments/blobMonsterGame/blobMonstersGame_023.html It doesnt work very well yet, is not much fun yet, but I have shapeshifting turing complete constraint solver ability and am planning to scale up to massively multiplayer and make some basic game content. The many players, if they like the content I make, will help expand the game with new content. You can write javascript code of 1 lambda into the text box on the left, for whichever "blob monster" is selected with the mouse so is flashing.

Some parts made by the combo of me and GPT-4 GPT-o1-preview or similar versions of GPT, which by this legal statement has entirely transferred copyright of that to code to me, as I pushed it through the space of possible code, and similarly it pushed me, back and forth in javascript code changes, which I opensourced as MIT:
"Ownership of content. As between you and OpenAI, and to the extent permitted by applicable law, you (a) retain your ownership rights in Input and (b) own the Output. We hereby assign to you all our right, title, and interest, if any, in and to Output." -- https://openai.com/policies/row-terms-of-use/


an opensource (MIT) 2d video game made of Blob Monsters which are a bunch of shapeshifting voxels made by any javascript code. Planned to be massively multiplayer and peer to peer but you can run it local too. Each monster has its own code, and any player can change that code while playing. Each variable is a dimension and has position and velocity, like m.p is position and m.v is velocity in game.addFunc((m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; }); Play Blob Monsters Game now at https://humanai.net/experiments/blobMonstersGame.html in a desktop browser such as fastest in Chrome or OperaGX but works in many browsers slowly. Its not working very well yet and is not much fun yet but that will change soon. Players can create new game content already using the textarea on the left of the game, by selecting any monster (it keeps flashing) and editing that text, but make sure to copy/paste it cuz you might break the game and lose that text. You can paste it back in there while a monster is selected to transform that monster.
..
2024-11-26+ There is now an option to turn Rock Paper Scissors glowing color game on/off by "game.doRps.p = 1;" to turn it on and = 0 to turn it off, on browser console. They are shapeshifting blob monsters either way. -- https://www.facebook.com/groups/blobmonstersgame/posts/1762526854563236/
..
Blob Monsters Game is the result of advanced math research. Here's a 128x128 grid of 4SAT solver. It solves it so fast I paint it with 2 mouse buttons, and it forms into the turing-complete triangles of rule110. Now they've got a 8192x8192 grid, expanding to a million by a million for massively multiplayer, and each monster can paint voxels wherever it wants, not just right next to itself. When 2 monsters paint the same pixel at the same time, it repels them.

Video at: https://www.youtube.com/watch?v=ROF6ZtF3zVk
and at: https://www.facebook.com/groups/blobmonstersgame/posts/1759387181543870/
..
There are 4 teams: red, green, blue, and gray. Red green and blue each have 1 predator team and 1 prey team. Red becomes green becomes blue becomes red, around and around, when they touch.
RED touches GREEN -> both GREEN.
GREEN touches BLUE -> both BLUE.
BLUE TOUCHES RED -> both RED.
Touch is symmetric, doesnt matter who touches who. they're touching the same pixel at the same time or not. Each monster is made of 2d voxels that touch other voxels at the same pixel. Each voxel is an int32: 13 bits of y, 13 bits of x, 2 bits of red, 2 bits of green, 2 bits of blue. Its a color in an 8kX8k square. 64 possible colors.
var predatorOf = team=>{
 if(team == REDTEAM) return GREENTEAM;
 if(team == GREENTEAM) return BLUETEAM;
 if(team == BLUETEAM) return REDTEAM;
 throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
var preyOf = team=>{
 if(team == GREENTEAM) return REDTEAM;
 if(team == BLUETEAM) return GREENTEAM;
 if(team == REDTEAM) return BLUETEAM;
 throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
..
Any player can view or edit the javascript code of any monster by selecting it with mouse, then code is in the text box on the left. It changes live while you edit it. You can share these small javascript codes in this facebook group and others cvan paste them in to play them, even to interact multiple of them together. Later this will be automatic in the massively multiplayer game.
..
Its not just 1 kind of monster, or a million kinds of monsters. Its every possible kind. If you make a tiny graphics algorithm in the editor, that makes pics depending on vector input (Y, X, heightToWidthRatio, otherThingB, etc...)=>{...make int voxels...}, then the game automatically varies that vector looking around for possible pics it makes. At each moment in the game, each monster makes 1 pic, of the exponentially many possible pics it can make. Wherever 2 of those pics overlap, they repel. When pushed like that, a pic changes to another similar pic that the monster can also create. Its a high dimensional constraint solver. heightToWidthRatio.p is position of heightToWidthRatio, and heightToWidthRatio.v is its velocity, and similar for otherThingB.p and otherThingB.v. The game doesnt know what heightToWidthRatio and otherThingB are. You make up whatever names you want, and it turns them into dimensions and constraint solves them. And does the red green blue team logic as they capture eachother by Rock Paper Scissors per voxel. You make a pic generating algorithm, and the game brings it to life.
..
I'd like to eventually expand Blob Monsters Game to 1 million simultaneous players. in a 1 million X 1 million pixel game area. Its 8k X 8k now. The math says it can work. Player created content will keep things endlessly interesting, new patterns forever. Peer to peer so nobody controls it. Just a bunch of computers and people building and playing together. It does not surprise me that ppl dont like it yet, that hardly anyone notices it. Thats just how KFactor works. You keep improving something until it passes KFactor=1 then it goes viral. And I've got the math to make that happen. All I gotta do is double the number of players 20 times. From the moment I wrote the first line of code that was the plan. It was designed from the start to scale like that. I'm a pure-function expert. I can move functions faster than Big Tech cuz I'm not weighed down with bloat. https://en.wikipedia.org/wiki/K-factor_(marketing)
..
Blob Monsters Game has a feature that Dagball lacks (my 2 games). The monsters can touch eachother. In dagball monsters can only touch bouncing balls cuz its so inefficient, but its all voxels to all voxels now. It had better graphics, but I'm taking this all the way. I just released Dagball V2, since I probably wont be updating it for a long time. Some features will get copied into Blob Monsters Game, id especially like the GPU optimized neural shapeshifters (saves/nnet*.dagball files), but we dont need GPU for basic shapeshifters and new fun kinds of gameplay. There is far lower hanging fruit. https://github.com/benrayfield/dagball
Neural shapeshifter in dagball. I'd like to make a GPU plugin for Blob Monsters Game to include these. "Dagball_2024-5-7-9aET_recurrentSigmoidNeuralnetWith22NodesTrainedLiveInGPUShader.mp4" and is at https://www.youtube.com/watch?v=4boQ9OvRz5U .
..
I wrote this, not knowing if it would work out, about 6 weeks ago (2024-10), and now I'm getting ready to scale up a video game to massively multiplayer which computes the 2d form of it. 3d is just too much data, but if u wanna bring more computers it could be done the same way. I wasnt sure it was the right equation. but soon I tested it. If this game scales up to a million simultaneous players, it is still a single equation that many dimensional sparse dimensional gradient happens on. That is why it will sync at low lag and why it will work and why Im going to beat the Big Tech giants. The world appears to me as a giant cellular automata that I can now build on in the form of equations that people and computers interact with eachother thru. Once it expands it doesnt stop.
3d wavefunction: poten (game) = integral_x integral_y integral_z integral max(0,things-1). accel = -gradient(poten).
See the relevant code in Game.prototype.addVox = function(voxel), addVoxWithTeam, remVox, remVoxWithTeam, etc.
pic: https://www.facebook.com/photo?fbid=9151039754908623&set=pcb.1759567084859213
and at "blobMonstersGame_000_3dWavefunctionEquation_IMG_20241121_203003455.jpg"
and related "blobMonstersGame_000_3dWavefunctionEquation_IMG_20241121_203003455.jpg (B 002).jpg".
..
When I say online multiplayer I mean swarms. Blob Monsters Game wont be able to do exactly this cuz the math it is based on cant efficiently do friction (might have to simulate simplex-noise or something). All its surfaces are superconductors superfluids etc. No friction at all. It does have anyVar.kv as continuous decay rate (using Math.exp) of every dimension and variable, but it doesnt depend on things rubbing eachother. It just stops the world from exploding. https://www.youtube.com/watch?v=5TxGgmR7fgU "Shutter Crush - Marble Race Countries in Algodoo".
..
See zoom out to whole terapixel (1048576 X 1048576) game area at once, but its only repeating the 8192x8192 (64 megapixel) area that it loads and unloads game content in. I broke the red green and blue glows (distance caches for chasing/running from eachother) and it wont select monsters with the mouse anymore, but the world expanding is proceeding.
"blobMonstersGame_027_millionXmillionPixelSpaceRepeating8kX8k_butBrokeTheGlowingDistanceCacheAndWontSelectMonsters.mp4"
..
max(0,things-1) as a loss/potentialEnergy function means at most 1 thing here, and when used with the integral_x integral_y etc, it means the sum of those, where 0 means true and positive means false, and the more positive the more unlikely it is, as usual in a loss function. So in a 2d or 3d space, the equation means that at every possible 3d position there are either 0 or 1 things but not more than 1, and if more than 1, then repel that possible world in the multiverse space.

TODOS
-- make immutable object type (PartialGameState) thats any set of the game area (which is 2**20 X 2**20) but only the wall vs open area vs unspecified if its wall or open area. And similarly, each gob having a primaryKey of gob.big (or gob.name, see gob.text() which returns one or the other) which is basically primaryKey of the js code string of js lambda (gob.brain)... may make it inefficient to sync and would be more efficient if it was just content addressable with no primaryKey, its just wherever those gobs are (not even where they paint, but where their Y.p and X.p lambda params are in 2d game coords. Im thinking about using gob.name as primaryKey of the TYPE of "blob monster" but u can have any number of instances and they all gotta have Y and X as their first 2 lambda params. So every gob is at a specific 1 of the 2**40 pixels of game coords, at all times. But there can be multiple instances of it, and which such pixel theyre at would be part of their primaryKey (the other part being their js code). I want the Bloomtree/Bitpic (from dagball) kind of 2d compression to be expanded (fork it for Blob Monsters Game) to also have a Var's contents (such as a Gob, where gob.ob is the var of that gob, and gob.ob.bo===gob) as data and the floored (round down) 2**20 X 2**20 (pixelOfTera meaning 1 of terapixel number of pixels in the sparse voxel/pixel space) coordinate of it is part of its primaryKey. Lets also limit each pixelOfTera to at most 1 Gob at a time. That gob can have a more precise y and x position (thats rounded down to the pixel index its in) as they are float64s and have position and velocity and epsilon and accelMul and gp each (those last 3 are constants defined in the code string, but position and velocity vary many times per second when an object is not paused/frozen). Basically, i think ive found a way to turn this back into a pure cellular automata again, with all data being stored in individual pixels (of 2**40 sparse pixels), and that data is a js code string and a position and velocity (float64s), at each moment. It might also have t (utc time) like Var.t is a new field of Var, not used yet 2024-11-20 but is there cuz each Var is a vector stream of position and velocity at every possible time, so a mapping of time to position and velocity that is incomplete/transparent in the future, cached well at any NOW, and may be stored or not for THEPAST. But basically its just position velocity and the last t it was updated in case the object is frozen. Or maybe should just mark is it frozen or not. I want the Bloomtree (from dagball) kind of 2d image compression to be expanded to make sparse pieces of this fit together. ITS VERY IMPORTANT THAT THESE SPARSE PIECES SUCH AS B C, B.poten(C) -> amount of potentialEnergy/loss to add if both of these occur at once by merging them to their average high dimensional vector or something like that. Very high poten (repel force) between 2 "make immutable object type thats any set of the game area" (as written earlier in this paragraph) would happen if they are just incompatible, like if one of them has different game rules than the other or does not allow use of the 'Math.random' function which the other of B or C has in any of its code strings or whatever reason. Its important cuz thats how it will, by boltzmann or hopfield network with those poten as the weights the value of adding each will be a different field B.biasPoten C.biasPoten (todo choose a field name for it, is biasPoten ok?), will set each of them to -1 or 1 or maybe to 0 or 1, by that energy. The B.poten(C) function may be expensive but also only need be called once and other than roundoff should be deterministic. Those boltzmann or hopfield weights may also be adjusted by simulation finding that some of the objects tend to break eachother or cause vanishing/exploding gradient or something, but that should be coded as making another such object ExcludeThatStuffIDislike and including ExcludeThatStuffIDislike.poten(B) and ExcludeThatStuffIDislike.poten(C). And u can even call ExcludeThatStuffIDislike.poten(ExcludeThatStuffIDislike) to make sure its self consistent by its own rules. We are looking for a clique, as in NP-Complete math, of sparse pieces of the game world. How would this keep track of which gob is selected? Could just have that be one of the Var fields. its in Gob.m.isSelected and Gob.m.isSelectable. That could just be copied to the other pixel. But the bigger problem is, the peer to peer net wont be exactly in sync always, will disagree on gobs being where, and if a gob can be at multiple pixelOfTeras at once (y x coords) as it can have multiple instances, then when we see 1 of those in one PartialGameState and 2 of those near that in another PartialGameState, or just 1 of those but at a different position, or combos like that, then it could be they're disagreeing on how many of them there should be, or it could be they had another such gob from farther away come and be near a gob of its same type. The problem is in peer to peer net (which as of 2024-11-20 does not exist but is planned) its hard to tell the difference between disagreeing on positions vs disagreeing on how many gobs of a certain type (js code string) there are. Id like that to be in B.poten(C) where B and C are both PartialGameState's, but i need to define how to detect that, as math. .......... [[I have math for something better than https. Its pure-functions called on eachother in all possible pairs, which you'll navigate sparsely as each will look like a "blob monster" in a video game for example and be copy/pasteable. Some kinds of these could make every existing hash algorithm and every existing digital signature algorithm, hash and sign eachother in every combo. Not that I need it for that, I'll just use ed25519 and sha256 by default, but what I do need it for is that quicksaves/quickloads of nearby parts of my game world (PartialGameState) can disagree with eachother in a peer to peer network (in theory which doesnt exist yet 2024-11-20) but based on them each being called on eachother (B.poten(C) for example, see my other post), the entire system globally syncs to include every possible thing that could happen, might has well does happen as we can gradient against it,  It has no time. All possible pasts, presents, and futures are facts of math that can each allow vs repel eachother by NP-Complete math. I am trying to turn an existing prototype of my video game (Blob Monsters Game, which is 1 html file) into a massively multiplayer game-theory experiment. If my new kind of game-theory works, then the game will scale and expand and have KFactor > 1, go viral and be self sustaining past superintelligence. If not, nobody will care. i wrote at https://www.facebook.com/ben.f.rayfield/posts/pfbid0wJcNZZvS3wXAwi7C2dyDuw5cYCQSy87hwth7Yi6H5io7aQGU7vkbNxZdGd2HzVSl ]].
-- make BloomTree/BitPic based gobs/vars and use Var.searchYXR to find them, and make there be an easy way to know which to replace when painting with mouse 2 buttons 1 to paint walls and 1 to paint open areas aka delete walls.
-- Decide if I want mutid or not, where at most 1 of varnameABC.p can be nonzero (to say it exists) which have same mutid, so you can edit the code of a gob/blobMonster which means its primaryKey changes, so its 2 different gobs/vars, but thru mutid would automatically exclude eachother. Should it be in the Var.name, like mutidBob_sha256$sdfasdfasdfasdfasdf vs mutidBob_sha256$ssssssfdfddddddddddd or something like that? but mutidBob_sha256$sdfasdfasdfasdfasdf.mutid would be a string that would be derived from the name. Seems overly complex, but it does something useful. Figure out how to get it simple and useful, or choose not to use it. How else would it know to replace a powOf2 sized square of BloomTree compressed wall with another edited such wall? mutid is useful in dagball. It might be here too. But only within that namespace. Or maybe i should use V.theNamespace.theMutid.theJsCode?
-- use Var.searchYXR to find gobs/vars to display sparsely, and scroll the 8kX8k area by wrapping, not by copying. its already displaying that way, so simply remove some gobs/vars and add others, where gobnameABC.p==0 or ==1 determines if exists or if displays here. Maybe should be a separate gobnameABC.existsInView55 or something. or just use game.gobs which is a js [] list.
-- Done 2024-11-21 or earlier: fix the duplication bug in Vars that possibly involves V.testnet.gobname.vars (list) and .pu ({} map) and they seem to have duplicates and .p changes in one but not the other.
-- make game state loadable/saveable as json (V.toMap()). 2024-11-21 or earlier, toMap makes json, but not loading it yet.
-- start using V.testnet.gobnameABC.p==0 to mean delete that gobnameABC and ==1 to create or keep gobnameABC.
-- make 1 JSP file that remembers some basic serverMoney shortterm as a way to rate limit possible spammers and uploaders of huge amount of content, but start creating content in browser and uploading/downloading it there. Put searchYXR etc there too, have queries go by that.
-- Make a kind of object with an ed25519 publickey generated by a password (have code in Dagverse.js to modify) to put 1 mouse circle in the shared game area per publicKey. The rest are whatever gobs are there, but each mouse gets to move around. Will have more advanced controls later.


DONES:
-- done 2024-11-20 in version 023 possibly a version or few earlier. Rename Y and X funcs if Y and X will be the standard Var names for Var.searchYX. game.addFunc(`(Y/ *${targetY}* /, X/ *${targetX}* /, heightToWidthRatio) for example (without the spaces between / and *). Cuz Y and X strings are in DefaultAllowedClassDotFuncs.
*/







const DefaultQuadForTile = new Quad(tileHeight, ArraysOfOneByte[WRGB(0,1,1,1)]); //todo make this 0 0 0 0?




//
/*
checkForUnexpectedEvalsInJsParsingBeforeCrossSiteScriptingReactor

//quote from farther below 2024-11-17, in progress of making Var instances be a tree with V as its root then namespace...
//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var('V'); //var Var = function(optionalName, optionalGob, optionalParentVar, optionalBig)


TODO "or what if I divided them into each their own mini game world, in a 3kX3k square that mostly reads and syncs from outside the 2kX2k square in its
center (so border width 512). I could make these sizes parameters. But I think it would be more efficient to swarm many small ones"


[[[2024-11-11 https://x.com/benrayfield/status/1855944895057268971
Post
Conversation
Lambda Rick /acc
@benrayfield
·
5h
See that slightly jagged line between the 2 green blobs. Thats cuz its doing dijkstra shortest path finding, between each pixel and the 8 adjacent pixels. Thats where the colors come from. They estimate distance: 3 to up down left right. 4 to upleft upright downleft downright.
Image
Lambda Rick /acc
@benrayfield
·
1h
4/3 is a poor substitute for sqrt(2). Id have liked to use 7/5 but i only had 2 extra bits in 10 bit distance if i want about max distance of 256. I can compute ddistance squared exactly for every pixel to every voxel but its alot slower
Lambda Rick /acc
@benrayfield
·
1h
As long as the distance-like algorithm is the same within a peer to peer net sharing a 8k X 8k canvas, it will sync exactly. Theres a correct 10 bits for every pixel (times 3 teams) for each possible world state.
Lambda Rick /acc
@benrayfield
·
55m
It does 3 dijkstras at once in the same int array. State of dijkstra is entirely in that array and 2 loops, one forward then one backward, each reading 5 of the 9 ints as 3x3 (like in conways game of life) and writes the center int. All 9 ints are in CPU L1 cache, hella fast
Lambda Rick /acc
@benrayfield
·
49m
A world state is a set of javascript lambdas and a position and velocity for each param. The pambda returns an int array of any size, even varying the size based on params, 1 int per 2d voxel in 8k X 8k shared canvas and 64 possible colors. It changes by high dimensional gradient
Lambda Rick /acc
@benrayfield
·
38m
To approx high dimensional gradient, it removes a lambda (of n params) from world state, computes total potential energy, then calls lambda n+1 times to get n+1 arrays of voxels, counts collisions where pixels (of 64 megapixels) are written twice. Also can add to energy directly
Lambda Rick /acc
@benrayfield
·
25m
Each pixel can store, in just 9 bytes, up to 2^26-1 voxels which have the same (x,y) coordinate and may differ in color and team. There are 3 teams. Usually stores 0-2 voxels. It can do this cuz its entirely reversible by xor and counting of color and team mask.
Lambda Rick /acc
@benrayfield
I had to support 64 million voxels overlapping in the same pixel, without any slowdown in computing gradient, cuz some users will likely DoSAttack a shared canvas. They will fail.
7:05 AM · Nov 11, 2024
·
39
 Views
]]]
 I dont know what to call it, but its doing something like raytracing. But instead of the usual rays its a triple dijkstra per pixel, emitted from every voxel in all directions. Nothing in there is just for graphics. These rays will for teams to chase and run from eachother.
 I have 2 bits unused in the triple dijkstra. 10 bits per distance. 3 distances to nearest team (of 3 teams). So I could put a wall bit in there, which would make the raytracing curve around walls, take a longer path, and display darker the longer the path goes.
If I did this, and once i hook the blob monsters into it to chase and run from the other 2 teams, then they would automatically do basic pathfinding, would automatically take the correct path thru a maze, for example.
If I had 3 bits left I would have used 11 bits per distance instead of 10. but there is no int33. its int32.
but I'd have to go back to the priority-queue of what order to update the pixels, instead of the constant order it is now, which would make it take 3 times longer cuz i couldnt do 3 dijkstras at once, and would take log(numPixels) times longer cuz of the priority queue. nevermind.

also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints

[[[[2024-10-26 https://x.com/benrayfield/status/1850224874586837004
Lambda Rick /acc
@benrayfield
I'm building a cross-site-scripting reactor. Anything could come up in the form of small strings of javascript code. Basic thing, dont let them call functions except Math.exp Math.sin Math.pow etc. Check for number of flops, no infinite loops, so sub-turing but turing up as MMG
1:16 PM · Oct 26, 2024
·
29
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
Now
also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints.
Lambda Rick /acc
@benrayfield
·
10m
The power of a cross-site-scripting reactor is not supposed to be by security flaw, tho its designed to safely contain any bit strings even if theyre computer viruses (if given execute permission, so do ur own proofs 1st if u do that). The power is in the shared worlds it builds.

If such code is valid under the rules of the simulation (and which sim you want to do is up to you, its your billions of transistors), then in theory (if it ended up being coded this way, which im still in early research about) it just another way to write the same thing.
]]]]
<<<<<https://x.com/benrayfield/status/1850234847731527956
Lambda Rick /acc
@benrayfield
·
11m
Got a GPU doing nothing in your house? What if u could store GPU power in opensource peer to peer network in a tit-for-tat way, so that you could instead of just locally having a burst-rate of 1 teraflop, have a burst rate of 1 petaflop, but can only do so 1/1000'th of the time?
Lambda Rick /acc
@benrayfield
If 10^12 calculations per second isnt doing it for u then what good is 10^15? I went back to CPU only. I made turing complete autodiff using JS funcs as blackboxes and have 12 of em bouncing around using 2d voxels. And if ppl wanna burst-rate petaflops in certain forks, go for it
2:00 PM · Oct 26, 2024
·
7
 Views
View post engagements
>>>>>
{{{
t
Conversation
Lambda Rick /acc
@benrayfield
NP-complete game object in blue at the top
Image
12:59 PM · Nov 11, 2024
·
31
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
4s
#TripleDijkstra graphics
Lambda Rick /acc
@benrayfield
·
13m
this is the most basic level of my new game system. CPU only. about a 100kB html file. only 1 file. and its currently running about 25FPS and doesnt have enuf objects on screen. but i do have teraflops available thru shaders
Lambda Rick /acc
@benrayfield
·
9m
every javascript function added can write sparsely to any address 0 to (2**26)-1, write to it by making a voxel there which repels any other voxels written there such as by 2 javascript functions trying to kick eachothers asses in a game or such as NSAT solving.
Lambda Rick /acc
@benrayfield
·
8m
even if distance calculations are only calculated in some parts (cuz expensive), the exact potential energy of the collisions part of the 64 megapixel canvas, is ALREADY how it works.
}}}
In #TripleDijkstra graphics, I compute the dijkstra shortest path between all pairs of about 50,000 voxels and 1,048,576 nodes (pixels), 25 (todo 60) times per second. Ok thats just normal optimizing. The advanced part is I do it 3 times in parallel, same order of nodes for all 3 --2024-11-11 https://x.com/benrayfield/status/1856040659221713292
*/
//
//The code anonymously shared and spread thru my tiny game engine should be thought of as an antivirus-quarantine but
//not a quarantine cuz its opensource and anyone can make copies and swarm and stream it. Just be warned,
//it might want to hack u so dont give it execute permission. Html can generate any file type and offer it for download
//or give you a string of hex to paste into a hex tool or something which can turn it into bytes in a file.
//If those are just other html or json files, fine, but dont trust executable types.
//js run in browser is not executing. js run in nodejs/npm is executing. Depends where you run it.
//Also it could run an infinite loop or redirect the page to a spammers website, but u can just close the browser tab if so.
//Files by themself are not dangerous, even if they contain viruses, as long as you dont give them execute permission.
//
//My tiny game engine does something the others dont: If you bend it certain ways, it will bend back in other ways,
//not just like a spring but like a computer thinking about how it wants to bend.
//I'm making a #web3 compatible system that runs in thousands of browsers at once, sharing a 8192x8192 (64 colors)
//interactive video at 60 FPS gaming-low-lag, which 2d voxels are painted by a high dimensional scalar-field simulation.
//Shapeshifting blobs move by constraint solving
//How many colors do you really need for a video game to be fun? If I use 6 bits for color I can expand the game area
//to 8192x8192 pixels, and voxel still fits in an int. If you can see a 512x512 area at a time, thats 16 screens wide
//and tall, so could fit a scrollable game level
//This 8192x8192 pixel object will be a #web3 data structure, sparse and gaming-low-lag and stored very compressed.
//It might have thousands of players per 8kX8k square. Physics happens in each pixel individually by accelerating
//away from gradient, might add differential equations.
//The voxels are general problem solvers though come in many tiny pieces. They are N-SAT solvers, fourier solvers,
//fractal solvers, and generally anything thats not TOO hard a puzzle, cuz they will get stuck in local minimums.
//But it works as a video game. We expand from there.
//My area of web3 is things that spread cuz they are fun or useful, instead of to buy and sell them. Any system,
//nomatter what it is, must produce at least as much as it consumes, to survive. I count progress in units of
//KFactor, will this spread more than it fades away?
//I have turing-complete autodiff, but just a little of it, not very deep, and I'm gonna have it paint 64 megapixels
//per shared virtual screen, per pixel. Each pixel has 6 bit color, 64 possible colors, and a 26 bit (8192x8192) address.
//What I'm about to build, a scaleable prototype of turing-complete-autodiff that paints 64 megapixels live, is the
//result of over and over asking myself, how could I raise KFactor of this tech while still being turing complete?
//So Cut off parts didnt need, adjusted bit sizes etc.
//Its CPU only for now. The older versions used GPU, but I optimized it so well I can do it  without,
//leaving GPU for more advanced stuff to add on later, maybe some neuralnets or something.
//The difference between AI and physics is not clear cut. Theres gradual levels between. I've been training small
//neuralnets with a physics algorithm in many dimensions. And when I make 2d shapeshifting game objects, thats a
//little like AI. They learn live, which is the gameplay.
//In turing-complete-autodiff, u make 1 mechanical part, which may be in multiple parts
//(return whatever set of voxels u want, no judgement on if theyre connected), and return an extra
//amount of loss (like neuralnet loss, more general) and physics is by automatic constraint solver
//Theres 67,108,864 pixels in 1 game state. Each keeps a count of number of objects currently
//touching/painting it, a count which can go up to 67,108,863 objects. Each pixel can store 1 NSAT bit
//and 6 color bits. 2**26 pixels can be 8k x 8k, 512 x 512 x 256, or 26 dimensions size 2
//Game state also TODO... includes a string of javascript code of a lambda of n float params, named
//whatever that function likes. Func object is scanned for its parameter list, and 1 dimension in the
//game world created for each, with a position and velocity. It returns an int array
//potential energy ranges 0 to 2**53-1 so fits in a float64. Add max(0,count-1) for each pixel,
//of counting number of objects which touch/paint that pixel. Each game object can also add an
//arbitrary integer to potential energy for things like springs, least squares. Multiverse...
//Turing-complete-autodiff will use this API:
//game.addFunc((centerY, centerX, varA, varB, nameVarsWhateverYouWant)=>{...return a list of int voxels...}).
//Doesnt matter what javascript function you put in there, as long as all its parameters
//are a Var instance, like centerY.p varA.p .
//I computed potential-energy across multiple black-boxes and the game survived and physics kept working. They are
//basically simulated graygoo if u didnt have to worry about how to physically make tiny computers,
//just a fun software API for it.
//
/*
My 36kB game engine will be a serious game-theory research platform with lots of AIs and people building and playing
and experimenting together. Each "blob monster" can include a loss function, used like:
centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract
All the .poten are summed. You only need 1 of them, and it doesnt matter which you add into. There was just nowhere
else to put it than in the Var objects that are auto generated as the params of any JS func you write.
--- https://x.com/benrayfield/status/1850497760463647137
*

In peer to peer network, the whole 8192x8192 shared canvas would be updated, each computer computing physics locally in the parts they're near. but its just on 1 computer for now. game state is very compressed, just the code strings of JS that make voxels and 2 numbers per param. -- https://x.com/benrayfield/status/1856413738741457180
*


I should probably make neural-shapeshifter plugin for Blob Monsters Game. I could fork out of dagball, built on my Ap.js GPU programming language, which is built on my TinyGLSL stateless synchronous (no async/await) way to call GPU from browser.
youtube.com
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
https://www.youtube.com/watch?v=4boQ9OvRz5U
this blob species "neural shapeshifter" would be just another JS func that happens to call the GPU thru my opensource local API,
but I'd have to upgrade Blob Monsters Game to have a parallel API where you can call monster.brain(...(monster.vars))
monster.length+1 times at once.
If i copy a 80x80 pic of 1 bit per pixel, into GPU, I can copy it into EVERY GPU core at once, or at least usefully 1000 of them,
and compute collisions inside the GPU cores, so return the loss function. 1001 GPU threads to compute the gradient of float[1000]
loss function.loss function.


The fun game content should come from that Blob Monsters Game is a turing-complete constraint solver that can solve about a million vars at once. Thats what I gotta build on. When you zoom out to 64 million it updates most of the 64 megapixels slower, those near the mouse fast.
Imagine players build forts or stacks or chains and other simple machines, of combos of these shapeshifting blob monsters (which can shapeshift in far more advanced ways than shown here). 50 players in one fort. 70 players in another. Try to invade cuz colors spread exponentially -- https://x.com/benrayfield/status/1857501980366672174
What kinda "simple machines" could u build? Maybe... catapult, gearbox with stick shift and realistic torque, 2 squares that if u turn them relative to eachother they wormscrew closer/farther from eachother, a wrench to grab such a square, 3 elevators which total constant height.
The game is open-ended. In general a team wins by turning the game world to their own color (red, green, or blue), but as its turing-complete and has a code editor on every player's screen (select any object), I cant know all the possible ways to win. I will be surprised.

Blob Monsters Game 019 has decentralized sync built in among its hundreds of megabytes of memory (in browser) already. Doesnt update all the pixels at once, but does update all of them soon and those near mouse instantly and near any random voxel of any random game object #web3 -- https://x.com/benrayfield/status/1857518756324585793

...
TODO still use ints in gob.brain but have it check game.offsetY game.offsetX or something like that, or put it in Var instances in params somehow
maybe but dont complicate them. Define it in math this way?...
binheapY 21 bits, binheapX 21 bits, 6 bits color, mask 5 bits, fits in uint53 which fits in float64.
The 5 bits are for teams REDTEAM GREENTEAM BLUETEAM WALLTEAM and a bit for is it moveable vs constant,
which it should be constant (todo fix mouse gob to have more than 0 params, and set those params
by Var.mn and Var.mx (min and max truncation) by Controls.mouseY etc, so anything which has 0 params automatically is marked as constant in that bit,
so 53 bit voxels in the expanded form that can handle powOf2 aligned voxels in a 1 terapixel space (2**20 each of y and x, with an extra bit for binheap).
Dont do variable size voxels. Use 2 voxels if u wanna do that, to define a top left and bottom right corner, or something like that.
How about y22 x22 color6 teamMask3, where neutralTeam is teamMask of 0?
Or I could just use 2 bits for team, for 4 teams red green blue wall.
Probably best to leave a few extra bits for future expansion.
Go with y20 x20 color6 teamMask4 reservedForFutureExpansion3. fits in uint53 that fits in float64.
Choose a place to put offsetY and offsetX which are each uint20 and never get too close to the millionXmillion square for the 8kX8k to fall off or wrap.
1mX1m space, 64 colors, and 4 team bits, comes to 50 bits.
I could use just 2 team bits if its 1 of 4 specific teams (red green blue wall), but what if i want more teams for powerups or something later?
I should just put Var.m.offsetY Var.m.offsetX as a place to put extra variables like this?
I like using 5 hex digits for y and x as coords. that seems like something players would prefer over a partial hex digit which u get with
2million or 4milllion or 8million but next hex digit as 16million. 1million seems a good size to snap that to.
or should offsetY and offsetX just be global vars? var offsetY = 0x576bb;
Go with 20 bits of y, 20 bits of x.
Do I want to shrink the 8kX8k to 4kX4k so it fits in 3 hex digits? i could fit 2 bits of team in there, but gob.brain shouldnt have to know its team.
8kX8k works already (2024-11-16). The 4kx4k area in its center, or maybe 6kX6k area in its center, would be computed here but border of 1k to 2k wide
would just read whats nearby in the huge game world. 1mX1m world.
See game.oy and game.ox and game.ns.
--------
[[[2024-11-16 https://x.com/benrayfield/status/1857893345617437061
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
Quote
Lambda Rick /acc
@benrayfield
Replying to @benrayfield
If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
We might in some ways of using the system be able to ballpark estimate lightspeed by max internet speed, like recursive dijkstra. not that we need to. but half or so of lag in games is generally cuz of lightspeed.
I can do alot of steps and a few network hops before light reaches between the multiple computers I'm controlling.
These coordinates in million X million pixels should be used in saved and loaded game states. I havent made those files yet
but this seemed an important thing to do before it.
..
I want 1 million simultaneous players in my Blob Monsters Game. So I expanded address space to exactly 1048576x1048576 pixels (1 terapixel),
sparsely as voxels, 6 bit color, 10 bit glowing distance cache for each of 3 Rock Paper Scissors teams, 1 bit per team is it touching pixel
-- https://x.com/benrayfield/status/1857920330532028545
Within a namespace, everyone can see all 2^40=1099511627776 (1.1 trillion) pixels and scroll and zoom in/out but some things will
look blurry or missing as they're loading. 60 FPS if u play at 512x512 resolution not zoomed out too far, or u can fiddle with it. Swarm the games.
Game state is turing-complete compressed in the form of each game object (Gob)'s primaryKey is a string of JS code of a lambda that returns an
int array of int voxels, with data of a vector of a position and velocity per lambda param. Will soon expand to 1048576x1048576 addresses.
its 1024 times wider and 1024 times taller than this (pic of 1024x1024 resolution with a 768x768 in it).
Even those its sparse, I hope to live fill at 60 FPS every one of those pixels, though in more relaxed games u could leave stuff unexplored. Each player can fill a million or so.
Imagine r/place but with a shortage of people willing to expand ever bigger, and balance it kind of, and throw in turing complete shapeshifting blobs battling eachother.
the uint10 glowing distance caches would not be copied. only the JS code strings and positions and velocities would be copied, and less often,
the recursive quadtree based 1 terapixel sparse image at 2 bits per 2x2 fork or wall or nonwall or transparent/unspecifiedIfItsWallOrNot.
As far as I know, nobody has ever made a massively multiplayer video game that is entirely decentralized. The hundreds of megabytes of RAM it uses is decentralized.
It updates random areas of 64k numbers at a time, and they converge to exactly the same thing nomatter that order. -- https://x.com/benrayfield/status/1857940083254411506
There is a likely opensource upgrade path to swarm the combined exaflop/sec of those computers GPUs plus whatever even greater cloud supercomputers some fewer users might
hook in thru digital signatures, to scale up my neural-(playdough-like) blob monster like in this video https://www.youtube.com/watch?v=4boQ9OvRz5U
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained live in GPU shader (GLSL)
<<My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet.
It does gradient descent with momentum and annealing automatically of
whatever you type in there. By dragging around the icons, some bright and some dark, I shape the bright
and dark areas. It does at least 1 training batch per video frame 1/60
second, sometimes around 6 batches per 1/60 second. This will in theory scale up to doing live neural qlearning
in a GPU shader on tiny neuralnets and to fit many such
neuralnets together to do bigger things, or at least to make the dagball game more curvy, bouncy, bendy, and fun.
>>
]]]

GPT-o1-mini and -preview helped me with 8-way-manhattan distance cache algorithm that I now use in 64 megapixels per computer. U can read that conversation
here "We [OpenAI] hereby assign to you all our right, title, and interest, if any, in and to Output" -- https://x.com/benrayfield/status/1858279962559565830
https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js.txt
*/


const dagball = {}; //only some parts copied from Dagball.html, didnt want to rename their function calls. Maybe will modify them.



const SizeBits = 13;
const Size = 1<<SizeBits; //8192
const SizeMask = Size-1;
const Area = Size**2; //8192*8192
const Colors = 1<<6;
if(Area*Colors > 2**32) throw new Error('Voxel layout does not fit in int. If you want more space, try uint53 or int54'+
	' (21 or 22 more bits) which fits in float64 but that redesign would cost alot of speed. Example, and would have to'+
	' be sparse cuz cant store that much in dense array: 16k x, 16k y, 16k z, 4k colors, 54 bits per voxel.');
const ColorMask = Colors-1;
const MaxVoxPerGob = 1<<20; //should probably be alot lower than 1<<20, but 1<<20 can technically work.

const MagnifyShift = 2; //Size is 4 times smaller than SmallSize. Area is 4x4 times smaller than SmallArea.
const SmallSizeBits = SizeBits-MagnifyShift; //4x4 smaller
const SmallSize = 1<<SmallSizeBits;
const SmallSizeMask = SmallSize-1;
const SmallArea = SmallSize**2;
if(((1<<MagnifyShift) != (Size/SmallSize)) || ((1<<(MagnifyShift<<1)) != (Area/SmallArea))) throw new Error(
	'MagnifyShift is broken. This line is here as a way to explain it to humans and AIs and possibly to help the JIT compiler optimize ints.');
if(Area != SmallArea<<4) throw new Error('This will never happen. Just helping the compiler optimize maybe.');
if(SmallSizeBits!=11) throw new Error('toSmall and other funcs are being hardcoded for this size, 2048x2048 small, 8192x8192 normal');

//With this upgrade I'll only store an extra int (triple dijkstra, 3 of uint10) and an extra byte (team masks),
//per 16 pixels (4x4). So thats 64 megapixels for main voxels, 4 megapixels for this other stuff, magnified.

//13 high bits and 13 low bits -> 11 high bits and 11 low bits, dropping the low 2 bits from each uint13.
//TODO Small indexs are used in game.rps.tridistSmall (not game.rps.team cuz xoring 0-16 team masks together might cancel itself out).
//Big indexs are used in game.board.
const toSmall = yx=>(((yx&0b11111111111000000000000000)>>>4)|((yx&0b1111111111100)>>>2));

//11 high bits and 11 low bits -> 13 high bits and 13 low bits ->, adding 2 low 0 bits to each uint13.
//toSmall(toBig(smallIndex))==smallIndex, but toBig(toSmall(bigIndex)) only equals bigIndex if its y and x are both divisible by 4.
const toBig = yxSmall=>(((yxSmall&0b1111111111100000000000)<<4)|((yxSmall&0b11111111111)<<2));

//TODO rename toBig to toMid or something like that, and rename this toMega to toBig. Find 3 good names of the
//existing sizes (which are exactly 2048**2, 8192**2, 1048576**2, aka small=(2**11)**2 big=(2**13)**2 mega=(2**20)**2).
//const bigToMega = yx=>(IY(yx)*(2**33)+IX(yx)*(2**13)));

//throw new Error('TODO make game.rps.tridist be 4x4 smaller, so 2048x2048, and update redByteAtYX etc to use that size.')

const Controls = {
	mouseY: 0,
	mouseX: 0,
	mouseButton0: 0,
	pause: 0, //toggled by pause button on keyboard
};

const IY = voxel=>(voxel>>>19);
const IX = voxel=>((voxel>>>6)&0x1fff);
const IR = voxel=>((voxel>>>4)&3); //get red as uint2
const IG = voxel=>((voxel>>>2)&3); //get green as uint2
const IB = voxel=>(voxel&3); //get blue as uint2
const IC = voxel=>(voxel&0x3f); //get color as uint6
//0b1010101*0b11==0b11111111. Im using this to turn 2 bits of red, green, or blue into 8 bits.
//if u multiply 0..3 by 85, it becomes 0, 85, 170, or 255. It hits the min and max brightness.
const RR = voxel=>(IR(voxel)*85); //get red as uint8, which is 1 of: 0, 85, 170, 255.
const GG = voxel=>(IG(voxel)*85); //get green as uint8, which is 1 of: 0, 85, 170, 255.
const BB = voxel=>(IB(voxel)*85); //get blue as uint8, which is 1 of: 0, 85, 170, 255.
//Shape/color code adds voxels like this:
//game.addFunc((m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; });
//Makes the bending parabola. Search for game.addFunc in the html.
const YXC = (y,x,color)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|(color&0x3f));
const PC = (yx,color)=>(((yx&0x3ffffff)<<6)|(color&0x3f));
const IP = voxel=>(voxel>>>6); //get yx position without color, 0 to 2**26-1
const YXRGB = (y,x,r,g,b)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|((r&3)<<4)|((g&3)<<2)|(b&3));

const SetC = (voxel,color)=>((voxel&0xffffffc0)|(color&0x3f)); //replace color get new voxel

const IColorStr = voxel=>('#'+doubleHexDigits[RR(voxel)]+doubleHexDigits[GG(voxel)]+doubleHexDigits[BB(voxel)]); //like 0b011011 -> #55aaff

const randInt = max=>Math.floor(Math.random()*max);

const randTeam = ()=>(1<<randInt(3)); //random one of REDTEAM, GREENTEAM, or BLUETEAM. Never returns BLACKTEAM cuz that means no gob is there.

const Err = str=>{
	throw new Error(str||'');
};
const Todo = str=>{ throw new Error('TODO: '+(str||'')); };


const INF = 1<<29;
//orthogonal adds 3. diagonal adds 4. so 4 is shorter than 3+3. See computeUint10Distances.
//The best ratio of these is orthogonal*Math.sqrt(2)=diagonal, but we dont have enuf bits of precision for that.
const TINF = (1<<10)-1; //1 uint10 max aka 1023. used with game.rps.tridist, either the first second or third 10 bits, so it uses its low 30 bits.
const TRINF = (1<<30)-1; //3 uint10s each 1023. used with game.rps.tridist.
//const INF = 0x7FFFFFFF; //max int, infinity-like. used in game.rps.boardR, .boardG, and .boardB to say distanceSquared has not been computed
//const newRpsArray = ()=>(new Int32Array(Area).fill(INF));
const newRpsArray = ()=>(new Int32Array(Area).fill(TRINF));

const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers.
const REDTEAM = 1;
const GREENTEAM = 2;
const BLUETEAM = 4; //const BLUETEAM = 3;
//A gob should be counted as nonmoving if it has 0 params as gob.brain aka gob.vars.length, but since "mouse" a js var whose value is a Gob,
//uses Controls.mouseY and Controls.mouseX, as of 2024-11-17, which makes it stateful, that contradicts that design. Should add params for that.
//If there are things that need defining for optimizations, put them in gob.m such as gob.m.isSelected, gob.m.isSelectable, gob.m.team, etc,
//which are more of primary data storage than optimization but theres things to untangle and redesign here todo.
//
//GRAYTEAM created cuz: TODO 2024-11-17 this is new. its meant as a neutral team, made of walls that may be moving or nonmoving. if nonmoving, dont call gob.nextState(dt)
//on them as they wouldnt change state anyways, so an optimization of reaching the same result.
//This is needed for the Rock Paper Scissors teams to use as shields to do more strategic gameplay
//Remember, this is built on a turing complete sparse-dimensional many-dimensional constraint solver. We can build many possible kinds of gameplay and mix them.
//There are only 7 teams available in uint53 voxels (an inefficient form of oy and ox and oshift used with int arrays of int32 voxels),
//of which 4 are used so far 2024-11-17: REDTEAM, GREENTEAM, BLUETEAM, GRAYTEAM. BLACKTEAM does not count cuz is just the name of the lack of any teams at a pixel.
//This is cuz in 53 bits (which fits in a float64 as nonnegative integers): y 20 bits, x 20, color 6, teamMask 7. Have used 4 of the 7 bits available for teamMask.
//Maybe should use those other 3 for some simple categories of powerups or wall pic compression or generally... 3 bits Reserved For Future Expansion. is 50 bits so far 2024-11-17.
//float64 can hold absolute voxel 2d coordinates and color and set of teams there (that are not cancelled out by an even number of the same team being there),
//but for efficiency oy and ox and oshift should define where in terapixel coordinates it goes (40 bits) and the 26 bits of local coords (8k square) are relative to that.

const GRAYTEAM = 8;

/*This isnt gonna work cuz scrolling the 8kX8k game.board over the much bigger area would require copying it. I want it stored as 1 bit per pixel.
Maybe I should use blocks of 8kX8k bits which is 8mB each, or 1kX1k bits which is 128kB each, and have a sparse array of 1024x1024 of those. Call it WallTile.
//TODO like GRAYTEAM but optimized for nonmoving walls. we put those walls TODO using powOf2 aligned blocks compressed by BitPic/BloomTree from dagball caode.
//WALLTEAM will go in game.board to count that theres a wall, so theres no extra collision detection code, its already using that.
//All we gotta do 
const WALLTEAM = 16;
const WallColor = 0b010101; //of WALLTEAM
*/

const teamShift = new Int32Array(5); //holds REDTEAM, GREENTEAM, and BLUETEAM, but not higher teams.
//const teamShift = new Int32Array(16);
teamShift[REDTEAM] = 0;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 20;
//GRAYTEAM should not go in tridist so shouldnt shift: teamShift[GRAYTEAM] = 30; //there are 2 bits left, though we should probably leave them unusued.
/*
teamShift[REDTEAM] = 20;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 0;
*/
//(game.rps.tridistSmall[(smallY<<SmallSizeBits)|smallX]>>>teamShift[BLUETEAM])&mask10
//is the uint10 of approx cached distance (with some max) to nearest BLUETEAM voxel, from (smallY,smallX) pixel.
const teamName = [];
teamName[BLACKTEAM] = 'BLACKTEAM';
teamName[REDTEAM] = 'REDTEAM';
teamName[GREENTEAM] = 'GREENTEAM';
teamName[BLUETEAM] = 'BLUETEAM';
teamName[GRAYTEAM] = 'GRAYTEAM';
while(teamName.length < 256) teamName.push('NOTEXIST'+teamName.length+'TEAM'); //all byte values have a team name.
teamName[REDTEAM|GREENTEAM] = 'REDTEAM|GREENTEAM';
teamName[GREENTEAM|BLUETEAM] = 'GREENTEAM|BLUETEAM';
teamName[REDTEAM|BLUETEAM] = 'REDTEAM|BLUETEAM';
teamName[REDTEAM|GREENTEAM|BLUETEAM] = 'REDTEAM|GREENTEAM|BLUETEAM';
teamName[REDTEAM|GREENTEAM|GRAYTEAM] = 'REDTEAM|GREENTEAM|GRAYTEAM';
teamName[GREENTEAM|BLUETEAM|GRAYTEAM] = 'GREENTEAM|BLUETEAM|GRAYTEAM';
teamName[REDTEAM|BLUETEAM|GRAYTEAM] = 'REDTEAM|BLUETEAM|GRAYTEAM';
teamName[REDTEAM|GREENTEAM|BLUETEAM|GRAYTEAM] = 'REDTEAM|GREENTEAM|BLUETEAM|GRAYTEAM';
teamHtmlColorName = [];
teamHtmlColorName[REDTEAM] = 'red';
teamHtmlColorName[GREENTEAM] = 'green';
teamHtmlColorName[BLUETEAM] = 'blue';
teamHtmlColorName[GRAYTEAM] = 'gray';


//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

//Returns the amount of free memory (bytes) in a browser tab. countFreeMem() 8588886016 8gB for example.
//This is a slow func. You have to fill it with a nonzero value so it actually gets allocated.
//"const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers." makes use of that if available.
const countFreeMem = ()=>{
	let arrays = [];
	let siz = 1<<20;
	while(true) try{
		arrays.push(new Uint8Array(siz).fill(arrays.length+1));
	}catch(e){
		return arrays.length*siz;
	}
};

//const DefaultIsLocal = true;
const DefaultNamespaceName = 'testnet';
/*wrap instead. const MinOy = 0x00000;
const MaxOy = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const MinOx = 0x00000;
const MaxOx = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const DefaultOy = MinOy; //TODO should this be in the middle of the space instead of its top left corner?
const DefaultOx = MinOx;
const DefaultGobOy = 1<<19; //approx the middle of a 1<<20 size space, approx cuz Size (1<<13) of it is reduced so the 8kX8k game.board must not hang off edge of the 1<<20.
const DefaultGobOx = 1<<19;
*/

//var DefaultSpawnY = 75800; //address space 0 to (2**18)-1. OLD: expanding address space to be 0 to (2**20)-1 in both Y and X.
//var DefaultSpawnX = 75500;
var DefaultSpawnY = 75000;
var DefaultSpawnX = 75000;
//var DefaultSpawnY = 505800; //expanding address space to be 0 to (2**20)-1 in both Y and X.
//var DefaultSpawnX = 505500;
//var DefaultSpawnY = 4000; //FIXME go back to 504000,504000 thats where some of the objects are put, near middle of the million X million
//var DefaultSpawnX = 4000;

/*2024-12-3+ Shrinking Blob Monsters Game to 256k X 256k canvas cuz of new kind of wall (vs open area) voxels.
Each fits in a float64 and is an integer from 2**16 to (2**53)-1. 0 is null. Each has a payload of 16 bits for 4x4,
scaled to any powOf2 size. Each has 37 bits of binheap address.
It can only display 8k X 8k at a time which is 64 megapixels, but it wraps. You get 1024 blocks of 64 megapixels each
so 64 gigapixels. 32 blocks wide and 32 blocks tall. Theres no loading time to move across them cuz it wraps.
My new kind of 53 bit voxels (that fit in a normal javascript number) will be useful for video compression,
can each define up to 68,719,476,736 pixels, of 1 bit color each (wall vs open area).
1x1 2x2 4x4 8x8 ... 131072x131072 262144x262144, and defines 4x4 squares inside that.
I'm literally going to use them to define walls vs open areas in the 262144x262144 pixel game area
in massively multiplayer, which cuz of this will allow the terrain shape to change during the game,
depending what kind of game rules it is. This is a kind of number, where every integer thats at least 65536, without limit
toward infinity, is a voxel. It just keeps getting bigger. You could use them as bigints, but I'm using float64s for speed.
*/
const MinY = 0;
//const MaxY = 0xfffff;
const MaxY = 0xffffff; //(2**24)-1 cuz Square, SquareY, SquareX, and SquareH funcs all use uint53 this way.
const MinX = 0;
//const MaxX = 0xfffff;
//const MaxX = 0x3ffff; //(2**18)-1
const MaxX = MaxY;

//var Game = function(optionalIsLocal, optionalNamespaceString, optionalY_uint20, optionalX_uint20){
//var Game = function(namespaceVar, optionalY_uint20, optionalX_uint20){
//gameVarInNamespaceVar is a Var whose name is "game" and which is a child of a namespace Var,
//var Game = function(gameVarInNamespaceVar, optionalY_uint20, optionalX_uint20){
//like V.testnet.game is in the namespace V.testnet. TODO V.testnet.game.Y.p and .x.p and .zoom.p etc.
var Game = function(gameVarInNamespaceVar){
	if(!(gameVarInNamespaceVar instanceof Var)) throw new Error('gameVarInNamespaceVar is not a Var: '+gameVarInNamespaceVar);
	this.bo = gameVarInNamespaceVar; //self var should always be named q?
	this.bo.ob = this; //Var.ob is Game or Gob or null
	//throw new Error('TODO some kind of variable recursion bloomtree considering its 2**40 pixels and we dont want to lockstep which causes lag across earths diameter is 42 light-milliseconds (and thats straight line distance in 3d so its more than that).');
	//TODO changing namespace, oy, and ox, should in theory connect you to different games across the world
	//and different 8kX8k 2d areas inside them, computed by whatever players are near that part of the game.
	//As this is opensource, anyone can create a namespace of any name they want, but if theres collisions
	//you'd join the existing game, in theory. You might generate this by a hash of the human readable rules of the game
	//or of a publicKey or just a random name you make up.
	//If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
	//As a turing complete constraint solver, it can only make constraints in the nearby few megapixels,
	//such as 8kX8k at the most, or probably will define a limit like the middle 6kX6k or middle 4kX4k of that,
	//where it just reads game state from network in the 1k-2k border around that
	//
	//this.ns = optionalNamespaceString || DefaultNamespace;
	//this.ns = namespaceVar || NS; //NS is the default namespace as a Var.
	//by default, run local game instead of on network. TODO this is not used as of 2024-11-16 and its been all local so far.
	//in theory, works with any namespace, even if you've already downloaded from it then switch this to local,
	//it means dont use ajax or img src=downloadFromUrl or iframe src=downloadFromUrl etc. No networking.
	//Should probably have a separate setting or value/level of this where ur running a localhost server that this ajaxes to
	//but which tells that server to not network outside the computer. but that would depend on your firewall cuz a server,
	//even if localhost, doesnt normally check where its coming from and it may be unreliable to verify,
	//at the most basic level. So this var game.isLocal should probably draw the line at allowing ajax or not, instead of that.
	//not using this as of 2024-11-18, had never used it: this.isLocal = optionalIsLocal!==undefined ? !!optionalIsLocal : DefaultIsLocal;
	//like 0x00000. global offset y, a uint20 which adds 7 bits to y in 32 bit voxels which have uint13 y, so a 1048576x1048576 game area sparsely.
	//wrap instead of: this.oy = optionalY_uint20!=undefined ? optionalY_uint20 : DefaultOy;
	//wrap instead of: this.ox = optionalX_uint20!==undefined ? optionalX_uint20 : DefaultOx; //like 0x00000. similar to oy but for x
	//2024-11-17 todo: Use game.oy and game.ox with gob.oy and gob.ox. The gob returns voxels whose 13 bit y and 13 bit x are relative to gob.oy and gob.ox.
	//If game.oy!=gob.oy andOr game.ox!=gob.ox, that creates complexity but can still be computed, TODO.
	//Depending on gob.oy and gob.ox, gob.brain(...(gob.vars)) should return only the voxels within some square centered on gob.oy gob.ox,
	//even if it could generate other voxels. This is basically a view rectangle that it should only display in that.
	//Im undecided if gob.oy and gob.ox should be allowed to be any integers in that range vs only on some tile size thats a powOf2.
	//if(Math.random()<.01) throw new Error('should every gob be required to have centerY and centerX Vars? that seems it would interfere with wall gobs having 0 params to mark that they dont need to be recomputed. But with centerY and centerX vars we could automaticly update gob.oy and gob.ox. Id like to but theres still the issue of rounding. Var.p (such as centerY.p) is a float64 and changes smoothly. If voxels are relative to that, theyd have to round/floor/ceil it (such as |0). I could make a func similar to YXC(y,x,color) that takes numbers bigger than the 8kX8k, relative to gob.oy gob.ox, but it would likely cost some speed. It seems the output format should change so that ints oy ox go with the int[numVoxels]. {oy: 323633, ox: 800000, ints: Int32Array(numVoxels)}, or could put oy and ox as fields in the Int32Array. I want things to appear in whole near the sides of the 8kX8k, and disappear when they cross out of it, so the size it can touch should be alot less than that. Maybe 2kX2k, since 4 of those wide can fit in 8k. they would partially overlap. I need some minimum space for interesting patterns to form. is 2kX2k enuf? If so, any 2kX2k that at all overlaps the middle 2kX2k must be included, and any 2kX2k that goes even slightly outside the current 8kX8k must be removed for sparsity. therefore i can mask it with 22 bits (11 of each 13 bits for y and x) so that it automatically only generates within some 2kX2k square. So AND it with 0b00111111111110011111111111111111. That will put it in 1 of the corners of the 8kX8k thats exactly 2kX2k. But how to offset it from there? and how to know what such ints to generate? Working on the million X million pixel addressing in Blob Monsters Game. It fits 8kX8k in RAM. If I limit each monster to a moving 2kX2k square, that it can only put voxels in that, then I could have these 2kX2k squares come in from the sides when they entirely fit in the 8kX8k. ... generalize that to powers of 2, so a wall gob could have a size of 64x64 for example, and its oy and ox be powOf2 aligned so they fit as tiles simply, and in the js code string include base64 of the compressed pic format BitPic/BloomTree that i use in dagball. ... it seems oy and ox would be the top left corner, so centerY.p and centerX.p are not the same (center vs top left), and need another o var like oshift. oy+(voxel&((1<<oshift)-1)) or something like that. but it would actually get optimized to just adding an int voxel to everything in the int voxels list, since an int voxel has 13 bits y 13 bits x 6 bits color. ... Find a way to make the whole game state, including interactive gobs and walls, be a vector where every dimension has position and velocity, including .influence (like in dagball.Circ.influence and dagball.Ball.influence) as a dimension but a lower precision one cuz its either on or off in Blob Monsters Game. When you edit a wall with circular paintbrush using 2 mouse buttons, one to paint wall and one to paint open area removing wall, that should navigate the vector space of possible game states. game.rps.distToPoten is 1024 ints (might switch to uint16s?). that should be 1024 dimensions. Theres various other params in game too, excluding the caches that can be derived from vector state of the game. A particular player viewing an area of the game at an x y zoom, that seems like vector dimensions. Where could ed25519 pubkeys controlling some monsters (a player controls a character in the game) be represented as vector of game state? Every dimension should have a Var instance, so theres some new Var instances to create. I should in theory be able to represent the vectors as a set of Var instances. But its not so simple, cuz theyre spread around various object types. Every Var should have a global id by hash, though these wont be copied thru network every time. Should a Var have an optional parent Var, which gob.influence would be such a Var for the whole gob, and gob.vars would be its childs? Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var. ... Vars are becoming a tree, like V/namespaceABC/monster567sHashId/heightToWidthRatio exists if V/namespaceABC/monster567sHashId has position 1, and does not exist if it has position 0. In theory, if u paint a small area of the huge game world with mouse, the thing you painted is a Var which contains that compressed pic data, and its name is the hash of that, and if its value/var.p/position is 1 then it exists and that displays, else doesnt display, across world. If u want to screw with it, just make up a new namespace like V/kj4w3e5q3ew45rtdsfg43534e5 u just make up a random string and copy the relevant parts into there in new Var objects, and explore variants of the global game state. multiverse vectors. ... ot sure where the tree of Var objects goes in the OSI Model of the internet, which is an attempt to map whats out there. I want 1 million simultaneous players, using turing-complete compression of voxel generating lambdas to game together. Experiment, turing completeness expands (SEE PIC "2024-11-17 where does the tree of Var objects fit into the OSI model.png"). most data will be transferred in filenames. file content is constant size, float64s for position velocity etc. Kinda like OpenCogs TruthValue but more limited, simpler, not well organized. But will stream hella fast from everywhere to everywhere. megabyte filenames shrink by hash. The tree of Var objects is a level below constraint solving, but levels above that, Blob Monsters Game does play as a game, not very fun yet, but it works by constraint solving among many millions of bits.');

	//(y,x) is a top left corner (UPDATE 2024-11-16: is it the center of the 8kX8k area, not top left?
	//i recently adjusted some code to do that somewhere in here),
	//that canvas would display. maybe its a 512x512 canvas, or whatever size.
	//board is 8192x8192 and has color and count at each pixel, so can display any of those.
	//its not using .y and .x as of 2024-11-9, always in top left corner of the 8k x 8k space.
	//this.y = Size>>1;
	//this.x = Size>>1;
	//this.y = (optionalY_uint20 || 0)&0xfffff; //now its 2**20 but 8192 in memory wrapped. OLD: since it wraps around 8192, it can start anywhere
	//this.x = (optionalX_uint20 || 0)&0xfffff;
	this.ns = this.bo.up;
	this.Y = this.bo.Y.if0(DefaultSpawnY); //FIXME make sure to call y.p (position of y) instead of just y, even though y's valueOf func slowly evals to y.p.
	this.X = this.bo.X.if0(DefaultSpawnX);
	
	//this.QuadLogLev = this.bo.QuadLogLev.setNow(1);
	this.QuadLogLev = this.bo.QuadLogLev.setNow(0); //0 is dont log. 1 is log. maybe will have multiple levels later.
	
	
	//this.Y.if0(Size/2); //FIXME fix the coordinate system, top left corner vs center, and Size X Size wrapping.
	//this.X.if0(Size/2);
	
	
	//this.zoom = 1; //changed by mouse wheel, how far you zoom in/out the view whose top left corner in game coords (0 to 8191) is this.y and this.x.
	//this.zoom = 5;
	this.zoom = this.bo.zoom.if0(5); //zoom.p
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.01);
	
	
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.03);
	//extremely increasing rpsAccelMul cuz added this code:
	//	let normedPredatorPoten = predatorPoten/voxels.length;
	//	let normedPreyPoten = preyPoten/voxels.length;
	//	gamePoten += rpsAccelMul*(normedPreyPoten-normedPredatorPoten);
	this.rpsAccelMul = this.bo.rpsAccelMul.if0(300);
	
	//do rock paper scissors?, using teams REDTEAM, BLUETEAM, GREENTEAM, and of course GRAYTEAM is neutral and not directly part of that
	this.doRps = this.bo.doRps.setNow(0); //off
	//this.doRps = this.bo.rpsAccelMul.setNow(1); //on
	console.log('Game.doRps.p='+this.doRps.p+' (1 to do Rock Paper Scissors with REDTEAM, BLUETEAM, GREENTEAM, 0 not to)');
	//TODO also (not just doRps) this.doYXRps which will be a simpler far more efficient kind of RPS, that just uses Y and X, not per voxel.
	//You would normally do doRps or doYXRps or neither, but technically you could do both.
	
	
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.3);
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.1);
	//this.rpsAccelMul.p = 0; //FIXME
	
	
	//the original, the linear counterpart of collideSqMul. Until 2024-11-25 it was all collideLinMul, then adding collideSqMul experimentally.
	//collideLinMul is like "L1 norm". collideSqMul is like "L2 norm". But its not a norm here.
	//FIXME i want 0 to be a valid value for this, but Var.if0 doesnt work that way. Maybe add Var.defaultP (find shorter name).
	this.collideLinMul = this.bo.collideLinMul.if0(1); //normal
	//this.collideLinMul.p = 0; //experimenting 2024-11-25 to use collideSqMul instead
	//this.collideLinMul = this.bo.collideLinMul.if0(.000000001); //experimental, near 0 but cant be 0 cuz incompatible with if0
	
	//Diff of game.poten between a gob being there or not, is squared and multiplied by this to compute actual poten,
	//or leave this as 0 to only use the linear poten (game.poten) directly which will happen either way by collideLinMul.
	//FIXME i want 0 to be a valid value for this, but Var.if0 doesnt work that way. Maybe add Var.defaultP (find shorter name).
	//this.collideSqMul = this.bo.collideSqMul.if0(.05);
	//this.collideSqMul = this.bo.collideSqMul.if0(.01);
	//this.collideSqMul = this.bo.collideSqMul.if0(.002);
	this.collideSqMul = this.bo.collideSqMul.if0(.01);
	//this.collideSqMul = this.bo.collideSqMul.if0(1);
	//this.collideSqMul.p = 0; //FIXME
	
	
	//this.collideSqMul = this.bo.collideSqMul.if0(.000000001); //near 0, basically no effect but cant be 0 cuz incompatible with if0
	this.board = new Uint32Array(Area); //26 bit count as high bits, 6 bit color as low bits.
	
	/*
	//Immutable 1 terapixel pic of walls vs opens.
	//TODO this is a WallQuad which is an immutable forkEditable compressed 1 terapixel 1-bit-per-pixel pic of WQWALL vs WQOPEN vs for sparsity WQFORK.
	//TODO if i choose this wall data structure design then code it in a big Int32Array where half the array
	//is literal bits and the other half is pairs of int pointers, and use it as a binary tree of sparse
	//powOf2 aligned squares of WQWALL vs WQOPEN vs WQTRAN.
	this.wal = null;
	*/
	
	this.wallDisplayDist = this.bo.wallDisplayDist.if0(Size*3/4); //normal
	
	/* 2024-12-22 ive decided to go with 128x128 Tile objects in a BigTile stored here,
	so Quad doesnt go here, its a BigTile which is mutable and contains tiles containing Quads,
	and Quad is used as immutable.
	*/
	this.wal = new BigTile(); //empty at first, see game.wal.tiles[square] contains a Tile.
	
	/*
	2024-12-16 ive decided to proceed with Quad, not more complex kind with isComplexFork. make terrain asap
	but todo bring in some of the features of the more advanced kind, like bits to say which of 4 childs are included,
	and maybe some of the symbols mean heights 0..24. Or maybe QTRANSPARENT being only 1 byte we dont need an optimization for it?
	Leave quad as it is and just start using it. Make game.wal be a Quad instance of whole 2**24 X 2**24 game area
	or whichever parts we know about.
	*/
	//this.wal = QuadTransparent;
	//this.wal = Todo('put Qtransparent here by default, whole game world 2 pow 24 by 2 pow 24');
	
	//wall binary, tells where the walls are, 1 bit per pixel.
	//16m slots that can each be a Int32Array(1<<11). If all were filled thats 2**40 bits. Sparse.
	//this.wab is filled as needed from this.wall which is the Bloomtree/Bitpic compressed pic data format from dagball,
	//always of size 2**40 pixels. Each pixel can be 10 meaning wall, 01 meaning open/nonwall,
	//or 00 meaning it does not make any statement about that (transparent),
	//in case you dont have data for parts of the million X million game area and dont want to assume.
	//In an Int32Array(1<<11), high 8 bits of index choose which of 256 y values / rows. Low 3 bits choose which of 8 ints.
	//Next 5 bits (not in the index) choose a bit in an int (todo endian?). 2048 ints are a 256 X 256 of 1 bit per wall vs nonwall.
	//First you choose which of 2**24 indexs in this.wab, which gives you either null or a Int32Array(1<<11).
	//If its null, recurse in this.wal to create it.
	//If this.wal changes, set those parts to null here. In the worst case, thats setting 16m things to null,
	//but usually it will be at most at 16k X 16k area so 4096 of these,
	//which is 2x2 times bigger than the 8kX8k which would be in the middle of that, or some similar size, so this seems practical for those uses,
	//which will happen by having a prev and next this.wal which are both immutable, and diffing them to know what to set to null in this.wab.
	//2024-12-16 nevermind this; this.wab = new Array(1<<24);
	
	//this.wal = new Array(1<<20); //1024x1024 of WallTile which is each sparse 1024x1024 pixels.
	//this.wall.fill(null);
	//potentialEnergy, which is sum of max(0,countAtPixel-1) forall pixels.
	//maybe add a squaring of that later? or is linear good enuf cuz usually its just 0, 1, or 2 count?
	//This changes when you add or remove a voxel.
	this.poten = 0;
	this.gobs = [];
	//this.maxSpeed = this.bo.maxSpeed.if0(1000);
	//max angled Y X speed per Var. 2024-11-23 its getting way too big (500 sometimes) when gob.setExists(true) comes back during game.sparseUpdate().
	//this.maxSpeed = this.bo.maxSpeed.if0(10);
	//this.maxSpeed = this.bo.maxSpeed.if0(100);
	//this.maxSpeed = this.bo.maxSpeed.if0(1000);
	this.maxSpeed = this.bo.maxSpeed.if0(10000);
	//max gradient per Var. 2024-11-23 its getting way too big (20k sometimes) when gob.setExists(true) comes back during game.sparseUpdate().
	//this.maxGr = this.bo.maxSpeed.if0(100);
	//this.maxGr = this.bo.maxGr.if0(1000); //normal
	//this.maxGr = this.bo.maxGr.if0(1000000000); //FIXME
	this.maxGr = this.bo.maxGr.if0(1000000); //FIXME
	this.rps = {
		//rock paper scissors. these are big arrays, 256mB each, same size as game.board,
		//that each contain distanceSquared at each pixel, to the nearest voxel of the R/red G/green or B/blue team.
		//They should be updated sparsely using computeSquaredDistances, such as a 512x512 area near where things are changing,
		//but dont use the whole 512x512, leave some area around the edges so its more accurate.
		//Maybe later we will expand this to be always accurate everywhere, but thats for research into the sparse updates.
		//game.board is always accurate in the whole 8k x 8k area, but rps is a more expensive calculation.
		//The 512x512 or 1024x1024 or 128x128 etc that computeSquaredDistances makes is exact
		//(TODO fix bugs, it shouldnt have a Float32Array, which may make it inexact) but if the actual game world is partly outside
		//it, then it wouldnt be exact, but would be closer to accurate maybe in the 700x700 in the middle of a 1024x1024 for example.
		//boardR: newRpsArray(), //distanceSquared from each pixel to nearest voxel on red team
		//boardG: newRpsArray(), //to green team
		//boardB: newRpsArray(), //to blue team
		//tridist: newRpsArray(), //use computeUint10Distances
		tridistSmall: new Int32Array(SmallArea).fill(TRINF), //use computeUint10Distances in 4x4 smaller 2d array than this.board
		
		//team (BLACKTEAM, REDTEAM, GREENTEAM, or BLUETEAM, and todo GRAYTEAM is neutral for walls and shields,
		//maybe other teams later). no need to .fill(BLACKTEAM) cuz BLACKTEAM==0.
		//store the number of voxels of each team which touches each pixel, as 1 bit. It only measures if the number of your team's voxels
		//there is even or odd. But hopefully this will be good enuf cuz it only takes 1 such collision, between all pairs of voxels.
		/*In Blob Monsters Game, I store number of voxels of each team which touches each pixel, as 1 bit. Only measures even odd.
		It has to be reversible. If I was to expand it to full count, that would be 3 ints instead of 3 bits that fit in 1 byte.
		U can make monsters that dont collide (in team changing by rock paper scissors, but they still collide in game.poten so repel).
		This could be defended against by sorting then deduping voxels returned by a "blob monster" (Gob). I cud do it in constant
		time using the VoxStream class which is 1 bit per pixel for 64 megapixels and is a reversible stack and set of voxels for
		deduping. Dont wanna pay for that.
		*/
		team: new Uint8Array(Area),
		//teamSmall: new Uint8Array(SmallArea),
		
		//how fast do gobs accelerate based on game.rps.tridistSmall, by multiplying the chance in
		//potential energy (poten) from that by this. Set to 0 to not react to the glowing colors.
		//Since game.rps.distToPoten is int32s (or TODO uint16s?), which is required so potentialEnergy is exactly reversible without roundoff,
		//game.rps.accelMul has to be small to balance that. FIXME should accelMul have to be a powOf2, a negative power? Even if so,
		//that could break the potential energy calculation. but maybe it will be ok as long as its not the collisions thing in game.board vs game.poten?
		//accelMul: .0000000000000001,
		//accelMul: 0,//.0001,
		//accelMul: 1,
		//accelMul: .1,
		//accelMul: .01,
		//cant do this cuz Var.accelMul. TODO make a list of fields that dont get auto created as Var childs. Moving this to game.rpsAccelMul. accelMul: this.bo.rps.accelMul.if0(.01),
		//accelMul: .3,
		//can differ across different Games, peer to peer nets, etc.
		//for every possible uint10 distance, add accelMul*distToPoten[dist] to poten,
		//so predator chases prey which runs from predator. See predatorOf and preyOf functions.
		distToPoten: (()=>{ //TODO put this in as 1 or 1024 Vars?
			/*GPT4 says newtonian gravity, so basically just make it proportional to 1/dist plus.
			function gravitationalPotentialEnergy(m1, m2, r) {
				const G = 6.67430e-11; // Gravitational constant in m^3 kg^-1 s^-2
				return -G * m1 * m2 / r;
			}*/
			let distToPoten = new Int32Array(1024); //TODO to not take up too much of CPU L1 cache, maybe this should be a Uint16Array?
			for(let dist=0; dist<1024; dist++){
				//TODO like newtonian gravity, cuz see rock paper scissors video in dagball. distToPoten[dist] = ((2**30)/(dist+1))|0;
				//distToPoten[dist] = dist; //FIXME
				
				//"distToPoten[dist] = Math.min(dist,1019);" sometimes or partially fixes bug 2024-11-25-1p_rpsAccelMul_isInterferingWith_collideSqMul which
				//was caused by using multiple constants for max distance, those constants being 1019 and 1023.
				//distToPoten[dist] = Math.min(dist,1019);
				//distToPoten[dist] = Math.min(dist,900); //FIXME this is way too big a flat area at the end.
				distToPoten[dist] = Math.min(dist,980); //FIXME this is way too big a flat area at the end.
				//distToPoten[dist] = Math.min(dist,700); //FIXME this is way too big a flat area at the end.
			}
			return distToPoten;
		})(),
	};
	this.stats = {
		fpsVal: 60,
	};
	this.logMap = {
		FPS: ()=>this.stats.fpsVal,
	};
	//dont allow Math.random, but since its not in the whitelist...
	this.allowedClassDotFuncs = new Set(DefaultAllowedClassDotFuncs);
};

var lastTouchOrder = 0;

//Returns 1 if wall, 0 if not. y and x each range 0 to 0xfffff. Its sparse using this.wal (WallQuad)
//and this.wab (1d array used as 4096x4096 of null or 256x256 BitPic, todo put bitPic.touchOrder = ++lastTouchOrder;).
Game.prototype.wallAtYX = function(y, x){
	Err('use tileHeight and the 128x128 tiles, a BigTile instance, that maybe goes in this.wal, not a WallTile instance which is older class.');
	//return this.wal.get(y,x)==WQWALL; //is WQWALL, WQOPEN, or WQTRAN.
};

Game.prototype.shouldDisplayTile = function(tile){
	return tile.yxDist(this.Y.p,this.X.p) <= this.wallDisplayDist.p;
};

/*//4 child indexs in WallQuad.childs
const WQUPLEFT = 0;
const WQUPRIGHT = 1;
const WQDOWNLEFT = 2;
const WQDOWNRIGHT = 3;
*/

//constants for indexs in WallQuad.childs and for each uint2 in the base64 compressed form.
const WQTRAN = 0b00;
const WQOPEN = 0b01;
const WQWALL = 0b10;
const WQFORK = 0b11;
//const WQMaxHeight = 40;

/*throw new Error(`monstPaintableWallsVsOpenAreaLikeInDagball_mustSaveIntoWorldStateJsonFileAlongWithGobBrainsAndPositionsAndVelocitiesEtc
It cant be done efficiently in game.board, which has a uint26 count per pixel, cuz when it scrolls in the terapixel space, it would have to be copied, and its too much memory to do that fast. So the data structure has to be separate for walls. Make it 1 bit per pixel in small areas, base64 BloomTree/BitPic compressed  before expanding to such small areas. Maybe make 2**24 areas of 256x256, thats a single 2**40 pixel immutable BloomTree stored in game.wal as the top WallQuad. Yes, do that. Store only the base64 string form compressed as big or small as it needs to be, but always do the expanded dense form as 256x256 blocks. If the whole million X million game area is all wall or all nonwall, that only takes 1 char to store, and dont pad it since the bloomtree/bitpic datastruct can detect when its done at a certain bit index.
`);*/

//Immutable. To efficiently navigate this in a mutable way, use new WallNav(wallQuad, 0).
//see Game.wal which is a 4096x4096 array (1d used as 2d) of nulls that can become BitPics that are from wallQuad.bitpic.
//
//OLD...
//
//TODO Each WallTile is stored as compressed by the Bitpic/Bloomtree code in dagball
//which is good pic compression for 1 bit color with transparency.
//11 means fork 2x2. 10 means wall. 01 means nonwall/openArea. 00 means transparent/unspecified.
//It compressions to a size proportional to the total curve lengths of the borders between wall and nonwall.
//You'll find examples of these base64 data structures in https://github.com/benrayfield/DagBall/tree/main/saves like this //{"type":"dagball_bitpic","wallPoten":50,"wallThick":5,"height":1024,"width":1024,"bloomtree":"/7q7q6u6m5W7vqVe5XmVv5l5lflVW7 (base64 continues...).
//If its all wall or all nonwall, that would be just 2 bits, so plus padding that would probably be 4 chars. That one ended with "qq91raqqqqgA==".
//tileIndex ranges 0 to 0xfffff, high 10 bits of y, low 10 bits of x, then inside that use the base64 for sparse bits in 1024x1024.
//TODO hook this into the V/Var tree, where Var.big contains tileIndex and this base64, maybe as a string of json,
//or maybe tileIndex should be part of the base64 as it can specify that in 10 recursions, leaving 3 out of each 4 as transparent/00,
//and when it zooms in far enuf (from 2**20 X 2**20 zoom in to a 2**10 X 2**10).
//Lets do that. Get rid of the game.wal array and make that val be an immutable WallQuad.
//WallQuad is immutable, so you modify it by forkEdit only.
//Use data OR childs but not both. WallQuad is a quadtree.
//var WallQuad = function(height, stringDataOrFourChilds){
var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr){
	throw new Error('As of 2024-12-11 WallQuad was never finished and Quad, which is a more efficient design, is proceeding instead');
	//256x256 bit cache of this WallQuad if this.height==8, created as needed.
	//This can be reused in game.wab[((12 high bits of y)<<12)|(12 high bits of x)]
	this.bitpic = null;
	this.height = Math.max(0, Math.min(height|0, 20)); //height 0 is a single pixel in the 2**20 X 2**20 space. Height 20 is the whole space.
	this.base64 = optionalBase64!==undefined ? optionalBase64 : null;
	//could instead be WQOPEN, WQWALL, or WQTRAN, a giant pixel of squareSide==(1<<this.height).
	//If this.base64 is a string (compressed pic), this must be the first uint2 in it. TODO is that the low 2 bits or high 2 bits of the first 6 bit char?
	//this.val = val&3; //this.val = WQFORK;
	if(optionalVal === undefined){
		if(this.base64 == null){
			this.val = WQTRAN; //transparent/unspecified, since they didnt give base64 of compressed pic or uint2 val.
		}else{
			if(this.base64.length > 4){
				//cuz firstUint2InBase64 isnt working yet (2024-12-1) and its gotta be WQFORK if it has childs. The base64 comes in blocks
				//of 4 chars that means 3 bytes. The 4 chars are padded with = if needed. So smallest base64 in this system is 4 chars.
				//Even if height is big, there could still be a leaf uint2 here (WQTRAN, WQOPEN, WQWALL) if the base64 is size 4
				//or if base64 is not given but val is given.
				this.val = WQFORK;
			}else{
				this.val = firstUint2InBase64(this.base64);
			}
		}
		//this.val = optionalVal!==undefined ? (optionalVal&3) : 
	}else{
		this.val = optionalVal&3; //TODO if base64
	}
	this.ul = optionalUl || null; //up left child in 2x2 quadtree
	this.ur = optionalUr || null; //up right
	this.dl = optionalDl || null; //down left
	this.dr = optionalDr || null; //down right
	//this.isLeaf = !ul;
	/*if(typeof(stringDataOrFourChilds) == 'string'){
		this.base64 = stringDataOrFourChilds;
		this.childs = [];
		//this.height = 10; //FIXME should it always be 10 aka 1024X1024 aka 2**10 X 2**10?
		//this.walls = FIXME; //range 0 (inclusive) to 2**40 (inclusive), so need 41 bits to store this. That fits in a float64.
		//this.opens = FIXME; //range 0 (inclusive) to 2**40 (inclusive)
		this.walls = 0; //FIXME
		this.opens = 0; //FIXME
		this.trans = 0; //FIXME
		if(this.trans != 0){
			throw new Error('at this leaf, it must be all WQWALL or WQOPEN (and of course WQFORK for inner nodes in the base64)');
		}
	}else{
		this.base64 = '';
		this.childs = stringDataOrFourChilds;
		if(this.childs.length != 4){
			throw new Error('Must be 4 childs');
		}
		this.walls = this.childs[0].walls + this.childs[1].walls + this.childs[2].walls + this.childs[3].walls;
		this.opens = this.childs[0].opens + this.childs[1].opens + this.childs[2].opens + this.childs[3].opens;
		this.trans = this.childs[0].trans + this.childs[1].trans + this.childs[2].trans + this.childs[3].trans;
		let total = this.walls+this.opens+this.trans;
		if(total != (2**this.height)){
			throw new Error('total != (2**this.height), walls='+this.walls+' opens='+this.opens+' trans='+this.trans+' height='+this.height);
		}
	}*/
};
/*var WallTile = function(tileIndex, base64){
	this.tileIndex = tileIndex;
	this.base64 = base64;
};*/
//WallQuad.prototype.
//WallTile.prototype. = function(tileIndex, base64){
//var WallTile = function(base64)

//Mutable. Navigates through a WallQuad tree, including WallQuad objects and pointers into WallQuad.base64
//in units of 2 bits so 3 of those per char (last few chars each have 1 or 0 of those. = is char that has 0).
//i is 0 if there is no wq.base64, and it means WQFORK. This can go into any of the 4 childs,
//whether its a WallQuad or changing this.i to point at a child in that same string.
//When you navigate from a WallQuad to one of its childs and that child is another WallQuad, replaces this.WallNav.
//
//Instead of OLD[[this.i is added to wq.i in case wq is a view of somewhere inside wq.base64]],
//should this.i start at wq.i?
//
//which can be caused by making a new WallQuad from 4 WallNavs in a way that reuses existing base64 strings
//since those strings can get big enuf that their memory matters when theres a million of them or so.
//There will be millions of them sometimes in game.wab, and the root WallQuad is in game.wal.
var WallNav = function(wq, i){
	this.wq = wq;
	this.i = i;
};

//gets WQTRAN, WQOPEN, WQWALL, or WQFORK.
WallNav.prototype.val = function(){
	Todo();
};

/*WallNav.prototype.isLeaf = function(){
	return this.val()!=WQFORK;
};*/

//modify self to point at the up left child of what self was pointing at.
WallNav.prototype.ul = function(){
	Todo();
};

WallNav.prototype.ur = function(){ //up right child
	Todo();
};

WallNav.prototype.dl = function(){ //down left child
	Todo();
};

WallNav.prototype.dr = function(){ //down right child
	Todo();
};

//set union of wall pixels
WallQuad.prototype.or = function(wq){
	throw new Error('TODO');
};

//set intersection of wall pixels
WallQuad.prototype.and = function(wq){
	throw new Error('TODO');
};

var byteArrayRange = (byteArray, start, end)=>{
	if(start == 0 && end == byteArray.length) return byteArray;
	if (start < 0 || end > byteArray.length || start > end) {
		throw new Error("Invalid start or end index");
	}
	return new Uint8Array(byteArray.buffer, byteArray.byteOffset + start, end - start);
};

Quad.prototype.bytesToBase64 = function(){
	return dagball.bytesToBase64(byteArrayRange(this.B, this.i, this.length));
};

//content of this tile to hash to make a Var.big string which Var.name is made from,
//and 'mutid$tile34534534543$' etc goes before it, the number being the Square uint53.
Tile.prototype.contentToHash = function(){
	this.syncSparseDense();
	return this.sparse.bytesToBase64();
};

//Like in dagball, a mutid is any arbitrary short name (no whitespace etc)
//that there can be at most 1 instance of per namespace at a time, so if you edit it,
//it automatically replaces older versions with the same mutid, a mutable variable.
Tile.prototype.mutid = function(){
	return 'tile'+this.square;
};

//Tile is mutable and its content can change based on painting wall/open and 64 colors in it,
//so which Var it is can change. Its mutid wont change, but the hash after it will.
//This is an expensive calculation cuz hashes the pic content every time. todo cache the Var until changes?
Tile.prototype.toVar = function(){
	this.syncSparseDense();
	let quad = this.sparse;
	if(!quad) Err('no quad');
	//return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(sha256(byteArrayRange(this.B, this.i, this.length)))];
	//Err('need to modify Var so when get from it some content it auto generates the mutid prefix. put that prefix in the content');
	//return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(byteArrayRange(quad.B, quad.i, quad.length))]; //todo make it grab the mutid from the prefix
	return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(quad.getBytes())];
	
};

dagball.bytesToBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

dagball.base64ToBytes = base64=>{ //returns Uint8Array
	const binaryString = atob(base64);
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
};

//set this.bitpic to a 256x256 instance of dagball.BitPic, normally when this.height==8 and it doesnt already have this.bitpic
WallQuad.prototype.makeBitpic = function(){
	if(this.base64 == null){ //in case its all WQTRAN which is 0b00, cant use if(this.base64).
		Err('No base64');
	}
	//let bytes = (typeof(base64StringOrBytes)=='string') ? dagball.base64ToBytes(this.base64) : base64StringOrBytes;
	let bytes = dagball.base64ToBytes(this.base64);
	let bloomtree = new dagball.BloomTree(bytes);
	let squareSide = 1<<this.height;
	let area = squareSide**2;
	//let area = (1<<(this.height<<1));
	let wallPoten = DefaultBitPicWallPoten;
	let wallThick = DefaultBitPicWallThick;
	let aftrans = null; //FIXME? thats from dagball. we use game.Y.p, game.X.p, and game.zoom.p instead.
	let bitpic = new dagball.BitPic(wallPoten, wallThick, squareSide, squareSide, bytes, aftrans);
	bloomtree.paintOntoBitPic(bitpic);
	return this.bitpic = bitpic;
};

var DefaultBitPicWallPoten = 50; //FIXME
var DefaultBitPicWallThick = 5; //FIXME

/*
//heights 0..20 inclusive. (height<<2)|uint2, so if its a smallest pixel then its just the uint2 cuz height is 0.
const onePixelWallQuad = [];
for(let height=0; height<=20; height++) for(let uint2=0; uint2<4; uint2++){
	onePixelWallQuad[(height<<2)|uint2] = new WallQuad(height, null, uint2);
}*/

//Makes a base64 for a WallQuad of the given height, by calling hyxToUint2(height,y,x) -> WQTRAN or WQOPEN or WQWALL,
//where y and x each range 0 to (1<<height)-1. yFrom and xFrom are only used as offsets in params of yxToUint2.
//Default height for making base64 is 8 so is 256x256. Sparse pic goes up to height 20.
var funcToBase64Walls = function(hyxToUint2, optionalHeight, optionalYFrom, optionalXFrom){
	let height = optionalHeight!==undefined ? optionalHeight : 8; //
	let yFrom = optionalYFrom!==undefined ? optionalYFrom&SizeMask : 0;
	let xFrom = optionalXFrom!==undefined ? optionalXFrom&SizeMask : 0;
	let squareSide = 1<<height;
	let area = squareSide**2;
	let wallPoten = DefaultBitPicWallPoten; //FIXME
	let wallThick = DefaultBitPicWallThick; //FIXME
	let aftrans = null; //FIXME? thats from dagball. we use game.Y.p, game.X.p, and game.zoom.p instead.
	let bitpic = new dagball.BitPic(wallPoten, wallThick, squareSide, squareSide, bytes, aftrans);
	let yTo = yFrom+squareSide;
	let xTo = xFrom+squareSide;
	for(let dy=0; dy<squareSide; dy++){
		for(let dx=0; dx<squareSide; dx++){
			let uint2 = yxToUint2(height, yFrom+dy, xFrom+dx);
			bitpic.writeYXRaw(dy, dx, (uint2==WQWALL)?1:0)
		}
	}
	let bloomtree = bitpic.toBloomTree();
	return dagball.bytesToBase64(bloomtree.bytes);
};

var randomWallQuad256x256 = fractionWall=>(
	new WallQuad(8, funcToBase64Walls((y,x)=>(Math.random()<fractionWall ? WQWALL : WQOPEN))));

//WallQuad is a tree. Starts hyxToUint2 at the top of tree (1 terapixel) and recurses it wherever it says WQFORK.
//Creates 256x256 BitPic then converts to compressed base64 to make the wallquad
//(FIXME make funcToBase64Walls return the BitPic too for WallQuad.bitpic as cache?)
//but only at height 8 or less (128x128 at height 7, 4x4 at height 2, and uses onePixelWallQuad if gets that low),
//but should end at height 8 (256x256). If you start it below height 8, it will do that, else it chooses 8 as the limit.
//May ignore hyxToUint2 at heights 1..7, which would normally be WQFORK, and go straight to height 0 and call it
//256x256 times to make a height 8 WallQuad containing that generated compressed base64.
//Func hyxToUint2 takes height, y, x, where y and x are powOf2 aligned, normally starting at height 20 (terapixel).
//hyxToUint2(y,x,height) -> [[WQTRAN or WQOPEN or WQWALL] to end recursion] or [WQFORK to recurse]. Must not recurse at height 0.
//optionalHeight defaults to 20, the 2**20 X 2**20 terapixel game size.
//
var funcToWallQuad = (hyxToUint2, optionalHeight, optionalYFrom, optionalXFrom)=>{
	let height = optionalHeight!==undefined ? optionalHeight : 20;
	let yFrom = optionalYFrom!==undefined ? optionalYFrom&SizeMask : 0;
	let xFrom = optionalXFrom!==undefined ? optionalXFrom&SizeMask : 0;
	if(height < 0 || 20 < height || (height|0)!=height){
		Err('height='+height);
	}
	let uint2 = hyxToUint2(height, yFrom, xFrom);
	if(height == 0){
		return onePixelWallQuad[uint2];
	}else if(height <= 8){
		//make BitPic then base64 from it, of squareSide (1<<height).
		let base64 = funcToBase64Walls(hyxToUint2, height, yFrom, xFrom);
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(height, base64);
	}
};

/* Replacing get with hyx cuz hyx is more general as it can get internal tree nodes too.
//returns WQTRAN or WQOPEN or WQWALL (each is 2 bits) if in range, else (TODO?) throws cuz out of range.
//Y and x each range 0 to (1<<this.height)-1 which is at the most 0xfffff.
//returns 10 if WQWALL, 01 if WQOPEN, 00 if transparent/unspecified. Wont return 11/WQFORK cuz would recurse.
//WallQuad.prototype.bbAtYX = function(y, x){
//};
WallQuad.prototype.get = function(y,x){
	if(this.bitpic || (this.height==8 && this.makeBitpic())){
		return this.bitpic.readBit(((y&0xff)<<8)|(x&0xff)) ? WQWALL : WQOPEN;
	}else if(this.height > 8){
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.ul.get(y,x);
			}else{
				return this.ur.get(y,x-halfSize);
			}
		}else{
			if(x < halfSize){
				return this.dl.get(y-halfSize,x);
			}else{
				return this.dr.get(y-halfSize,x-halfSize);
			}
		}
	}else{
		Err('Dont call WallQuad.get where the WallQuad.height < 8 cuz at 8 we expand the cache to a 256x256 bit BitPic');
	}
};*/
//
//
//get uint2 at height, y, x. Height ranges 0 to this.height inclusive. y and x range 0 to (1<<this.height)-1 inclusive.
WallQuad.prototype.hyx = function(height, y, x){
	if(this.val !== WQFORK){
		return this.val;
	}else if(this.bitpic){
		return this.bitpic.readBit(((y&0xff)<<8)|(x&0xff)) ? WQWALL : WQOPEN;
	}else if(this.height <= 8){ //should use compressed base64 pic, to generate BitPic
		//there should never be a bitpic in a parent and in a child or any child reachable.
		//1 level only, normally always at height 8 as that makes 256x256, which up to 2**24=16777216 of can go in game.wab sparsely.
		this.makeBitpic();
		return this.hyx(height,y,x);
	}else{ //higher than 8 so should be a tree
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.ul.hyx(height-1,y,x);
			}else{
				return this.ur.hyx(height-1,y,x-halfSize);
			}
		}else{
			if(x < halfSize){
				return this.dl.hyx(height-1,y-halfSize,x);
			}else{
				return this.dr.hyx(height-1,y-halfSize,x-halfSize);
			}
		}
	}
};

//WallQuad is used as immutable, so this forkEdits to return another WallQuad with the given wq WallQuad's
//top left corner at y x, but y x must be powOf2 aligned to wq.height.
WallQuad.prototype.putYXWq = function(y, x, wq){
	if(wq.height == this.height){
		return wq; //since its immutable, reuse it as completely overwriting this WallQuad by forkEdit. Both still exist.
	}else if(wq.height < this.height){
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.setUl(ul.put(y,x,wq));
			}else{
				return this.setUr(this.ur.put(y,x-halfSize,wq));
			}
		}else{
			if(x < halfSize){
				return this.setDl(this.dl.put(y-halfSize,x,wq));
			}else{
				return this.setDr(this.dr.put(y-halfSize,x-halfSize,wq));
			}
		}
	}else{
		Err('wq is bigger (height '+wq.height+') than this WallQuad (height '+this.height+')');
	}
};

//forkEdits this to return new WallQuad, unless this.ul already === ul.
//FIXME check if all 4 childs are leaf uint2s, and merge them if so.
WallQuad.prototype.setUl = function(ul){
	if(this.ul === ul){
		return this;
	}else if(this.base64 != null){
		Todo();
	}else{
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(this.height, null, WQFORK, ul, this.ur, this.dl, this.dr);
	}
};

WallQuad.prototype.setChilds = function(ul, ur, dl, dr){
	if(this.ul === ul){
		return this;
	}else if(this.base64 != null){
		Todo();
	}else{
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(this.height, null, WQFORK, ul, ur, dl, dr);
	}
};

//for dedup. key is wallQuad.base64, val is that wallQuad.
//Used where alsoDedupBase64 is true in WallQuad.prototype.dedup = function(alsoDedupBase64)
//var mapBase64ToWallQuad = {};
//TODO make hash ids using sha256 of some combo of height and base64, or of height and the 4 childs.
//See WallQuad.prototype.toString and make a variant of that which returns the whole string to be hashed,
//or maybe use a normed json of it like in Dagverse.js/DV but dagverse has too much

//If all 4 childs, each deduped by this func, are leaf uint2s (not WQFORK) and are the same uint2, then that uint2
//replaces this WallQuad. Returns either this WallQuad or a forkEdited one, with the same content but possibly uses less memory.
//Warning: deduping by 
WallQuad.prototype.dedup = function(alsoDedupBase64){
	if((alsoDedupBase64 && this.isDeduped_alsoDedupBase64) || (!alsoDedupBase64 && this.isDeduped_not_alsoDedupBase64)){
		return this;
	}
	if(alsoDedupBase64){
		Todo('alsoDedupBase64, see comments: TODO make hash ids using sha256 of some combo of height and base64, or of height and the 4 childs');
	}
	let ret;
	if(this.val == WQFORK){
		let dedupedUl = this.ul.dedup(alsoDedupBase64);
		let dedupedUr = this.ur.dedup(alsoDedupBase64);
		let dedupedDl = this.dl.dedup(alsoDedupBase64);
		let dedupedDr = this.dr.dedup(alsoDedupBase64);
		let anyChildsChanged = this.ul!==dedupedUl || this.ur!==dedupedUr || this.dl!==dedupedDl || this.dr!==dedupedDer;
		let v = dedupedUl.val;
		if(v === WQFORK){
			ret = anyChildsChanged ?
				new WallQuad(this.height, null, WQFORK, dedupedUl, dedupedUr, dedupedDl, dedupedDr) : this;
			//mark this as deduped (in 1 of 2 ways depending on alsoDedupBase64) and return this
			if(alsoDedupBase64){
				ret.isDeduped_alsoDedupBase64 = true;
			}else{
				ret.isDeduped_not_alsoDedupBase64 = true;
			}
			return ret;
		}else{
			let childsAreAllSameUint2 = v===dedupedUr.val && v===dedupedDl.val && v===dedupedDr.val;
			ret = childsAreAllSameUint2 ? onePixelWallQuad[(this.height<<2)|v] : Todo('still need to check anyChildsChanged, merge that code');
		}
		return ret;
	}else{
		return onePixelWallQuad[this.val];
	}
};

const uint2ToChar = [];
uint2ToChar[WQTRAN] = 't';
uint2ToChar[WQOPEN] = 'o';
uint2ToChar[WQWALL] = 'w';
uint2ToChar[WQFORK] = 'f';

WallQuad.prototype.toString = function(){
	if(this.height == 0){
		return uint2ToChar[this.val];
	}else if(this.base64 != null){
		if(this.base64.length > 50){
			return 'wqPart$h'+this.height+'$'+this.base64.substring(0,20)+'..len'+this.base64.length+'..'+this.base64.substring(this.base64.length-20);
		}else{
			return 'wq$h'+this.height+'$'+this.base64;
		}
	}else{
		return 'wq$h'+this.height;
	}
};

/*
//WallQuad is used as immutable, so this forkEdits to return another WallQuad that reuses
//all branches not changed, with val&3 set at a pixel. OptionalHeight defaults to 0 aka single pixel
//or you can give it at a height 0..40 inclusive to overwrite whatevers there with a powOf2 size square.
WallQuad.prototype.put = function(y, x, val, optionalHeight){
	let putHeight = optionalHeight|0;
	if(this.height <= putHeight){
		Todo('return a new WallQuad of 1 giant pixel that is val, at putHeight');
	}else{
		
	}
	Todo();
};*/

//makes a WallQuad thats WQWALL or WQOPEN at the given circle and is WQTRAN everywhere else.
//You make this when painting or erasing a circle area with mouse to modify game.wab (tree)
//which then modifies game.wal (grid) by the diff between previous and next game.wal,
//considering that WQTRAN is unspecified/transparent areas. Uses squareCirc in recursion.
const wqCirc = ()=>{
	Todo();
};

//return 1 if circle is completely outside circle, -1 if completely inside, or 0 if its part inside part outside.
//TODO choose what behaviors I want for if its exactly on the line as in <= vs <.
const squareCirc = (squareMinY, squareMinX, squareSide, circleY, circleX, radius) => {
	const squareMaxY = squareMinY + squareSide;
	const squareMaxX = squareMinX + squareSide;
	if(squareMaxX < circleX - radius || squareMinX > circleX + radius ||
			squareMaxY < circleY - radius || squareMinY > circleY + radius){ //fast check before squaring
		return 1; // Square is completely outside the circle
	}
	const radiusSquared = radius * radius;
	const dx1 = (squareMinX - circleX)**2;
	const dx2 = (squareMaxX - circleX)**2;
	const dy1 = (squareMinY - circleY)**2;
	const dy2 = (squareMaxY - circleY)**2;
	if(	dx1 + dy1 > radiusSquared || //Top-left corner
		dx2 + dy1 > radiusSquared || //Top-right corner
		dx1 + dy2 > radiusSquared || //Bottom-left corner
		dx2 + dy2 > radiusSquared) { //Bottom-right corner
		return 0; // Square is partly inside, partly outside
	}
	return -1; // All corners are inside the circle
};


var setDifference = function(setA, setB){
	return new Set([...setA].filter(x => !setB.has(x)));
};


//FIXME 2024-11-20 this is making either all the gobs or none of them appear, depending on if move past around maxDistance.
//Replaces this.gobs which is a [] list of Gob instances, those near this.y.p this.x.p
Game.prototype.sparseUpdate = function(){
	//return; //cuz is broken.
	//console.log('FIXME game.sparseUpdate gotta deal with game.gobs list, that no Gob has ever been removed from that as of 2024-11-20, and this might be a good time to use quadtree or redesign that?');
	let myNamespace = this.bo.up;
	//let maxDistance = 500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 2000; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 3500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 4500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 24500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	let y = this.Y.p, x = this.X.p;
	//y += Size>>1; //FIXME fix the coordinate system, top left corner vs center. Shouldnt have to add Size/2.
	//x += Size>>1;
	let maxDistance = Size/2;
	
	
	//compute objects that are near mouse, instead of center view.
	y = mouse.y();
	x = mouse.x();
	
	let newGobs = myNamespace.searchYXRGoal(y, x, maxDistance, gobVar=>{
		return gobVar !== this.bo;
	}).map(gobVar=>gobVar.getOb()); //getOb returns a Gob, reuses it if exists
	if(!newGobs.includes(mouse)) newGobs.push(mouse); //always include mouse gob
	//if(!newGobs.includes(cShapedGob)) newGobs.push(cShapedGob); //always include	cShapedGob, for testing. FIXME remove this.
	let newGobsSet = new Set(newGobs);
	let oldGobsSet = new Set(this.gobs);
	let gobsToAddSet = setDifference(newGobsSet,oldGobsSet);
	let gobsToRemoveSet = setDifference(oldGobsSet,newGobsSet);
	for(let gob of gobsToAddSet){
		//gob.setGameVoxs(gob.think());
		gob.setExists(true); //FIXME linear cost of game.gobs.length
	}
	for(let gob of gobsToRemoveSet){
		//gob.setGameVoxs(null); //modifies game.board and game.rps.team but not game.rps.tridistSmall cuz thats an expensive calculation.
		gob.setExists(false); //FIXME linear cost of game.gobs.length
	}
	this.gobs = newGobs;
};

const DefaultAllowedClassDotFuncs = new Set('Math.abs Math.acos Math.acosh Math.asin Math.asinh Math.atan Math.atan2 Math.atanh Math.cbrt Math.ceil Math.clz32 Math.cos Math.cosh Math.exp Math.expm1 Math.floor Math.fround Math.hypot Math.imul Math.log Math.log1p Math.log2 Math.log10 Math.max Math.min Math.pow Math.round Math.sign Math.sin Math.sinh Math.sqrt Math.tan Math.tanh Math.trunc IY IX IR IG IB IC YXC PC IP YXRGB SetC ret.push sigmoid'.split(' '));
//FIXME only allow ret.push if ret is a [] created in that func. Should probably use a shared VoxStream instance VS instead.

/*
//voxel coordinates range 0x00000 to 0xfffff for each of y and x. Thats 128x128 times bigger than fit in game.board which is 8kX8k,
//more if the tiles partially overlap. This is for sparse updates as that 8kX8k window in game.board moves around.
//Maybe a tile should overlap in 1/8 of its width on each border, like ive been doing with updating tridist using a 768x768 in the middle of a 1024x1024,
//but tile will probably be bigger than that.
//Id rather have a powerset of gobs being included or not.
//Need to define primaryKey of gob as ''+gob.brain (aka js code) AND an instance id so u can have multiple instances of the same compiled js code,
//and primaryKey should be hash of that code with that instance id, so primaryKey is shorter.
var Tile = function(shift, oy, ox){
	this.shift = shift; //this is a (1<<shift) x (1<<shift) 2d area
	this.oy = oy;
	this.ox = ox;
	this.gobs = [];
	this.wall = null; //a BloomTree/BitPic (like in dagball), but only up to the powOf2 size
};*/

/*2024-11-20 if you want a Game object just type V.someNamespace55.getGame(),
and similar for V.someNamespace55['(Y,X,varABC,varD)=>{...js code here...}'].getOb() returns a Gob.
//fork this Game object by moving to another y and x, in the approx million X million space that we can only overlap 8k X 8k of at a time per Game object.
//Copies any overlapping parts, in the game.board array and game.rps.tridistSmall and game.rps.team (or was it named teams? TODO was thinking of renaming it to team or teams) etc,
//which are all 2d arrays of int or byte, so just copy the overlapping parts
//and mark the other parts as unknown (max distance 1023 in tridistSmall each int containing 3 uint10s) for example.
//These 2 Game objects, this and what this.forkYX(...) returns, will have no overlapping parts, all copied, can be used mutably.
//Lambdas should be used as immutable, do not store data in them
//(like my Wikibinator203 does store a little data in fields of JS lambda objects it creates
//as u can see in lambdize func which adds lambdaX.n.lam==lambdaX fields and lambdaX(lambdaX)->someLambda).
//I have not included such lambdas here cuz they're very inefficient, but this "Blob Monster Game" is for mass-producing sharing and using javascript lambdas that
//make voxels as a sparse dimensional space that a million players can play together in 1 namespace at once or many namespaces however they wanna organize the computing.
Game.prototype.forkYX = function(optionalY_uint20, optionalX_uint20){
	throw new Error('TODO');
};*/

var MaxCodeLen = 2**16; //chars of what goes in Var.big aka js code evaled to become a gob.brain.

Game.prototype.canEvalClassDotFunc = function(classDotFunc){
	//Do NOT allow 'Math.random', but since its not in this.allowedClassDotFuncs dont need to check for it here,
	//but as opensource u can do it, and gob jumps around randomly and kind of works but when other gobs
	//touch that gob they are thrown really fast.
	return this.allowedClassDotFuncs.has(classDotFunc);
};

//This firewalls JS code to allow it to eval some of it and not others. Replace this func in game instance
//if you prefer a different infinite set of possible js code to eval in your browser.
//WARNING: This software is designed to share untrusted js code across internet, and this is where
//to put the inner sandbox code. The browser sandbox is the outer sandbox. This is the sandbox inside that
//which should block code like '()=>{ while(true); }' cuz it does an infinite loop and crashes the browser tab,
//or it could send the webpage to a spam site or something.
//Browser sandbox blocks execute permission either way, even if uses WebGL2 GLSL ES 300 GPU shaders
//(TODO those shaders using dagball/lib/Ap.js or just dagball/lib/TinyGLSL.js which Ap.js calls),
//and TODO fix TinyGLSL.js to work on linux, is some buffer type error as seen in this pic:
//https://github.com/benrayfield/DagBall/blob/main/doc/gpu/ubuntuTestFailed2023-11-24/tinyGLSLNotWorkInUbuntu2023-11-24.jpg
//which says "WebGL warning: readPixels: Format and type RED/FLOAT incompatible with this R32F attachment. This framebuffer requires either RGBA/FLOAT or getParameter(IMPLEMENTATION_COLOR_READ_FORMAT/_TYPE) RGBA/FLOAT."
//and says "correct5678=32239684 observed5678=0" which I remember it was returning all 0s in the float array,
//and is caused by this code "gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, canvasWidth, canvasHeight, 0, http://gl.RED, gl.FLOAT, null);".
//So thats how to upgrade Blob Monster Game to GPU to work in windows browsers and how to fix a bug so it works in linux too.
//GPU can give you more speed for neuralnet monster types.
Game.prototype.canEval = function(jsCode){
	if(typeof(jsCode) != 'string') throw new Error('Not a string');
	if(jsCode.length > MaxCodeLen) throw new Error('Too long: '+jsCode.length);
	return true; //FIXME
};

Game.prototype.tryEval = function(jsCode){
	if(this.canEval(jsCode)){
		return eval(jsCode);
	}else throw new Error('NOT_canEval jsCode='+jsCode);
};

Game.prototype.onTextareaInput = function(text){
	let selectedGobs = this.selectedGobs();
	if(selectedGobs.length == 1){
		let sel = selectedGobs[0];
		let textarea = document.getElementById('mainTextarea');
		try{
			//FIXME either require the ( ) be in the code itself or  find a way to make it work here without that.
			//it doesnt like some kind of functions function(){} or ()=>{} or ()=>(...) or something.
			let evaled = eval('('+text+')');
			//FIXME check for number of names of params changing. might be a completely new func.
			//else its editing the selected gob.brain func.
			sel.brain = evaled;
			textarea.style.backgroundColor = 'black'; //ok
		}catch(e){
			textarea.style.backgroundColor = '#220000'; //error
			console.error(e);
		}
	}
};

var testFlipTerrainColors = ()=>{
	for(let tile of Object.values(game.wal.tiles)){
		tile.syncSparseDense();
		tile.copySparseToDense();
		for(let i=0; i<tile.dense.length; i++) if(tile.dense[i] < 128){ //0..127 are isWall and 6 bits of color.
			tile.dense[i] ^= ColorMask; //flip low 6 bits
		}
		tile.copyDenseToSparse();
	}
	game.wal.paintGame();
};

var testFlatPackTerrain = ()=>{
	for(let tile of Object.values(game.wal.tiles)){
		tile.syncSparseDense();
		tile.sparse = tile.sparse.flatPack();
	}
	game.wal.paintGame();
};

Game.prototype.onMouseWheelChange = function(amount){
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 50));
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 2000));
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 10000));
	this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 640000));
	//this.zoom.p = Math.max(.01, Math.min(this.zoom.p*Math.exp(.001*amount), 2000));
};

/*wrong, its supposed to be 0b1111111111 aka TINF where theres no voxel: const teamsToTridistInt = Int32Array.of(
	0b00111111111111111111111111111111, //TRINF, cuz 
	0b00000000000000000000001111111111, //REDTEAM
	0b00000000000011111111110000000000, //GREENTEAM
	0b00000000000011111111111111111111, //REDTEAM|GREENTEAM
	0b00111111111100000000000000000000, //BLUETEAM
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
);*/
/*[...teamsToTridistInt].map(x=>[getDistance1(x),getDistance2(x),getDistance3(x)])
(8) [Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3)]
0: (3) [1023, 1023, 1023]
1: (3) [1023, 1023, 0]
2: (3) [1023, 0, 1023]
3: (3) [1023, 0, 0]
4: (3) [0, 1023, 1023]
5: (3) [0, 1023, 0]
6: (3) [0, 0, 1023]
7: (3) [0, 0, 0]

game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
42351
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
40826
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
43329

game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
27755
game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
23285
game.rps.team.reduce((sum,x)=>(((x==GREENTEAM)?1:0)+sum));
6317
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10531
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10654
*/
const teamsToTridistInt = new Int32Array(8);
//2024-11-20 theres about to be a GRAYTEAM which we dont do tridist for. Its for walls and moving shields.
//Its neutral, doesnt interact with Rock Paper Scissors teams but does repel by normal game.board trying
//to have at most 1 voxel per pixel but counts up to (2**26)-1 voxels per pixels. Doesnt change its team.
//teamsToTridistInt[r*REDTEAM + g*GREENTEAM + b*BLUETEAM] could have a problem if we included that here.
//Just leave it as part of game.rps.team byte.
for(let r=0; r<2; r++){ //include REDTEAM or not
	for(let g=0; g<2; g++){ //include GREENTEAM or not
		for(let b=0; b<2; b++){ //include BLUETEAM or not
			//const setDistances = (d1, d2, d3) => ((d1 & mask) | ((d2 & mask) << 10) | ((d3 & mask) << 20));
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = (r?0:1023) | ((g?0:1023)<<10) | ((b?0:1023)<<20);
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
			teamsToTridistInt[r*REDTEAM + g*GREENTEAM + b*BLUETEAM] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
		}
	}
}

const redByteAtYX_shift = teamShift[REDTEAM]+2;
const greenByteAtYX_shift = teamShift[GREENTEAM]+2;
const blueByteAtYX_shift = teamShift[BLUETEAM]+2;

/*The whole 8192x8192 canvas displays a color computed in game.redByteAtYX(y,x), game.greenByteAtYX(y,x), and game.blueByteAtYX(y,x).
Thats how I display the voxels, of 64 possible colors, over the distance fields of 16 million possible colors. AIs could get access to pixel colors
*/
Game.prototype.redByteAtYX = function(y,x){
	//return ++this.board[(y<<13)|x]); //TODO range check?
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	//const i = ((y&SizeMask)<<13)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
	return (color6 || !this.doRps.p) ? RR(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>redByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>2)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)>>2,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
		//Math.max(0,Math.min(((this.rps.tridist[i]>>255)&255)*1.0534,255))|0;
		//Math.max(0,Math.min((this.rps.tridist[i]&1023)*.0534,255))|0;
		//(255-Math.max(0,(((this.rps.tridist[i]>>>2)&255)*3)));
	//|| a display of distance of RED team as in rock paper scissors
	//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
	//return (this.rps.tridist[i]>>>2)&255;
	//return (this.rps.tridist[i]&1023)*.2;
	//return 200;
};

Game.prototype.greenByteAtYX = function(y,x){
	//return GG(this.board[(y<<13)|x]); //TODO range check?
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return color6 ? GG(color6) : (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
	return (color6 || !this.doRps.p) ? GG(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>greenByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)*10,255));
		//255-111.01*Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)**.5,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>12)&255)*5.1,255));
	//return GG(this.board[i]) || (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
};

Game.prototype.ns = 

Game.prototype.blueByteAtYX = function(y,x){
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let color6 = this.board[i]&ColorMask;
	//return color6 ? BB(color6) : (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	return (color6 || !this.doRps.p) ? BB(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>blueByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>22)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>22)&255)*5.1,255));
	//return BB(this.board[i]) || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	//const voxel = this.board[i]; //TODO range check?
	//const blueByteOfVoxel = BB(voxel);
	
	//This is how gptVoxelDijkstra_011.html colors it: const blueValue = (distSq === 0xFFFFFFFF) ? 0 : Math.max(0, 255-Math.min(distSq,255));
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i]>>2,255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	
	//if theres a nonblack voxel, display it, else display a uint10 from game.rps.tridist which is written by computeUint10Distances.
	//RED=0 GREEN=1 BLUE=2 ALPHA=3, used in ByteRect. Use that same order but as uint10s. Just get the high 8 bits of that uint10, dropping its low 2 bits.
	//It would be a little better to add 1 or 2 to it in case distance is only 3 (cuz of orthogonal=3 diagonal=4) so 0 and 3 dont look the same.
	//|| a display of distance of BLUE team as in rock paper scissors
	//return 0; //return blueByteOfVoxel || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
};

//func is the kind that goes in a gob.brain and takes params of ...gob.vars which is a list of Var instances.
Game.prototype.addFunc = function(funcOrCodeOfFunc){
	if(typeof(funcOrCodeOfFunc)=='string'){
		console.log('game.addFunc evaling: '+funcOrCodeOfFunc);
		funcOrCodeOfFunc = eval(funcOrCodeOfFunc);
	}
	//this.gobs.push(new Gob(this,funcOrCodeOfFunc));
	return new Gob(this,funcOrCodeOfFunc); //pushes itself into this.gobs
	//let gob = new Gob(this,funcOrCodeOfFunc);
	//gob.setExists(true);
	//return gob;
};

Game.prototype.addAndSelectFunc = function(funcOrCodeOfFunc){
	return this.setSelectedGob(this.addFunc(funcOrCodeOfFunc));
};

/*didnt work cuz theyre still in the V/Vars tree: Game.prototype.addAsOnlyFunc = function(funcOrCodeOfFunc){
	while(this.gobs.length){
		this.gobs[this.gobs.length-1].setExists(false);
	}
	return this.setSelectedGob(this.addFunc(funcOrCodeOfFunc));
};*/

//voxel stream, where they are added 1 at a time but not added if that YX (primaryKey) is already there.
//Uses 2**26 bits in 2**21 ints, 1 bit per pixel, to mark if thats already been written.
//So if you want to paint over a YX, make sure you do that part first and the "covered up" layers later which get ignored.
//
//you do a bunch of this.addVox(voxel) and it returns true if added, false if that repeats a yx (primaryKey) aka tries to paint the same pixel more than once.
//You then call this.end() to get a Uint32Array of the voxels added in the order added, keeping only the first per yx.
//
//You normally reuse 1 VoxStream for all Gobs, cuz it uses a few mB of RAM, and most gobs will be far smaller than that. Its sparse optimized.
//
//This works in a 8192x8192 2d area sparsely. So this might be a good place to put basic paint functions like circles, lines, etc.
//
var VoxStream = function(){
	this.set = new Uint32Array(Area>>>5); //1 bit per pixel in Area.
	this.vox = new Uint32Array(MaxVoxPerGob);
	this.size = 0; //what indexs in this.vox are used?
};

VoxStream.prototype.addVox = function(voxel){
	let yx = IP(voxel);
	//As of 2024-11-12 i am not using VoxStream but might use it later. Its use is to dedup voxels created in different ways in the same Gob.
	let high = yx>>>5; //bits packed into an int. int has (1<<5)==32 bits. This saves alot of memory to only store 1 bit.
	let low = yx&31;
	let lowMask = 1<<low;
	if(this.set[high] & lowMask){ //FIXME is that reversed? should it be 31 minus that?
		return false; //not add voxel cuz that primaryKey/yx was already added (may be a different color)
	}else{
		this.set[high] |= lowMask; //add the yx of the voxel to the set, but not its color.
		if(this.size == this.vox.length) throw new Error('Full. MaxVoxPerGob.');
		this.vox[this.size++] = voxel;
		return true; //added voxel
	}
};

//ends the stream, undoes whatevers in it, and returns the voxels that were in it, copied to a new Uint32Array(this.size)
VoxStream.prototype.end = function(){
	let ret = new Uint32Array(this.size);
	for(let i=0; i<ret.length; i++){
		let voxel = this.vox[i];
		ret[i] = voxel;
		//TODO? this.vox[i] = 0;
		//let yx = IP(voxel);
		//let high = yx>>>5;
		this.vox[voxel>>>11] = 0; //this.vox[high] = 0; //erase all bits in this.vox that could be nonzero
	}
	this.size = 0;
	return ret;
};

//xors the color but does not count it toward potentialEnergy. This is how you paint the background with no effect on physics.
//Doing this again undoes it cuz its xor graphics. The same voxel can be added by addVox too, which would make it black but still count in energy.
Game.prototype.ghostVox = function(voxel){
	this.board[voxel>>>6] ^= (voxel&63); //xor the uint6 color
};

//add voxel. adjusts this.poten and this.board.
Game.prototype.addVox = function(voxel){
	let yx = IP(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
};

//voxel is an int. team is a byte.
Game.prototype.addVoxWithTeam = function(voxel, team){
	let yx = IP(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	//this.rps.team[yx] = team; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible. BLACKTEAM is 0. Anything else is some powerset of teams, by default only REDTEAM, GREENTEAM, and BLUETEAM which are masks.
};

//remove voxel. adjusts this.poten and this.board.
Game.prototype.remVox = function(voxel){
	let yx = IP(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
	}
};

Game.prototype.remVoxWithTeam = function(voxel, team){
	let yx = IP(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
	}
	//this.rps.team[yx] = BLACKTEAM; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible but probably buggy unless each team number is a power of 2, and should BLACKTEAM (empty, no gob there) have such a pow of 2?
};

//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.addVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.addVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			this.addVox(voxels[i]);
		}
	}
	return this.poten;
};

//return change that would happen in this.poten if called this.addVoxs(voxels), but without actually doing it
//cuz its faster, BUT warning if the voxels write the same empty pixel 2 or more times it
//wont count that cuz is not looking for collisions between the voxels and themself.
//This is number of colliding voxels. TODO Used during gradient calculations.
Game.prototype.potenDiffIfNoCollisionsBetweenParamVoxels = function(voxels){
	let collisions = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		if(this.board[voxel>>>6]&0xffffffc0){ //high 26 bits count how many voxels are at that pixel
			collisions++;
		}
	}
	return collisions;
};

Game.prototype.potenDiffFromRpsDistanceCache_team_voxels = function(team, voxels){
	const shift = teamShift[team]; //0, 10, or 20, to get a uint10 out of tridistSmall.
	const tridistSmall = this.rps.tridistSmall;
	//uint10 dist -> change of poten. distToPoten can differ as a param of Game, in diff peer to peer nets etc.
	//distToPoten should fit in CPU L1 cache so not slow things down much, though maybe i should make it 
	const distToPoten = this.rps.distToPoten;
	let poten = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		let smallI = toSmall(voxel>>>6);
		//uint10. it maxes out around 1019 or 1023, but below that its computed by dijkstra with 8 adjacent pixels,
		//costing 3 for orthogonal and 4 for diagonal.
		let tridistInt = tridistSmall[smallI];
		let distUint10 = (tridistInt>>>shift)&mask10;
		poten += distToPoten[distUint10];
	}
	return poten;
};


//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.remVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.remVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			this.addVox(voxels[i]);
		}
	}
	return this.poten;
};

var generatedNameCounter = 0;

//var DefaultEpsilon = .01;
var DefaultEpsilon = 2**-7;

//This should be a little more than the common epsilon of 1 for pixel coordinates (1 pixel over)
//so it can jump a little past that. If its 1, it moves a little too slow. If 2 its noticably jumpy.
//var DefaultGp = 1.5; //normal
var DefaultGp = .2;
//var DefaultGp = 0; //experimental, trying setting this to 0 2024-11-25 to experiment with game.collideSqMul.
//var DefaultGp = 5.5;
//var DefaultGp = 15.5;


//use this one cuz its sorted by utf8 and ascii except = padding
const dvBase64Digits = '$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz=';
//This is whats made by javascript atob and btoa funcs. This one is only used internally for atob and btoa
const jsBase64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

const CharToNum = {};
const NumToChar = [];
for(let num=0; num<65; num++){
	let ch = dvBase64Digits[num];
	CharToNum[ch] = num;
	NumToChar[num] = ch;
}

const TwoPow53 = 2**53;

const NineCharsToInt54 = (str,optionalOffset)=>{
	//FIXME did i get this backward?
	let offset = optionalOffset|0;
	let ret = 0;
	let neg = false;
	//for(let i=8; i>=0; i--){
	for(let i=0; i<9; i++){
		let num0To63 = CharToNum[str[offset+i]];
		//if(i===8 && 32 <= num0To63){
		if (i === 0 && num0To63 >= 32) { // Check if the most significant digit has a sign bit
			num0To63 -= 32;
			neg = true;
		}
		ret = ret*64+num0To63;
	}
	if(neg){
		ret -= TwoPow53; //like in twos complement integers, an int54
	}
	return ret;
};

/*I convert between 9 chars and int54. Each will be a 4x4 voxel of 4x4 to 256kX256k magnify
int54=4328196882455350 EN6YSg_gq rebuiltInt54=4328196882455350
int54=437956406831598 0Y_5g2abi rebuiltInt54=437956406831598
int54=-7829852537175394 ZAgdZsB9T rebuiltInt54=-7829852537175394
*/
const Int54ToNineChars = int54=>{
	//FIXME did i get this backward?
	let s = '';
	if(int54 < -TwoPow53 || TwoPow53 <= int54 || Math.floor(int54)!==int54){
		Err('Invalid int54: '+int54);
	}
	let neg = int54<0;
	if(neg){
		int54 += TwoPow53; //is now in range 0 to (2**53)-1
	}
	for(let i=0; i<9; i++){
		let digit0To63 = int54%64;
		int54 = (int54-digit0To63)/64;
		if(i===8 && neg){ //FIXME did i get this backward?
			digit0To63 += 32; //sign bit
		}
		s = NumToChar[digit0To63]+s;
	}
	return s;
};

for(let i=0; i<10000; i++){
	let int54 = Math.floor((Math.random()*2-1)*(2**53));
	let nineChars = Int54ToNineChars(int54);
	let rebuiltInt54 = NineCharsToInt54(nineChars);
	if(i<20){
		console.log('int54='+int54+' nineChars='+nineChars+' rebuiltInt54='+rebuiltInt54);
	}
	if(int54 !== rebuiltInt54){
		Err('Test failed. int54='+int54+' nineChars='+nineChars+' rebuiltInt54='+rebuiltInt54);
	}
}
console.log('Int54ToNineChars and NineCharsToInt54 basic tests passed');

/*
//returns first float64
const Wall = NineCharsToInt54;

//base64.length is a multiple of 9 chars since each uint53 voxel
//(37 bits of binheap for quadtree, and low 16 bits of payload of 4x4 wallVsOpenArea) fits in that.
//Use like this: (Y/*72000*,X/*78005*)=>Walls('thebase64......................3453453454334534534645645')
//normally very long. If such a Gob lambda returns a Float64Array,
//its used as wall voxels. If Int32Array its the normal kind of voxels.
//TODO code will scam for that and just grab the base64 out of it without evaling, for efficiency.
const Walls = base64=>{
	if(base64.length%9){
		Err('Walls base64 must be a multiple of 9 chars but is '+base64.length);
	}
	let ret = new Float64Array(base64.length/9);
	for(let i=0; i<ret.length; i++){
		ret[i] = Wall(base64,(i<<3)+i); //aka i*9
	}
	return ret;
};

//inverse of Walls. Param is a Float64Array of int53s. Returns a base64 string 9 times as many chars.
const Wally = int54s=>{
    let parts = [];
    for(let int54 of int54s){
        parts.push(Int54ToNineChars(int54));
    }
    return parts.join('');
};
if(Wally(Float64Array.of(3761487178300722,0,1,2,3,-1)) != 'CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz'){
	Err('Wally(nums) test failed');
}else console.log('Wally(nums) test pass');
if(Wally(Walls('CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz')) != 'CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz'){
	Err('Wally(Walls(str)) test failed');
}else console.log('Wally(Walls(str)) test pass');
console.log('Int54ToNineChars and NineCharsToInt54 all tests passed');
*/

//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn .mx and .poten
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt).
//Also dont modify prevP, epsilon, accelMul, or gp. Those are set externally.
//TODO over time, remove this.gob/optionalGob and use ONLY Var, and same for Game and other classes.
//They were made first, then redesigned as Var is their data format but its also a fast param like centerY.p.
const Var = function(optionalParentVar, optionalName, optionalBig, optionalGob){

	this.brain = null; //where compiled (this.big || this.name) goes, normally a js func of Var's to list/array of int voxels.
	this.vars = null;
	
	//If this.name is a hash id (or might be prefixed with something? todo), then its the hash of this.big which is probably a string of json (see Dagverse json norming, in dagball, TODO).
	//This must be verifiable. Dont just make up a name and make up a big that cant prove that its name is the hash of that.
	this.big = optionalBig || null;
	this.t = 0; //TODO actual current time //TODO? this.t = utc time as float64 so has at least microsecond precision for 100+ more years.
	
	//TODO? this.ch = [] child vars list (gob.vars if this is gob.influence), if this is a .influence var
	//that is 1 for this thing exists and 0 for does not exist.
	//so there is 1 correct answer, or it should converge, to what .p and .v should a var be at time t
	//TODO? this.ns = string namespace, like game.ns.
	//TODO? this.pk = primaryKey of this Var. or should that be per scalar instead of per Var?
	//should pk depend on namespace? be concat to that? or what? pk certainly should not depend on t/time.
	this.name = optionalName || 'v'+(++generatedNameCounter);

	/*Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var.
	*/
	this.up = optionalParentVar || null;
	if(!this.up && this.name != 'V'){ //FIXME remove this. The V global var is root of all Vars, but someone might rename it something else, who knows. This is a test to find those not in the tree at all 2024-11-21.
		throw new Error('Var not in the tree: '+this.path());
	}
	//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
	//Gobs normally go at height 2. Gob fields height 3.
	this.h = this.up ? this.up.h+1 : 0;
	
	if(this.name=='Y' && this.h==2){
		throw new Error('Var named '+this.name+' as child in namespace. should be 1 deeper.');
	}
	
	//pu is opposite of up aka down.
	//TODO make a {} whose Object.getPrototypeOf is custom built so any field that doesnt exist automatically creates
	//a Var instance as that child with that name and this Var as its parent and its .p of 0 and .v of 0 and other defaults.
	this.pu = {}; //mape of childVar.name to childVar.//this.down = {}; //mape of childVar.name to childVar.
	
	//TODO this field Var.gob will be removed, Var class replaces Gob class. parent is this.up. childs are in this.pu.
	//can put same fields in Var as long as they're deriveable by Var.p Var.v Var.name Var.big etc.
	//The root (V) Var, and a namespace Var (like V/blobMonstersGameDefaultNamespace), dont have a Gob.
	//Its 1 layer deeper (theGobVar itself instead of gob.instance), and inside that is gob.vars.
	this.ob = null; //Gob or Game instance, whose parent Var is the same such as V.testnet: this.gob = optionalGob || null;
	
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	this.gr = 0; //same as .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
	//use this.brain instead: this.evaled = null; //eval of this.big || this.name, a js lambda whose params are all Var objects, those in this.influence.vars or gob.vars
	//gp: Like -dt*gr (gradient) usually goes into velocity, this part goes into position. p += -dt*gp.
	//This is an experimental field of Var added 2024-11-13 to try to solve that gobs overlap too much, take too long to accel away from eachother,
	//so this should slightly make them instantly jump away from eachother too.
	//I just doubled constraint solving efficiency of Blob Monster Game in 2 lines of code, in Var class:
	//"this.gp = 1.5; //TODO this.gp = 0;" and "let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);".
	//Now they overlap less. https://pic.x.com/7OjEWfA9hC (2024_pic.x.comSLASH7OjEWfA9hC.png)
	//This might be useful as a neuralnet param, built on the loss function it solves toward lower. Ive already live trained a 22 node sigmoid RNN
	//whose output is to recurse 15 cycles then take one node's output as potentialEnergy. Bent it like neural playdough. Havent tried this on it 2024-11-13.
	//--https://x.com/benrayfield/status/1856780041985687963
	//this.gp = 2.3; //TODO this.gp = 0;
	this.gp = DefaultGp;
	if(this.up && this.up.pu[this.name]){
		throw new Error('Duplicate Var, same name, same parent Var');
	}
	if(this.up) this.up.pu[this.name] = this;
	
	/*doesnt work, need Proxy: this.get = function(fieldName){
		console.log('fieldName='+fieldName);
		return this[fieldName]!==undefined ? this[fieldName] : this.Pu(fieldName); //creates fieldName
	};*/
};

Var.prototype.Mn = function(val){
	this.mn = Math.max(this.min,val);
};

Var.prototype.Mx = function(val){
	this.mx = Math.min(val, this.mx);
};

//does both Mn and Mx. Same as setting this.p (after this.nextState(dt)) but if others have set this.mn or this.mx
//and the value this sets it to is not in that allowed range, it does not get set at all. Thats to keep it independent
//of the order Var's are updated, which is less important in Blob Monsters Game than it was in dagball cuz Var is so
//far 2024-11-23 only used in 1 Gob/monster at a time, but in dagball they have EdJoint's. Might add EdJoints here later.
//Var.prototype.MnMx = function(val){
Var.prototype.set = function(val){
	this.mn = Math.max(this.min,val);
	this.mx = Math.min(val, this.mx);
};

//get namespace
Var.prototype.ns = function(){
	if(this.h <= 1){
		if(this.h == 0) throw Error('This is root Var, which namespaces are childs of.');
		return this;
	}
	return this.up.ns();
};

//gets the Game (like V.testnet.game) of the namespace, even if this is like V.testnet.someGob555
Var.prototype.getGameVar = function(){
	return this.ns().game; //TODO multiple views, each a Game instance.
};

Var.prototype.getGame = function(){
	return this.getGameVar().getOb(); //Game instance
};

//lazy create ob (Gob or Game, depending on var path ends with .game or not, todo multiple views/games).
Var.prototype.getOb = function(){
	if(this.ob){
		return this.ob;
	}else{
		if(this.h == 2){
			let text = this.text();
			if(text.startsWith('(')){
				let game = this.getGame(); //likely a sibling, and game.influence===this.getGameVar()
				//text is a js lambda (brain) whose params if evaled should be Var objects, returns list of int voxels
				return this.ob = new Gob(game, text);
			}else if(text == 'game'){
				//like V.testnet.game is the default path of the game,
				//but todo multiple games/views at once of each namespace.
				return this.ob = new Game(this);
			}else{
				throw new Error('Uknown object type: '+text);
			}
		}else{
			throw new Error('this.h/height is '+this.h+' but Gob and Game go at height 2 (right after namespace at height 1)');
		}
	}
};

/*//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
//Gobs normally go at height 2. Gob fields height 3.
Var.prototype.h = function(){
	return this.up ? (this.up.pathHeight()+1) : 0;
};*/

Var.prototype.toMap = function(){
	let ret = {
		p: this.p,
		v: this.v,
		//name: this.name,
		//pu: {},
	};
	if(this.t){
		ret.t = t; //UTC time updated. not all code will use this. but each Var is a time-series of 2 numbers: position and velocity.
	}
	if(this.big){
		ret.big = this.big;
	}
	for(let childName in this.pu){
		let pu = ret.pu || (ret.pu = {});
		pu[childName] = this.pu[childName].toMap();
	}
	return ret;
};

Var.prototype.text = function(){
	return this.big || this.name;
};

const DefaultMaxResults = 2**16;
const DefaultRadiusResults = 2**12;

//goal(anyVar)->score (FIXME or should it be loss which is -score or someConstant-score?
//As goal, any positive number passes, and any 0 or negative number does not match.
//Sort by that descending, of those which pass.
Var.prototype.search = function(goal, maxResults){
	if(maxResults === undefined) maxResults = DefaultMaxResults;
	let scores = new Map();
	let ret = [];
	for(let n in this.pu){
		let childVar = this.pu[n];
		let score = goal(childVar);
		if(score > 0){
			scores.set(childVar, score);
			ret.push(childVar);
		}
	}
	ret.sort((a,b)=>{
		let scoreA = scores.get(a), scoreB = scores.get(b);
		if(scoreA < scoreB) return -1;
		if(scoreA > scoreB) return 1;
		return 0;
	});
	while(ret.length > maxResults) ret.pop();
	//console.log('Var.search got '+ret.length+' results, goal='+goal);
	if(game.gobs.length > 0 && ret.length == 0){ //FIXME remove this
		lastGoalWhenEmpty = goal;
		lastGobsListWhenEmptying = [...(game.gobs)];
	}
	return ret;
};

var lastGoalWhenEmpty = null; //FIXME remove this
var lastGobsListWhenEmptying = null; //FIXME remove this

//FIXME rename centerY and centerX in existing game content to Y and X, like game.Y and game.X TODO game.Y and game.X.
//if its on the line, is not included. Has to be less than r distance. This is cuz sorts by a relative distance, and 0 must not be included.
Var.prototype.searchYXR = function(y, x, r, maxResults){
	if(r === undefined) r = DefaultRadiusResults;
	const rr = r*r;
	return this.search(
		vr=>{
			return rr - ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		},
		maxResults);
};

Var.prototype.searchYX = function(y, x, maxResults){
	return this.searchYXR(y, x, undefined, maxResults);
};

//makes a new goal that also  requires it be within r distance of (y,x) (not on the line).
Var.prototype.searchYXRGoal = function(y, x, r, goal, maxResults){
	const rr = r*r;
	return this.search(vr=>{
		let isNear = rr > ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		if(!isNear) return 0;
		return goal(vr);
	}, maxResults);
};

Var.prototype.if0 = function(newP){
	if(!this.p) this.p = newP;
	return this;
};

Var.prototype.setNow = function(newP){
	this.p = newP;
	return this;
};

const hashIdLen = ('sha256$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
//TODO what should this limit be?
//If its longer  than this, auto hashes it and uses the hash (prefixed by what, in case it starts with a digit etc?)
//as the Var.name and the content hashed as the Var.big.
//so u can know if its a hash or not by its length. or could check for any chars then $ like sha256$thehash.
const MaxLiteralNameLen = hashIdLen-1;

//get or create child Var
Var.prototype.Pu = function(nameOrBig){
	let ret;
	if(nameOrBig.length <= MaxLiteralNameLen && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(nameOrBig)){ //TODO make this condition be a func
		ret = this.pu[nameOrBig] || new Var(this, nameOrBig, null, this.ob||null); //auto puts it in this.pu[string]
	}else{
		//let hash = hashStringToHex(nameOrBig);
		let name = hashStringToBase64(nameOrBig);
		if(nameOrBig.startsWith('mutid$')){
			let i = nameOrBig.indexOf('$','mutid$'.length);
			if(i!=-1){ //found next $ like in mutid$tile3534523423$...
				name = nameOrBig.substring(i+1)+name; //mutid$tile3534523423$234324hash345345
			}else Err('no second $ found in mutid$...');
		}else{
			name = 'sha256$'+name; //no special prefixing
		}
		//ret = this.pu[name] || new Var(this, name, nameOrBig, this.gob||null); //auto puts it in this.pu[string]
		ret = this.pu[name] || new Var(this, name, nameOrBig, this.ob||null); //auto puts it in this.pu[string]
	}
	if(ret.big && ret.big.startsWith('(')){ //likely a js function string
		let listOfLists = getParamNames(ret.big);
		if(listOfLists.length){
			ret.vars = []; //same order as in gob.vars, a list instead of the .pu {} of paramName to Var. Vars either way.
			for(let list of listOfLists){
				let paramName = list[0]; //TODO if theres more stuff in it, do whats normally done after getParamNames, fill in .p .v .epsilon andOr .accelMul etc.
				ret.vars.push(ret.Pu(paramName));
			}
		}
	}
	return ret;
};

Var.prototype.think = function(){
	let brain = this.brain || (this.brain = eval(this.big || this.name));
	return brain(...(this.vars)); //list or Int32Array of int voxels. only the low 13 bits of y and of x even if bigger.
};

// Proxy handler for Var.prototype
/*const varProxyHandler = {
	get(target, prop, receiver) {
		// Handle Symbol properties normally
		if (typeof prop === 'symbol') {
			return Reflect.get(target, prop, receiver);
		}

		// Ensure 'Pu' is not proxied to avoid infinite recursion
		if (prop === 'Pu') {
			return Reflect.get(target, prop, receiver);
		}

		// Check if the property exists on the instance
		if (Reflect.has(receiver, prop)) {
			return Reflect.get(receiver, prop, receiver);
		}

		// Check if the property exists on Var.prototype
		if (Reflect.has(target, prop)) {
			return Reflect.get(target, prop, receiver);
		}

		// Property not found, call Pu(prop) directly from originalPrototype
		return target.Pu.call(receiver, prop);
	}
};

// Apply the Proxy to Var.prototype
Var.prototype = new Proxy(Var.prototype, varProxyHandler);
*/

const varProxyHandler = {
	get(target, prop, receiver){ //works
		//console.log('proxy target='+(target||null)+' prop='+(prop instanceof Symbol ? prop.description : prop)+' receiver='+(receiver||null));
		//console.log('proxy target='+(target||null)+' prop receiver='+(receiver||null));
		//console.log('proxy');
		// Handle Symbol properties normally
		if (typeof prop === 'symbol') {
			return Reflect.get(target, prop, receiver);
		}

		/*
		// Ensure 'Pu' is not proxied to avoid infinite recursion
		if (prop === 'Pu') {
			return Reflect.get(target, prop, receiver);
		}

		// Check if the property exists on the instance
		if (Reflect.has(receiver, prop)) {
			return Reflect.get(receiver, prop, receiver);
		}

		// Check if the property exists on Var.prototype
		if (Reflect.has(target, prop)) {
			return Reflect.get(target, prop, receiver);
		}

		// Property not found, call Pu(prop) directly from originalPrototype
		return target.Pu.call(receiver, prop);
		*/
		//return Reflect.get(target, prop, receiver);
		//return target.Pu.call(receiver, prop);
		return target[prop] || receiver.Pu(prop); //FIXME if target[prop] is 0, use 0 instead of calling receiver.Pu(prop)? If not fix that, then some game content that uses 0s here might be able to cause things to slow down alot like a DoSAttack?
	},
	/*set(obj, prop, value){
		if(typeof prop === 'symbol'){
			return Reflect.set(obj, prop, value);
		}
		if(obj.pu && obj.pu[prop]){
			obj.pu[prop].p = value; //V.abc.xyz = 10 sets V.abc.xyz.p = 10;
			return this; //FIXME?
		}
		return Reflect.set(obj, prop, value);
	},*/
	/*broken set(target, prop, value, receiver) {
		console.log(`Proxy set called for property: ${String(prop)} with value:`, value);

		// Handle Symbol properties normally
		if (typeof prop === 'symbol') {
			console.log(`Setting Symbol property: ${String(prop)}`);
			return Reflect.set(target, prop, value, receiver);
		}

		// Check if the value is a function or the property exists on the prototype
		if (typeof value === 'function' || Reflect.has(target, prop)) {
			console.log(`Setting method or existing prototype property '${prop}' directly on instance.`);
			// Set directly on the target to avoid recursion
			target[prop] = value;
			return true;
		}

		// If the property exists within pu, set its 'p' property
		if (receiver.pu && receiver.pu[prop]) {
			console.log(`Property '${prop}' exists in pu. Setting pu['${prop}'].p to:`, value);
			receiver.pu[prop].p = value;
			return true; // Indicate that the assignment was successful
		}

		// Otherwise, set the property directly on the instance
		console.log(`Property '${prop}' does not exist in pu. Setting directly on instance.`);
		// Set directly on the target to avoid recursion
		target[prop] = value;
		return true;
	},*/
};

Var.prototype = new Proxy(Var.prototype, varProxyHandler);

//Var.prototype.prototype = new Proxy(Var.prototype.prototype, varProxyHandler);
//Var.prototype.prototype = new Proxy(Var.prototype.prototype || {}, varProxyHandler);
//Object.setPrototypeOf(Object.getPrototypeOf(Var), new Proxy({}, varProxyHandler));

/*Var.prototype.getProperty = function(fieldName){
	console.log('fieldName='+fieldName);
	return this[fieldName]!==undefined ? this[fieldName] : this.Pu(fieldName); //creates fieldName
};*/

/*wrap instead. Var.prototype.relY = function(){
	return this.p-this.gob.oy;
};

//using this.gob.ox as the 0, return relative position. This should only be used if this Var is named like "centerY" or "someVarY" etc, not for "someVarX" etc.
Var.prototype.relX = function(){
	return this.p-this.gob.ox;
};

Var.prototype.oyx = function(){
	const gob = this.gob;
	return [gob.oy&0xfffff, gob.ox&0xfffff];
};

Var.prototype.oy = function(){
	this.gob.oy&0xfffff;
};

Var.prototype.ox = function(){
	this.gob.ox&0xfffff;
};

/*var VarP = p=>{
	let ret = new Var();
	ret.p = p;
	return ret;
};

var VarPV = (p,v)=>{
	let ret = new Var();
	ret.p = p;
	ret.v = v;
	return ret;
};

var VarPVEA = (position, velocity, epsilon, accelMul)=>{
	let ret = new Var();
	ret.p = position;
	ret.v = velocity;
	ret.epsilon = epsilon;
	ret.accelMul = accelMul;
	return ret;
};*/

//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p is probably more efficient.
	return this.p;
};

Var.prototype.path = function(){
	return this.up ? this.up.toString()+'.'+this.name : this.name;
};

Var.prototype.toString = function(){
	return this.path();//return this.up ? this.up.toString()+'.'+this.name : this.name;
	//return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

Var.prototype.nextState = function(dt){
	if(dt){
		//use someVar.nextState(0) to clear someVar.kv someVar.dp etc, without modifying someVar.p or .v etc.
		//For use during gradient of things that might happen but have not decided to make them happen.
		
		//this.v = 0; //FIXME
		//let nextP = this.p + dt*(this.v+this.dp);
		let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);
		if(this.mn <= this.mx){
			nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
		}
		let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
		//let nextV = 0; //FIXME
		
		
		//let changePAmount = Math.abs(this.p-nextP);
		//if(changePAmount > 100 && this.ob==cShapedGob){ //FIXME remove this
		//	console.log('Var '+this.path()+' changePAmount='+changePAmount);
		//}
		
		this.p = nextP;
		this.v = nextV;
	}
	//this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.kv = this.dp = this.dv = this.poten = 0; //leave this.gr as is, since its not a sum, is just set all at once in one of the doPhysics funcs.
	this.mn = -Infinity;
	this.mx = Infinity;
};

/*var getParamNames = func=>{
	const fnStr = func.toString().replace(/[\r\n]/g, '');
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\s,]+)/g);
	return params === null ? [] : params;
};*/

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = funcOrStr=>{
	const fnStr = funcOrStr.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
		.map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
	return params.map(match => {
		const [_, name, comment] = match;
		const numbers = comment ? comment.match(/\d+/g) : [];
		return [name, ...(numbers || []).map(Number)];
	});
};

//gob.brain(...gob.vars) may check this to decide to do diffeq and poten fields in Vars or not.
//You dont need this during the gob.size+1 number of calls to just get 32 bit voxels
//for collision detection, that part of the potential energy math.
//You only need this once per gob per physics cycle to choose to add extra change to var.p andOr var.v
//like how the "pinball bumpers" work in dagball by diffeq.
//should I use this.diffeq instead? do i want the func to have access to a this? var Diffeq = true;
//var Diffeq = true;

//Game OBject. brain(...floatVars) returns Uint32Array of voxels. It can be a different number of voxels depending on those float vars.
//brain returns an Out.
//var Gob = function(game, brain, optionalInfluence){
var Gob = function(game, brain){
	let big = ''+brain;
	//let name = hashStringToHex(big);
	//this.influence = optionalInfluence || new Var(null, name, big, this);
	
	//this.influence.p is 1 for this to exist, else is 0 for this not to exist.
	//other values, i guess try to converge to one of those.
	//This is how you add or delete game content in a live multiplayer game or local.
	//this.influence = NS.Pu(''+brain).setOb(this);
	//this.bo = NS.Pu(''+brain).setOb(this); //Var.ob is a Gob or Game or null. Gob.bo is a Var. Game.bo is a var. gobA.bo.ob===gobA.
	let namespaceVar = game.bo.up;
	this.bo = namespaceVar.Pu(''+brain).setOb(this); //Var.ob is a Gob or Game or null. Gob.bo is a Var. Game.bo is a var. gobA.bo.ob===gobA.
	this.Y = this.bo.Y;
	this.X = this.bo.X;
	
	this.game = game;
	//dont use oy or ox, cuz wrap around 8k instead using centerY.p and centerX.p: this.oy = DefaultGobOy; //FIXME??
	//dont use oy or ox: this.ox = DefaultGobOx; //FIXME??
	game.gobs.push(this);
	this.brain = brain;
	//this.diffeq = false;
	if(typeof(this.brain)!='function') throw new Error('Not a function: '+brain);
	this.size = this.brain.length; //number of params in this.brain. You use this.brain(...this.pos) for example.
	//this.pos = new Float32Array(this.size); //position
	//this.vel = new Float32Array(this.size); //velocity
	this.vars = [];
	let names = getParamNames(brain); //names[index][0] is the name. [1] is first number right after that, if any. 0-4 numbers for position, velocity, epsilon, accelMul.
	if(names.length != this.size) throw new Error('names='+JSON.stringify(names));
	//let accelMulMul = 10; //cuz i removed the dt*10, back to dt*1.
	//let accelMulMul = 5; //normal? cuz i removed the dt*10, back to dt*1.
	let accelMulMul = 3;
	//let accelMulMul = 5000; //FIXME
	for(let i=0; i<this.size; i++){
		
		//broken cuz gives null parent: let v = new Var(null, names[i][0], null, this); //function(optionalParentVar, optionalName, optionalBig, optionalGob)
		//duplicate Var: let v = new Var(namespaceVar, names[i][0], null, this); //function(optionalParentVar, optionalName, optionalBig, optionalGob)
		let lambdaParamName = names[i][0];
		//console.log('Gob constructor, lambdaParamName='+lambdaParamName);
		let v = this.bo[lambdaParamName].setOb(this);
		
		if(i<2){ //FIXME, this is for centerY and centerX vars, but not every Gob/func will have those or in same order. for testing.
			//v.p = Math.random()*400; //FIXME
			v.p = Math.random()*400; //FIXME
			v.v = Math.random()*200-100; //FIXME
			//v.accelMul = .001;
			//v.accelMul = .0001;
			//v.accelMul = .0000001;
			//v.accelMul = .1*accelMulMul;
			v.accelMul = .3*accelMulMul;
			v.epsilon = 1;
		}else if(i == 2){ //ratio
			v.p = .5+Math.random();
			v.accelMul = 12*accelMulMul;
			v.epsilon = .01;
		}
		//v.accelMul = 1;
		v.accelMul = 1*accelMulMul;
		if(names[i].length > 1){
			v.p = names[i][1]; //it gave a default position
		}
		if(names[i].length > 2){
			v.v = names[i][2]; //it gave a default velocity
		}
		if(names[i].length > 3){
			v.epsilon = names[i][3]; //it gave a default epsilon
		}
		if(names[i].length > 4){
			v.epsilon = names[i][4]; //it gave a default accelMul
		}
		this.vars.push(v);
	}
	//js {} map of extra data, whatever else might get added to the Gob later.
	//Gob must be deriveable from the string of js code in gob.brain and from
	//the .p and .v and .epsilon and .accelMul in each Var in gob.vars and gob.m.
	//Keep it organized this way so its easy to store and load state.
	this.m = {
		//TODO move gob.brain and gob.vars in here?
		//Not all parts of a Var are primary data. Some parts are derived/cache other than roundoff.
		isSelected: false,
		isSelectable: true, //you might want to make the mouse gob, if its used, not selectable.
		
		//256 bits, 1 bit per portal, 2**256 possible worlds, each a 256k tall 128k wide rectangle.
		//cross at x=(2**17). 256 y portals in blocks of 1024. (this.Y.p>>>10)&255 is which portal, 0 to 255,
		//crossed when crossing this.X.p==(1<<17) the horizontal midpoint. Near the borders of portals nothing should be allowed
		//to cross there cuz theres too many things intersecting it to be viewed as a flat 2d space, so just put walls near portal edges.
		//To block a portal, just put a 1024 tall wall touching it. They wont be able to come thru from either side.
		//gate: new Uint32Array(8),
		//TODO should gate be 8 Var's using Var.p as 32 bits or 5 of them using 52 or 51 bits?
		//V.testnet.hashOfSomeBrainCode435345345.gatesA.p .gatesB.p etc?
		//Or maybe should use a bigint in just 1 of those? seems like it would cause problems in code that uses float64s or ints.
		
		//8 Var's using Var.p|0 as 32 bits each, total 256 bits for 256 gates and 2**256 possible mutable worlds.
		ga: this.bo.ga, //gates 0 to 31
		gb: this.bo.gb, //gates 32 to 63 in, for example, V.testnet.idOfThisObject345345.gb.p|0
		gc: this.bo.gc, //gates 64 to 95
		gd: this.bo.gd, //gates 96 to 127
		ge: this.bo.ge, //gates 128 to 159
		gf: this.bo.gf, //gates 160 to 191
		gg: this.bo.gg, //gates 192 to 223
		gh: this.bo.gh, //gates 224 to 255
		
		
		team: randTeam(), //see game.rps aka rock paper scissors. Each gob is 1 of REDTEAM, GREENTEAM, or BLUETEAM. Theres also BLACKTEAM
		//team: REDTEAM, //FIXME
		//team: BLUETEAM, //FIXME
		//team: GREENTEAM, //FIXME
		//oy: DefaultGobOy,
		//ox: DefaultGobOx,
		displayText: '',
	};
	if(Math.random()<.1){
		this.m.team = GRAYTEAM; //experimental 2024-11-20+. Doesnt have glowing distance cache / tridist. Is neutral wall or shield. TODO change its voxel colors or something so users can see its GRAYTEAM.
	}
	this.voxInGame = null; //If this is in game.board (2**26 ints), remember them here so can remove them during gradient calculation or just to remove the object. null if not in game.board.
	this.voxLast = null; //last output from this.brain(...this.vars). the other output is it modifies fields in Vars in this.vars.
	this.stats = {};
};

/*like BitPic but just in a Uint32Array without object.
dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.bytes[index>>3]>>(index&7))&1;
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.bytes[index>>3] |= (1<<(index&7));
	}else{
		this.bytes[index>>3] &= ~(1<<(index&7));
	}
};*/
Gob.prototype.crossGate = function(gateByte){ //flips a bit in this.m.gate, of 256 gates which are at x=(1<<17), 1024 tall each stacked.
	this.m.gate[gateByte>>5] ^= (1<<(gateByte&31));
};
Gob.prototype.gateBit = function(gateByte){ //0 or 1
	return this.m.gate[gateByte>>5]>>>(gateByte&31);
};
Gob.prototype.setGateBit = function(gateByte, newBit){
	let readBit = this.gateBit(gateByte); //TODO optimize this so it doesnt call gateBit, just does &= or |=
	if(readBit != newBit){
		this.crossGate(gateByte);
	}
};

Gob.prototype.setAllVars0Speed = function(){
	for(let vr of this.vars) vr.v = 0;
};

Gob.prototype.getVar = function(name){ //Example: this.getVar('Y').p is y position, and 'X', normally the first 2 in this.vars.
	try{
		//return this.bo.up[name];
		return this.bo[name];
	}catch(e){
		console.error(e); //put breakpoint here
		throw e;
	}
};

Var.prototype.setOb = function(gobOrGame){
	this.ob = gobOrGame;
	return this;
};

Gob.prototype.y = function(){
	//return this.getVar('Y').p;
	return this.Y.p;
};

Gob.prototype.x = function(){
	//return this.getVar('X').p;
	return this.X.p;
};

//uses Y X vars, not per voxel. does not wrap.
Gob.prototype.simpleDist = function(y,x){
	return Math.hypot(this.y()-y, this.x()-x);
};


//FIXME use this.Y.p and this.X.p rounded down to blocks of 8192 (Size) and add voxel position to those,
//but TODO??? until that fix im gonna mod y and x by that? but FIXME that will be buggy near the borders of each 8k X 8k wrapped.
//uses this.voxInGame. minimum distance from any voxel to the given y x. will wrap around Size=8192 but this.simpleDist does not wrap so can do the full millionXmillion.
Gob.prototype.dist = function(y,x){
	y = y%Size; //FIXME that will be buggy near the borders of each 8k X 8k wrapped
	x = x%Size;
	let minDistSq = Infinity;
	if(this.voxInGame) for(let voxel of this.voxInGame){
		let dy = IY(voxel)-y;
		let dx = IX(voxel)-x;
		let distSq = dy*dy+dx*dx;
		minDistSq = Math.min(minDistSq,distSq);
	}
	return Math.sqrt(minDistSq);
};

Gob.prototype.varPotens = function(erase){
	let poten = 0;
	for(let v of this.vars){
		poten += v.poten;
		if(erase) v.poten = 0;
	}
	return poten;
};

//update this.voxLast and some of the fields in Var's in this.vars, but do not update this.voxInGame and not the Game itself.
Gob.prototype.think = function(){
	return this.voxLast = this.modVoxels(this.brain(...this.vars));
};

var modVoxelsPutThisColorInSomeButNotAll = (voxels,newColor)=>{
	for(let i=0; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
		voxels[i] = SetC(voxels[i],newColor);
		voxels[i+1] = SetC(voxels[i+1],newColor);
	}
	return voxels;
};

//changes the pixels that modVoxelsPutThisColorInSomeButNotAll doesnt change, so could do both.
var modVoxelsPutThisColorInSomeButNotAllB = (voxels,newColor)=>{
	for(let i=2; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
		voxels[i] = SetC(voxels[i],newColor);
		voxels[i+1] = SetC(voxels[i+1],newColor);
	}
	return voxels;
};

var modAllVoxelsPutThisColor = (voxels,newColor)=>{
	for(let i=0; i<voxels.length; i++){
		voxels[i] = SetC(voxels[i],newColor);
	}
	return voxels;
};

var DefaultGrayTeamColor = 0b101010; //light gray, of the 64 possible colors.

//This is how you create overlay graphics, show a gob flashing cuz its selected, etc.
//Normally this returns its param (voxels) with no changes.
//voxels is a Uint32Array (Int32Array?) of int voxels or a [] list of those. May modify voxels content, such as to change
//their colors to show this gob is selected, or replace them with a different list/array. Either way, returns it.
//Be careful if u return a new list/array of int voxels cuz some code might assume its the same list/array as the param.
Gob.prototype.modVoxels = function(voxels){
	/*
	if(this.m.isSelected){
		let newColor = randInt(Colors);
		for(let i=0; i<voxels.length; i++){
			voxels[i] = SetC(voxels[i],newColor);
		}
	}else if(this.m.team == GRAYTEAM){
		let newColor = DefaultGrayTeamColor;
		//for(let i=0; i<voxels.length; i++){
		for(let i=0; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
			voxels[i] = SetC(voxels[i],newColor);
			voxels[i+1] = SetC(voxels[i+1],newColor);
		}
	}
	return voxels;
	*/
	if(this.m.isSelected){
		return modAllVoxelsPutThisColor(voxels,randInt(Colors));
	}else if(this.m.team == GRAYTEAM){
		return modVoxelsPutThisColorInSomeButNotAll(voxels,DefaultGrayTeamColor);
	}else return voxels;
};

/*this doesnt count if game.gobs contains this, so am commenting it out and doing it all in setExists. Gob.prototype.exists = function(){ //exists in game?
	return !!(this.voxInGame);
};*/

var listRemoveFirst = (list,removeThis)=>{
	let i = list.indexOf(removeThis);
	list.splice(i, 1);
	return list;
};

//both in this.game.gobs list and this.voxInGame
Gob.prototype.setExists = function(shouldExist){ //shouldExist is true/false. exists in game or not. can still exist as Gob either way.
	let existsInGameGobsList = this.game.gobs.includes(this);
	let existsVoxelsInGame = !!(this.voxInGame);
	let exists = existsInGameGobsList && existsVoxelsInGame;
	if(exists != shouldExist){
		if(shouldExist){ //add
			console.log('Add gob '+this);
			if(!existsInGameGobsList){
				this.game.gobs.push(this);
			}
			if(!existsVoxelsInGame){
				this.setGameVoxs(this.think()); //voxels
			}
		}else{ //remove
			console.log('Remove gob '+this);
			
			//2024-11-23 This is an ugly hack. Gobs have been getting high gradients (like gob.Y.gr) and high speeds (like gob.Y.v)
			//instantly when they come back after being removed for game.sparseUpdate() which removes gobs that arent near enough to
			//the mouse (or game center view, was the earlier code).
			//this.setAllVars0Speed();
			
			if(existsVoxelsInGame){
				this.setGameVoxs(null); //remove voxels
			}
			if(existsInGameGobsList){
				listRemoveFirst(this.game.gobs,this);
			}
		}
	}
};

//each Gob can have at most 1 list of voxels in the Game at once. If there is such a list in game already, remove it,
//then either way add this one, unless voxels is null or undefined then dont add any, so thats how to remove it.
//this.voxInGame will be this param voxels either way at the end (null if not exist).
Gob.prototype.setGameVoxs = function(voxels){
	//FIXME game.gobs is a list which could get expensive adding and removing gobs but Gob.setExists is changing the design that its gotta be removed from that.
	if(this.voxInGame){
		this.game.remVoxs(this.voxInGame, this.m.team);
		this.voxLast = null;
	}
	if(voxels){
		//this.game.addVoxs(voxels);
		this.game.addVoxs(voxels, this.m.team);
	}
	this.voxInGame = voxels || null;
	return this.game.poten;
};

//Returns a byte. get the OR aka | of the team byte of all voxels this.voxInGame touches.
//This should always include (as mask) this.m.team if this.voxInGame exists.
Gob.prototype.getTeamsImTouching = function(){
	const voxels = this.voxInGame;
	let teams = 0;
	if(voxels){
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teams |= teamsArray[voxels[i]>>>6];
		}
	}
	return teams;
};

//updates this.m.team and this.game.rps.team, if newTeam differs from this.m.team.
//Does not update this.game.rps.tridist, which should happen in next physics cycle.
Gob.prototype.setTeam = function(newTeam){
	//throw new Error('FIXME how to mark a team in a 4x4 grid if 0-16 voxels might be in here? Should team still be big size (Area) not SmallSize (SmallArea)?');
	const xor = newTeam^this.m.team;
	const voxels = this.voxInGame;
	if(xor && voxels){
		//TODO rename to this.game.rps.teams cuz its xor of all teams touching it such as REDTEAM|BLUETEAM.
		//Also, it only shows up if odd number of a team is touching there.
		//if even, it cancels out. so its parity. cuz i only wanted to spend a byte on it.
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teamsArray[voxels[i]>>>6] ^= xor;
		}
	}
	this.m.team ^= xor; //remove this.m.team, add newTeam.
	if(this.m.team != newTeam) throw new Error('The team xor algorithm didnt work'); //TODO remove this test after know this basic thing is working?
};

//A capture happens when 2 teams touch at the same pixel and a random weighted coin
//is heads cuz otherwise it sometimes wont break ties. Its per pixel,
//so if they slightly squeeze by in any strange shape without touching, even while reshaping, theres no capture.
//This works whether the distance cache (game.rps.tridist) has been updated or not. Its a big cache of 64 megapixels,
//normally only updated on the screen you're viewing at the time, and stays that way until you look near there again.
//The distance cache game.rps.tridist is where the ambient-light-like colors come from, showing the distance from
//each pixel to nearest voxel of REDTEAM, GREENTEAM, and BLUETEAM. Thats for chasing and running from eachother.
//Detecting collisions is easier. If you are on BLUETEAM your goal is to turn the whole game world blue
//before REDTEAM or GREENTEAM turn it those colors instead. Each team captures 1 color and is captured by the
//other color, around and around. Or maybe the amount of time the game world is mostly blue. I dont know.
//The game is supposed to produce a continuous stream of fun, that you can jump in for a minute, join a team,
//and leave, or 10 minutes. Its not longterm accumulation of items like in a RPG. Nobody gets kicked out for being
//captured or losing. They just change teams when captured.
//but the game should accumulate new species over long times, pieces of javascript code that bend into different
//shapes and move differently. This is the cambrian-explosion, that the game gets more and more fun over time cuz
//of player created content, including content by LLMs.
var predatorOf = team=>{ //reverse it so red chases green chases blue chases red.
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == GREENTEAM) return REDTEAM;
	if(team == BLUETEAM) return GREENTEAM;
	if(team == REDTEAM) return BLUETEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

var preyOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == REDTEAM) return GREENTEAM;
	if(team == GREENTEAM) return BLUETEAM;
	if(team == BLUETEAM) return REDTEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
/*var predatorOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == REDTEAM) return GREENTEAM;
	if(team == GREENTEAM) return BLUETEAM;
	if(team == BLUETEAM) return REDTEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

var preyOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == GREENTEAM) return REDTEAM;
	if(team == BLUETEAM) return GREENTEAM;
	if(team == REDTEAM) return BLUETEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};*/

//teams is a mask such as REDTEAM or REDTEAM|BLUETEAM
Game.prototype.countTeam = function(teams){
	let count = 0;
	for(let gob of this.gobs){
		if(gob.m.team&teams) count++;
	}
	return count;
};

Gob.prototype.doTeamLogic = function(){
	let touchingTeams = this.getTeamsImTouching();
	let myTeam = this.m.team;
	if(myTeam == GRAYTEAM){
		//there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
		return;
	}
	let predatorTeam = predatorOf(myTeam);
	if(touchingTeams&predatorTeam){
		//console.log(teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) captured a '+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)');
		//console.log('%cGreen %cBlue', 'color: green;', 'color: blue;');
		console.log('%c'+teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) %ccaptured a %c'+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)%c.\nOK.',
			'color: '+teamHtmlColorName[predatorTeam], '', 'color: '+teamHtmlColorName[myTeam], '');
		if(Math.random()<.9){ //so they dont get deadlocked when all 3 teams are touching eachother somewhere, someone has to become the other team first
			this.setTeam(predatorTeam);
		}
	}
};

const squaredKeepSign = x=>(x<0 ? -x*x : x*x);

//After calling this, gob.vars[eachIndex].gr is set to the gradient,
//by difference of total potentialEnergy, combining game.poten and this.vars[anyIndex].poten,
//but there are adjustments to it based on game.collideLinMul.p and game.collideSqMul.p.
//TODO update gradient in this.vars and compute this.vars.length+1 separate lists of voxels (which may be different sizes).
//Does not change var.p (position) or var.v (velocity) but does set var.gr (gradient), and TODO maybe also xpoten (todo should that go in here),
Gob.prototype.doPhysicsA = function(){
	let relTimeFrom = performance.now();
	let g = this.game;
	try{
		//create this.size+1 lists of voxels to compute the part of gradient of collision detection in game.board
		let gamePotenWithoutThisGob = this.setGameVoxs(null);
		let potenOfFork = new Float64Array(this.size+1); //each should always be an integer 0 to 2**53-1.
		for(let fork=0; fork<=this.size; fork++){
			/*for(let v=0; v<this.size; v++){ //mod var positions by epsilon
				//let epsilon = .01; //FIXME see indexToEpsilon and indexToAccelMul
				if(v == fork){
					this.vars[v].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
				}
			}*/
			if(fork < this.size){
				this.vars[fork].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
			}
			//let voxels = fork<this.size ? this.think() : null; This is wrong cuzthe last fork should have voxels, just the voxels as it is now unmodified.
			let voxels = this.think();
			
			
			//the accurate way that considers collisions even within voxels list: let gamePoten = this.setGameVoxs(voxels); //if voxels is null, removes it from game.
			let collidePotenDiff = g.potenDiffIfNoCollisionsBetweenParamVoxels(voxels);
			//let gamePoten = this.game.poten + potenDiff; //the fast way. does not modify game. just reads it.
			let gamePoten = g.poten + g.collideLinMul.p*collidePotenDiff +
				g.collideSqMul.p*squaredKeepSign(collidePotenDiff); //the fast way. does not modify game. just reads it.
			//let rpsAccelMul = this.game.rps.accelMul;
			//let rpsAccelMul = this.game.rps.accelMul.p;
			let rpsAccelMul = g.rpsAccelMul.p;
			let myTeam = this.m.team;
			if(g.doRps.p && myTeam != GRAYTEAM && rpsAccelMul){ //if its set to 0, dont spend on this calculation
				let predatorTeam = predatorOf(this.m.team);
				let preyTeam = preyOf(this.m.team);
				if(predatorTeam&myTeam){
					throw new Error('i am my own predator, predatorTeam='+predatorTeam+' myTeam='+myTeam);
				}
				if(preyTeam&myTeam){
					throw new Error('i am my own predator, predatorTeam='+predatorTeam+' myTeam='+myTeam);
				}
				//let rpsPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(this.m.team, voxels);
				//TODO optimize by doing just 1 call of a variant of potenDiffFromRpsDistanceCache_team_voxels that does both predator and prey at once.
				let predatorPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(predatorTeam, voxels); //accelerate away from predator voxels
				let preyPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(preyTeam, voxels); //accelerate toward prey voxels
				//gamePoten += rpsAccelMul*rpsPoten;
				let normedPredatorPoten = predatorPoten/voxels.length;
				let normedPreyPoten = preyPoten/voxels.length;
				gamePoten += rpsAccelMul*(normedPreyPoten-normedPredatorPoten);
				//gamePoten += rpsAccelMul*(preyPoten-predatorPoten);
				//let rpsPotenDiff = preyPoten-predatorPoten;
				//gamePoten += rpsAccelMul*(rpsPotenDiff + .00000001*squaredKeepSign(rpsPotenDiff));
			}
			
			
			
			
			//this.varPotens() gets the sum of var.poten for all this.vars. The true param makes it erase those potens to 0 after that.
			potenOfFork[fork] = gamePoten + this.varPotens(true);
			//potenOfFork[fork] = gamePoten; //FIXME also include this.varPotens(true). just testing why its accelerating for no apparent reason.
			if(fork < this.size){
				this.vars[fork].popEpsilon(); //undo "mod var positions by epsilon"
			}
		}
		//if(gamePotenWithoutThisGob != potenOfFork[this.size]){
		//	throw new Error('gamePotenWithoutThisGob != potenOfFork[this.size], but those should be duplicate. TODO redesign to not duplicate that calculation, so its faster. But still, they should be exactly equal cuz potentialEnergy is always an integer from 0 to 2**53-1.');
		//}
		let maxGr = this.game.maxGr.p;
		for(let i=0; i<this.size; i++){
			let vr = this.vars[i];
			vr.nextState(0); //clear parts that were modified during what-if calculations during gradient, that we are not actually going to do, just measure.
			//let epsilon = v.epsilon;
			//let accelMul = v.accelMul;
			let oneDimOfGradient = (potenOfFork[i]-potenOfFork[this.size])/vr.epsilon; //gradient
			vr.gr = oneDimOfGradient;
			if(maxGr < vr.gr){
				let newGr = maxGr;
				console.log(vr.path()+'.gr limited by maxGr to '+newGr+', was '+vr.gr); //TODO merge duplicate code
				vr.gr = newGr;
			}else if(vr.gr < -maxGr){
				let newGr = -maxGr;
				console.log(vr.path()+'.gr limited by maxGr to '+newGr+', was '+vr.gr); //TODO merge duplicate code
				vr.gr = newGr;
			}
		}

		//document.title = 'gob_poten='+potenOfFork[this.size];
		//console.log('potenOfFork='+JSON.stringify([...potenOfFork]));

		//this last .think() puts back what was cleared by v.nextState(0).
		this.setGameVoxs(this.think()); //not gradient. just whatever it is now. paint that onto game, and leave it there for other gobs to collision against.
	}finally{
		this.stats.lastPhysicsASecs = (performance.now()-relTimeFrom)*.001;
	}
};

Gob.prototype.speedYX = function(){
	return Math.hypot(this.Y.v, this.X.v);
};

//updates var.p (position) and var.v (velocity)
Gob.prototype.doPhysicsB = function(dt){
	let relTimeFrom = performance.now();
	try{
		let speed = this.speedYX();
		let maxSpeed = this.game.maxSpeed.p;
		if(speed > maxSpeed){
			let mul = maxSpeed/speed;
			this.Y.v *= mul;
			this.X.v *= mul;
			//console.log('Limiting speed of '+this.bo.path()+' to maxSpeed='+maxSpeed+', was '+speed);
		}
		for(let v of this.vars){
			v.nextState(dt);
		}
		this.Y.p = Math.max(MinY, Math.min(this.Y.p, MaxY)); //TODO use this.Y.mn and this.Y.mx instead? They'd get set
		this.X.p = Math.max(MinX, Math.min(this.X.p, MaxX));
	}finally{
		this.stats.lastPhysicsBSecs = (performance.now()-relTimeFrom)*.001;
	}
};

//update gob.m.displayText etc. for debugging as of 2024-11-23 but seems a useful place to put stuff in general so keep it for other things later.
Gob.prototype.stepC = function(){
	//if(this != mouse && this != cShapedGob) return;
	//let s = 'Y.gr='+this.Y.gr+' Y.v='+this.Y.v;
	//let s = 'Y.gr='+this.Y.gr+' yv='+this.Y.v;
	//let s = 'distG='+this.simpleDist(game.Y.p, game.X.p);
	//if(this != mouse) s = 'y='+this.getVar('Y').p+' x='+this.getVar('X').p+'\n'+s;
	//let s = 'y='+this.Y.p+' x='+this.X.p+'\n';
	//this.m.displayText = s;
	this.m.displayText = '';
	//this.m.displayText = 'y='+this.getVar('Y').p+' x='+this.getVar('X').p+'\ndistG='+this.simpleDist(game.Y.p, game.X.p);
	
};


const randOf = list=>list[randInt(list.length)];

var isInGameNextState = false;

Game.prototype.nextState = function(dt){
	if(isInGameNextState){
		throw new Error('Already in game.nextState. Probably a thread error');
	}
	try{
		isInGameNextState = true;

		this.sparseUpdate(); //replace game.gobs with near Gobs from the Var tree.
		
		let mouseMoved = (game.prevMouseY===undefined || game.prevMouseY!==Controls.mouseY || game.prevMouseX!==Controls.mouseX);
		if(mouseMoved){
			testPaintAtMouse(); //FIXME remove this. it paints a pixel on game.wal (a BigTile) to test the terrain system.
		}
		game.prevMouseY = Controls.mouseY;
		game.prevMouseX = Controls.mouseX;
		//
		game.wal.sync();
		game.wal.paintGame();

		//if(game.rps){ //rock paper scissors per voxel
		if(this.doRps.p){
			let tridistComputeHAndW = 256;
			let border = 32;
			for(let repeat=0; repeat<2; repeat++){ //normal
			//for(let repeat=0; repeat<1; repeat++){ //for testing
				//let smallCenterY = Controls.mouseY>>MagnifyShift;
				//let smallCenterX = Controls.mouseX>>MagnifyShift;
				
				let smallCenterY = (Controls.mouseY&SizeMask)>>MagnifyShift;
				let smallCenterX = (Controls.mouseX&SizeMask)>>MagnifyShift;
				
				//if(Math.random()<.5){
				if(repeat==1){
					if(this.gobs.length && Math.random()<.5){ //pick a gob at random, then pick a voxel in it at random, and center there, so gobs are updated more often
						//tridistComputeHAndW /= 2; //FIXME remove this?
						//border /= 2; //FIXME remove this?
						let randGob = randOf(this.gobs);
						let voxels = randGob.voxInGame;
						if(voxels && voxels.length){ //if its displaying at least 1 voxel in game.board
							let randVoxel = randOf(voxels); //only has 8k X 8k position, even if its bigger and wrapped around that, so dont need to &SizeMask.
							smallCenterY = IY(randVoxel)>>>MagnifyShift;
							smallCenterX = IX(randVoxel)>>>MagnifyShift;
						}
					}else{ //random in whole game area
						smallCenterY = randInt(SmallSize); //FIXME what if it hangs off the edge?
						smallCenterX = randInt(SmallSize);
					}
				}
				let smallFromY = smallCenterY-(tridistComputeHAndW>>1);
				let smallToY = smallFromY+tridistComputeHAndW;
				let smallFromX = smallCenterX-(tridistComputeHAndW>>1);
				let smallToX = smallFromX+tridistComputeHAndW;
				//console.log('smallFromY='+smallFromY);
				this.updateTridist(smallFromY, smallToY, smallFromX, smallToX, border); //arbitrary rectangle. can be any rect in the 2048x2048 board. game.rps.tridistSmall, not .tridist.
			}
		}

		for(let gob of this.gobs){
			gob.doPhysicsA();
		}
		for(let gob of this.gobs){
			//gob.setAllVars0Speed(); //FIXME remove this. in theory it makes it only update positions without velocities, by Var.gp
			gob.doPhysicsB(dt);
		}
		for(let gob of this.gobs){
			gob.stepC(); //update gob.m.displayText etc. debug stuff.
		}
		if(this.doRps.p){
			for(let gob of this.gobs){
				gob.doTeamLogic();
			}
		}
		
		//select gob by distance to mouse
		//FIXME use different coordinates for mouse relative to screen or canvas vs relative to game coords which are an 8192 side square.
		let bestGob = null;
		let bestDist = Infinity;
		for(let gob of game.gobs){
			if(gob.m.isSelectable){ //normally this only excludes the mouse gob
				let dist = gob.dist(Controls.mouseY,Controls.mouseX);
				if(dist < bestDist){
					bestGob = gob;
					bestDist = dist;
				}
			}
		}
		let maxDistToSelectGob = 50;
		if(bestDist < maxDistToSelectGob){
			console.log('Select gob '+bestGob);
			game.setSelectedGob(bestGob);
		}
		
		/*for(let smallY=0; smallY<SmallSize; smallY++){
			let smallX = smallY;
			let smallI = ((smallY<<SmallSizeBits) | smallX);
			this.rps.tridistSmall[smallI] = randInt(1<<30); //3 random uint10s
		}*/
		
		//let fpsMul = Math.exp(-dt*this.stats.fpsDecay);
		//this.stats.fpsVal = this.stats.fpsVal*fpsMul+(1-fpsMul)/dt; //*1 cuz its 1 more frame
		//this.stats.fpsVal = this.stats.fpsVal*Math.exp(-dt*this.stats.fpsDecay)+this.stats.fpsDecay;
		this.stats.fpsVal = this.stats.fpsVal*(1-dt)+1;
		
		/*let s = 'Game.logMap eval:';
		for(let k in game.logMap){
			s += '\n'+k+': '+game.logMap[k](); //TODO shouldnt have to write game twice. see how i did it in dagball. was it a global instance (dagball.something...)?
		}
		console.log(s);
		*/
		//document.title = 'M'+game.rps.boardR[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame';
		//document.title = 'Tridist'+game.rps.tridist[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
		//let tridist = game.rps.tridist[mouseI()];
		
		/*//FIXME remove distStr logging, added 2024-11-21 cuz sparseUpdate is making gobs appear and disappear in confusing ways
		let distStr = 'game.Y.p='+game.Y.p+' game.X.p='+game.X.p;
		for(let gob of game.gobs){
			distStr += '\n'+gob.dist(game.Y.p, game.X.p);
		}
		console.log(distStr);
		*/
		
		
		let tridist = game.rps.tridistSmall[toSmall(mouseI())];
		//let s = 'MouseY '+Controls.mouseY+'X'+Controls.mouseX+' '+'R'+getDistance1(tridist)+' G'+getDistance2(tridist)+' B'+getDistance3(tridist)+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
		//let s = 'gameyxDist='+mouse.simpleDist(game.Y.p, game.X.p)+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
		let s = (game.Y.p|0)+','+(game.X.p|0)+' FPS'+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
		if(Controls.pause) s = 'Paused '+s;
		document.title = s;
		if(Math.random()<.0001) console.log('FIXME put a string filtering function as part of game.something game.jsFirewall or something. game.jsFirewall("while(true);") false, dont wanna infinite loop, if knew to check for that. but i just wanna define a pattern of JS code that is complex enough to be interesting as game content and to make things very strategic and lead to combos of AI experiments, but which doesnt allow calling just any arbitrary function. I want it sandboxed enough to know how many flops at most it can do, or some max it could do, that it cant ever do more, but it may always do alot less, proof based. Thats future research to do in javascript, after i have done it in Wikibinator203. The.whole.game.state.across.the.earth will be a sparse dimensional vector, and you can literally dot-product it with other game states, though i wouldnt expect that to be very useful cuz of some dimensions having far more effect in some combos than others. [anything to the contrary adding to loss function and accelerated by negative gradient] includes every possible algebra equation. \nTODO putLiveBlobMonstersGameOnlineAtSomeWebsite');
		//console.log('cShapedGob.y='+cShapedGob.Y.p+' yv='+cShapedGob.Y.v);
	}finally{
		isInGameNextState = false;
	}
};


var VS = new VoxStream();

var getNamespace = nameOrBig=>(V[nameOrBig]);

//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var(null, 'V'); //var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob)
//child of V which is the root Var for all possible namespaces
//(make up any string, or hash a bigger string) and use the hash as the namespace string.
var NS = getNamespace(DefaultNamespaceName);

//V.testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; }'] === V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8
//But it only works if you give it the big string first.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p and .v are the
//m var's position and velocity. still buggy, seems to be duplicating some of the Var objects. but .think()
//should use those .m and .b vars cuz theyre in the code string hashed.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p would be a global var,
//that exists across the earth could be updated at gaming low lag. The tree of Var's is potentially endless.
//put whatever strings in there u want. turing complete game sync
//http://V.this.is.a.turing.complete.vector.system['(sideA,sideB)=>([Math.hypot(sideA,sideB)])'].testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(0, 0, 0b000011)); return voxs; }'].think() returns int voxels & worldwide shared high dimensional vectors.
//The vectors already do sparse dimensional high dimensional gradients. Huge swarms of dimensions.
//This worldwide vector system should be used as a constraint solver aka potential energy or loss minimizer.
//V.turing.complete.poten += amount to add to loss.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].big
'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].path()
//'V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e'
//V.testnet.big
//null
//even tho it was smaller than the generated hash, it couldnt be a js var name. had ( and other chars not allowed. so hashed it.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].shittyVarName would work too, even though theres no such variable.
//Its just a tree. It doesnt care what you name things or how big it is. If its big or not a valid JS var name, it will hash it
//and use that instead.
//what im trying to build across the world is that anyone anywhere can run a peer to peer swarm to all have the same number
//for V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.shittyVarName or any other made up
//path, swarms streams of sparse vectors

var game = new Game(NS.game);
//paint coordinate lines, horizontal and vertical, as a 32x32 grid of 256x256 pixels each.
//for(let y=0; y<Size; y+=256){
//for(let y=0; y<Size; y+=1024){
for(let y=0; y<Size; y+=Size){
	for(let x=0; x<Size; x++){
		//for(let thick=0; thick<25; thick++){
			//game.ghostVox(YXC(y+thick,x,randInt(Colors)));
			//for(let i=0; i<15; i++) game.ghostVox(YXC(y+randInt(21)-11,x,randInt(Colors)));
			for(let i=0; i<55; i++) game.ghostVox(YXC(y+randInt(500)-250,x,randInt(Colors)));
		//}
	}
}
for(let y=0; y<Size; y+=256){
	for(let x=0; x<Size; x++){
		game.ghostVox(YXC(y+randInt(21)-11,x,randInt(Colors)));
	}
}
//for(let x=0; x<Size; x+=256){
//for(let x=0; x<Size; x+=1024){
for(let x=0; x<Size; x+=Size){
//for(let x=0; x<Size; x+1000){
	for(let y=0; y<Size; y++){
		//game.ghostVox(YXC(y,x,randInt(Colors)));
		//game.ghostVox(YXC(y,x+randInt(21)-11,randInt(Colors)));
		for(let i=0; i<55; i++) game.ghostVox(YXC(y,x+randInt(500)-250,randInt(Colors)));
	}
}
for(let x=0; x<Size; x+=256){
	for(let y=0; y<Size; y++){
		game.ghostVox(YXC(y,x+randInt(21)-11,randInt(Colors)));
	}
}


const sigmoid = x=>(1/(1+Math.exp(-x)));

//const numReshapingRects = graphicsLev>1 ? 50 : 12; 
const numReshapingRects = graphicsLev>1 ? 30 : 12; 
for(let i=0; i<numReshapingRects; i++){
//let targetY = 504250;
//let targetX = 504400;
let targetY = 74250;
let targetX = 74400;
if(10 <= i && i < 20){
	targetY += randInt(2000)-1000;
	targetX += randInt(2000)-1000;
}
if(20 <= i){
	targetY += randInt(5000)-2500;
	targetX += randInt(5000)-2500 + Size; //1 8kX8k to the right, test wrapping
}
game.addFunc(`(Y/*${targetY}*/, X/*${targetX}*/, heightToWidthRatio)=>{
	let i = ${i};
	//const m = centerY.gob.m;
	//const oy = m.oy, ox = m.ox;
	//dont use this, wrap instead: const [oy,ox] = centerY.oyx();
	//let area = 400;
	let area = 2400;
	/*if(gob.m.isSelected){
		area *= 5; //experiment. FIXME remove this
	}*/
	let ratio = .2+2*sigmoid(heightToWidthRatio.p*.02-.01);
	//let ratio = Math.tanh(heightToWidthRatio.p*.3);
	//let ratio = Math.exp(heightToWidthRatio.p*.5);
	//let ratio = Math.max(.2, Math.min(heightToWidthRatio.p, 5));
	//let ratio = 1;
	
	//FIXME this doesnt look like the right calculation. should ratio go in the sqrt? do algebra.
	//Use my NsatDesignToolGpu https://tinyurl.com/NsatDesignToolGpu if needed,
	//can brute force up to 40 bit vars, which u can mount uintN's in totalling at most 40 bits.
	
	let h = Math.ceil(ratio*Math.sqrt(area));
	
	let w = Math.ceil(area/h);
	/*let fromY = (centerY.p|0) - 20;
	let fromX = (centerX.p|0) - 20;
	let toY = fromY+40;
	let toX = fromX+40;
	*/
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let color = 63-i;
			ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
		}
	}
	Y.poten += .01*Math.hypot(Y.p-${targetY},X.p-${targetX})**2; //attract to that
	heightToWidthRatio.poten += .03*(heightToWidthRatio.p-1)**2;
	//centerY.kv += 3;
	//centerX.kv += 3;
	//centerY.kv += .1;
	//centerX.kv += .1;
	Y.kv += .3;
	X.kv += .3;
	//heightToWidthRatio.kv += .003;
	heightToWidthRatio.kv += .01141;
	return ret;
}`);
}

//game.addFunc((centerY=VarP(700), centerX=VarPV(700,100), heightToWidthRatio=VarP(1))=>{
game.addFunc((Y/*74310*/, X/*74300 10*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 4000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//Y.poten += .1*Math.hypot(Y.p-4150,X.p-4175)**2; //attract to that
	Y.poten += .1*((Y.p-74150)**2 + (X.p-74175)**2); //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

game.addFunc((Y/*4710*/, X/*4700 10*/)=>{
	//in top left 8kX8k block. for debugging.
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*((Y.p-4650)**2 + (X.p-4675)**2); //attract to that
	Y.kv += .1;
	X.kv += .1;
	return ret;
});

const cShapedGob = game.addFunc((Y/*74300*/, X/*74800 100*/, areaMul)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	//let area = 90000; //before cut circle out of it
	let area = 20000*(1+9*sigmoid(areaMul.p*.01)); //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX+40;
	//let otherRR = rr*sigmoid(rrMul.p)*.5;
	let otherRR = rr*.8;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			let otherDx = otherX-x;
			let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*Math.hypot(Y.p-74200,X.p-74375)**2; //attract to that
	areaMul.poten += 11.01*areaMul.p**2;
	areaMul.kv += .9;
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .2;
	X.kv += .2;
	//heightToWidthRatio.kv += .003;
	return ret;
});

const donutShapedGob = game.addFunc((Y/*74000*/, X/*74000*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 120000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX;
	let otherRR = rr*.58;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			let otherDx = otherX-x;
			let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//Y.poten += .1*Math.hypot(Y.p-4200,X.p-4375)**2; //attract to that
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

const Ave = floats=>{
	if(!floats.length) return 0;
	let sum = 0;
	for(let i=0; i<floats.length; i++) sum += floats[i];
	return sum/floats.length;
};

const Dev = (floats, optionalAve)=>{
	let ave = optionalAve===undefined ? Ave(floats) : optionalAve;
	let sumOfSquares = 0;
	for(let i=0; i<floats.length; i++) sumOfSquares += floats[i]**2;
	return Math.sqrt(sumOfSquares/floats.length);
};

const AveDev = floats=>{
	let ave = Ave(floats);
	return [ave,Dev(floats,ave)];
};















/* Dagball quicksaves are way too big (250kB) cuz dense pic of 1 bit pixels of wall vs open area. Sparse quadtree bloom filter
of 2 bits per node so sync easy across net. 00 means transparent / leave it as it is.
01 means 0. 10 means 1. 11 means 4 way branch https://en.wikipedia.org/wiki/Quadtree
A feature of this kind of image compression is its deterministic and has no room to sneak in metadata.

a sparse matrix of bits optimized for 2d powOf2 aligned powOf2 sized squares
//that are all 0s, all 1s, or all transparent (to leave it as it is).
//The max size is 8/3 bits per pixel. It will usually be closer to .01 bits per pixel
//if the shapes are simple, lots of thick areas of all 0s and other areas of all 1s.
//This is meant to be used with dagball.BitPic of size 1024x1024 or 4096x4096 or 32x32 etc.
//This will normally be stored in wholeGameState instead of a BitPic cuz this will
//make the .dagball/json files many times smaller (they are around 253kB now, and most of that is bitpic).
//
//Data format: Its a list of blocks. Each block is 2 bits and is 1 of these symbols:
//00 - transparent/unspecified, leave it as it is.
//01 - all 0s in this square and recursively smaller down to infinitely small.
//10 - all 1s in this square and recursively smaller down to infinitely small.
//11 - branch with 4 blocks.
//This often wont align on byte or int sizes so pad with 00s.
//
//This is called BloomPic cuz its a kind of bloomFilter but with disproofByContradiction built in
//per bit (which is 2 bits) so across network if there is disagreement
//on where the walls (10) vs open areas (01) are, so both cant be true.
//
//FIXME use 2 bits per wall/open pixel in BitPic?
//
dagball.BloomPic = function(ints){
	this.height = height;
	this.width = width;
	this.ints = ints;
};

It uses 2-bit blocks. 11 is followed by 4 nodes as 2x2. 10 is white. 01 is black. 00 is transparent. At any depth,
it can color the whole thing white, black, or transparent, any power of 2 aligned and sized square. And thats it.
Just recurse that and it cuts away huge solid areas.
*/
dagball.BloomTree = function(bytes){
	this.bytes = bytes;
};

//it only cares about the first char. but which endian?
var firstUint2InBase64 = function(base64){
	Todo();
};

dagball.BloomTree.prototype.type = 'dagball_bloomtree';

dagball.BloomTree.prototype.read = function(index){ //returns 0 1 2 or 3. Index is in units of uint2s.
	//index = index*2;
	//return (this.bytes[index>>3]>>(index&7))&3;
	let b = this.bytes[index>>2];
	let lowestBitIndexInByte = 6-((index&3)<<1);
	return (b>>lowestBitIndexInByte)&3;
};

//index is in units of int2s.
dagball.writeInt2IntoBytes = function(bytes, index, int2){
	let byteIndex = index>>2;
	let prevByte = bytes[byteIndex];
	//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
	let lowestBitIndexInByte = 6-((index&3)<<1);
	//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
	let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
	bytes[byteIndex] = prevByteWithoutThose2Bits | (int2<<lowestBitIndexInByte);
};

dagball.BloomTree.prototype.write = function(index, num){ //write 0 1 2 or 3
	return dagball.writeInt2IntoBytes(this.bytes, index, num);
	/*
	//let highBit = (num>>1)&1;
	//let lowBit = num&1;
	//TODO optimize by writing 2 bits at a time
	//this.writeBit(index*2, lowBit); //FIXME should this endian be swapped?
	//this.writeBit(index*2+1, highBit); //FIXME should this endian be swapped?
	let byteIndex = index>>2;
	let prevByte = this.bytes[byteIndex];
	//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
	let lowestBitIndexInByte = 6-((index&3)<<1);
	//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
	let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
	this.bytes[byteIndex] = prevByteWithoutThose2Bits | (num<<lowestBitIndexInByte);
	*/
};

dagball.BloomTree.prototype.toMap = function(){
	return {
		type: this.type,
		base64: dagball.bytesToBase64(this.bytes),
	};
};

dagball.mapToBloomTree = function(map){
	if(!map || !map.base64){
		Err('Some stuff missing: '+JSON.stringify(map));
	}
	if(map.type != 'dagball_bloomtree'){
		Err('Not a dagball_bloomtree: '+JSON.stringify(map));
	}
	return new dagball.BloomTree(dagball.base64ToBytes(map.base64));
};

/*dagball.bloomTransparent = 0b00; //leaf transparent / leave the bitpic pixel as it is
dagball.bloomOpen = 0b01; //leaf open
dagball.bloomWall = 0b10; //leaf wall
dagball.bloomBranch = 0b11; //4 way branch
*/
dagball.bloomTransparent = WQTRAN; //leaf transparent / leave the bitpic pixel as it is. Same constants in Dagball and Blob Monsters Game.
dagball.bloomOpen = WQOPEN; //leaf open
dagball.bloomWall = WQWALL; //leaf wall
dagball.bloomBranch = WQFORK; //4 way branch

dagball.isPowOf2 = function(x){
	return (x&(x-1))==0;
};

/* use BigPic instead.

//Mutable, normally 2**20 X 2**20 pic of 2 bits per pixel that can be WQTRAN, WQOPEN, WQWALL, or internal nodes WQFORK as quadtree,
//with parts 256x256 and smaller compressed by dagball.Bloomtree base64.
//FIXME if WallQuad is immutable then i cant share BitPics between it and game.wab if I modify them in game.wab
//to then convert them to WallQuad which is used as immutable. I could do it with twice as many, still sparse, BitPics 256x256.
//Id like to, but its probably too slow, use uint53 voxels, 41 bits of binheap for 2**20 X 2**20, 6 bit color,
//2 bit WQTRAN, WQOPEN, WQWALL, or internal nodes WQFORK, 4 bit team mask, totals 53 bits,
//which is slow cuz of recursing 1-2 bits at a time for quadtree all the way down those 41 bits as binheap indexing,
//and using it in float64 makes it slower. Im sticking with the int voxels (13 bits y, 13 bits x, 6 bits color) in 8192 X 8192
//that wrap around (&8191) so you can view 8kX8k areas of the 1mX1m whole game area.
//BitPic, WallQuad, etc, are for walls, which I want to not be wrapped around 8k but be the whole 1m X 1m space at once sparsely.
//As Im building it im finding WallQuad hard to use cuz it doesnt let you modify just 1 pixel at a time
//which is cuz it stores base64 compressed form of 256x256 (or smaller).
//Im thinking of turning them all into (y,x,height) funcs.
dagball.SparseBitPic = function(){
	Todo();
};
*/


//UPDATE: 2024-1-1+ changing this.ints to this.bytes to avoid having to deal with endian.
//This is for painting walls that balls bounce and lay on. Circs are an expensive game object.
//You can have alot of 1 bit wall pixels compared to that, such as 4k x 4k of them is 2mB.
//Circs have infinite (actually up to float32 precision) resolution similar to SVG. These walls dont.
//a pic of 1 bit color per pixel. stored in Int32Array. Wall is 1. Open area is 0.
//For physics, this should be used in gradient/potens func and add to potentialEnergy
//right after GPU comnputes potentialEnergy, but this is done by CPU.
//For each ball, sum over near pixels the bellcurve height of the distance between ball center and that pixel,
//or something like that.
dagball.BitPic = function(wallPoten, wallThick, height, width, bytes, aftrans){
	this.wallPoten = wallPoten;
	this.wallThick = wallThick;
	this.height = height;
	this.width = width;
	this.bytes = bytes;
	this.aftrans = aftrans;
};
dagball.BitPic.prototype.type = 'dagball_bitpic';
dagball.BitPic.prototype.toMap = function(){
	return {
		type: this.type,
		wallPoten: this.wallPoten,
		wallThick: this.wallThick,
		height: this.height,
		width: this.width,
		//bytes: dagball.bytesToHex(this.bytes),
		bloomtree: dagball.bytesToBase64(this.toBloomTree().bytes), //deterministic lossless-compressed same bytes as in this.bytes
		aftrans: this.aftrans.toMap(),
	};
};
dagball.mapToBitPic = function(map){
	if(!map || !map.wallPoten || !map.height || !map.width || (!map.bloomtree && !map.bytes && !map.ints) || !map.aftrans){ //2024-1-1 changed from ints to bytes
		Err('Some stuff missing: '+JSON.stringify(map));
	}
	if(map.type != 'dagball_bitpic'){
		Err('Not a dagball_bitpic: '+JSON.stringify(map));
	}
	let bytes;
	let bloomTreePaintsBitPic = false; //in case bloomtree isnt the default (use map.bytes from older code) later
	if(map.bloomtree){
		if(!dagball.isPowOf2(map.height) || map.height != map.width){
			Err('Invalid height and width combo (must be a powOf2 and both equal if bloomtree), h'+map.height+' w'+map.width);
		}
		bytes = new Uint8Array(Math.ceil(map.height*map.width/8)); //start as all 0s, fill in after create BitPic
		bloomTreePaintsBitPic = true;
	}else if(map.bytes || map.ints){
		bytes = dagball.hexToBytes(map.bytes || map.ints);
	}else Err('Does not have bloomtree or bytes (OLD) or ints (OLDEST): '+JSON.stringify(map));
	let bitpic = new dagball.BitPic(
		map.wallPoten,
		map.wallThick || 5,
		map.height,
		map.width,
		bytes, //dagball.hexToBytes(map.bytes || map.ints), //2023-12-31 map.ints existed but then changed it to map.bytes so dont have to deal with endian.
		dagball.mapToSimpleAftrans(map.aftrans)
	);
	if(bloomTreePaintsBitPic){
		let bloomtree = new dagball.BloomTree(dagball.base64ToBytes(map.bloomtree));
		bloomtree.paintOntoBitPic(bitpic);
	}
	return bitpic;
};
dagball.BitPic.prototype.fillRandom = function(){
	for(let i=0; i<this.bytes.length; i++){
		this.bytes[i] = Math.floor(Math.random()*256)&255;
	}
};
/*dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.ints[index>>5]>>(index&31))&1; //littleEndian
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.ints[index>>5] |= (1<<(index&31)); //littleEndian
	}else{
		this.ints[index>>5] &= ~(1<<(index&31)); //littleEndian
	}
};*/
dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.bytes[index>>3]>>(index&7))&1;
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.bytes[index>>3] |= (1<<(index&7));
	}else{
		this.bytes[index>>3] &= ~(1<<(index&7));
	}
};

dagball.BitPic.prototype.toBloomTree = function(){
    if(!dagball.isPowOf2(this.height)){
        throw new Error('BitPic height is not a power of 2');
    }
    if(this.height !== this.width){
        throw new Error('BitPic height and width must be equal');
    }

    // Recursive function for both computing size and filling the array
    let bitCount = 0;
    let bloomByteArray;

    const process = (x, y, size, fillArray)=>{
        let isUniform = true;
        let firstBit = this.readBit(y*this.width+x);

        for(let row=y; row<y+size; row++){ //TODO optimize this. it runs log times more than needs to.
            for(let col=x; col<x+size; col++) {
                if(this.readBit(row*this.width+col) !== firstBit){
                    isUniform = false;
                    break;
                }
            }
            if(!isUniform) break;
        }

        if(fillArray){
			/*this is littleEndian, index 0 being at low 2 bits in byte. 2024-1-1 switching to bigEndian inside byte, so at index 6 and 7.
            //let position = bitCount>>5; //divide by int32 size
			let position = bitCount>>3; //divide by byte size
            //let shift = bitCount%32;
			//let shift = bitCount&31;
			let shift = bitCount&7;
            let value = isUniform ? (firstBit ? dagball.bloomWall : dagball.bloomOpen) : dagball.bloomBranch;
            bloomByteArray[position] |= value << shift;
			*/
			/*//code copied from dagball.BloomTree.prototype.write
			let byteIndex = index>>2;
			let prevByte = this.bytes[byteIndex];
			//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
			let lowestBitIndexInByte = 6-((index&3)<<1);
			//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
			let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
			this.bytes[byteIndex] = prevByteWithoutThose2Bits | (num<<lowestBitIndexInByte);
			*/
			let value = isUniform ? (firstBit ? dagball.bloomWall : dagball.bloomOpen) : dagball.bloomBranch;
			dagball.writeInt2IntoBytes(bloomByteArray, bitCount>>1, value); //bitCount>>1 cuz index is in units of int2s
        }
        
        bitCount += 2; //2 bits for every node

        if(!isUniform){
            const halfSize = size/2;
            process(x, y, halfSize, fillArray); //top left
            process(x+halfSize, y, halfSize, fillArray); //top right
            process(x, y+halfSize, halfSize, fillArray); //bottom left
            process(x+halfSize, y+halfSize, halfSize, fillArray); //bottom right
        }
    };

    // First Pass: Compute the size in bits
    process(0, 0, this.width, false);

    // Allocate the array based on computed size
    //let maxPossibleIntSize = Math.ceil(bitCount/32);
	let maxPossibleByteSize = Math.ceil(bitCount/8);
    bloomByteArray = new Uint8Array(maxPossibleByteSize);

    // Second Pass: Fill the array
    bitCount = 0; // Reset bit counter for the second pass
    process(0, 0, this.width, true);

    return new dagball.BloomTree(bloomByteArray);
};

//like readYX many times in parallel in a 2d grid. uses 2 aftrans, one as param and one in this bitpic.
dagball.BitPic.prototype.paintOntoPotens = function(addHere, addHereHeight, addHereWidth, secondAftrans){
	let i = 0;
	const addY = -secondAftrans.addY/(secondAftrans.magnifyY*this.aftrans.magnifyY)-this.aftrans.addY/this.aftrans.magnifyY;
	const mulY = 1/(secondAftrans.magnifyY*this.aftrans.magnifyY);
	const addX = -secondAftrans.addX/(secondAftrans.magnifyX*this.aftrans.magnifyX)-this.aftrans.addX/this.aftrans.magnifyX;
	const mulX = 1/(secondAftrans.magnifyX*this.aftrans.magnifyX);
	let yy = addY;
	let thisWallPoten = this.wallPoten;
	//xx = (canvasX*mulX+addX)|0;
	//const startCanvasX = Math.max(0, Math.min(Math.ceil(-addX), addHereWidth)); //when canvasX is 0
	/////////////////const startCanvasX = Math.max(0, Math.min(Math.ceil(addX), addHereWidth)); //when canvasX is 0
	//////const startCanvasX = Math.max(0, Math.min(Math.ceil(-addX), this.width)); //when canvasX is 0
	//end, when canvasX*mulX+addX is just past addHereWidth
	//canvasX*mulX+addX==addHereWidth
	//canvasX==(addHereWidth-addX)/mulX
	//const endCanvasXExcl = Math.max(0, Math.min(Math.ceil((addHereWidth-addX)/mulX), addHereWidth));
	//////const endCanvasXExcl = Math.max(0, Math.min(Math.ceil((addHereWidth-addX)/mulX), this.width));
	//for(let canvasY=0; canvasY<addHereHeight; canvasY++){
	for(let canvasY=0; canvasY<addHereHeight; canvasY++){
		//let yy = (canvasY*mulY+addY)|0;
		let xx = addX;
		//let xx = startCanvasX*mulX+addX;
		let yyInt = (yy|0);
		if(0 <= yyInt && yyInt < this.height){
			let yyIntTimesWidth = yyInt*this.width;
			//let yyIntTimesWidth = (yy|0)*addHereWidth; //FIXME?
			//This wraps the game world horizontally when past its edges: for(let canvasX=0; canvasX<addHereWidth; canvasX++){
			//////i += startCanvasX; //skip these xx on left of screen
			//i += startCanvasX; //skip these canvasX on left of screen
			//let i = yyIntTimesWidth+startCanvasX;
			//////for(let canvasX=startCanvasX; canvasX<endCanvasXExcl; canvasX++){
			//for(let canvasX=0; canvasX<addHereWidth; canvasX++){
			//for(let canvasX=startCanvasX; canvasX<addHereWidth; canvasX++){
			for(let canvasX=0; canvasX<addHereWidth; canvasX++){
				//let xx = (canvasX*mulX+addX)|0;
				let xxInt = (xx|0);
				if(0 <= xxInt && xxInt < this.width){
					let index = yyIntTimesWidth+xxInt;
					let readThisBit = (this.bytes[index>>3]>>(index&7))&1;
					let poten = readThisBit*thisWallPoten;
					addHere[i] += poten;
				}
				i++;
				xx += mulX;
			}
		}else{
			i += addHereWidth;
		}
		//////i += addHereWidth-endCanvasXExcl; //skip these xx on right of screen
		yy += mulY;
	}
};

//in game coordinates returns potentialEnergy added by this bitpic there. jagged. if you want the
//smooth bellcurvelike potentialEnergy used for balls, TODO use another func (TODO make one) for that.
dagball.BitPic.prototype.readYX = function(y,x){
	//return .3; //FIXME
	//return x; //FIXME
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	//return y; //FIXME
	//return x; //FIXME
	//return ((Math.hypot(y,x)-2.5)<.02) ? this.wallPoten : 0; //FIXME
	//return Math.hypot(y,x); //FIXME
	//return Math.hypot(yy,xx); //FIXME
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	if(yy < 0 || yy >= this.height || xx < 0 || xx >= this.width){
		return 0; //out of range, its 0s there
	}
	let index = yy*this.width+xx;
	return this.readBit(index)*this.wallPoten;
};
dagball.BitPic.prototype.bilinearReadYX = function(y,x){ //TODO test this (now is 2023-12-30)
	//return x; //FIXME
	let rawYY = this.aftrans.reverseY(y);
	let rawXX = this.aftrans.reverseX(x);
	//return y; //FIXME
	//return x; //FIXME
	//return ((Math.hypot(y,x)-2.5)<.02) ? this.wallPoten : 0; //FIXME
	//return Math.hypot(y,x); //FIXME
	//return Math.hypot(yy,xx); //FIXME
	yy = Math.floor(rawYY);
	xx = Math.floor(rawXX);
	if(yy < 0 || yy >= (this.height-1) || xx < 0 || xx >= (this.width-1)){
		return 0; //out of range, its 0s there
	}
	let y0x0 = this.readBit(yy*this.width+xx);
	let y0x1 = this.readBit(yy*this.width+(xx+1));
	let y1x0 = this.readBit((yy+1)*this.width+xx);
	let y1x1 = this.readBit((yy+1)*this.width+(xx+1));
	let yFraction = rawYY-yy;
	let xFraction = rawXX-xx;
	let bilinear =
		(y0x0*(1-yFraction)*(1-xFraction))+
		(y0x1*(1-yFraction)*(xFraction))+
		(y1x0*(yFraction)*(1-xFraction))+
		(y1x1*(yFraction)*(xFraction));
	return bilinear*this.wallPoten;
};
dagball.BitPic.prototype.writeYXRaw = function(y,x,bit){ //no aftrans
	let index = y*this.width+x;
	this.writeBit(index, bit);
}
dagball.BitPic.prototype.writeYX = function(y,x,bit){
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	if(yy < 0 || yy >= this.height || xx < 0 || xx >= this.width){
		return; //out of range
	}
	let index = yy*this.width+xx;
	this.writeBit(index, bit);
};
dagball.BitPic.prototype.writeYXR = function(y,x,r,bit){
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	let rr = r/this.aftrans.magnifyY; //FIXME magnifyX and magnifyY? theyre probably equal.
	if(rr > dagball.maxRadiusOutToReadOrWriteInBitpicRR){
		Err('Its gonna be very slow. Something likely went wrong. rr='+rr+' and about to double loop 2*rr each')
	}
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	rr = Math.ceil(rr);
	let rr2 = rr*rr;
	for(let yyy=yy-rr; yyy<=yy+rr; yyy++){
		for(let xxx=xx-rr; xxx<=xx+rr; xxx++){
			if(yyy < 0 || yyy >= this.height || xxx < 0 || xxx >= this.width){
				continue; //out of range
			}
			let dy = yyy-yy;
			let dx = xxx-xx;
			if(dy*dy+dx*dx > rr2){
				continue; //not in circle shape of paintbrush
			}
			let index = yyy*this.width+xxx;
			this.writeBit(index, bit);
		}
	}
};
//This is potentialEnergy that balls roll up to make them bounce on the wall or lay on it
//This is _OLD cuz its not using bilinear interpolation (bilinearReadYX) which is making the balls bounce jumpy.
dagball.BitPic.prototype.readSmoothYXR_OLD = function(y,x,r,optionalNumStdDevs){
	let stdDevs = optionalNumStdDevs || 2;
	let stdDevs2 = stdDevs*stdDevs;
	let rawYY = this.aftrans.reverseY(y);
	let rawXX = this.aftrans.reverseX(x);
	//FIXME? let rawRR = (r*stdDevs)/this.aftrans.magnifyY; //FIXME magnifyX and magnifyY? theyre probably equal.
	let rawRR = (r*stdDevs); //FIXME? why doesnt this multiply or divide by magnifyY or magnifyX?
	yy = Math.floor(rawYY);
	xx = Math.floor(rawXX);
	rr = Math.ceil(rawRR);
	if(rr > dagball.maxRadiusOutToReadOrWriteInBitpicRR){
		Err('Its gonna be very slow. Something likely went wrong. rr='+rr+' and about to double loop 2*rr each')
	}
	let rr2 = rr*rr;
	let sumBellHeights = 0;
	for(let yyy=yy-rr; yyy<=yy+rr; yyy++){
		for(let xxx=xx-rr; xxx<=xx+rr; xxx++){
			if(yyy < 0 || yyy >= this.height || xxx < 0 || xxx >= this.width){
				continue; //out of range
			}
			let index = yyy*this.width+xxx;
			let observedBitThere = this.readBit(index);
			if(observedBitThere){
				//let dy = yyy-yy;
				//let dx = xxx-xx;
				let dy = yyy-rawYY;
				let dx = xxx-rawXX;
				let distSq = dy*dy+dx*dx;
				let observedStdDevSquared = distSq/rr2;
				let bellHeight = Math.exp(-.5*observedStdDevSquared); //is height 1 at observedStdDevSquared==0, unlike a normed height bellcurve
				//sumBellHeights += bellHeight*observedBitThere;
				sumBellHeights += bellHeight;
			}
		}
	}
	let weightedAveBellHeights = sumBellHeights;
	weightedAveBellHeights /= rr2; //FIXME is this right? somewhere around there i think.
	return weightedAveBellHeights*this.wallPoten;
	//return weightedAveBellHeights; //already includes this.wallPoten thru 
};
//This is potentialEnergy that balls roll up to make them bounce on the wall or lay on it
//Uses using bilinear interpolation (bilinearReadYX) to (TODO verify this works???) make balls not bounce so jumpy (bounce smooth).
//dagball.BitPic.prototype.readSmoothYXR = function(y,x,r,optionalNumStdDevs)


dagball.BitPic.prototype.readSmoothYXR = function(y,x){
	let r = this.wallThick;
	/*if(!dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap){
		let apeCode = dagball.addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap;
		let ape = Ap.lazyEvalOld(apeCode).ape;
		let jsLambdaCode = ape.jsLambdaCode();
		let jsLambda = TinyGlsl.cachedJsEval(jsLambdaCode);
		dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap = jsLambda;
		console.log('bitpic.readSmoothYXR caching dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap (wont be updated if you change that string) =\n'+
			dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap);
	}*/
	let dist = this.distanceToClosestWall(y,x,r);
	//TODO return dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap(dist);
	if(dist == Infinity) return 0;
	let distFraction = dist/r;
	let closenessFraction = 1-distFraction;
	return this.wallPoten*closenessFraction*closenessFraction;
	//return .3;

	//return 10/(1+dist);
};












































if(graphicsLev>1) game.addFunc(function(Y/*74300*/, X/*74500*/, ay/*10 0 1*/, ax/*20 0 1*/, by/*34 0 1*/, bx/*19 0 1*/, cy/*-10 0 1*/, cx/*-35 0 1*/, dy/*15 0 1*/, dx/*-27 0 1*/, ey/*40 0 1*/, ex/*-20 0 1*/, fy/*-58 0 1*/, fx/*30 0 1*/, gy/*-80 0 1*/, gx/*28 0 1*/){ //hypercubewave
	const sideBits = 5;
	//const sideBits = 8;
	//const sideBits = 9;
	const side = 1<<sideBits;
	const mid = side/2;
	const stdDev = mid/10;
	//const stdDev = mid/5;
	const stdDevSquared = stdDev**2;
	const sideMask = side-1;
	const square = side**2;
	const squareMask = square-1;
	let picA = new Float32Array(square);
	//let xyMul = 52;
	//let xyMul = .5;
	let xyMul = 1.3;
	let offsets = [
		(((ay*xyMul)&sideMask)<<sideBits) | ((ax*xyMul)&sideMask),
		(((by*xyMul)&sideMask)<<sideBits) | ((bx*xyMul)&sideMask),
		(((cy*xyMul)&sideMask)<<sideBits) | ((cx*xyMul)&sideMask),
		(((dy*xyMul)&sideMask)<<sideBits) | ((dx*xyMul)&sideMask),
		(((ey*xyMul)&sideMask)<<sideBits) | ((ex*xyMul)&sideMask),
		(((fy*xyMul)&sideMask)<<sideBits) | ((fx*xyMul)&sideMask),
		(((gy*xyMul)&sideMask)<<sideBits) | ((gx*xyMul)&sideMask),
	]
	let sumDy = 0, sumDx = 0;
	//for(let offset of offsets){
	for(let i=0; i<offsets.length; i++){
		let offset = offsets[i];
		sumDy += offset>>>sideBits; //y from 0 to side-1
		sumDx += offset&sideMask; //x from 0 to side-1
	}
	//let maxCenterAdjust = mid*.7; //dont move center outside the picA/picB square
	let maxCenterAdjust = mid*.9; //dont move center outside the picA/picB square
	//let maxCenterAdjust = mid*1.7; //dont move center outside the picA/picB square
	sumDy = Math.max(-maxCenterAdjust, Math.min(sumDy, maxCenterAdjust));
	sumDx = Math.max(-maxCenterAdjust, Math.min(sumDx, maxCenterAdjust));
	for(let i=0; i<square; i++){ //fill in 1 bellcurve at center of picA
		let y = i>>>sideBits;
		let x = i&sideMask;
		//let bellY = mid+sumDy*2;
		//let bellX = mid-sumDx*0;
		//let bellY = -sumDy/2;
		//let bellX = -sumDx/2;
		let bellY = mid-sumDy/2;
		let bellX = mid-sumDx/2;
		//let devSquared = ((y-mid)**2 + (x-mid)**2)/stdDevSquared;
		let devSquared = ((y-bellY)**2 + (x-bellX)**2)/stdDevSquared;
		let bellHeight = Math.exp(-devSquared);
		picA[i] = bellHeight;
	}
	for(let offset of offsets){
		if(offset==0) Y.poten += 10; //resist the params being exactly 0 after roundoff, cuz they dont copy picA when they are.
	}
	let picB = new Float32Array(square);
	for(let dup=0; dup<offsets.length; dup++){
		let offset = offsets[dup];
		if(offset){ //cant copy 2 of them to the exact same place, one positive and one negative, cuz it cancels out.
			for(let i=0; i<square; i++){
				//copy picA 2 times onto picB,
				//once as is and once 2d position offset and negated brightness
				picB[i] = picA[i] - picA[(i+offset)&squareMask]; //wrap. TODO dont wrap
			}
			[picA, picB] = [picB, picA];
		}
	}
	for(let i=0; i<square; i++) picA[i] = Math.abs(picA[i]);
	let sum = 0;
	for(let i=0; i<square; i++) sum += picA[i];
	let ave = sum/square;
	let vox = [];
	//let limit = ave*3.5;
	let limit = ave*1.5;
	let magnify = 4;
	let addA = YXC(2,0,0); //make 4 voxels instead of 1, cuz magnify is 2.
	let addB = YXC(0,2,0);
	let addC = YXC(2,2,0);
	for(let i=0; i<square; i++){
		//if(limit < picA[i] || i==0 || i==square-1){ //i==0 || i==square-1, is 2 corners to show the square its painting in.
		if(limit < picA[i]){
			let localY = i>>>sideBits;
			let localX = i&sideMask;
			let y = Y + (localY - mid)*magnify;
			let x = X + (localX - mid)*magnify;
			let color = 0b011111;
			let voxel = YXC(y,x,color);
			vox.push(voxel);
			vox.push(voxel+addA);
			vox.push(voxel+addB);
			vox.push(voxel+addC); //FIXME might wrap around at edges
		}
	}
	Y.poten += .1*((Y.p-74100)**2 + (X.p-74425)**2); //attract to that
	Y.kv += .315;
	X.kv += .315;
	//let flatZone = mid/8.5; //each (y,x) param pair, except the first 2, is a vector. we dont push on it if its within the flatZone radius. We do if it gets too big.
	let flatZone = 7;
	for(let i=2; i<arguments.length; i+=2){
		let kv = .2;
		let varY = arguments[i], varX = arguments[i+1];
		varY.kv += kv;
		varX.kv += kv;
		let len = Math.hypot(varY.p,varX.p);
		if(len > flatZone){
			varY.poten += .7*(len-flatZone)**2;
		}
		//varY.dp += 10; (Math.random()*2-1)*10;
		//varY.dp += (Math.random()*2-1)*.31;
	}
	//for(let i=2; i<arguments.length; i+=2){
	//	arguments[i].dp += (Math.random()*2-1)*.11;
	//}
	return vox;
});


//game.addFunc(function(Y/*505000*/, X/*506000*/, momentum/*5 0 1*/, shift/*15 0 1*/, pulse/*25 0 1*/, wave/*35 0 1*/, flicker/*45 0 1*/, doorAngle/*30 0 1*/) {
if(graphicsLev>1) game.addFunc(function(Y/*75000*/, X/*76000*/, momentum/*5 0 1*/, wave/*35 0 1*/, doorAngle/*30 0 1*/) {
	const baseSize = 300; // Base size of the structure
	const wallThickness = 40; // Wall thickness
	const doorThickness = wallThickness / 2; // Door thickness, half that of the wall
	const voxels = [];
	// Define the three remaining sides of the box (excluding the side where the door will be)
	const sides = [
		{ start: 0, end: baseSize, orientation: 'horizontal', displacement: 0 }, // Top side
		{ start: 0, end: baseSize, orientation: 'vertical', displacement: 0 }, // Left side
		{ start: 0, end: baseSize, orientation: 'vertical', displacement: baseSize } // Right side
	];
	// Create walls
	sides.forEach(side => {
		for (let i = side.start; i < side.end; i++) {
			for (let j = 0; j < wallThickness; j++) { // Apply set thickness
				let y = (side.orientation === 'horizontal') ? Y.p + side.displacement : Y.p + i;
				let x = (side.orientation === 'horizontal') ? X.p + i : X.p + side.displacement;
				if (side.orientation === 'horizontal') {
					y += j; // Expand thickness horizontally
				} else {
					x += j; // Expand thickness vertically
				}
				const color = 0b101010; // Consistent color for the structure
				voxels.push(YXC(y, x, color));
			}
		}
	});
	// 6-way rotating door replacing the bottom wall, spans the entire length of the wall
	const doorLength = baseSize; // Door spans the entire wall length
	const doorCenterY = Y.p + baseSize; // Positioning the door at the bottom
	const doorCenterX = X.p + baseSize / 2;
	const angle = doorAngle.p * Math.PI / 180; // Convert angle from degrees to radians
	for (let k = 0; k < 6; k++) { // Six arms
		const armAngle = angle + k * Math.PI / 3; // Dividing 360 degrees into six parts
		for (let l = 0; l < doorLength / 2; l++) { // Length of each arm, adjusted to fit
			for (let m = 0; m < doorThickness; m++) { // Apply half thickness
				const y = doorCenterY + l * Math.sin(armAngle) + m * Math.cos(armAngle); // Offset for thickness
				const x = doorCenterX + l * Math.cos(armAngle) - m * Math.sin(armAngle); // Offset for thickness
				const color = 0b010101; // Color for the door
				voxels.push(YXC(Math.round(y), Math.round(x), color));
			}
		}
	}
	// Increase sensitivity to interaction by lowering the rotational inertia
	doorAngle.dv += momentum.p * 0.0001; // Lower inertia for easier rotation
	// Velocity decay
	Y.kv += .3;
	X.kv += .3;
	momentum.kv += .1;
	doorAngle.kv += 1.7;
	// Potentially attract to the center position
	Y.poten += 0.01 * (75000 - Y.p)**2; // Gradually attract Y to the center position
	X.poten += 0.01 * (76000 - X.p)**2; // Gradually attract X to the center position
	return voxels;
});


var mouse = game.addFunc((Y, X)=>{
	//let Y = {p:Controls.mouseY};
	//let X = {p:Controls.mouseX};
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				//let color = 0b110011;
				let color = 0b000111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	//Y.kv += .1;
	//X.kv += .1;
	//heightToWidthRatio.kv += .003;
	Y.set(Controls.mouseY);
	X.set(Controls.mouseX);
	return ret;
});
mouse.m.isSelectable = false;
//mouse.m.displayText = 'mouse';


//const ExampleWallVoxels = Float64Array.of(3761487178300722,0,1,2,3,-1);
//game.addFunc("(Y/*75000*/, X/*76000*/)=>Walls('"+Wally(ExampleWallVoxels)+"')");











//Canvas and ByteRect code are opensource MIT licensed
//(parts from benrayfield's various other projects including https://jsfiddle.net/q687fcrk/1/ and
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html )

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA;

//modified https://github.com/benrayfield/jsutils/blob/master/src/FullScreenCanvasPrototype.html
var FullScreenCanvas = function(optionalHeight, optionalWidth, optionalParentDom){ //FullScreenCanvas opensource MIT licensed by Ben F Rayfield
	let parentDom = optionalParentDom  || document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	//else uses window size. FIXME also 
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		let targetHeight = optionalHeight || window.innerHeight;
		let targetWidth = optionalWidth || window.innerWidth;
		if(this.dom.height != targetHeight) this.dom.height = targetHeight;
		if(this.dom.width != targetWidth) this.dom.width = targetWidth;
	};
	
	/*//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	//FIXME reuse some of these vars. might be slowing it down doing getContext and imageData every time, for example,
	//but careful with that cuz canvas doesnt update if you do this wrong.
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		
		//this.context = this.dom.getContext('2d');
		//cuz got this warning 2023-9-2: ForestCurveFit004.html:1503 Canvas2D: Multiple readback operations using getImageData
		//are faster with the willReadFrequently attribute set to true.
		//See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
		this.context = this.dom.getContext('2d', {willReadFrequently: true});

		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};*/
	this.beforePaint = function(){
		if(this.dom == null) throw new Error('No canvas');

		// Create the context if it doesn't exist
		if(!this.context){
			this.context = this.dom.getContext('2d', {willReadFrequently: true});
		}

		//Only create image data if it doesn't exist or if the canvas size has changed
		if(!this.imageData || this.imageData.width !== this.dom.width || this.imageData.height !== this.dom.height){
			this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
			this.pixels = this.imageData.data;
			this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
		}
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw new Error('No canvas');
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)];
};


ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(y*this.width+x)*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	if(x < 0 || this.width <= x || y < 0 || this.height <= y) return;
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

var canv = null;

var endingCanv = false;

/** utc time in seconds */
var time = function(){
	//FIXME use the code from dagball for more precise time using performance.now and an offset
	return Date.now()*.001;
};

var timeStarted = 0;

/** get bellcurve height on a chosen bellcurve thats stretched and moved */
var bell = function(ave, dev, maxHeight, observe){
	let diff = (observe-ave)/dev;
	return Math.exp(-diff*diff);
};

/*var sigmoid = function(x){
	return .5+.5*Math.tanh(x);
};*/

//0 to 255
var backgroundRed = 0;
var backgroundGreen = 0;
var backgroundBlue = 0;


//age in seconds since transition started. Just paints onto ByteRect
var doGraphicsDtAgeByterect = function(dt, age, byteRect){

	//dt *= 20;
	//dt *= 10;
	//2024-11-26 moving this to just before doGraphicsDtAgeByterect is called so speed profiler in browser can measure them separately easier: game.nextState(dt);

	let bytes = byteRect.bytes;
	let offset = Math.floor(Math.sin(time()*5*2*Math.PI)*100+100);
	let w = byteRect.width;
	let h = byteRect.height;
	let cx = Math.floor(w/2); //center x
	let cy = Math.floor(h/2); //center y
	/*for(let i=0; i<bytes.length; i+=4){
		bytes[i+RED] = backgroundRed;
		bytes[i+GREEN] = backgroundGreen;
		bytes[i+BLUE] = backgroundBlue;
		bytes[i+ALPHA] = 255;
	}*/
	let i = 0;
	//let viewRect = game.getViewRect
	//let fromY = game.Y;
	//let toY = fromY+h;
	//let fromX = game.X;
	//let toX = fromX+w;
	
	let screenH = canv.dom.height;
	let screenW = canv.dom.width;
	let centerYGameCoords = game.Y.p; //FIXME until 2024-11-14-1206pET game.Y and game.X were top left corner. i might want it to be center of view.
	let centerXGameCoords = game.X.p; //FIXME until 2024-11-14-1206pET game.Y and game.X were top left corner. i might want it to be center of view.
	let gameDisplayH = screenH*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameDisplayW = screenW*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameFromY = game.Y.p-gameDisplayH/2;
	let gameFromX = game.X.p-gameDisplayW/2;
	let gameDy = game.zoom.p;
	let gameDx = game.zoom.p;
	//for(let y=fromY; y<toY; y++){
		//for(let x=fromX; x<toX; x++){
	let zoomedY = gameFromY;
	//const wrap = true; //display around the 8kX8k window
	//const wrap = false; //display only 1 8kX8k window without wrapping
	for(let screenY=0; screenY<screenH; screenY++){
		let zoomedX = gameFromX;
		for(let screenX=0; screenX<screenW; screenX++){
			//if(wrap || (0 <= zoomedY && zoomedY < Size && 0 <= zoomedX && zoomedX < Size)){ //in game area
			//	bytes[i+RED] = game.redByteAtYX(zoomedY,zoomedX);
			//	bytes[i+GREEN] = game.greenByteAtYX(zoomedY,zoomedX);
			//	bytes[i+BLUE] = game.blueByteAtYX(zoomedY,zoomedX);
			if(MinY <= zoomedY && zoomedY <= MaxY && MinX <= zoomedX && zoomedX <= MaxX){ //in game area which is about a million by a million (2**20)
				bytes[i+RED] = game.redByteAtYX(zoomedY,zoomedX);
				bytes[i+GREEN] = game.greenByteAtYX(zoomedY,zoomedX);
				bytes[i+BLUE] = game.blueByteAtYX(zoomedY,zoomedX);
			}else{
				bytes[i+RED] = 40; //very dark gray background outside the 8kX8k square
				bytes[i+GREEN] = 40;
				bytes[i+BLUE] = 40;
			}
			/*bytes[i+RED] = game.redByteAtYX(y,x);
			bytes[i+GREEN] = game.greenByteAtYX(y,x);
			bytes[i+BLUE] = game.blueByteAtYX(y,x);
			*/
			bytes[i+ALPHA] = 255; //visible, not transparent
			i += 4;
			zoomedX += gameDx;
		}
		zoomedY += gameDy;
	}

};

Game.prototype.setSelectedGob = function(gob){
	let i = this.gobs.indexOf(gob);
	if(i == -1) this.gobs.push(gob); //selecting a gob that wasnt added yet
	for(let g of this.gobs){
		g.m.isSelected = (g===gob);
	}
	document.getElementById('mainTextarea').value = ''+gob.brain;
	return gob;
};

Game.prototype.searchGobs = function(query){
	return this.gobs.filter(query);
};

Game.prototype.selectedGobs = function(){
	return this.searchGobs(g=>(g.m.isSelected));
};

var SEL = function(){ //get first selected gob or null
	return game.selectedGobs()[0] || null;
};

var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;

//get array index mouse last touched, for game.board[mouseI()] and game.rps.boardR[mouseI()] and boardG and boardB.
var mouseI = ()=>((Controls.mouseY<<SizeBits)|Controls.mouseX);

var DefaultTextColor = '#33ff55';

/*canv.dom.addEventListener('mousemove', event=>{
	let prevRawMouseY = Controls.rawMouseY;
	let prevRawMouseX = Controls.rawMouseX;
	Controls.rawMouseY = event.offsetY;
	Controls.rawMouseX = event.offsetX;
	let mouseDy = Controls.rawMouseY-prevRawMouseY;
	let mouseDx = Controls.rawMouseX-prevRawMouseX;
	if(Controls.mouseButton0){ //dragging the ground to move view
		game.Y.p -= mouseDy*game.zoom.p;
		game.X.p -= mouseDx*game.zoom.p;
		//game.Y = Math.max(0, Math.min(game.Y, Size-canv.dom.height))&SizeMask;
		//game.X = Math.max(0, Math.min(game.X, Size-canv.dom.width))&SizeMask;
		//console.log('game.Y='+game.Y+' x='+game.X);
	}
	Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)&SizeMask;
	Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)&SizeMask;;
});
*/
var afterAfterPaint = canv=>{ //doOverlays. canv is the FullScreenCanvas instance. canv.dom is the canvas. canv.context is the canvas context object.
	let ctx = canv.context;
	let g = game; //FIXME could be multiple games, one per namespace like V.testnet.game and V.otherNamespace.game.
	for(let gob of g.gobs){ //those displayed. normally should be alot more of them in the namespace. those displayed are also in that namespace.
		let displayText = gob.m.displayText;
		//if(displayText && gob == mouse){
		if(displayText){
			//throw new Error('FIXME gob.getVar(\'Y\') is causing error with Proxy or something');
			let gobY = gob.Y.p;
			let gobX = gob.X.p;
			//let canvasY = ((gobY-game.Y.p)*game.zoom.p)&SizeMask;
			//let canvasX = ((gobX-game.X.p)*game.zoom.p)&SizeMask;
			//let canvasY = (((gobY-game.Y.p)*game.zoom.p)+canv.dom.height/2)|0;
			//let canvasX = (((gobX-game.X.p)*game.zoom.p)+canv.dom.width/2)|0;
			//let canvasY = (((gobY-game.Y.p)*game.zoom.p))|0;
			//let canvasX = (((gobX-game.X.p)*game.zoom.p))|0;
			let cH = canv.dom.height;
			let cW = canv.dom.width;
			let canvasY = (((gobY-game.Y.p)/game.zoom.p)+cH/2)|0;
			let canvasX = (((gobX-game.X.p)/game.zoom.p)+cW/2)|0;
			canvasX += 12;
			//canvasY += 7;
			canvasY -= 3;
			//canvasY = 300;
			//canvasX = 300;
			//ctx.fillStyle = '#33ff55'; //green
			ctx.fillStyle = (gob.voxInGame && gob.voxInGame.length) ? IColorStr(gob.voxInGame[0]) : DefaultTextColor; //color of first voxel
			//ctx.fillText("Hello world "+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world cY="+canvasY+'_cX='+canvasX+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' zoom='+game.zoom.p+' '+gob.bo.name, 300, 300);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' zoom='+game.zoom.p+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText(displayText, canvasX, canvasY);
			for(let line of displayText.split('\n')){
				ctx.fillText(line, canvasX, canvasY);
				canvasY += 15;
			}
			//ctx.fillText("Hello world", 10, 50);
		}
	}
};

var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		//canv = new FullScreenCanvas();
		//let magnify = 2; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		let magnify = 3;
		if(graphicsLev < 2) magnify *= 2; //half the width and height so it runs faster
		//let magnify = 4; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		let h = window.innerHeight/magnify;
		let w = window.innerWidth/magnify;
		canv = new FullScreenCanvas(h, w);
		let dom = canv.dom;
		dom.style.display = 'block';
		dom.style.transformOrigin = '0 0';
		dom.style.position = 'absolute';
		dom.style['z-index'] = -1;
		dom.style.top = '0';
		dom.style.left = '0';
		dom.setAttribute('tabIndex', 0); //make canvas focusable
		dom.style.transform = `scaleX(${magnify}) scaleY(${magnify})`;
		dom.style.cursor = 'none'; //hide mouse pointer when over canvas cuz mouseball (in game.addFunc theres one that checks Controls.mouseY etc) is there.
		document.body.addEventListener('keyup', event=>{
			if(event.key == 'Pause'){
				Controls.pause = Controls.pause ? 0 : 1; //toggle
				if(!Controls.pause){
					console.log('Unpause');
					requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
				}
			}
		});

		
		canv.dom.addEventListener('mousemove', event=>{
			let prevRawMouseY = Controls.rawMouseY;
			let prevRawMouseX = Controls.rawMouseX;
			Controls.rawMouseY = event.offsetY;
			Controls.rawMouseX = event.offsetX;
			let mouseDy = Controls.rawMouseY-prevRawMouseY;
			let mouseDx = Controls.rawMouseX-prevRawMouseX;
			if(Controls.mouseButton0){ //dragging the ground to move view
				game.Y.p -= mouseDy*game.zoom.p;
				game.X.p -= mouseDx*game.zoom.p;
				//game.Y = Math.max(0, Math.min(game.Y, Size-canv.dom.height))&SizeMask;
				//game.X = Math.max(0, Math.min(game.X, Size-canv.dom.width))&SizeMask;
				//console.log('game.Y='+game.Y+' x='+game.X);
			}
			//Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)&SizeMask;
			//Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)&SizeMask;;
			//dont limit to SizeMask cuz it wraps around SizeXSize aka 8192X8192.
			Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)|0;
			Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)|0;
		});
		document.body.addEventListener('mousedown', event=>{
			//console.log('mousedown button='+event.button);
			if(event.button==0){ //dragging the ground to move view
				Controls.mouseButton0 = 1;
				Controls.rawMouseYWhenStartedDrag = Controls.rawMouseY;
				Controls.rawMouseXWhenStartedDrag = Controls.rawMouseX;
			}
		});
		document.body.addEventListener('mouseup', event=>{
			if(event.button==0){
				Controls.mouseButton0 = 0;
			}
		});
		document.body.addEventListener('wheel', function(event) {
			event.preventDefault(); // Prevents the default scrolling behavior
			const scrollAmount = event.deltaY; // Gets the vertical scroll amount
			game.onMouseWheelChange(scrollAmount); // Calls your function with the scroll amount
		}, {passive: false}); // Setting passive to false allows you to call preventDefault
		//canv.dom.style.cursor = "none"; //hide mouse cursor cuz its slightly out of sync with the player's blob and is annoying
	}
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	game.nextState(dt);
	doGraphicsDtAgeByterect(dt, age, canv.byteRect);
	canv.afterPaint();
	afterAfterPaint(canv); //must be after canv.afterPaint(), like in dagball its called afterAfterPaint. renaming this from doOverlays to afterAfterPaint.
	//setTimeout(doGraphicsDtAgeByterectAndMore, 1); //FIXME do requestAnimationFrame instead, for lower lag? or does waiting 1 more millisecond give it time to do other UI things?
	if(Controls.pause){
		console.log('Pause');
	}else{
		requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
	}
};

//moving this up, to replace other INF const: const INF = 1<<29;
//const distSqArrays = []; //sideBits -> Int32Array(1<<(sideBits<<1)). reuse.


//given 6 uint10s, 3 of them in each int i j, returns 3 uint10s in an int.
const triMin = (i,j)=>{
	let iLow = i&mask10;
	let jLow = j&mask10;
	let iMid = (i>>>10)&mask10;
	let jMid = (j>>>10)&mask10;
	let iHigh = (i>>>20)&mask10;
	let jHigh = (j>>>20)&mask10;
	let low = iLow<jLow ? iLow : jLow;
	let mid = iMid<jMid ? iMid : jMid;
	let high = iHigh<jHigh ? iHigh : jHigh;
	return (high<<20)|(mid<<10)|low;
};

//updates this.rps.tridist based on the team at each voxel. FIXME should i make game.rps.team as a Uint8Array or maybe a packed 1 bit per pixel int array?
//Game.prototype.updateTridist = function(yFrom, yTo, xFrom, xTo){
Game.prototype.updateTridist = function(smallYFrom, smallYTo, smallXFrom, smallXTo, optionalBorder){
	const rpsTeam = this.rps.team;
	//const rpsTridist = this.rps.tridist;
	const rpsTridistSmall = this.rps.tridistSmall;
	const endSize = Size*4;
	//let border = 50; //FIXME dont hardcode this
	let border = optionalBorder || 32;
	let innerSmallYFrom = smallYFrom+border;
	let innerSmallYTo = smallYTo-border;
	let innerSmallXFrom = smallXFrom+border;
	let innerSmallXTo = smallXTo-border;
	
	for(let smallY=smallYFrom; smallY<smallYTo; smallY++){
		let smallYIsInner = innerSmallYFrom <= smallY && smallY < innerSmallYTo;
		for(let smallX=smallXFrom; smallX<smallXTo; smallX++){
			let smallI = (smallY<<SmallSizeBits)|smallX;
			let teams = 0;
			let topLeftI = toBig(smallI); //top left of the 4x4, where 16 indexs in the big arrays aligns to 1 index in small array.
			for(let dyAdd=0; dyAdd<endSize; dyAdd+=Size){ //MagnifyShift==2 meaning 4x4 aka (1<<2)**2
				for(let dx=0; dx<4; dx++){
					let i = (topLeftI+dyAdd)|dx;
					teams |= rpsTeam[i]; //get all teams in the 4x4
				}
			}
			
			//TODO rename game.rps.team to game.rps.teams cuz it can have a powerset of all 3 teams?
			//let teams = rpsTeam[i]; //can be REDTEAM, BLUETEAM, GREENTEAM, or any 2 or 3 of those. Each next team that is added there xors a mask bit.
			//&7 soonly 3 teams in 8 possible combos (powerset), meaning is there an even vs odd number of that team at that voxel. its reversible. addVox remVox.
			//3 uint10s that are max (1023) if it needs to be recomputed, or is 0 to mean that team is here so distance from it is 0.
			//rpsTridist[i] = teamsToTridistInt[teams&7];
			
			let isInner = smallYIsInner && (innerSmallXFrom <= smallX && smallX < innerSmallXTo);
			if(isInner){
				//rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
				rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
			}else{
				rpsTridistSmall[smallI] = triMin(rpsTridistSmall[smallI],teamsToTridistInt[teams&7]);
				//throw new Error('TODO dont overwrite distances but take minimum 3 times');
			}
			
			
			//rpsTridistSmall[toSmall(i)] = teamsToTridistInt[teams&7];
			//rpsTridist[i] = teams==REDTEAM ? 0 : 1023;
			//rpsTridist[i] = randInt(1024);
			//rpsTridist &= mask10; //FIXME remove this. its all red, the low 10 bits.
		}
	}
	//computeUint10Distances(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	//computeUint10Distances(rpsTridistSmall, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	computeUint10Distances(rpsTridistSmall, SmallSizeBits, smallYFrom, smallYTo, smallXFrom, smallXTo); //modifies rpsTridist
	//broken and made it twice as slow so not pursuing this for now: computeUint10Distances2x2Magnify(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
};

//color is a uint6. distanceSquaredArray is 1 of game.rps.boardR or game.rps.boardG or game.rps.boardB.
//OLD: colorChannel is RED or GREEN or BLUE as in "const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;".
//Only does the top left 1024x1024, not the whole 8192x8192 but that is planned to do sparsely later.
//Gotta get it working in basic way first, to play rock paper scissors per voxel.
Game.prototype.updateDistanceCacheOLD = function(distanceSquaredArray, color){
	const sideBits = 10; //1024x1024
	const side = 1<<sideBits;
	const fromY = 0, fromX = 0; //make sure it doesnt hang off the end of the 8192x8192
	const board = this.board;
	let countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				countVoxelsOfThatColor++;
			}
		}
	}
	let voxelsY = new Int16Array(countVoxelsOfThatColor);
	let voxelsX = new Int16Array(countVoxelsOfThatColor);
	countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				voxelsY[countVoxelsOfThatColor] = y;
				voxelsX[countVoxelsOfThatColor++] = x;
			}
		}
	}
	let distanceSquareds = computeSquaredDistances(sideBits, voxelsY, voxelsX); //1024x1024 if sideBits is 10
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			//let voxel = board[offset+movedX];
			//distanceSquared may be approximate or exact, depending on computeSquaredDistances has at least 2 implementations.
			let distanceSquared = distanceSquareds[(y<<sideBits)|x];
			distanceSquaredArray[(movedY<<SizeBits)|movedX] = distanceSquared;
		}
	}
};

/*const computeSquaredDistances = (sideBits, voxelYs, voxelXs)=>{
	//return computeSquaredDistances_exactButSlow(sideBits, voxelYs, voxelXs);
	//return computeSquaredDistances_approximateAndHexagonsAndFast(sideBits, voxelYs, voxelXs);
	return computeBalancedDistances(sideBits, voxelYs, voxelXs);
	
	//TODO make something like computeSquaredDistances_approximateAndHexagonsAndFast
	//but find a way to make it exact like computeSquaredDistances_exactButSlow and still fast.
	//The main difference is computeSquaredDistances_exactButSlow works by intersection of 2 parabolas in the 2 vertical steps.
};*/

// Lambda functions for extracting and setting distances
const mask10 = 0x3FF; //10 bit mask
const getDistance1 = (val) => (val & mask10); //approx distance (scaled by 3 or 4 depending on angle) to nearest REDTEAM voxel, given a tridist int.
const getDistance2 = (val) => ((val >> 10) & mask10); //GREENTEAM. See teamShift int array.
const getDistance3 = (val) => ((val >> 20) & mask10); //BLUETEAM. FIXME is this right? did i mix up teams and order of bits here?
const setDistances = (d1, d2, d3) => ((d1 & mask10) | ((d2 & mask10) << 10) | ((d3 & mask10) << 20)); //makes an int for game.rps.tridist



//size->Int32Array(size)
const reusableIntArrays = {};
const reusableIntArray = size=>(reusableIntArrays[size] || (reusableIntArrays[size] = new Int32Array(size)));

//given 2 ints that each contain 3 uint10s, return 3 averages as an int, rounding down for each.
//This works 2024-11-12 but computeUint10Distances2x2Magnify does not, and since computeUint10Distances2x2Magnify is slow im trying something different,
//gonna make game.rps.tridist half size. or... maybe i should just reduce to 512x512 resolution and magnify the canvas. try that for now.
const tridistAve = (trintA,trintB)=>{
	let low10 = ((trintA&1023)+(trintB&1023))>>1;
	//let mid10 = ((trintA&0b11111111110000000000)+(trintB&0b11111111110000000000))>>1;
	let mid10 = ((trintA>>10)+(trintB>>10))<<9;
	//wait, is this gonna be the same as just (trintA+trintB)>>1? Try it...
	//return (trintA+trintB)>>1;
	let high10 = ((trintA>>>20)+(trintB>>20))<<19;
	return high10|mid10|low10;
};


//const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo)=>{
//If you use use a half (2x2) size 2d array, you'd use orthogonal 6 (default 3) and diagonal 8 (default 4),
//then interpolate between after it returns, or 1/4 size (4x4) would use orthogonal 12 diagonal 16, then interpolate.
//If you use bigger orthogonal andOr diagonal than those defaults, you might want to reduce maxDist (default 1019)
//so 1 more hop past that does not overflow uint10,
//and maybe a little less than that so 1023 (the max uint10) can mean havent processed this pixel.
const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo, orthogonalDist, diagonalDist, optionalMaxDist)=>{
	const orthogonal = orthogonalDist || 3;
	const diagonal = diagonalDist || 4;
	const maxDistance = optionalMaxDist || 1019;
	const mask10 = 0x3FF;
	const offset = 1 << shift;

	// Precompute bit masks
	const mask1 = mask10;
	const mask2 = mask10 << 10;
	const mask3 = mask10 << 20;

	// First pass: Top-left to bottom-right
	for (let y = yFrom; y < yTo; y++) {
		for (let x = xFrom; x < xTo; x++) {
			//let i = (y << shift) | x;
			let wrappedY = y&SmallSizeMask;
			let wrappedX = x&SmallSizeMask;
			let i = (wrappedY << shift) | wrappedX;

			// Current distances
			let val = tridist[i];
			let dist1 = val & mask1;
			let dist2 = (val >>> 10) & mask10;
			let dist3 = (val >>> 20) & mask10;

			// Neighbor indices
			let i_nw = i - offset - 1;
			let i_n = i - offset;
			let i_w = i - 1;
			let i_ne = i - offset + 1;
			/*
			//wrap around SmallSize X SmallSize aka the 2048 X 2048 that fits 4x4 magnified in the 8192 X 8192 Size X Size
			// Neighbor indices
			let i_nw = (i - offset - 1)&SmallSizeMask;
			let i_n = (i - offset)&SmallSizeMask;
			let i_w = (i - 1)&SmallSizeMask;
			let i_ne = (i - offset + 1)&SmallSizeMask;
			*/
			

			// Ensure indices are within bounds
			// (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
			// Otherwise, add boundary checks here.

			// Distances from neighbors
			let d1_nw = (tridist[i_nw] & mask1) + diagonal;
			let d1_n = (tridist[i_n] & mask1) + orthogonal;
			let d1_w = (tridist[i_w] & mask1) + orthogonal;
			let d1_ne = (tridist[i_ne] & mask1) + diagonal;

			let newDist1 = dist1;
			if (d1_nw < newDist1) newDist1 = d1_nw;
			if (d1_n < newDist1) newDist1 = d1_n;
			if (d1_w < newDist1) newDist1 = d1_w;
			if (d1_ne < newDist1) newDist1 = d1_ne;
			if (newDist1 > maxDistance) newDist1 = maxDistance;

			// Repeat for dist2
			let d2_nw = ((tridist[i_nw] >>> 10) & mask10) + diagonal;
			let d2_n = ((tridist[i_n] >>> 10) & mask10) + orthogonal;
			let d2_w = ((tridist[i_w] >>> 10) & mask10) + orthogonal;
			let d2_ne = ((tridist[i_ne] >>> 10) & mask10) + diagonal;

			let newDist2 = dist2;
			if (d2_nw < newDist2) newDist2 = d2_nw;
			if (d2_n < newDist2) newDist2 = d2_n;
			if (d2_w < newDist2) newDist2 = d2_w;
			if (d2_ne < newDist2) newDist2 = d2_ne;
			if (newDist2 > maxDistance) newDist2 = maxDistance;

			// Repeat for dist3
			let d3_nw = ((tridist[i_nw] >>> 20) & mask10) + diagonal;
			let d3_n = ((tridist[i_n] >>> 20) & mask10) + orthogonal;
			let d3_w = ((tridist[i_w] >>> 20) & mask10) + orthogonal;
			let d3_ne = ((tridist[i_ne] >>> 20) & mask10) + diagonal;

			let newDist3 = dist3;
			if (d3_nw < newDist3) newDist3 = d3_nw;
			if (d3_n < newDist3) newDist3 = d3_n;
			if (d3_w < newDist3) newDist3 = d3_w;
			if (d3_ne < newDist3) newDist3 = d3_ne;
			if (newDist3 > maxDistance) newDist3 = maxDistance;

			// Combine distances back into a single integer
			tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
		}
	}

	// Second pass: Bottom-right to top-left
	for (let y = yTo - 1; y >= yFrom; y--) {
		for (let x = xTo - 1; x >= xFrom; x--) {
			//let i = (y << shift) | x;
			let wrappedY = y&SmallSizeMask;
			let wrappedX = x&SmallSizeMask;
			let i = (wrappedY << shift) | wrappedX;

			// Current distances
			let val = tridist[i];
			let dist1 = val & mask1;
			let dist2 = (val >>> 10) & mask10;
			let dist3 = (val >>> 20) & mask10;

			// Neighbor indices
			let i_se = i + offset + 1;
			let i_s = i + offset;
			let i_e = i + 1;
			let i_sw = i + offset - 1;
			/*//wrap around SmallSize X SmallSize aka the 2048 X 2048 that fits 4x4 magnified in the 8192 X 8192 Size X Size
			// Neighbor indices
			let i_se = (i + offset + 1)&SmallSizeMask;
			let i_s = (i + offset)&SmallSizeMask;
			let i_e = (i + 1)&SmallSizeMask;
			let i_sw = (i + offset - 1)&SmallSizeMask;
			*/
			

			// Ensure indices are within bounds
			// (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
			// Otherwise, add boundary checks here.

			// Distances from neighbors
			let d1_se = (tridist[i_se] & mask1) + diagonal;
			let d1_s = (tridist[i_s] & mask1) + orthogonal;
			let d1_e = (tridist[i_e] & mask1) + orthogonal;
			let d1_sw = (tridist[i_sw] & mask1) + diagonal;

			let newDist1 = dist1;
			if (d1_se < newDist1) newDist1 = d1_se;
			if (d1_s < newDist1) newDist1 = d1_s;
			if (d1_e < newDist1) newDist1 = d1_e;
			if (d1_sw < newDist1) newDist1 = d1_sw;
			if (newDist1 > maxDistance) newDist1 = maxDistance;

			// Repeat for dist2
			let d2_se = ((tridist[i_se] >>> 10) & mask10) + diagonal;
			let d2_s = ((tridist[i_s] >>> 10) & mask10) + orthogonal;
			let d2_e = ((tridist[i_e] >>> 10) & mask10) + orthogonal;
			let d2_sw = ((tridist[i_sw] >>> 10) & mask10) + diagonal;

			let newDist2 = dist2;
			if (d2_se < newDist2) newDist2 = d2_se;
			if (d2_s < newDist2) newDist2 = d2_s;
			if (d2_e < newDist2) newDist2 = d2_e;
			if (d2_sw < newDist2) newDist2 = d2_sw;
			if (newDist2 > maxDistance) newDist2 = maxDistance;

			// Repeat for dist3
			let d3_se = ((tridist[i_se] >>> 20) & mask10) + diagonal;
			let d3_s = ((tridist[i_s] >>> 20) & mask10) + orthogonal;
			let d3_e = ((tridist[i_e] >>> 20) & mask10) + orthogonal;
			let d3_sw = ((tridist[i_sw] >>> 20) & mask10) + diagonal;

			let newDist3 = dist3;
			if (d3_se < newDist3) newDist3 = d3_se;
			if (d3_s < newDist3) newDist3 = d3_s;
			if (d3_e < newDist3) newDist3 = d3_e;
			if (d3_sw < newDist3) newDist3 = d3_sw;
			if (newDist3 > maxDistance) newDist3 = maxDistance;

			// Combine distances back into a single integer
			tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
		}
	}
};


//this is actually just an approximation of distance, and the angles matter its not exact. not distance squared.
const computeSquaredDistances_approximateAndHexagonsAndFast = (sideBits, voxelYs, voxelXs)=>{
	const side = 1 << sideBits;
	const sideMask = side - 1;
	const size = side * side;
	distSq = distSqArrays[sideBits] || (distSqArrays[sideBits] = new Int32Array(1<<(sideBits<<1))); //reuse
	//const distSq = new Int32Array(size).fill(Infinity);
	distSq.fill(INF);
	
	// Initialize distSq for voxels
	for(let v = 0; v < voxelYs.length; v++){
		const y = voxelYs[v] & sideMask;
		const x = voxelXs[v] & sideMask;
		distSq[(y << sideBits) | x] = 0;
	}
	
	// First Pass: Top-Left to Bottom-Right
	for(let y = 0; y < side; y++){
		for(let x = 0; x < side; x++){
			let i = (y << sideBits) | x;
			if(distSq[i] === 0) continue; // Voxel
			
			// Check top-left
			if(y > 0 && x > 0){
				let j = ((y -1) << sideBits) | (x -1);
				let distance = distSq[j] + 2; // Diagonal distance squared = 2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check top
			if(y > 0){
				let j = ((y -1) << sideBits) | x;
				let distance = distSq[j] + 1; // Vertical distance squared =1
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check top-right
			if(y >0 && x < side -1){
				let j = ((y -1) << sideBits) | (x +1);
				let distance = distSq[j] + 2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
		}
	}
	
	// Second Pass: Bottom-Right to Top-Left
	for(let y = side -1; y >=0; y--){
		for(let x = side -1; x >=0; x--){
			let i = (y << sideBits) | x;
			if(distSq[i] ===0) continue; // Voxel
			
			// Check bottom-right
			if(y < side -1 && x < side -1){
				let j = ((y +1) << sideBits) | (x +1);
				let distance = distSq[j] + 2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check bottom
			if(y < side -1){
				let j = ((y +1) << sideBits) | x;
				let distance = distSq[j] +1; // Vertical distance squared =1
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check bottom-left
			if(y < side -1 && x >0){
				let j = ((y +1) << sideBits) | (x -1);
				let distance = distSq[j] +2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
		}
	}
	
	return distSq; // distance squared from each pixel to nearest voxel.
};

//Opensource MIT licensed by Ben F Rayfield, that returns int array, 1 int per pixel,
//of distance squared to nearest voxel, of sparse voxels, in average constant time per pixel.
//https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js (that may be an old version as i modify it here)
const computeSquaredDistances_exactButSlow = (sideBits, voxelYs, voxelXs)=>{
  // Ensure sideBits does not exceed 15 to prevent integer overflow in squared distances
  if (sideBits > 15) throw new Error('sideBits must be <= 15');

  const side = 1 << sideBits;		   // Compute side length (e.g., 512 for sideBits=9)
  const size = side * side;			 // Total number of pixels in the grid

  // Initialize presence array: 1 where voxel exists, else 0
  const presence = new Uint8Array(size);
  for (let i = 0; i < voxelYs.length; i++) {
	const y = voxelYs[i];
	const x = voxelXs[i];
	if (y >= 0 && y < side && x >= 0 && x < side) {
	  presence[(y << sideBits) | x] = 1; // Bitwise indexing for faster computation
	}
  }

  const INF = 0x7FFFFFFF;				// Representation of infinity for distances
  const distRow = new Int32Array(size);   // Intermediate distance array after row-wise transform
  const finalDist = new Int32Array(size); // Final distance array after column-wise transform

  // Initialize distRow: 0 for voxels, INF otherwise
  for (let i = 0; i < size; i++) {
	distRow[i] = presence[i] ? 0 : INF;
  }

  /**
   * Row-wise Distance Transform (Two Passes: Forward and Backward)
   * Optimized for cache locality by accessing memory sequentially.
   */
  for (let y = 0; y < side; y++) {
	const rowOffset = y << sideBits; // Compute row offset using bitwise shift (y * side)

	// Forward Pass: Left to Right
	let lastVoxelX = -INF;
	for (let x = 0; x < side; x++) {
	  const idx = rowOffset | x; // Bitwise OR for faster index computation
	  if (presence[idx] === 1) {
		lastVoxelX = x;
		distRow[idx] = 0; // Distance to itself is 0
	  } else if (lastVoxelX !== -INF) {
		const dx = x - lastVoxelX;
		const dxSq = Math.imul(dx, dx); // Accurate computation of dx²
		if (dxSq < distRow[idx]) {
		  distRow[idx] = dxSq; // Update distance if smaller
		}
	  }
	}

	// Backward Pass: Right to Left
	lastVoxelX = -INF;
	for (let x = side - 1; x >= 0; x--) {
	  const idx = rowOffset | x;
	  if (presence[idx] === 1) {
		lastVoxelX = x;
		distRow[idx] = 0;
	  } else if (lastVoxelX !== -INF) {
		const dx = lastVoxelX - x;
		const dxSq = Math.imul(dx, dx);
		if (dxSq < distRow[idx]) {
		  distRow[idx] = dxSq;
		}
	  }
	}
  }

  // Initialize finalDist as a copy of distRow
  for (let i = 0; i < size; i++) {
	finalDist[i] = distRow[i];
  }

  /**
   * Column-wise Distance Transform (Two Passes: Forward and Backward)
   * Implements the Felzenszwalb and Huttenlocher 1D Distance Transform for each column.
   * This ensures accurate computation of squared Euclidean distances.
   */

  /**
   * Helper function to compute the 1D squared distance transform.
   * Implements the algorithm by Felzenszwalb and Huttenlocher (2004).
   * @param {Int32Array} f - The input array representing squared horizontal distances.
   * @param {number} n - The length of the input array.
   * @returns {Int32Array} - The output array representing squared Euclidean distances.
   */
  const distanceTransform1D = (f, n) => {
	const d = new Int32Array(n);
	const v = new Int32Array(n);
	const z = new Float32Array(n + 1);
	let k = 0;
	v[0] = 0;
	z[0] = -Infinity;
	z[1] = +Infinity;

	for (let q = 1; q < n; q++) {
	  let s;
	  do {
		const i = v[k];
		// Compute the intersection point between the parabola at i and q
		s = ((f[q] + Math.imul(q, q)) - (f[i] + Math.imul(i, i))) / (2 * q - 2 * i);
		if (s <= z[k]) {
		  k--;
		} else {
		  break;
		}
	  } while (k >= 0);

	  k++;
	  v[k] = q;
	  z[k] = s;
	  z[k + 1] = +Infinity;
	}

	k = 0;
	for (let q = 0; q < n; q++) {
	  while (z[k + 1] < q) {
		k++;
	  }
	  const i = v[k];
	  d[q] = Math.imul(q - i, q - i) + f[i];
	}

	return d;
  };

  // Perform column-wise distance transform using the 1D distance transform
  for (let x = 0; x < side; x++) {
	// Extract the column's row-wise distances
	const f = new Int32Array(side);
	for (let y = 0; y < side; y++) {
	  const idx = (y << sideBits) | x;
	  f[y] = distRow[idx];
	}

	// Compute the 1D distance transform for the column
	const dt = distanceTransform1D(f, side);

	// Update the finalDist array with the computed distances
	for (let y = 0; y < side; y++) {
	  const idx = (y << sideBits) | x;
	  finalDist[idx] = dt[y];
	}
  }

  return finalDist; // Return the final squared distance array
};


window.onload = ()=>{
	timeStarted = time();
	doGraphicsDtAgeByterectAndMore();
};

Controls.mouseY = game.Y.p; //so game.sparseUpdate() doesnt remove objects in view when mouse starts at (0,0) in 16million**2 space.
Controls.mouseX = game.X.p;
console.log('game.gobs.length=='+game.gobs.length);

</script>
</head>
<body>
<textarea id=mainTextarea onInput=game.onTextareaInput(this.value); style="background-color:black;color:white;position:absolute;z-index:10;opacity:.7" rows=60 cols=70>testing</textarea>
</body>
</html>
