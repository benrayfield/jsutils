<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" /> 
<title>2D Resizable Rectangle Simulation</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
<script>
//This software is offered by Ben F Rayfield under opensource MIT license.
console.log('Opensource MIT. This software (for now called Blob Monsters Game) is offered by Ben F Rayfield under opensource MIT license. What would cause them to sync? Those who want to play the same online game by the same rules would naturally want to be in sync while playing it, anything to the contrary adding to loss function and accelerated by negative gradient of the whole game state across the earth which is a sparse dimensional vector. Blob Monsters Game has 3 teams (red green blue), displays distance to nearest voxel of each. 9 bytes per pixel. 26 bits counts num of monsters touching this pixel. 6 bit color of voxels (24 bit color for the distance fields). 10 bits for distance up to 255. 3 bits for team masks. See game.rps.team, game.rps.tridist, game.board, and game.gob[int].m.team. The 3 teams are REDTEAM, GREENTEAM, BLUETEAM, and BLACKTEAM==0 means no gob is at that pixel.\n\nmonster = V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e is the name of some "blob monster" (object), identified by whatever JS code controls its vector & voxels it computes at that vec. To create monster: monster.p = 1; To delete: monster.p = 0; V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path(). V.testnet[\'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])\'].sideA.path() returns "V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.sideA".\n\nIts an in-memory high dimensional vector database designed for gaming-low-lag massively multiplayer sync, where any simple javascript lambda, that takes Var objects as named params, fits into that database and can be added and deleted by changing 1 of the vars/dimensions. The JS prototype of the Var class is a Proxy, but the Var itself is a normal object so can still be optimized without touching the Proxy. I dont need await/async cuz each Var has a t (UTC time) var with enough digits for slightly better than microsecond. If it hasnt been updated in a while, thats how to mark it.');

console.warn('TODO: use Tile.toVar TO GET SAVE AND LOAD WORKING. todo quad.compress and quad.flatPack. GET testFlatPackTerrain working, like testFlipTerrainColors already works as of 2024-12-26. ... //FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them, //but 2 recursions deep 1 4 16.');

/*
let me explain the math behind this potential energy calculation.

Think of it as a heightmap in range 0..1 for x and y. z can be any nonnegative scalar at every (y,x) in that range. Thats the root node. It has 4 childs that are each of size 1/2 by 1/2, and they have 4 childs that are each of size 1/4 by 1/4 and so on until they get down to 1/4096 x 1/4096. Each of those squares has 4 numbers. Ive been using 4 times less numbers by making them share the number at corners with their adjacent nodes, but as we've added 2 low bits to ptr, we wont share anymore. Either way the math will be the same.

Each node is a ptr and its 1 int (in qint array) and 1 flo (in qflo array). It has no other data. The ranges used in qint dont overlap the ranges used in qflo, so you can think of them as separate arrays.

Each node is computed as a simulated stack toward higher z, of 3 things:
childs
self
parents

Recursion only happens into parents, not into childs. Earlier recursions that started from my childs (of childs of childs...) will have updated self, but when self is updated, self does not recurse that direction cuz theres exponentially many childs but only log number of parents.

Childs are at higher z than self. Self is at higher z than parents.

Imagine a flat ground that you stack blocks on. You are self. You are told to rise (qint[self] += val) by val. You are a particular function z(y,x)=>number. That number is multiplied by qint[self], so qint[self]*z(y,x) is how much z you contribute at (y,x). Every (y,x) has log number of nodes add z there.

When you rise, you are lifting the mass of childs at each (y,x) you and childs both touch. How much? We dont track mass like that. What we track is sum of self(y,x)*child(y,x) for all y x overlaps, and sum that into qflo[self]. child adds into all log number of its parents qflos when child changes its qint, so parents later know (when parent's qint changes later) how much child its lifting. This is done in bilinearMult. bilinearMult does self(y,x)*child(y,x) depending how you use it.

I explained summing poten due to lifting childs. Let me get to the other thing QAdd does. Once childs are lifted, theres an empty space between parents and childs, of height z(y,x)*val at each (y,x). We must also compute the poten change due to filling that hole with mass. We get that mass from height 0 where it has no poten and lift it all the way up to the curvy floor made of parents. We dont move parents. So ive been interpolating parents to get their z sum at each of my 4 corners, then calling bilinearPotentialEnergy twice, once on that as is, and once on that plus what im adding by val, aka the curvy floor vs the curvy ceiling that i made an empty space, a cave, by lifting childs.

//first, compute potential energy of self and parents, but NOT childs (use qflo for that),
		//and after that, compute the change in potential energy by adding the "val" param to 1 corner of each of the 4 tarps,
		//and finally update parents qflo so if they change later, as I'm one of their childs, they know I changed.
		let sumULBefore = 0, sumURBefore = 0, sumDLBefore = 0, sumDRBefore = 0;
		let selfOrParent = startTarpPtr; //loop over log number of parent of parent of parent... (only to some max size (QMinPtr)).
		while(QMinPtr <= selfOrParent){
			
			//This part with QInterp8k is for measuring poten change due to self increasing in size.
			//Its childs on top of self on top of parents. Self gets bigger, and that has to pay for
			//lifting mass from height 0 to self's current height.
			//
			//parent is bigger than child, but view parent interpolated at childs corners.
			//TODO optimize?: If selfOrParent==ptr then these numbers are directly in the qint array
			//but Qinterp will still return them.
			let ul = QInterp8k(qint, selfOrParent, y, x); //z of parent at y x
			let ur = QInterp8k(qint, selfOrParent, y, xEnd);
			let dl = QInterp8k(qint, selfOrParent, yEnd, x);
			let dr = QInterp8k(qint, selfOrParent, yEnd, xEnd);
			sumULBefore += ul;
			sumURBefore += ur;
			sumDLBefore += dl;
			sumDRBefore += dr;
			
			if(selfOrParent !== startTarpPtr && tarpIndex==3){ //TODO move this IF out of the tarpIndex loop.
				let parent = selfOrParent;
				//This part is to update qflo so potenChange += val*qflo[selfOrParent], in future calls on any of my parents,
				//will know the right amount to change qint by.
				//let edgeWeight = bilinearMult(ul, ur, dl, dr, )
				//Err('This is supposed to be of the normed form, where all corners are either 0 or 1, for 8 corners, so I should make a QEdgeWeight func which is similar to bilinearMult but faster');

				//"update parents qflo so if they change later, as I'm one of their childs, they know I changed"
				//this is similar to bilinearPotentialEnergy but is a different func
				//that multiplies the 2 z heights at each (y,x)
				let edgeWeight = QEdgeWeight(parent, ptr);
				qflo[parent] += val*edgeWeight;
			}
			
			selfOrParent = Qp(selfOrParent); //parent is 2x2 times bigger than child and contains all the area of child.
		}
		//'adding the "val" param to 1 corner of each of the 4 tarps'
		let sumULAfter = sumULBefore + ((tarpIndex===0) ? val : 0); //val adds to 1 corner in each of 4 tarps
		let sumURAfter = sumURBefore +  ((tarpIndex===1) ? val : 0);
		let sumDLAfter = sumDLBefore +  ((tarpIndex===2) ? val : 0);
		let sumDRAfter = sumDRBefore +  ((tarpIndex===3) ? val : 0);
		//fixme bilinearPotentialEnergy uses coordinates of 0..1 for y and x, but we use 8192x8192, so some translation is needed.
		let potenExcludingChilds_before = area*bilinearPotentialEnergy(sumULBefore, sumURBefore, sumDLBefore, sumDRBefore);
		let potenExcludingChilds_after = area*bilinearPotentialEnergy(sumULAfter, sumURAfter, sumDLAfter, sumDRAfter);
		
		potenChange += potenExcludingChilds_after - potenExcludingChilds_before;
*/

const intVoxelsOnly = true; //YXC voxels, the original kind of Blob Monsters Game, that are fast and u get alot more of them.
//const intVoxelsOnly = false; //then you use IZ func.

const graphicsLev = 5; //normal fast gaming computer like from 2020.
//const graphicsLev = 1; //slow computer like from 2010-2015.
console.log('graphicsLev='+graphicsLev);


//var enableTestPaintMouse = Math.random()<.5; //for testing
var enableTestPaintMouse = false; //normal
console.log('enableTestPaintMouse='+enableTestPaintMouse);

//var enableTestGroundPaintMouse = true; //for testing. FIXME should be false
var enableTestGroundPaintMouse = false; //normal
console.log('enableTestGroundPaintMouse='+enableTestGroundPaintMouse);

//var enableSpawnNearTopLeft = true; //for testing graphics and physics. FIXME should be false
var enableSpawnNearTopLeft = false; //normal
console.log('enableSpawnNearTopLeft='+enableSpawnNearTopLeft);

var paintCoordinateLinesAtBoot = !enableSpawnNearTopLeft;
console.log('paintCoordinateLinesAtBoot='+paintCoordinateLinesAtBoot);


const Err = str=>{
	throw new Error(str||'');
};
const Todo = str=>{ throw new Error('TODO: '+(str||'')); };

//var DefaultSpawnY = 75800; //address space 0 to (2**18)-1. OLD: expanding address space to be 0 to (2**20)-1 in both Y and X.
//var DefaultSpawnX = 75500;
var DefaultSpawnY = 75000;
var DefaultSpawnX = 75000;
//var DefaultSpawnY = 505800; //expanding address space to be 0 to (2**20)-1 in both Y and X.
//var DefaultSpawnX = 505500;
//var DefaultSpawnY = 4000; //FIXME go back to 504000,504000 thats where some of the objects are put, near middle of the million X million
//var DefaultSpawnX = 4000;

if(enableSpawnNearTopLeft){
	DefaultSpawnY = 200;
	DefaultSpawnX = 200;
}


/* This is OLD. BigTile will be replaced by Qvox in game.qint and game.qflo.
TODO use game.wal which is a BigTile, in sparse 128x128 pieces.
make it paint (y,x) to byte func in chosen rect. loop over all tiles that touches and paint each that way.
game.wal.paintGame(); should be called every nextState. it only paints where not already painted or out of sync.
easier is tile.dense can be painted, as long as u do it with funcs so it marks it needing sync,
so it can efficiently paint 1 pixel at a time. todo make game.wal.paintYXB(y,x,byt); and paintYXWRGB.
*/






























/* 2025-2-1+ im proceeding with Qvox, not Quad, not WallQuad, not BigTile, not game.ground,
but some of that older stuff will still be useful at times for debug graphics or simple things maybe.
OLD:

proceed with 128x128 pieces of Quad. name each by hash id. Use Square (uint53) as key of it, and pair of Quad and dense Uint8Array as val.
Make a class so can edit it and know which needs updating, replace Quad and empty the Uint8Array, or mod that array and clear the Quad.
Just keep a var thats 1 0 or -1 for if one was updated before or after or at same time as the other.


2024-12-16 ive decided to proceed with Quad, not more complex kind with isComplexFork. make terrain asap
but todo bring in some of the features of the more advanced kind, like bits to say which of 4 childs are included,
and maybe some of the symbols mean heights 0..24. Or maybe QTRANSPARENT being only 1 byte we dont need an optimization for it?
Leave quad as it is and just start using it. Make game.wal be a Quad instance of whole 2**24 X 2**24 game area
or whichever parts we know about.

/*
Square = (y, x, h)=>(h*(2**48) + y*0x1000000 + x);
SquareX = sq=>(sq&0xffffff);
SquareY = sq=>((sq/0x1000000)&0xffffff));
SquareH = sq=>((sq/(2**48))&31);
Square(100,203,5) 1407376561275083
SquareY(1407376561275083) 100
SquareX(1407376561275083) 203
SquareH(1407376561275083) 5
*/

/** utc time in seconds */
/*var time = function(){
	//FIXME use the code from dagball for more precise time using performance.now and an offset
	return Date.now()*.001;
};*/
const timeOffset_ = performance.timing.navigationStart;
//UTC seconds with fraction. More precise than Date.now()*.001. Chrome seems to have 4 digits after decimal point, and brave and firefox 3 digits.
const time = ()=>((timeOffset_+performance.now())*.001);

var timeStarted = 0;


//y and x are integers in range 0 to (2**24)-1=16777215. height ranges 0 (for 1x1 to o 24 (for 16777216x16777216).
//y and x must be multiples of 1<<height.
//const Square = (y, x, height)=>(height*(2**48) + y*0x1000000 + x);
const Square = (height, y, x)=>(height*(2**48) + y*0x1000000 + x);
const SquareSafe = (height, y, x)=>(Math.min(height&31,24)*(2**48) + (y&0xffffff)*0x1000000 + (x&0xffffff));

//SquareX(Square(y,x,height))===x
const SquareX = square=>(square&0xffffff);

//SquareY(Square(y,x,height))===y
const SquareY = square=>((square/0x1000000)&0xffffff);

//SquareH(Square(y,x,height))===height
const SquareH = square=>((square/(2**48))&31);
const SquareHSafe = square=>Math.min((square/(2**48))&31,24);

const SquareDy = (squareA,squareB)=>(SquareY(squareA)-SquareY(squareB));
const SquareDx = (squareA,squareB)=>(SquareX(squareA)-SquareX(squareB));


/**
I think i can expand the game world to 16 million X 16 million, so big that you can just pic a place at random and start building and it may on some 2d paths (or portals?) lead smoothly between worlds made by players. Thats 256 trillion pixels sparsely.

Use this for terrain only, not monsters. Put it in blocks of 1024x1024 compressed as Uint8Array, in base64 form in Var tree as .big like in Walls vs Wally func. This is searchable in compressed form to get color6 and varint poten at every node, so within 1024x1024 (game.wab will be an array of maybe 256x256 byte arrays, flyweighting the 1 byte one. Might also put dense arrays of 1024x1024 ints or shorts or maybe it fits in bytes there for those frequently used, the uncompressed form.
Make circular paint brush and paint these asap. Generate V.testnet.hash43534534564356345345345 of wall like that.
EVERYTHING goes in Var tree. Theres nothing in game state outside it, except few fields in gob.m.isSelected etc, and those can be brought into var tree asap.

i want to use a uint53 as the address of any powOf2 size square from 1x1 2x2 4x4 ... 16777216x16777216. Low 24 bits are x. Mid 24 bits are y. High 5 bits are shift. width and height both equal 1<<shift. So this can fit in a float64 as a nonnegative integer. My compressed pic data format works in any sized area like that.

renaming isFork to isComplexFork. Split Transparent into the suffix 1111 means Transparent, and the suffixes 0000 to 0100 (zero to four) mean a height 1 SimpleFork whose childs are 4 SmallLeafs or Transparent, and the "zero to four" is totalPoten.

["root",
--- ["1xxxxxxx: SmallLeaf, 1 bit of numGobsTouchingHere, 6 bits of color"],
--- ["0xxxxxxx",
--- --- ["01xxxxxx: BigLeaf, 6 bits of color, varint numGobsTouchingHere"],
--- --- ["00xxxxxx: ForkOrPointerOrTransparent - next bit is IsComplexFork",
--- --- --- ["000xxxxx - not a ComplexFork. is pointer or transparent or SimpleFork or MidFork",
--- --- --- --- ["0000xxxx Transparent or SimpleFork or MidFork"]
--- --- --- --- --- {
--- --- --- --- --- --- "00000000 Transparent. Len 1 byte. Its very important that Transparent be the byte 0 cuz of memory allocation optimizations that lazy create memory thats still all 0s."
--- --- --- --- --- --- "00000001 TextContentTypeAndRawBytesVal - a place to hook in extended opcodes or plugins or ids of other systems. Followed by varint byte len, then varint ascii (0..127) text (since varint gives 7 bits per byte) of contentType then that many bytes."
--- --- --- --- --- --- "TODO put in here a constant that takes 8 bytes, first this header byte, then 3 bytes of x, then 3 bytes of y, then 1 byte of height, as a prefix, since browsers are generally little-endian of bytes when a float64 overlaps them, but that assumes some high bit is set, which i could do by using 0x5 (0b0101) as the high 4 bits of the float64, but lets just define them as integers in this data format. This can be used to tell where and how big to make the following quadtree content, so a quadtree as a byte array (or range in it) can tell you where in the game world, of a square 16million X 16million (powOf2), and all sizes 1x1 to 16mX16m, it is.",
--- --- --- --- --- --- "00000010..00000110 SimpleFork with poten=0..4. Len 5 bytes."
--- --- --- --- --- --- "00000111..00001111 MidFork with poten=0..8 (TODO 0..7 to make room), whose childs are 4 SimpleForks. Len 21 bytes."
--- --- --- --- --- }
--- --- --- --- ["0001xxxx Pointer. If its 00010000 then its vararg. If its 00010001..00011111 then it points 1..15 bytes down from itself."]
--- --- --- ]
--- --- --- ["001xxxxx: ComplexFork, hasVarintPoten, childrenPresence, varintPoten if hasVarintPoten, recursively encode children",
--- --- --- --- ["0010xxxx Fork without varintPoten. 4 bits of childrenPresence. varintLen. 0..4 children recursively."]
--- --- --- --- ["0011xxxx Fork with varintPoten.  4 bits of childrenPresence. varintLen. varintPoten. 0..4 children recursively."]
--- --- --- ]
--- --- ]
--- ]
]
varint is (TODO swap that so ASCII is all digits except the last, for when its used as contentType. 0x8|uint7 for the high and middle 7 bits, and is (a high 0 bit and) uint7 for the last uint7.
Start the byte array with 1 int (SP aka stack pointer) that is the index of the last byte appended, and 1 Transparent byte right after that, so the int starts as 4, so as littleEndian it starts with these 5 bytes: 4 0 0 0 0, where 0 is Transparent byte.
A byte array is therefore a complete byte stream that can be appended and keep track of that itself. Only its first 4 bytes are writable more than once. You can also pop bytes as long as you make sure SP points ONLY at the highest byte of some node, not at its internal bytes.

Do not change this tree. Use it as is. Explain the tree as best you understand it.

Start by making a Uint8Array(1<<30) and 2 funcs:
pushByte(byt), increments SP, puts the byte at the new SP, and returns SP. Does not guarantee the byte is a valid start of a node. You will need to call pushByte multiple times for nodes whose local size is bigger than 1 byte.
popByte() throws if SP===4 cuz thats as empty as its gonna get. Else decrements SP and returns the byte popped. Does not zero it out.

This kind of math can sum the number of intersecting points between any 2 2d shapes, of any strangely curved 1d border, for cost of the length of those curves, not costing by area, but its so slow anyways that its just faster to use point voxels for the monsters, this for terrain.
This means the game could have huge massively multiplayer areas of destructible and editable terrain like in Worms or r/place.

*/

/**
Why am I going for 7 bit color? 2 bits of red, 2 bits of green, and 2 bits of blue is 6 bit color, like in this gif from wikipedia
showing a 4x4x4 grid of colored voxels. I need the other bit to define game world terrain, that you can or cant move into that space. I will swarm it
*/

//tile is a (2**tileHeight) side square that a Quad goes in and a Uint8Array for cache and editing it densely.
//Height technically ranges 0 to 24, but for a tile it cant be in those bigger sizes. dont go over 10 cuz thats a megapixel.
const tileHeight = 7;
const tileHeightMask = (1<<tileHeight)-1;

//{}

//immutable, but other than that is like Tile. you cant paint it. this is used in Var.ob when isTileString(Var.name),
//since if it was just the Quad, that would be missing the data of y and x. this.quad goes in a Tile.sparse
const QuadTile = function(square, quad){
	this.square = square;
	this.quad = quad;
};

const Tile = function(square, optionalQuadOrDense){
	this.isPaintedOnGame = 0; //increases by every paint, decreases by every remove. normally is 0 or 1 but catches bugs if other vals.
	this.square = square; //2d size and location. 5 high bits of height. 24 mid bits of top left corner of y. 24 low bits of top left corner of x.
	if(SquareH(square)!==tileHeight) Err('tile.square differs in height from tileHeight constant');
	//this.height = tileHeight;
	this.sparse = null;
	this.dense = null;
	this.writeDirection = 0; //1 is sparse was replaced last. -1 is dense was modded last. 0 is they are in sync.
	if(optionalQuadOrDense){
		if(optionalQuadOrDense instanceof Quad){
			this.sparse = optionalQuadOrDense;
			this.writeDirection = 1;
		}else{
			this.sparse = DefaultQuadForTile;
			this.dense = optionalQuadOrDense;
			this.writeDirection = 1;
		}
	}
};

Tile.prototype.centerY = function(){
	return SquareY(square)+(1<<(tileHeight-1));
};

Tile.prototype.centerX = function(){
	return SquareX(square)+(1<<(tileHeight-1));
};

//distance to nearest y in the 1d range
Tile.prototype.yDist = function(y){
	let minY = SquareY(this.square);
	let maxY = minY+(1<<tileHeight);
	if(y < minY) return minY-y;
	if(maxY < y) return y-maxY;
	return 0;
};

//distance to nearest x in the 1d range
Tile.prototype.xDist = function(x){
	let minX = SquareX(this.square);
	let maxX = minX+(1<<tileHeight);
	if(x < minX) return minX-x;
	if(maxX < x) return x-maxX;
	return 0;
};

//distance to nearest y x point in the 2d range
Tile.prototype.yxDist = function(y,x){
	return Math.hypot(this.yDist(y),this.xDist(x));
};

//isRemove, similar to Gob.voxInGame is whats currently added into game.board and can get removed.
//TODO use dense if exists, as of 2024-12-22 this paints as Quad/sparse even if the dense version
//is available it copies it to sparse form first.
Tile.prototype.paintGame = function(optionalIsRemove, optionalGameG){
	const isRemove = !!optionalIsRemove;
	this.isPaintedOnGame += (isRemove ? -1 : 1);
	let topLeftY = SquareY(this.square);
	let topLeftX = SquareX(this.square);
	if(this.writeDirection < 0){
		this.copyDenseToSparse();
	}
	let chooseSparse = this.sparse;
	if(isRemove){
		if(!this.lastPaintedQuadOnGame) Err('no lastPaintedQuadOnGame to remove. maybe you are unpainting before painting?');
		chooseSparse = this.lastPaintedQuadOnGame;
		this.lastPaintedQuadOnGame = null;
	}else{
		this.lastPaintedQuadOnGame = this.sparse; //remember Quad, which is used as immutable, so can remove it from game.board later.
	}
	chooseSparse.paintGame(topLeftY, topLeftX, isRemove, optionalGameG);
	if(!isRemove && (this.lastPaintedQuadOnGame !== this.sparse)){
		Err('lastPaintedQuadOnGame');
	}
};

//paints or unpaints
Tile.prototype.setIsPaintedOnGame = function(isPaint, optionalGameG){
	if(!isPaint !== !this.isPaintedOnGame){ //if changing if its painted or not
		this.paintGame(!isPaint, optionalGameG);
		this.toVar(); //2025-2-8 moving this here to see if can get it to only update V/Var tree if changed
	}else if(isPaint && ((this.lastPaintedQuadOnGame !== this.sparse) || this.writeDirection < 0)){
		//if it painted an old version, remove it and update
		//isRemove vs isPaint is confusing cuz theyre NOT of eachother. choose a direction and stick with it.
		this.paintGame(true, optionalGameG); //remove old quad this.lastPaintedQuadOnGame from game.board
		this.paintGame(false, optionalGameG); //update this.sparse quad and paint game again, creating this.lastPaintedQuadOnGame
		this.syncSparseDense();
		this.toVar(); //2025-2-8 moving this here to see if can get it to only update V/Var tree if changed
	}
	//this.toVar(); //puts it in V/Var tree so if you call State(), that json includes it. FIXME delete tiles not used. set their. .p to 0 and let it happen automatically, though there should probably be some other check for it so u can still set .p to 1 to bring it back.
};


//tile.setSparse(forkEdit tile.sparse)
Tile.prototype.writeSparse = function(quad){
	if(quad.h !== tileHeight) Err('wrong height');
	this.writeDirection = 1; //sparse was written last
	this.sparse = quad;
};

Tile.prototype.writeDense = function(square, byt){
	if(SquareH(square)!==0) Err('must be 1x1 pixel square. todo loop if its bigger.');
	this.writeDenseRelyRelxByt(SquareDy(square,this.square), SquareDx(square,this.square), byt);
};

Tile.prototype.writeDenseRelyRelxByt = function(rely, relx, byt){
	let dense = this.lazyNewDense();
	this.writeDirection = -1; //dense was written last
	this.dense[(rely<<tileHeight)|relx] = byt;
};

Tile.prototype.copyDenseToSparse = function(){
	this.sparse = QEval((y,x)=>this.dense[(y<<tileHeight)|x], tileHeight);
	this.writeDirection = 0; //in sync
};

Tile.prototype.copySparseToDense = function(){
	let siz = 2**tileHeight;
	let dense = this.lazyNewDense();
	for(let rely=0; rely<siz; rely++) for(let relx=0; relx<siz; relx++){
		dense[(rely<<tileHeight)|relx]	= this.sparse.yx(rely, relx);
	}
	this.writeDirection = 0; //in sync
};

Tile.prototype.syncSparseDense = function(allowCreateEmptyDense){
	if(this.writeDirection == 1){ //sparse was written last
		if(this.dense || allowCreateEmptyDense) this.copySparseToDense();
		//else leave this.dense as null cuz sparse contains all the info
	}else if(this.writeDirection == -1){ //dense was written last
		this.copyDenseToSparse();
	}
};

Tile.prototype.lazyNewDense = function(){
	return this.dense || (this.dense = new Uint8Array(4**tileHeight));
};

//a sparse map of square to Tile. each tile is normally a 128x128, but any set of 128x128s can be defined.
const BigTile = function(){
	this.tiles = {}; //map of Square(tileHeight,y,x) to Tile.
	this.needSync = []; //tile objects needing sync. its ok if they go in here multiple times cuz is fast to check if they are already synced.
	//Err('too many kinds of tile, one is Quad which i like, 2 is dense byte array which im unsure if need it, and 3 is game.board which Quad can paint/unpaint at directly. and i need to store maybe a fourth or copy of one of those, to remove from game.board later, but it might have been edited. Quad is used as immutable, so could just do that.');
};

//for testing, get a random existing tile.
BigTile.prototype.randTile = function(){
	let squaresAsStringsOfNumbers = Object.keys(this.tiles);
	if(squaresAsStringsOfNumbers.length===0) Err('no tiles');
	return this.tiles[squaresAsStringsOfNumbers[randInt(squaresAsStringsOfNumbers.length)]];
};

BigTile.prototype.paintGame = function(){
	for(let square in this.tiles){
		let tile = this.tiles[square];
		tile.setIsPaintedOnGame(game.shouldDisplayTile(tile));
	}
};

BigTile.prototype.tile = function(square){
	let key = TileKey(square);
	return this.tiles[key] || (this.tiles[key] = new Tile(key));
};

BigTile.prototype.tileAndMark = function(square){
	let tile = this.tile(square);
	this.needSync.push(tile);
	return tile;
};

BigTile.prototype.sync = function(){
	while(this.needSync.length) this.needSync.pop().syncSparseDense();
};

//BigTile.prototype.writeSparse = function(vox){
//	Err();
//};

//this is the old way with Quad, but im moving on to game.ground
//which is 16x16 times smaller than the 8192x8192 game.board, as of 2025-1-20+.
var testPaintAtMouse = ()=>{
	let y = Controls.mouseY|0;
	let x = Controls.mouseX|0;
	let isWall = 1;
	//let isWall = 0;
	let color = randInt(Colors);
	game.wal.paintYXWC(y,x,isWall,color);
	let r = 30;
	for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++){
		if((dy*dy+dx*dx) <= (r*r)) game.wal.paintYXWC(y+dy,x+dx,isWall,color);
	}
};

//FIXME as of 2025-2 the game.groundA and game.groundB arrays were shrunk to 8x8 tiles, down from 16x16,
//but todo i might want them to be 32x32, but im not using that system anyways.
//
//1 number of x or y coordinate to a ground coordinate, which is 16 times smaller than the 8192x8192.
//This is the cheap way, just truncates to the top left of the 16x16 ground tile its in, but just 16 cuz its 1d.
const Ground = yOrX=>((yOrX>>4)&GroundMask);
const YXToGroundI = (y,x)=>((Ground(y)<<9)|Ground(x));

//the new kind of ground as of 2025-1-20+, using game.ground which is 16x16 times smaller than the 8192x8192 at game.board.
var testGroundPaintAtMouse = ()=>{
	let y = Controls.mouseY|0;
	let x = Controls.mouseX|0;
	let addToGround = DefaultZ;
	game.ground[YXToGroundI(y,x)] += addToGround;
};

BigTile.prototype.writeDense = function(square, byt){
	this.tile(square).writeDense(square, byt);
};

BigTile.prototype.paintYXB = function(y,x,byt){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, byt);
};

BigTile.prototype.paintYXWRGB = function(y,x,w,r,g,b){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, WRGB(w,r,g,b));
};

//y x isWall color6
BigTile.prototype.paintYXWC = function(y,x,w,c){
	let square = Square(0,y|0,x|0);
	this.tile(square).writeDense(square, WC(w,c));
};

//aligns on 128x128 in the 16m x 16m square. todo 2024-12-22 its still displaying 256k x 256k, change maxX maxY consts etc.
const TileKey = square=>Square(tileHeight, SquareY(square)&~tileHeightMask, SquareX(square)&~tileHeightMask);

//TileKey but 2d wrapped into the 8k x 8k game.board, so it puts all these in the top left 8k x 8k of the 16m x 16m space.
//This is used to detect overlap by wrapping, to remove a wall tile if collides with another tile of a different TileKey
//that happens to overlap when wrapped. We only have so much memory in game.board to display and compute the game.
const TileKeyWrap = square=>Square(tileHeight, SquareY(square)&~SizeMask, SquareX(square)&~SizeMask);

//QuadtreeByteArray: If you use 7 bit color you can make a whole bencoded searchable compressed pic with 1 byte quadtree nodes
//densely, bigger nodes for sparse that point into byte arrays with offset. Gonna be hella fast and compress terapixels,
//most of which will be oddly shaped solid areas of color. Use WRGB or WC to make a byte that has 1 bit of isWall and 6 bits of color.
//Use WEval to make a Quad by a function that says what byte where, still working on the compression part of that.
//
//This quadtree compression is about as small as the curvy border lengths where color changes, instead of the area.
//You can decompress a single pixel at any chosen x y coordinate in a few nanoseconds without decompressing any other pixels.
//Every pic is 1 byte or made of 4 pics.
//In theory the existing data format supports pics of unlimited size. The game area is 16 million pixels tall and wide
//(2**24 X 2**24 aka 256 trillion pixels), 64 possible colors per pixel. Small tiles of 128x128 pixels are stored
//as needed (sparse), each compressed separately.
//
const Quad = function(height, bytes, offset=0, childs=[null,null,null,null]){
	this.h = height;
	this.B = bytes;
	this.i = offset;
	this.c = childs;
	this.length = lenAtBytes(this.B,this.i); //same as array.length, for the range this.i to this.i+this.length-1.
	if(this.length < 1){
		Err('Quad.length='+this.length);
	}
	
	//this.todoRemoveThis = QBytesStr(this.B, this.i, this.B.length); //FIXME dont know the length cuz am still testing the length parsing
};

Quad.prototype.toBigString = function(){
	//if(this.h===0){
	if(this.isLeaf()){
		return doubleHexDigits[this.b(0)];
	}else{
		return '['+this.C(0).toBigString()+' '+this.C(1).toBigString()+' '+this.C(2).toBigString()+' '+this.C(3).toBigString()+']';
	}
};

Quad.prototype.to2dString = function(){
	let s = '';
	let siz = 1<<this.h;
	for(let y=0; y<siz; y++){
		if(y) s += '\n';
		for(let x=0; x<siz; x++){
			//if(x) s += ' ';
			//s += doubleHexDigits[this.yx(y,x)];
			s += doubleHexDigits[this.yx(y,x)];
		}
	}
	return s;
};

const QTRANSPARENT = 0x80;
const QWANTTOKNOW = 129;
//colors go in 0 to 127, high bit being isWall. symbols go in 128 to 191. 4 kinds of hex digit go in 192 to 255 for type safety per byte.
const QFORK = 191; //means u dont know what length header goes there but a byteAtYXH(y,x,height) func returns this to say fork and figure it out later.
//const QLASTSYMBOL = 191;

//these are for Quad, not game.qflo and game.qint. The q means something else here.
const QFORKC = 0xc0; //single byte length prefix, means including itself that theres 0-15 bytes
const QFORKD = 0xd0; //multi byte length prefix, start with these 16 hex digits
const QFORKE = 0xe0; //multi byte length prefix, use 0 or more of this kind of hex digits in the middle of QFORKD and QFORKF.
const QFORKF = 0xf0; //multi byte length prefix, end with these 16 hex digits

/*
/**
 * Computes the potential energy of a function defined by corner values in a unit square.
 * The function calculates:
 *   sumZ(x,y) = UL * (1-x) * (1-y) + UR * x * (1-y) + DL * (1-x) * y + DR * x * y,
 * with x and y ranging from 0 to 1.
 *
 * The potential energy is computed as the integral over the square of this function.
 *
 * @param {number} UL - Upper Left value
 * @param {number} UR - Upper Right value
 * @param {number} DL - Lower Left value
 * @param {number} DR - Lower Right value
 * @returns {number} - The computed potential energy.
 *
const potentialEnergyCorners = (UL, UR, DL, DR) => {
    // Define coefficients of the bilinear form
    const a = UL - UR - DL + DR; // Coefficient of xy
    const b = UR - UL;           // Coefficient of x
    const c = DL - UL;           // Coefficient of y
    const d = UL;                // Constant term

    // Compute the integral of the square of the bilinear form over [0,1] x [0,1]
    const integral = 0.5 * (
        (a * a) / 9 +           // integral of a^2 * x^2 * y^2
        (2 * a * b) / 6 +       // integral of 2ab * x^2 * y
        (2 * a * c) / 6 +       // integral of 2ac * x * y^2
        (b * b) / 3 +           // integral of b^2 * x^2
        (2 * b * c) / 4 +       // integral of 2bc * x * y
        (c * c) / 3 +           // integral of c^2 * y^2
        (2 * a * d) / 4 +       // integral of 2ad * x * y
        (2 * b * d) / 2 +       // integral of 2bd * x
        (2 * c * d) / 2 +       // integral of 2cd * y
        (d * d)                 // integral of d^2
    );

    return integral;
};

/**
 * Computes the approximate potential energy of a function defined by corner values in a unit square.
 * The function calculates:
 *   sumZ(x,y) = UL * (1-x) * (1-y) + UR * x * (1-y) + DL * (1-x) * y + DR * x * y,
 * with x and y ranging from 0 to 1.
 * The potential energy is approximated by numerically integrating 0.5 * (sumZ(x,y))^2 over the unit square.
 *
 * @param {number} UL - Upper Left value
 * @param {number} UR - Upper Right value
 * @param {number} DL - Lower Left value
 * @param {number} DR - Lower Right value
 * @param {number} [step=0.001] - The step size for discretizing the unit square (smaller steps increase accuracy)
 * @returns {number} - The approximated potential energy.
 *
const bruteForcePotentialEnergyCorners = (UL, UR, DL, DR, step = 0.001) => {
    let integral = 0.0;

    // Iterate over x from 0 to 1 with the specified step size
    for (let x = 0; x <= 1; x += step) {
        // Correct for floating-point precision to include x = 1
        if (x > 1) x = 1;

        // Iterate over y from 0 to 1 with the specified step size
        for (let y = 0; y <= 1; y += step) {
            // Correct for floating-point precision to include y = 1
            if (y > 1) y = 1;

            // Calculate the bilinear interpolation sumZ(x, y)
            const sumZ = UL * (1 - x) * (1 - y) + UR * x * (1 - y) + DL * (1 - x) * y + DR * x * y;

            // Calculate the integrand: 0.5 * (sumZ)^2
            const integrand = 0.5 * Math.pow(sumZ, 2);

            // Accumulate the integral using the area of each small rectangle (step * step)
            integral += integrand * step * step;
        }
    }

    return integral;
};

/**
 * Computes the absolute difference between the exact and brute-force potential energy calculations.
 *
 * @param {number} UL - Upper Left value
 * @param {number} UR - Upper Right value
 * @param {number} DL - Lower Left value
 * @param {number} DR - Lower Right value
 * @param {number} [step=0.001] - The step size for the brute-force approximation
 * @returns {number} - The absolute difference between exact and brute-force results.
 *
const diff = (UL, UR, DL, DR, step = 0.001) => {
    const exact = potentialEnergyCorners(UL, UR, DL, DR);
    const approx = bruteForcePotentialEnergyCorners(UL, UR, DL, DR, step);
    return Math.abs(exact - approx);
};

/**
 * Runs test cases to verify that the exact and brute-force potential energy calculations are consistent.
 *
const runTestCases = () => {
    // Define test cases
    const testCases = [
        { UL: 0, UR: 0, DL: 0, DR: 0 },
        { UL: 1, UR: 1, DL: 1, DR: 1 },
        { UL: 2, UR: 2, DL: 2, DR: 2 },
        { UL: 3, UR: 3, DL: 3, DR: 3 },
        { UL: 3, UR: 3, DL: 3, DR: 0 },
        { UL: 3, UR: 3, DL: 3, DR: 4 },
        { UL: 0, UR: 0, DL: 0, DR: 1 },
        { UL: 0, UR: 0, DL: 1, DR: 0 },
        { UL: 0, UR: 1, DL: 0, DR: 0 },
        { UL: 1, UR: 0, DL: 0, DR: 0 },
        { UL: 1, UR: 2, DL: 3, DR: 4 },
        { UL: 5, UR: 7, DL: 9, DR: 11 },
    ];

    const epsilon = 1e-6;

    testCases.forEach(({ UL, UR, DL, DR }) => {
        const exact = potentialEnergyCorners(UL, UR, DL, DR);
        const approx = bruteForcePotentialEnergyCorners(UL, UR, DL, DR, 0.001);
        const difference = diff(UL, UR, DL, DR, 0.001);
        const passed = difference < epsilon;

        console.log(`Test Case: UL=${UL}, UR=${UR}, DL=${DL}, DR=${DR}`);
        console.log(`Exact Integral: ${exact}`);
        console.log(`Brute-Force Approximation: ${approx}`);
        console.log(`Difference: ${difference}`);
        console.log(`Test ${passed ? "PASSED" : "FAILED"}\n`);
    });
};

// Run the test cases
runTestCases();

VM687:124 Test Case: UL=0, UR=0, DL=0, DR=0
VM687:125 Exact Integral: 0
VM687:126 Brute-Force Approximation: 0
VM687:127 Difference: 0
VM687:128 Test PASSED

VM687:124 Test Case: UL=1, UR=1, DL=1, DR=1
VM687:125 Exact Integral: 0.5
VM687:126 Brute-Force Approximation: 0.500000000003959
VM687:127 Difference: 3.959055305813308e-12
VM687:128 Test PASSED

VM687:124 Test Case: UL=2, UR=2, DL=2, DR=2
VM687:125 Exact Integral: 2
VM687:126 Brute-Force Approximation: 2.000000000015836
VM687:127 Difference: 1.5836221223253233e-11
VM687:128 Test PASSED

VM687:124 Test Case: UL=3, UR=3, DL=3, DR=3
VM687:125 Exact Integral: 4.5
VM687:126 Brute-Force Approximation: 4.50000000009116
VM687:127 Difference: 9.115996846276175e-11
VM687:128 Test PASSED

VM687:124 Test Case: UL=3, UR=3, DL=3, DR=0
VM687:125 Exact Integral: 2.75
VM687:126 Brute-Force Approximation: 2.752999374250121
VM687:127 Difference: 0.0029993742501210896
VM687:128 Test FAILED

VM687:124 Test Case: UL=3, UR=3, DL=3, DR=4
VM687:125 Exact Integral: 5.305555555555555
VM687:126 Brute-Force Approximation: 5.303889819361057
VM687:127 Difference: 0.0016657361944982796
VM687:128 Test FAILED

VM687:124 Test Case: UL=0, UR=0, DL=0, DR=1
VM687:125 Exact Integral: 0.05555555555555555
VM687:126 Brute-Force Approximation: 0.05538906936112521
VM687:127 Difference: 0.0001664861944303403
VM687:128 Test FAILED

VM687:124 Test Case: UL=0, UR=0, DL=1, DR=0
VM687:125 Exact Integral: 0.05555555555555555
VM687:126 Brute-Force Approximation: 0.05555548611112286
VM687:127 Difference: 6.944443269041312e-8
VM687:128 Test PASSED

VM687:124 Test Case: UL=0, UR=1, DL=0, DR=0
VM687:125 Exact Integral: 0.05555555555555555
VM687:126 Brute-Force Approximation: 0.05555548611112519
VM687:127 Difference: 6.944443036588366e-8
VM687:128 Test PASSED

VM687:124 Test Case: UL=1, UR=0, DL=0, DR=0
VM687:125 Exact Integral: 0.05555555555555558
VM687:126 Brute-Force Approximation: 0.05572240286112291
VM687:127 Difference: 0.00016684730556733307
VM687:128 Test FAILED

VM687:124 Test Case: UL=1, UR=2, DL=3, DR=4
VM687:125 Exact Integral: 3.333333333333333
VM687:126 Brute-Force Approximation: 3.329584249999233
VM687:127 Difference: 0.0037490833341000673
VM687:128 Test FAILED

VM687:124 Test Case: UL=5, UR=7, DL=9, DR=11
VM687:125 Exact Integral: 32.83333333333333
VM687:126 Brute-Force Approximation: 32.809336999989824
VM687:127 Difference: 0.02399633334350426
VM687:128 Test FAILED

undefined
*/


const SizeBits = 13;
const Size = 1<<SizeBits; //8192
const SizeMask = Size-1;
const Area = Size**2; //8192*8192
const Colors = 1<<6;
if(Area*Colors > 2**32) throw new Error('Voxel layout does not fit in int. If you want more space, try uint53 or int54'+
	' (21 or 22 more bits) which fits in float64 but that redesign would cost alot of speed. Example, and would have to'+
	' be sparse cuz cant store that much in dense array: 16k x, 16k y, 16k z, 4k colors, 54 bits per voxel.');
const ColorMask = Colors-1;
const MaxVoxPerGob = 1<<20; //should probably be alot lower than 1<<20, but 1<<20 can technically work.

const MagnifyShift = 2; //Size is 4 times smaller than SmallSize. Area is 4x4 times smaller than SmallArea.
const SmallSizeBits = SizeBits-MagnifyShift; //4x4 smaller
const SmallSize = 1<<SmallSizeBits;
const SmallSizeMask = SmallSize-1;
const SmallArea = SmallSize**2;
if(((1<<MagnifyShift) != (Size/SmallSize)) || ((1<<(MagnifyShift<<1)) != (Area/SmallArea))) throw new Error(
	'MagnifyShift is broken. This line is here as a way to explain it to humans and AIs and possibly to help the JIT compiler optimize ints.');
if(Area != SmallArea<<4) throw new Error('This will never happen. Just helping the compiler optimize maybe.');
if(SmallSizeBits!=11) throw new Error('toSmall and other funcs are being hardcoded for this size, 2048x2048 small, 8192x8192 normal');

//With this upgrade I'll only store an extra int (triple dijkstra, 3 of uint10) and an extra byte (team masks),
//per 16 pixels (4x4). So thats 64 megapixels for main voxels, 4 megapixels for this other stuff, magnified.

//13 high bits and 13 low bits -> 11 high bits and 11 low bits, dropping the low 2 bits from each uint13.
//TODO Small indexs are used in game.rps.tridistSmall (not game.rps.team cuz xoring 0-16 team masks together might cancel itself out).
//Big indexs are used in game.board.
const toSmall = yx=>(((yx&0b11111111111000000000000000)>>>4)|((yx&0b1111111111100)>>>2));

//11 high bits and 11 low bits -> 13 high bits and 13 low bits ->, adding 2 low 0 bits to each uint13.
//toSmall(toBig(smallIndex))==smallIndex, but toBig(toSmall(bigIndex)) only equals bigIndex if its y and x are both divisible by 4.
const toBig = yxSmall=>(((yxSmall&0b1111111111100000000000)<<4)|((yxSmall&0b11111111111)<<2));

//Size/Area is 8192x8192, the main thing. SmallSize/SmallArea is RPS (rock paper scissors) distances cache, the red green and blue glow,
//which as of 2025-1-20 havent been using for months cuz its slow when zoom out and fast when zoomed in small enuf.
//GroundSize and GroundArea are 16x16 smaller than Size/Area, which is 4x4 times smaller than Small.
//Thats cuz Ground counts stacked z (voxel thickness) to become a heightmap up to (2**21)-1 so comes in thin stacked slices.

/*//2025-1-26+ changing from 512x512 of 16x16 ground tiles to 1024x1024 of 8x8. OLD:
const GroundTileBits = 4;
const GroundTileSize = 1<<GroundTileBits;
const GroundTileSizeMask = GroundTileSize-1;
const GroundBits = SizeBits-GroundTileBits;
const GroundSize = 1<<GroundBits;
if(Size>>GroundTileBits != GroundSize) Err('GroundSize');
const GroundMask = GroundSize-1;
//512x512, each a 16x16 of Size/Area but we only store the ground height at these corners.
//The 8192x8192 area is just the nearest area. Its actually 2**24 X 2**24 as defined by Square, SquareH, SquareY, SquareX.
//All that wraps around the Size/8192x8192, Small/2048x2048, and Ground/512x512.
const GroundArea = GroundSize**2;
*/
//2025-1-26+ changing from 512x512 of 16x16 ground tiles to 1024x1024 of 8x8.
const GroundTileBits = 3;
const GroundTileSize = 1<<GroundTileBits;
const GroundTileSizeMask = GroundTileSize-1;
const GroundBits = SizeBits-GroundTileBits;
const GroundSize = 1<<GroundBits;
if(Size>>GroundTileBits != GroundSize) Err('GroundSize');
const GroundMask = GroundSize-1;
//1024x1024, each a 8x8 of Size/Area but we only store the ground height at these corners.
//The 8192x8192 area is just the nearest area. Its actually 2**24 X 2**24 as defined by Square, SquareH, SquareY, SquareX.
//All that wraps around the Size/8192x8192, Small/2048x2048, and Ground/1024x1024.
const GroundArea = GroundSize**2;

//2025-1-29 GroundArea and GroundSize and game.ground* vars, should not be used as they are being replaced by
//game.qint and game.qflo which are an Int32Array and Float64Array overlapping the same memory,
//which are used with Qu Qd Ql Qr Qp Qx Qy Qlev Blev etc, to implement quadtree bilinear interpolation
//of potential energy being of the total z height at each (y,x) so use bilinearPotentialEnergy func with it.
//TODO remove Ground code, WallQuad code, Quad code, BitPic code, and other experimental code before this new design.



/** computes the total potential energy (height*height/2) of every point in y=0..1 x=0..1,
which is the area under the curve (in that unit square) of .5*(UL*(1-x)*(1-y)+UR*x*(1-y)+DL*(1-x)*y+DR*x*y)**2
which is the heightmap of z=(UL*(1-x)*(1-y)+UR*x*(1-y)+DL*(1-x)*y+DR*x*y).

Very important: if UL UR DL and DR are all nonnegative multiples of 6, then potential energy is an integer.
*/
const bilinearPotentialEnergy = (UL,UR,DL,DR)=>{
	const a = UL - UR - DL + DR, b = UR - UL, c = DL - UL, d = UL;
	return .5*((a * a) / 9 + (2 * a * b) / 6 + (2 * a * c) / 6 + (b * b) / 3 + (2 * b * c) / 4 + (c * c) / 3 + (2 * a * d) / 4 + (2 * b * d) / 2 + (2 * c * d) / 2 + (d * d));
};

//For testing bilinearMult. In theory this is same as bilinearPotentialEnergy,
//but implemented using bilinearMult a slower way.
//Except for roundoff, which does not happen when params are multiples of 6 and small enuf,
//forall UL, UR, DL, DR, bilinearPotentialEnergy(UL, UR, DL, DR)==bilinearPotentialEnergyB(UL, UR, DL, DR).
const bilinearPotentialEnergyB = (UL,UR,DL,DR)=>(bilinearMult(UL,UR,DL,DR, UL,UR,DL,DR)/2);


//multiply the heights of 2 bilinear interpolations and return the area under the curve,
//as y and x each range 0..1 in this coordinate system,
//despite y and x range 0..8191 (or 8192 exclusive or if its viewed as continuous) in the other coords.
//Since bilinearPotentialEnergy computes sum of z*z/2, and this computes sum of az*bz,
//bilinearPotentialEnergy could be computed by calling this on the same 4 numbers each as 2 params
//then divide by 2, but this is the more expensive calculation so keep bilinearPotentialEnergy as it is.
//az=(aUL*(1-x)*(1-y)+aUR*x*(1-y)+aDL*(1-x)*y+aDR*x*y)
//bz=(bUL*(1-x)*(1-y)+bUR*x*(1-y)+bDL*(1-x)*y+bDR*x*y)
//sum of az*bz.
//const bilinearMult = (aUL,aUR,aDL,aDR, bUL,bUR,bDL,bDR)=>{	
//};
/**
 * Computes the integral of the product of two bilinear forms defined by their corner values in a unit square.
 * The function calculates:
 *   az(x,y) = aUL*(1-x)*(1-y) + aUR*x*(1-y) + aDL*(1-x)*y + aDR*x*y,
 *   bz(x,y) = bUL*(1-x)*(1-y) + bUR*x*(1-y) + bDL*(1-x)*y + bDR*x*y,
 * with x and y ranging from 0 to 1.
 *
 * The integral of the product of these two functions is computed over the unit square.
 *
 * @param {number} aUL - Upper Left value for az
 * @param {number} aUR - Upper Right value for az
 * @param {number} aDL - Lower Left value for az
 * @param {number} aDR - Lower Right value for az
 * @param {number} bUL - Upper Left value for bz
 * @param {number} bUR - Upper Right value for bz
 * @param {number} bDL - Lower Left value for bz
 * @param {number} bDR - Lower Right value for bz
 * @returns {number} - The computed integral of the product.
 */
//Very important: if all 8 params are nonnegative multiples of 6, then potential energy is an integer.
//TODO does it also work for negatives, and all combos of positives and negatives, of all 8 params?
const bilinearMult = (aUL, aUR, aDL, aDR, bUL, bUR, bDL, bDR) => {
    // Define coefficients for az
    const fa = aUL, ga = aUR-aUL, ha = aDL-aUL, ia = aUL-aUR-aDL+aDR;
    // Define coefficients for bz
    const fb = bUL, gb = bUR-bUL, hb = bDL-bUL, ib = bUL-bUR-bDL+bDR;

    // Compute the integral of the product az*bz over [0,1]x[0,1]
    const integral = 
        fa*fb + // integral of f*j
        fa*gb/2 + // integral of f*k*x
        fa*hb/2 + // integral of f*l*y
        fa*ib/4 + // integral of f*m*x*y
        ga*fb/2 + // integral of g*j*x
        ga*gb/3 + // integral of g*k*x^2
        ga*hb/4 + // integral of g*l*x*y
        ga*ib/6 + // integral of g*m*x^2*y
        ha*fb/2 + // integral of h*j*y
        ha*gb/4 + // integral of h*k*x*y
        ha*hb/3 + // integral of h*l*y^2
        ha*ib/6 + // integral of h*i*x*y^2
        ia*fb/4 + // integral of i*j*x*y
        ia*gb/6 + // integral of i*k*x^2*y
        ia*hb/6 + // integral of i*l*x*y^2
        ia*ib/9;  // integral of i*m*x^2*y^2

    return integral;
};

var test_bilinearMult = ()=>{
	let unit = 6;
	let bilinearMultOfSomePrimes_observed = bilinearMult(7*6, 11*6, 13*6, 17*6, 19*6, 23*6, 29*6, 31*6);
	let bilinearMultOfSomePrimes_correct = 11214;
	if(bilinearMultOfSomePrimes_observed != bilinearMultOfSomePrimes_correct){
		Err('bilinearMult(7*6, 11*6, 13*6, 17*6, 19*6, 23*6, 29*6, 31*6) returned '+
			bilinearMultOfSomePrimes_observed+' but expected '+bilinearMultOfSomePrimes_correct);
	}
	let repeat = 10;
	for(let UL=0; UL<repeat*unit; UL+=unit){
		for(let UR=0; UR<repeat*unit; UR+=unit){
			for(let DL=0; DL<repeat*unit; DL+=unit){
				for(let DR=0; DR<repeat*unit; DR+=unit){
					let a = bilinearPotentialEnergy(UL,UR,DL,DR);
					let b = bilinearPotentialEnergyB(UL,UR,DL,DR);
					if(a !== b){
						Err('bilinearPotentialEnergy ('+a+') differs from bilinearPotentialEnergyB ('+b+') params: '+UL+' '+UR+' '+DL+' '+DR);
					}
				}
			}
		}
	}
	console.log('test_bilinearMult test pass');
};
test_bilinearMult();


/* QEdgeWeight is used in QAdd to keep qflo updated. This is (TODO cached) bilinearMult of the normed view of
2 ptrs, where each corner is either height 0 or 1, as the tarp/pyramid/tent shaped windowing functions
are the basics of bilinear interpolation. Its not interpolating anything specific. Its the general bilinear
relations between 2 quadtree nodes, that doesnt change based on game state. Its derived only from the 2 int ptrs.
Its useful for any 2 quadtree nodes that overlap at all, as each is a powOf2 size and there can be
exponentially many such overlapping pairs, the exponent being it goes from 1x1 2x2 4x4 8x8 ... 4096x4096 8192x8192.
Each ptr refers to 1 corner shared between 4 such squares. Those 4 squares are called its tarps.
This handles all 4 tarps of parentPtr and all 4 tarps of childPtr.
//
if(selfOrParent !== startTarpPtr && tarpIndex==0){ //TODO move this IF out of the tarpIndex loop.
	let parent = selfOrParent;
	//This part is to update qflo so potenChange += val*qflo[selfOrParent], in future calls on any of my parents,
	//will know the right amount to change qint by.
	//let edgeWeight = bilinearMult(ul, ur, dl, dr, )
	Err('This is supposed to be of the normed form, where all corners are either 0 or 1, for 8 corners, so I should make a QEdgeWeight func which is similar to bilinearMult but faster');
	let edgeWeight = QEdgeWeight(parent, startTarpPtr);
	qflo[parent] += val*edgeWeight;
}*/
//the cached form of QEdgeWeightRaw, that for the first n qlevs, such as a 4x4 overlapping a 32x32, uses the math that
//the edge weights repeat in relative shapes, like QEdgeWeightRaw(ptr, Qul(Qdr(ptr))) should equal for all ptr on same qlev, etc.
var QEdgeWeight = (parentPtr, childPtr)=>{
	//TODO like a fractal, make most possible (parentPtr,childPtr) combos refer to those in a smaller range
	//where many such duplicates get redirected, to give the same answer as QEdgeWeightRaw but much faster.
	return QEdgeWeightRaw(parentPtr,childPtr);
};

var QEdgeWeightRaw = (parentPtr, childPtr)=>{
	if(parentPtr >= childPtr){ //to go up to parent, Qp does child>>2.
		return 0;
	}
	console.log('QEdgeWeightRaw start: parentPtr='+parentPtr+' childPtr='+childPtr);
	//call QEdgeWeight_parent_tarpIndex_child_tarpIndex 16 times.
	let sumOf16WeightsEachBetween2Tarps = 0;
	for(let childTarpIndex=0; childTarpIndex<4; childTarpIndex++){
		//console.log('outer loop, childTarpIndex='+childTarpIndex);
		let childTarpPtr = tarpFuncs[childTarpIndex](childPtr); //when parentTarpIndex is 3 this is just childPtr
		let chNormCorners = tarpNorms[childTarpIndex];
		let childY = Qy(childTarpPtr);
		let childYEnd = QyEnd(childTarpPtr);
		let childX = Qx(childTarpPtr);
		let childXEnd = QxEnd(childTarpPtr);
		for(let parentTarpIndex=0; parentTarpIndex<4; parentTarpIndex++){
			//console.log('inner loop, parentTarpIndex='+parentTarpIndex);
			let parentTarpPtr = tarpFuncs[parentTarpIndex](parentPtr); //when parentTarpIndex is 3 this is just parentPtr
			if(QContainsSquare(parentTarpPtr,childTarpPtr)){
				let parNormCorners = tarpNorms[parentTarpIndex];
				
				let parY = Qy(parentPtr);
				let parX = Qx(parentPtr);
				let parSide = Qside(parentPtr);
				let relChildY = (childY-parY)/parSide; //relative to as if parent square is 0..1
				let relChildYEnd = (childYEnd-parY)/parSide;
				let relChildX = (childX-parX)/parSide;
				let relChildXEnd = (childXEnd-parX)/parSide;
				//console.log('QEdgeWeightRaw, parentTarpPtr='+parentTarpPtr+' childTarpPtr='+childTarpPtr+' relChildY='+relChildY+' relChildYEnd='+relChildYEnd+' parY='+parY+' childY='+childY);
				
				
				/*fixme these errors are happening 2025-2-4+
				if(relChildY < 0 || 1 < relChildY){ //rel 0..1 is inside parent. some will be on the line. some more in the middle of parent.
					Err('relChildY='+relChildY);
				}
				if(relChildYEnd < 0 || 1 < relChildYEnd){
					Err('relChildYEnd='+relChildYEnd);
				}
				if(relChildX < 0 || 1 < relChildX){
					Err('relChildX='+relChildX);
				}
				if(relChildXEnd < 0 || 1 < relChildXEnd){
					Err('relChildXEnd='+relChildXEnd);
				}*/

				
				//Err('FIXME QInterp8k_ul_ur_dl_dr_y_x expects y and x in range 0..1');
				let parentNormedZAtChildUL = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], relChildY, relChildX);
				let parentNormedZAtChildUR = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], relChildY, relChildXEnd);
				let parentNormedZAtChildDL = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], relChildYEnd, relChildX);
				let parentNormedZAtChildDR = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], relChildYEnd, relChildXEnd);
				
				//let parentNormedZAtChildUL = QInterp8k_ul_ur_dl_dr_y_x(
				//	parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], childRelY, childRelX);
				/*let parentNormedZAtChildUL = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], childY, childX);
				let parentNormedZAtChildUR = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], childY, childXEnd);
				let parentNormedZAtChildDL = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], childYEnd, childX);
				let parentNormedZAtChildDR = QInterp8k_ul_ur_dl_dr_y_x(
					parNormCorners[0], parNormCorners[1], parNormCorners[2], parNormCorners[3], childYEnd, childXEnd);
				*/
					
				let weightBetween2Tarps = bilinearMult(
					chNormCorners[0], chNormCorners[1], chNormCorners[2], chNormCorners[3],
					parentNormedZAtChildUL, parentNormedZAtChildUR, parentNormedZAtChildDL, parentNormedZAtChildDR);
				
				//console.log(`childY: ${childY}, childX: ${childX}, childYEnd: ${childYEnd}, childXEnd: ${childXEnd}`);
				//console.log(`parentNormedZAtChildUL: ${parentNormedZAtChildUL}, parentNormedZAtChildUR: ${parentNormedZAtChildUR}`);
				//console.log(`parentNormedZAtChildDL: ${parentNormedZAtChildDL}, parentNormedZAtChildDR: ${parentNormedZAtChildDR}`);
				//console.log(`weightBetween2Tarps: ${weightBetween2Tarps}`);
				sumOf16WeightsEachBetween2Tarps += weightBetween2Tarps;
			}
		}
	}
	//console.log('QEdgeWeightRaw end: parentPtr='+parentPtr+' childPtr='+childPtr+', returning sumOf16WeightsEachBetween2Tarps='+sumOf16WeightsEachBetween2Tarps);
	return sumOf16WeightsEachBetween2Tarps;
};

/* 2025-2-3 this is very wrong. they should all be the same.
for(let i=64; i<128; i++) console.log(QEdgeWeight(i, Qdr(i)));
VM1199:1 0.87890625
2VM1199:1 0.76171875
VM1199:1 0.6601562500000001
VM1199:1 0.64453125
VM1199:1 0.52734375
VM1199:1 0.55859375
VM1199:1 0.45703124999999994
VM1199:1 0.64453125
VM1199:1 0.55859375
VM1199:1 0.52734375
VM1199:1 0.45703125
VM1199:1 0.47265625
2VM1199:1 0.38671875
VM1199:1 0.31640625
VM1199:1 0.41015624999999994
VM1199:1 0.29296875
VM1199:1 0.35546875
VM1199:1 0.25390624999999994
VM1199:1 0.17578125
VM1199:1 0.05859374999999999
VM1199:1 0.15234375
VM1199:1 0.05078125
VM1199:1 0.30078125
VM1199:1 0.21484375
VM1199:1 0.24609375
VM1199:1 0.17578125
VM1199:1 0.12890625
VM1199:1 0.04296875
VM1199:1 0.10546875
VM1199:1 0.03515625
VM1199:1 0.41015625
VM1199:1 0.35546875
VM1199:1 0.29296875
VM1199:1 0.25390625000000006
VM1199:1 0.30078125
VM1199:1 0.24609375
VM1199:1 0.21484375
2VM1199:1 0.17578125
VM1199:1 0.15234375
VM1199:1 0.05859375
VM1199:1 0.05078125
VM1199:1 0.12890625000000003
VM1199:1 0.10546875
VM1199:1 0.04296875000000001
VM1199:1 0.03515625
VM1199:1 0.19140625
2VM1199:1 0.13671875
VM1199:1 0.09765625
VM1199:1 0.08203125
VM1199:1 0.02734375
VM1199:1 0.05859375
VM1199:1 0.01953125
VM1199:1 0.08203125
VM1199:1 0.05859374999999999
VM1199:1 0.02734375
VM1199:1 0.019531249999999997
VM1199:1 0.03515625
VM1199:1 0.011718750000000002
VM1199:1 0.01171875
VM1199:1 0.00390625
undefined
*/
var test_QEdgeWeightRaw_symmetryByOffsetYAndX = ()=>{
	//for(let ptr in [1, 4, 5, 6, 7, 16, 17, 18, 19, 30, 31, 128, 129, 130, 131, 132, 133, 204653]){
	let theseTestsPassed = 0;
	let funcs = [
		//Ql, Qr, Qu, Qd, Qul, Qur, Qdl, Qdr, Qp,
		Qul, Qur, Qdl, Qdr,
		ptr=>Qdl(Qul(ptr)),
		ptr=>Qdr(Qul(ptr)),
		ptr=>Qul(Qul(ptr)),
		ptr=>Qur(Qul(ptr)),
		ptr=>Qdl(Qur(ptr)),
		ptr=>Qdr(Qur(ptr)),
		ptr=>Qul(Qur(ptr)),
		ptr=>Qur(Qur(ptr)),
		ptr=>Qdl(Qdl(ptr)),
		ptr=>Qdr(Qdl(ptr)),
		ptr=>Qul(Qdl(ptr)),
		ptr=>Qur(Qdl(ptr)),
		ptr=>Qdl(Qdr(ptr)),
		ptr=>Qdr(Qdr(ptr)),
		ptr=>Qul(Qdr(ptr)),
		ptr=>Qur(Qdr(ptr)),
		ptr=>Qur(Qul(Qdr(ptr))),
		ptr=>Qur(Ql(Qul(Qdr(ptr)))),
		ptr=>Qur(Qr(Qul(Qdr(ptr)))),
		ptr=>Qur(Qu(Qul(Qdr(ptr)))),
		ptr=>Qur(Qd(Qul(Qdr(ptr)))),
		ptr=>Qur(Qd(Qul(Qu(Qdr(ptr))))), //can go 3 deep Qur Qul Qdr (Qd and Qu dont count cuz those are siblings) cuz "for(let qlev=3;"
	];
	for(let qlev=3; qlev<8; qlev++){ //TODO up to which qlev do we cache QEdgeWeightRaw into QEdgeWeight?
		let minPtrAtQlev = 1<<(26-(qlev<<1)); //1<<26 is lowest ptr at qlev 0, which is 8192x8192 of 1x1 qtiles
		let maxPtrAtQlev = (minPtrAtQlev<<1)-1;
		for(let f=0; f<funcs.length; f++){
			let func = funcs[f]; //ptr=>ptr func
			let firstEdge = QEdgeWeightRaw(minPtrAtQlev, func(minPtrAtQlev));
			for(let otherPtr=minPtrAtQlev; otherPtr<=maxPtrAtQlev; otherPtr = ((otherPtr*1.05)+1)|0){
				let otherEdge = QEdgeWeightRaw(otherPtr, func(otherPtr));
				let diff = Math.abs(firstEdge-otherEdge);
				if(diff > .0001){
					Err('test_QEdgeWeightRaw_symmetryByOffsetYAndX test fail.\nQEdgeWeightRaw(minPtrAtQlev='+minPtrAtQlev+', func(minPtrAtQlev)='+func(minPtrAtQlev)+')='+firstEdge+'\ndiffers from\nQEdgeWeightRaw(otherPtr='+otherPtr+', func(otherPtr)='+func(otherPtr)+')='+otherEdge+'\nbut they should equal (except roundoff, which im gonna fix to be exact integers by multiples of 6 by a powOf2 see bilinearMult and bilinearPotentialEnergy) cuz QEdgeWeightRaw depends only on the 2 int ptrs and not game state. qlev='+qlev+' theseTestsPassed='+theseTestsPassed+'\nfunc='+(func.name || func));
				}
				theseTestsPassed++;
			}
		}
	}
	console.log('All '+theseTestsPassed+' test_QEdgeWeightRaw_symmetryByOffsetYAndX tests pass.');
};

var QContainsSquare = (parentPtr, childPtr)=>{ //contains at any depth, like 5 contains Qur(Qdl(Qdr(5))).
	//could do this using Math.clz32 without the loop. would it be faster?
	while(childPtr>0){
		if(parentPtr === childPtr){
			return true;
		}
		childPtr = Qp(childPtr);
	}
	return false;
};

//var QEdgeWeight_parent_tarpIndex_child_tarpIndex = (parentPtr, parentTarpIndex, childPtr, childTarpIndex)=>{
//};


const Test = (condition, message)=>{
	if(condition){
		console.log('Test pass: '+message);
	}else{
		let s = "Test fail";
		if(message) s += ": "+message;
		Err(s);
    }
}

const TestEqq = (valA, valB, message)=>{
	if(!message) message = '';
	message += ' valA='+valA+' valB='+valB;
	if(valA === valB){
		console.log('Test pass: '+message);
	}else{
		Err("Test fail: "+message);
    }
}

const TestEvalEqq = (evalA, valB, message)=>{
	if(!message) message = '';
	let valA = eval(evalA);
	message += 'evalA['+evalA+'] valA='+valA+' valB='+valB;
	if(valA === valB){
		console.log('Test pass: '+message);
	}else{
		Err("Test fail: "+message);
    }
}



//other q funcs numbers, for use with game.qint and game.qflo arrays (which share the same buffer).
//The biggest square range in those is Size*Size aka Area. Its still 8192x8192 but also has 1x1 2x2 4x4 512x512 etc,
//though only the small ones are used cuz sums get big, maybe up to 64x64 or something like that.
const Qarsiz = Area<<1; //Q array size. in units of ints. The Float64Array overlapping it only uses the odd binheap indexs.

//aka highest 1 bit at
//const Blev = ptr=>(31-Math.clz32(ptr)); wrong cuz is reversed
const Blev = ptr=>(Math.clz32(ptr)-5);

//The level at a pointer/ptr the log2 of its width and of its height. Qlev(1) is 13 as its a 8192x8192 tile.
//Qlev(4) up to Qlev(7) is 12 as each is a 4096x4096 tile. Qlev(1<<26) to Qlev((1<<27)-1) is 0 as each is a 1x1 tile.
//The area of the tile at ptr is 4**Qlev(ptr),
//but thats just the bottom right tarp of 4 tarps of ptr. Ql(ptr), Qu(ptr), and Ql(Qu(ptr)) are the other 3,
//as thats how the "z = max(0, 1 - abs(x)) * max(0, 1 - abs(y))" function overlaps itself.
//Each voxel is a copy of that function affine transformed into the game area.
const Qlev = ptr=>(Blev(ptr)>>1);
//const Qlev = ptr=>(31-Math.clz32(ptr));
TestEvalEqq('Qlev(1)', 13);
TestEvalEqq('Qlev(1<<22)', 2);
TestEvalEqq('Qlev((1<<23)-1)', 2);
TestEvalEqq('Qlev(1<<24)', 1);
TestEvalEqq('Qlev((1<<25)-1)', 1);
TestEvalEqq('Qlev(1<<26)', 0);
TestEvalEqq('Qlev((1<<27)-1)', 0);
console.log('Qlev tests pass.');

const Qside = ptr=>(1<<Qlev(ptr));

//A tile's quadtree primaryKey is its bottom right child of 4 childs,
//so area is actually 2x2 bigger, but we compute it in tarps cuz they're easier to sum recursively.
//
//area of a tile. same as Qside(ptr)**2.
const Qarea = ptr=>(1<<Blev(ptr));

//this is backward: const QyxMask = ptr=>(Qarea(ptr)-1); //mask over the y x y x... in the high 1 bit then y x y x y x...
const QyxMask = ptr=>((1<<(31-Math.clz32(ptr)))-1); //mask over the y x y x... in the high 1 bit then y x y x y x...
TestEvalEqq('QyxMask(1)', 0);
TestEvalEqq('QyxMask(4)', 3);
TestEvalEqq('QyxMask(7)', 3);
TestEvalEqq('QyxMask(16)', 15);
TestEvalEqq('QyxMask(31)', 15);
TestEvalEqq('QyxMask(1<<26)', (1<<26)-1);
TestEvalEqq('QyxMask((1<<27)-1)', (1<<26)-1);

//mask over the y x y x... in the high 1 bit then y x y x y x...
//Be careful not to include the high 1 bit as an x, since x's go at even indexs,
//and node ptrs (not the game.qflo at odd binheap levels) always have high 1 bit at even bit index
const QBiggestYxMask = Area-1; //low 26 bits all 1s as its where the coordinates for 8192x8192 go in biggest quadheap level

//just the odd bits. Since a quadheap ptr has high 1 bit at even index, u can use this for y but not for x.
//const QyMaskCheap = 0xaaaaaaaa;
const QyMaskCheap = 0xaaaaaaaa&QBiggestYxMask; //&QBiggestYxMask so it only includes the low 26 bits for 8192x8192

//just the even bits. Since a quadheap ptr has high 1 bit at even index, you cant optimize with this like u can
//with QyMaskCheap cuz it will include the high 1 bit as if it was an x bit which its not. The high 1 bit is just
//there to tell the binheap level, and quadheap is 2 binheap levels at once, and we store game.qflo in the
//odd binheap levels overlapping 2 ints in game.qint.
const QxMaskCheap = 0x55555555&QBiggestYxMask; //&QBiggestYxMask so it only includes the low 26 bits for 8192x8192

//QHighBitMask(ptr)|QyMask(ptr)|QxMask(ptr) is all the bits covered by the ptr.
const QHighBitMask = ptr=>(1<<Blev(ptr));

const QyMask = ptr=>(QyxMask(ptr)&QyMaskCheap); //even indexed bits below the high 1 bit

const QxMask = ptr=>(QyxMask(ptr)&QxMaskCheap); //odd indexed bits below the high 1 bit

TestEvalEqq('(1<<26)+QxMask((1<<27)-1)+QyMask((1<<27)-1)', (1<<27)-1);
TestEvalEqq('(1<<26)+QxMask((1<<27)-12345)+QyMask((1<<27)-12345)', (1<<27)-1);
TestEvalEqq('QxMask(16)', 0b0101);
TestEvalEqq('QxMask(31)', 0b0101);
TestEvalEqq('QyMask(16)', 0b1010);
TestEvalEqq('QyMask(31)', 0b1010);
TestEvalEqq('QyMask(4)', 0b10);
TestEvalEqq('QyMask(7)', 0b10);
TestEvalEqq('QxMask(4)', 0b01);
TestEvalEqq('QxMask(7)', 0b01);
TestEvalEqq('QxMask(1)', 0);


//int32 -> uint16, dropping the odd indexed bits. https://en.wikipedia.org/wiki/Z-order_curve
const QEvenBitsAsUint16 = i=>{
	i &= 0b01010101010101010101010101010101;
	i |= i >>> 1;
	i &= 0b00110011001100110011001100110011;
	i |= i >>> 2;
	i &= 0b00001111000011110000111100001111;
	i |= i >>> 4;
	i &= 0b00000000111111110000000011111111;
	i |= i >>> 8;
	i &= 0b00000000000000001111111111111111;
	return i;
};

//int32 -> uint16, dropping the even indexed bits. https://en.wikipedia.org/wiki/Z-order_curve
const QOddBitsAsUint16 = i=>QEvenBitsAsUint16(i>>>1);

//inverse of QEvenBitsAsUint16. https://en.wikipedia.org/wiki/Z-order_curve
const QUint16ToEvens = uint16 => {
	let i = uint16 & 0b00000000000000001111111111111111;
	i |= i << 8;
	i &= 0b00000000111111110000000011111111;
	i |= i << 4;
	i &= 0b00001111000011110000111100001111;
	i |= i << 2;
	i &= 0b00110011001100110011001100110011;
	i |= i << 1;
	return i & 0b01010101010101010101010101010101;
};

//inverse of QOddBitsAsUint16. https://en.wikipedia.org/wiki/Z-order_curve
const QUint16ToOdds = uint16=>(QUint16ToEvens(uint16)<<1);

var test_QEvenBitsAsUint16_etc = ()=>{
	let testsPassed = 0;
	let j = 0;
	while(j<(2**32)){
		let i = j|0; //int32. will include negatives.
		let evensUint16 = QEvenBitsAsUint16(i);
		let oddsUint16 = QOddBitsAsUint16(i);
		if(evensUint16 > 0xffff){
			Err('QEvenBitsAsUint16 is broken, i='+i);
		}
		if(oddsUint16 > 0xffff){
			Err('QOddBitsAsUint16 is broken, i='+i);
		}
		let rebuiltI = QUint16ToOdds(oddsUint16)|QUint16ToEvens(evensUint16);
		if(i != rebuiltI){
			Err('i ('+i+') != rebuiltI ('+rebuiltI+'). evensUint16='+evensUint16+' oddsUint16='+oddsUint16+' testPassed='+testsPassed);
		}
		testsPassed++;
		j += (j<1234567) ? 1 : 1234567;
	}
	console.log('Tests pass for QEvenBitsAsUint16, QUint16ToEvens, QOddBitsAsUint16, QUint16ToOdds.');
};
test_QEvenBitsAsUint16_etc();

const QYTile = ptr=>QOddBitsAsUint16(ptr&QyMaskCheap);
const QXTile = ptr=>QEvenBitsAsUint16(ptr&QxMask(ptr));
TestEvalEqq('QYTile(1)', 0);
TestEvalEqq('QYTile(4)', 0);
TestEvalEqq('QXTile(4)', 0);
TestEvalEqq('QYTile(7)', 1);
TestEvalEqq('QXTile(7)', 1);
TestEvalEqq('QYTile(16)', 0);
TestEvalEqq('QXTile(16)', 0);
TestEvalEqq('QYTile(31)', 3);
TestEvalEqq('QXTile(31)', 3);
TestEvalEqq('QYTile(1<<26)', 0);
TestEvalEqq('QXTile(1<<26)', 0);
TestEvalEqq('QYTile((1<<27)-1)', 8191);
TestEvalEqq('QYTile((1<<27)-2)', 8191);
TestEvalEqq('QXTile((1<<27)-2)', 8190);

//get y coordinate, from 0 to Size-1, of the quadheap ptr. Can use QyMaskCheap here cuz quadheap ptr has
//high 1 bit at even index, but cant QxMaskCheap for that same reason.
//this is actually the tile index in x: const Qy = ptr=>QOddBitsAsUint16(ptr&QyMaskCheap);
const Qy = ptr=>(Qside(ptr)*QYTile(ptr));
const QyEnd = ptr=>(Qy(ptr)+Qside(ptr));

//get x coordinate, from 0 to Size-1, of the quadheap ptr. Cant use QxMaskCheap cuz quadheap ptr has high 1 bit at even index.
//this is actually the tile index in x: const Qx = ptr=>QEvenBitsAsUint16(ptr&QxMask(ptr));
const Qx = ptr=>(Qside(ptr)*QXTile(ptr));
const QxEnd = ptr=>(Qx(ptr)+Qside(ptr));

//Tiles are 2x2 times bigger each next parent, so qlev0To13 number of low bits are dropped from each uint13.
const QlevYXToPtr = (qlev0To13,yUint13,xUint13)=>(
	(1<<((13-qlev0To13)<<1)) | //high 1 bit
	QUint16ToOdds((yUint13&0x1fff)>>qlev0To13) | //y quadtree node index at odd bits under the high 1 bit
	QUint16ToEvens((xUint13&0x1fff)>>qlev0To13) //x quadtree node index at even bits under the high 1 bit
);
TestEvalEqq('QlevYXToPtr(13,0,0)',1); //root quadtree node at ptr 1
TestEvalEqq('QlevYXToPtr(12,0,0)',4);
TestEvalEqq('QlevYXToPtr(12,0,4096)',5);
TestEvalEqq('QlevYXToPtr(12,4096,0)',6);
TestEvalEqq('QlevYXToPtr(12,4096,4096)',7);
TestEvalEqq('QlevYXToPtr(11,0,0)',16);
TestEvalEqq('QlevYXToPtr(11,2048*3,2048*3)',31);
TestEvalEqq('QlevYXToPtr(0,0,0)',1<<26);
TestEvalEqq('QlevYXToPtr(0,8191,8191)',(1<<27)-1);
TestEvalEqq('QlevYXToPtr(1,0,0)',1<<24);
TestEvalEqq('QlevYXToPtr(2,0,0)',1<<22);
//todo TestEvalEqq('QlevYXToPtr(2,8192-4,8192-4)',WHAT?);

/* packs 5 numbers into 1 number. Each paints 1..thousands of pixels.
Qvox(418,34,2,1856,8044)
3595161826117
Vz(3595161826117)
418
Vc(3595161826117)
34
Vqlev(3595161826117)
2
Vy(3595161826117)
1856
Vx(3595161826117)
8044
Vptr(3595161826117)
5763909
Its by design very fast to get the array pointer from a qvoxel. 3595161826117&0x7ffffff
returns 5763909. Just takes the low 27 bits of the positive integer. And thats what index
you use it in the Int32Array qint and Float64Array qflo.
A qvoxel is an integer between 1 and ((2**53)-1)=9007199254740991, that refers to a 1x1, 2x2,
4x4, or up to 8192x8192, area of the screen to paint 1 of 64 colors and add a height between
plus/minus 500k (for mountains, valleys, saddlepoints, and other shapes of game objects).
You will only be able to use some of those "height between plus/minus 500k" when using
bigger (in screen size) qvoxels, cuz I can only compute the total potential energy of the
game world if all squares I do physics on have at their 4 corners a multiple
of 6 (height/brightness/z). -- https://x.com/benrayfield/status/1886476184625766424 2025-2-3.
The number of joules of potential energy of the whole simulation is always an integer.
I'm making a game-tree. Many paths can lead the same place. Many paths lead to ever expanding
worlds of all possible combos. Functions are dimensions you can fade them in and out.
The amount of mass is an integer, and the amount of potential energy is an integer,
or if its not then theres still some bugs around, things to scale, etc.
When a voxel is added on top of other voxels of varying sizes and positions, that they
partially overlap, mass must sometimes be created by paying the energy cost to lift from
potential energy 0 to current potential energy.
*/
//Packs a quadtree voxel into a uint53 (in a float64), a 6 bit color and 20 bit z/thickness at a (y,x).
//Maybe z should be an int20 (-2**19 to (2**19)-1) or a uint20 (0 to (2**20)-1).
//If we define it as int20 then a voxel can be defined as removing another voxel by negating it.
//To get the y out of it, use Qy(Qvox(...)). To get x, Qx(Qvox(...)). To get qlev, 
const Qvox = (zThicknessInt20,colorUint6,qlev0To13,yUint13,xUint13)=>(
	(zThicknessInt20&0xfffff)*(2**33) +
	(colorUint6&63)*(1<<27) +
	QlevYXToPtr(qlev0To13, yUint13, xUint13)
);

//get ptr, which is a uint27, (at a quadtree node in game.qint and game.qflo) from a qvox voxel.
const Vptr = v=>(v&0x07ffffff);

//get the qlev of a qvox voxel, which is 0..13.
//The high 1 bit in Vptr(voxel) is 1<<(Vqlev(voxel)<<1) and at 1<<Blev(voxel).
const Vqlev = v=>Qlev(Vptr(v));
//get the blev of a qvox voxel, which is 0..26 counting by 2s.
const Vblev = v=>Blev(Vptr(v));

//get zThickness of a qvox voxel which is an int20, which ranges -(1<<19) to (1<<19)-1.
//this would be uint20, but its supposed to be int20: const Vz = v=>((v/(2**33))&0xfffff);
//To make it an int20, slide it down to be the high 20 bits in an int32, then >> it into the low 20 bits,
//so it copies the highest of those 20 bits into the 12 bits above those 20,
//the highest of which is the int32 sign bit, so it returns between -(1<<19) to (1<<19)-1, both inclusive.
const Vz = v=>((v/(1<<21))>>12);

//get y of a qvox voxel, which ranges 0 to 8191.
const Vy = v=>Qy(Vptr(v));

//get x of a qvox voxel, which ranges 0 to 8191.
const Vx = v=>Qx(Vptr(v));

//get 6 bit color from a qvox voxel. Each of red, green, and blue is a uint2
//and is multiplied by 85 to get 0, 85, 170, or 255 as brightness of red green or blue.
//See the old voxel system (that uses game.board) such as YXRGB func:
//"const YXRGB = (y,x,r,g,b)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|((r&3)<<4)|((g&3)<<2)|(b&3));".
//Qvox is a new system 2025-1+, but we can still keep game.board and YXRGB etc for use as debug graphics,
//which can be customized by redByteAtYX, greenByteAtYX, and blueByteAtYX funcs
//which is what chooses the color of each pixel at each 1/60 of a second in the html canvas.
const Vc = v=>((v/(1<<27))&63);

//get red as uint2, of a qvox voxel.
const Vr = v=>(Vc(v)>>4);

//get green as uint2, of a qvox voxel.
const Vg = v=>((Vc(v)>>2)&3);

//get blue as uint2, of a qvox voxel.
const Vb = v=>(Vc(v)&3);

//get red byte of a qvox voxel, which will be 0, 85, 170, or 255 which are evenly spread over all brightnesses.
const Vrr = v=>(Vr(v)*85);

//get green byte of a qvox voxel
const Vgg = v=>(Vg(v)*85);

//get blue byte of a qvox voxel
const Vbb = v=>(Vb(v)*85);

//const Q = (qlev0To13,yUint13,xUint13,zThicknessInt20,colorUint6)=>(

TestEvalEqq('Qy(31)', 3*2048);
TestEvalEqq('QyEnd(31)', 4*2048);

console.log('Starting tests: Qvox and the inverses of its parts.');
for(let i=0; i<1000; i++){ //test Qvox and the inverses of its parts.
	let zThicknessInt20 = i+1;
	let colorUint6 = (i*i*i*3+i*i*7+i*19+5)&63;
	let qlev0To13 = i%5;
	let yUint13 = (i*i)&8191;
	let xUint13 = (i*19+123)&8191;
	let mask = ~((1<<qlev0To13)-1);
	yUint13 &= mask; //so when Qvox func drops the low qlev0To13 bits, they were already all 0s so test wont detect a difference.
	xUint13 &= mask;
	let qvoxel = Qvox(zThicknessInt20,colorUint6,qlev0To13,yUint13,xUint13); //a uint53 in a float64.
	console.log('Qvox('+zThicknessInt20+','+colorUint6+','+qlev0To13+','+yUint13+','+xUint13+') returned '+qvoxel);
	if(qvoxel !== Math.floor(qvoxel)){
		Err('test'+i+' qvoxel is not an integer qvoxel='+qvoxel);
	}
	if(qvoxel < 1 || qvoxel >= (2**53)){
		Err('test'+i+' qvoxel='+qvoxel+' is too small or big an integer');
	}
	let ptr = qvoxel&0x07ffffff;
	if((Math.clz32(ptr)&1)===0){
		Err('test'+i+' (qvoxel='+qvoxel+') ptr='+ptr+' is at an odd blev (between 2 qlevs). Those are the indexs that qflo uses. Qint uses the even levels.');
	}
	let rebuiltZ = Vz(qvoxel);
	let rebuiltColor = Vc(qvoxel);
	let rebuiltQlev = Vqlev(qvoxel);
	let rebuiltY = Vy(qvoxel);
	let rebuiltX = Vx(qvoxel);
	if(rebuiltZ !== zThicknessInt20){
		Err('test'+i+' zThicknessInt20='+zThicknessInt20+' !== rebuiltZ='+rebuiltZ);
	}
	if(rebuiltColor !== colorUint6){
		Err('test'+i+' colorUint6='+colorUint6+' !== rebuiltColor='+rebuiltColor);
	}
	if(rebuiltQlev !== qlev0To13){
		Err('test'+i+' qlev0To13='+qlev0To13+' !== rebuiltQlev='+rebuiltQlev);
	}
	if(rebuiltY !== yUint13){
		Err('test'+i+' yUint13='+yUint13+' !== rebuiltY='+rebuiltY);
	}
	if(rebuiltX !== xUint13){
		Err('test'+i+' xUint13='+xUint13+' !== rebuiltX='+rebuiltX);
	}	
}
console.log('Tests pass: Qvox and the inverses of its parts.');

//Ql Qr Qu Qd use z order curve math like this from https://en.wikipedia.org/wiki/Z-order_curve
//but need Math.clz32 to find high 1 bit for level size.
//top    = (((z & 0b10101010) − 1) & 0b10101010) | (z & 0b01010101)
//bottom = (((z | 0b01010101) + 1) & 0b10101010) | (z & 0b01010101)
//left   = (((z & 0b01010101) − 1) & 0b01010101) | (z & 0b10101010)
//right  = (((z | 0b10101010) + 1) & 0b01010101) | (z & 0b10101010)

//get left sibling of quadheap node, wrapping.
const Ql = ptr => {
	let xMask = QxMask(ptr); //get 00x0x0x0x... from 1yxyxyxyx...
	//y bits being 0 is for is for carrying binary digits during -1.
	let newXBits = ((ptr&xMask)-1)&xMask; //-1/+1 is even index 0 for x. -2/+2 is odd index 1 for y.
	return (ptr&~xMask)|newXBits; //change only x bits
};

//get right sibling of quadheap node, wrapping.
const Qr = ptr => {
	let xMask = QxMask(ptr); //get 00x0x0x0x... from 1yxyxyxyx...
	//|QyMaskCheap is for carrying binary digits during +1.
	let newXBits = ((ptr|QyMaskCheap)+1)&xMask; //-1/+1 is even index 0 for x. -2/+2 is odd index 1 for y.
	return (ptr&~xMask)|newXBits; //change only x bits
}; 

//get up/top sibling of quadheap node, wrapping.
const Qu = ptr => {
    let yMask = QyMask(ptr); //get 0y0y0y0y0... from 1yxyxyxyx...
    //x bits being 0 is for carrying binary digits during -2 (-1 skipping the low x bit).
    //let newYBits = ((ptr&yMask)-2)&yMask;
	let newYBits = ((ptr&yMask)-1)&yMask;
    return (ptr&~yMask)|newYBits; //change only y bits
};

//get down/bottom sibling of quadheap node, wrapping.
const Qd = ptr=>{
    let yMask = QyMask(ptr); //get 0y0y0y0y0... from 1yxyxyxyx...
    //x bits being 1 is for carrying binary digits during +2 (+1 skipping the low x bit).
    //let newYBits = ((ptr|QxMaskCheap)+2)&yMask;
	let newYBits = ((ptr|QxMaskCheap)+1)&yMask;
    return (ptr&~yMask)|newYBits; //change only y bits
};

//get up left child of quadheap node. 2 binheap jumps.
const Qul = ptr=>(ptr<<2);

//get up right child of quadheap node. 2 binheap jumps.
const Qur = ptr=>((ptr<<2)|1);

//get down left child of quadheap node. 2 binheap jumps.
const Qdl = ptr=>((ptr<<2)|2);

//get down right child of quadheap node. 2 binheap jumps.
const Qdr = ptr=>((ptr<<2)|3);

//get parent of quadheap node. 2 binheap jumps.
//Since each quadheap node has 4 tarps (which are bilinear interpolations in 1 of the 2x2 quarters of the 2d tent function),
//which include Qu(Ql(ptr)), Qu(ptr), Ql(ptr), and ptr, this can be viewed as the "down right parent" aka the main parent,
//you first get those 4 ptrs and go Qp(Qp(Qp(ptr)))... from each (4 loops of log size each) to update game.qflo[ptrs]
//which is a cache entirely derived from game.qint[ptrs] thats used for computing changes in poten.
const Qp = ptr=>(ptr>>2);

//navigate from root ptr 1 to some of its childs, wrap around y and x, back up to parents, etc. Its a bunch of int=>int funcs.
var testQDirections = ()=>{
	let path = [1, Qr, 1, Ql, 1, Qu, 1, Qd, 1, Qul, 4, Qd, 6, Qr, 7, Ql, 6, Qr, 7, Qu, 5, Qr, 4, Qr, 5, Qr, 4, Qr, 5,
		Qp, 1, Qdr, 7, Qp, 1, Qdl, 6, Qdl, 26, Qr, 27, Qr, 30, Qr, 31, Qr, 26, Qr, 27,
		Qd, 17, Qd, 19, Qd, 25, Qd, 27, Qu, 25, Qu, 19, Qu, 17, Qu, 27, Qp, 6, Qp, 1,
		Qur, 5, Qp, 1, Qdl, 6, Qp, 1, Qdr, 7, Qdr, 31, Qdr, 127, Qdr, 511, Qdr, 2047, Qdr, (1<<13)-1, Qdr, (1<<15)-1,
		Qdr, (1<<17)-1, Qdr, (1<<19)-1, Qdr, (1<<21)-1, Qdr, (1<<23)-1, Qdr, (1<<25)-1, Qdr, (1<<27)-1];
	let ptr = path[0];
	let history = 'testQDirections ptr='+ptr; 
	for(let i=1; i<path.length; i+=2){
		let func = path[i];
		let correctNextPtr = path[i+1];
		let observedNextPtr = func(ptr);
		history += ' '+func.name+' '+observedNextPtr;
		if(correctNextPtr != observedNextPtr){
			Err('i='+i+' ptr='+ptr+' correctNextPtr='+correctNextPtr+' != observedNextPtr='+observedNextPtr+'\nhistory: '+history);
		}
		ptr = observedNextPtr;
	}
	console.log('testQDirections tests pass');
};
testQDirections();

const QUpLeftSibling = ptr=>Ql(Qu(ptr));

const Qident = ptr=>ptr;

/*let ptrDR = ptr; //down right tarp aka the self tarp, which quadtree nodes are aligned on.
let ptrDL = Ql(ptr); //down left tarp, which the voxel hangs into.
let ptrUR = Qu(ptr); //up right tarp, which the voxel hangs into.
let ptrUL = Ql(ptrUR); //up left tarp, which the voxel hangs into.
//ptrUL, ptrUR,
//ptrDL, ptrDR
let ptrs = [ //TODO do it without heap. its just a list size 4, but still\ TODO do no heap.
	ptrUL, ptrUR,
	ptrDL, ptrDR
];*/
const tarpFuncs = [
	QUpLeftSibling, Qu,
	Ql,             Qident
];

//Outer index is same as tarpFuncs. Inner index is 3 0s and a 1 toward center of 2x2 tarps
const tarpNorms = [
	[0,0, //QUpLeftSibling
	 0,1],
			[0,0, //Qu
			 1,0],
	[0,1, //Ql
	 0,0],
			[1,0, //Qident
			 0,0],
];

//const QMinPtr = 1; //the root node, but stuff gets big, numbers only have so much digits, so you'd need bigints for this.
//1<<26 (min if you want it to stop at 1x1 which would be ridiculous) to (1<<27)-1 is the 8192x8192 biggest layer.
//1<<16 for example is 512x512 of 32x32 tiles, cuz its 32x32 (1<<10) times smaller than 1<<26.
//Each <<2 gets you a 2x2 times bigger.
//const QMinPtr = 1<<16;
const QMinPtr = 1<<12; //1<<12 is the smallest ptr of a 128x128 qtile (qlev 7). 1<<26 is the smallest ptr at a 1x1 qtile (qlev 0).
const QMaxPtr = Area; //1<<26

//do bilinear interpolation from a chosen ptr.
//y and x range 0..1 (both ends inclusive) in these coords. If you want game coords use QInterp8k.
var QInterp1 = (qint,ptr,y,x)=>{
	let UL = qint[ptr]>>>6; //the high 26 bits are zSum. Low 6 bits are color.
	let UR = qint[Qr(ptr)]>>>6;
	let DL = qint[Qd(ptr)]>>>6;
	let DR = qint[Qr(Qd(ptr))]>>>6;
	/*this made things appear too far down right.
	let UL = qint[Qu(Ql(ptr))]>>>6;
	let UR = qint[Qu(ptr)]>>>6;
	let DL = qint[Ql(ptr)]>>>6;
	let DR = qint[ptr]>>>6; //the high 26 bits are zSum. Low 6 bits are color.
	*/
	return UL*(1-x)*(1-y) + UR*x*(1-y) + DL*(1-x)*y + DR*x*y;
};

//x and y range 0..8192, and this is a smooth bilinear interpolation so you can go all the way to 8192 not just 8191.
//This is based on that Size==8192 as the game area loaded at once is 8192x8192.
//var QInterp8k = (qint,ptr,y,x)=>QInterp1(qint,ptr,y/Size,x/Size);
var QInterp8k = (qint,ptr,y,x)=>{
	//Wrap around 8192x8192 game area which is reused for whatever gobs are near in y and x's real
	//range 0 to 0xffffff, see Square SquareH SquareY SquareX funcs as theres actually qlev 0..25 (SquareH).
	//Could just &8191 but i might want fractional pixel interpolation? get the whole thing working then optimize
	if(y > Size) y %= Size;
	if(x > Size) x %= Size;
	//let side = Qside(ptr);
	//return QInterp1(qint,ptr,y/side,x/side);
	//return QInterp1(qint,ptr,y/Size,x/Size);
	//return QInterp1(qint,ptr,y/testInterpDivide,x/testInterpDivide);
	let ptrY = Qy(ptr);
	let ptrX = Qx(ptr);
	let ptrSide = Qside(ptr);
	let relY = (y-ptrY)/ptrSide; //is 0..1 if (y,x) is inside the square of ptr
	let relX = (x-ptrX)/ptrSide;
	return QInterp1(qint,ptr,relY,relX);
};

var QInterp1_ul_ur_dl_dr_y_x = (ul,ur,dl,dr,y,x)=>{
	return ul*(1-x)*(1-y) + ur*x*(1-y) + dl*(1-x)*y + dr*x*y;
};

var QInterp8k_ul_ur_dl_dr_y_x = (ul,ur,dl,dr,y,x)=>
	QInterp1_ul_ur_dl_dr_y_x(ul,ur,dl,dr,y/Size,x/Size);
/*var QInterp8k_ul_ur_dl_dr_y_x = (ul,ur,dl,dr,y,x)=>{
	if(y > Size) y %= Size;
	if(x > Size) x %= Size;
	let ptrY = Qy(ptr);
	let ptrX = Qx(ptr);
	let ptrSide = Qside(ptr);
	let relY = (y-ptrY)/ptrSide; //is 0..1 if (y,x) is inside the square of ptr
	let relX = (x-ptrX)/ptrSide;
	fixme i dont have a ptr to get ptrY ptrX and ptrSide from.
	return QInterp1_ul_ur_dl_dr_y_x(qint,ptr,relY,relX);
};*/

//same as QAdd but does not compute change in potential energy, and makes qflo incompatible with
//future calls of QAdd since it wont correctly compute changes in potential energy.
//Maintaining the qflo cache is most of the compute cost of this algorithm,
//but if you want to skip that and just use it as quadtree bilinear interpolation,
//you can do that with this func instead.
var QAddIgnorePoten = (qint,ptr,val,color)=>{
	qint[ptr] = (qint[ptr]^(color&63)) + (val<<6);
	return 0;
};

//add voxel (into qint and qflo, which are normally sharing the same memory,
//qint being Int32Array (normally game.qint), and qflo being Float64Array (normally game.qflo))
//which is a power of 2 size and has a y, x, and zThickness and is a tent/pyramid shaped function
//that does bilinear interpolation but just 1 corner of it but does 1 corner in each of 4 squares.
//To remove the voxel later, use negative zThickness. If theres color, it just xors it into 6 bits.
//qint[ptr]>>>6 (uint26) is the position of that tent/pyramid function, the amount its multiplied by,
//the amount of influence it has on the height of the heightmap.
//Low 6 bits are xor of color of all voxels that paint here.
//
//My quadtree voxels fit in 9 base64 digits each an integer between 1 and (2**53)-1. Each has power
//of 2 size 1x1 to 8192x8192 and y and x, stored as a 2d z-order-curve of 27 bits, 2 bits of red,
//2 bits of green, 2 bits of blue, 20 bits of z/thickness. 4328196882455350 is EN6YSg_gq.
//See Int54ToNineChars and NineCharsToInt54 funcs.
//Since each voxel fits in a normal javascript number or a string of 9 chars, and z can be positive
//or negative, this is a kind of sparse vector of (2**26)+(2**24)+(2**22)...+(2**0)=89478485 dimensions,
//each of which can range plus/minus 2**19, heightmaps can be mixed.
//I could make a version of it thats 3d from 1x1x1 to 512x512x512, and it would run physics
//about the same speed as 2d, but thats too small a game area. 8192x8192 is just big enuf to load
//the stuff nearby in the game.
//Similarly I could split it into 4d of 1x1x1x1 to 64x64x64x64 or 5d of 1x1x1x1x1 to 32x32x32x32x32.
//However u wanna divide the up to 27 bits. Cuz in browser u can only have an
//int array up to 1<<28 ints aka 1gB.
//Also if i make it 3d i'd have to raytrace thru octree which would make the graphics alot slower
//than the physics. The physics in theory works in under 1 microsecond per quadtree voxel modifying
//whole world state to get exact potential energy change, but thats to be tested.
//
var QAdd = (qint,qflo,val,color,ptr)=>{
	qint[ptr] ^= (color&63); //its low bits are the xor of all voxels added there. High 26 bits are zSum.	
	//let y = Qy(ptr), x = Qx(ptr); //the center point of the 4 tarps, the top left corner of the bottom right tarp.
	let potenChange = 0;
	//width and height of the square referred to by ptr,
	//and side of each of its 3 siblings, that together make the 4 tarps of that ptr.
	let side = Qside(ptr);
	let area = side**2;
	for(let tarpIndex=0; tarpIndex<4; tarpIndex++){
		let startTarpPtr = tarpFuncs[tarpIndex](ptr); //when tarpIndex==3 this is just ptr, other 3 times its sibling squares.
		//childs cached their bilinearMult (between that child and self)
		//so when self changes we know how much poten to add. This is an exact calculation
		//(use multiples of 6 so bilinearPotentialEnergya nd bilinearMult are exact) even though
		//that cache could have been updated by exponentially many childs which overlap this parent as its powOf2 sized.
		potenChange += val*qflo[startTarpPtr];
		
		//the square of this tarp, not the parent tarps.
		//It bilinear interpolates the parent tarps with Qinterp to see where they are on this tarp.
		let y = Qy(startTarpPtr), x = Qx(startTarpPtr); //, side = Qside(startTarpPtr);
		let yEnd = y+side, xEnd = x+side;
		
		//first, compute potential energy of self and parents, but NOT childs (use qflo for that),
		//and after that, compute the change in potential energy by adding the "val" param to 1 corner of each of the 4 tarps,
		//and finally update parents qflo so if they change later, as I'm one of their childs, they know I changed.
		let sumULBefore = 0, sumURBefore = 0, sumDLBefore = 0, sumDRBefore = 0;
		let selfOrParent = startTarpPtr; //loop over log number of parent of parent of parent... (only to some max size (QMinPtr)).
		while(QMinPtr <= selfOrParent){
			
			//This part with QInterp8k is for measuring poten change due to self increasing in size.
			//Its childs on top of self on top of parents. Self gets bigger, and that has to pay for
			//lifting mass from height 0 to self's current height.
			//
			//parent is bigger than child, but view parent interpolated at childs corners.
			//TODO optimize?: If selfOrParent==ptr then these numbers are directly in the qint array
			//but Qinterp will still return them.
			let ul = QInterp8k(qint, selfOrParent, y, x); //z of parent at y x
			let ur = QInterp8k(qint, selfOrParent, y, xEnd);
			let dl = QInterp8k(qint, selfOrParent, yEnd, x);
			let dr = QInterp8k(qint, selfOrParent, yEnd, xEnd);
			sumULBefore += ul;
			sumURBefore += ur;
			sumDLBefore += dl;
			sumDRBefore += dr;
			
			if(selfOrParent !== startTarpPtr && tarpIndex==3){ //TODO move this IF out of the tarpIndex loop.
				let parent = selfOrParent;
				//This part is to update qflo so potenChange += val*qflo[selfOrParent], in future calls on any of my parents,
				//will know the right amount to change qint by.
				//let edgeWeight = bilinearMult(ul, ur, dl, dr, )
				//Err('This is supposed to be of the normed form, where all corners are either 0 or 1, for 8 corners, so I should make a QEdgeWeight func which is similar to bilinearMult but faster');

				//"update parents qflo so if they change later, as I'm one of their childs, they know I changed"
				//this is similar to bilinearPotentialEnergy but is a different func
				//that multiplies the 2 z heights at each (y,x)
				let edgeWeight = QEdgeWeight(parent, ptr);
				qflo[parent] += val*edgeWeight;
			}
			
			selfOrParent = Qp(selfOrParent); //parent is 2x2 times bigger than child and contains all the area of child.
		}
		//'adding the "val" param to 1 corner of each of the 4 tarps'
		let sumULAfter = sumULBefore + ((tarpIndex===0) ? val : 0); //val adds to 1 corner in each of 4 tarps
		let sumURAfter = sumURBefore +  ((tarpIndex===1) ? val : 0);
		let sumDLAfter = sumDLBefore +  ((tarpIndex===2) ? val : 0);
		let sumDRAfter = sumDRBefore +  ((tarpIndex===3) ? val : 0);
		//fixme bilinearPotentialEnergy uses coordinates of 0..1 for y and x, but we use 8192x8192, so some translation is needed.
		let potenExcludingChilds_before = area*bilinearPotentialEnergy(sumULBefore, sumURBefore, sumDLBefore, sumDRBefore);
		let potenExcludingChilds_after = area*bilinearPotentialEnergy(sumULAfter, sumURAfter, sumDLAfter, sumDRAfter);
		
		potenChange += potenExcludingChilds_after - potenExcludingChilds_before;
	}
	//low 6 bits are color. high 26 bits are z sum
	//in units of multiplying the tent/pyramid func "z = max(0, 1 - abs(x)) * max(0, 1 - abs(y))".
	qint[ptr] += val<<6;
	return potenChange;
};

//add a qvox voxel as a uint53 in a float64. If you negate the Vz(qvoxel) part it removes.
var Qad = (qint,qflo,qvoxel)=>QAdd(qint, qflo, Vz(qvoxel), Vc(qvoxel), Vptr(qvoxel));

//get z+color/64 at a given (y,x) coordinate, where y and x range 0 to 8191,
//so rounding down drops color and you just have z, or to get color out of it, (Qget(y,x)*64)&63.
//Using quadtree bilinear interpolation so sums log number of linear interpolations,
//but takes color from the smallest tile thats colored
//(FIXME should i use 0b000000/black as the ignore signal)?
//FIXME should this instead just return a qvoxel? It would only have int20 z,
//but this z+color/64 kind can potentially have 47 bits of z,
//which might be useful for finding bugs but should probably limit it to int20?
//optionalTestPtrFunc helps you display related nodes like check if Ql is broken by
//using optionalTestPtrFunc=(ptr=>Ql(Ql(Ql(ptr)))) so displays things 3 qtiles to the right,
//which differs in how far to the right by qlev since the qtiles are different sizes.
//Normally you dont give a optionalTestPtrFunc param).
var Qget = (qint, y, x, optionalTestPtrFunc)=>{
	const startPtr = QlevYXToPtr(0,y,x); //at a 1x1 in biggest (8192x8192) layer, which is 1<<26 to (1<<27)-1.
	let ptr = startPtr, color = 0, z = 0;
	while(QMinPtr <= ptr){ //log number of bilinear interpolations in parents
		if(color === 0){ //if its still black/0b000000 then use color of parent. smallest/closest parent.
			color = qint[ptr]&63;
		}
		
		//let bilinearInterpolatedZ = QInterp8k(qint, ptr, y, x); //normal
		//let bilinearInterpolatedZ = QInterp8k(qint, Ql(ptr), y, x); //for testing, to make different things appear like show us all its Ql or all its Qu
		//let bilinearInterpolatedZ = QInterp8k(qint, Ql(Ql(Ql(ptr))), y, x); //for testing, to make different things appear like show us all its Ql or all its Qu
		//let bilinearInterpolatedZ = QInterp8k(qint, Qu(Qu(Qu(ptr))), y, x); //for testing, to make different things appear like show us all its Ql or all its Qu
		//let bilinearInterpolatedZ = QInterp8k(qint, Qd(Qd(Qd(ptr))), y, x); //for testing, to make different things appear like show us all its Ql or all its Qu
		let pt = optionalTestPtrFunc ? optionalTestPtrFunc(ptr) : ptr;
		let bilinearInterpolatedZ = QInterp8k(qint, pt, y, x);
		
		z += bilinearInterpolatedZ;
		//If z is not an integer then you can fix it by using voxel z's that are multiple of 6<<Qlev(ptr)
		//or something like that, based on that bilinearPotentialEnergy func and bilinearMult func
		//both return an integer if all their params are multiples of 6,
		//which is a very important design of the qvoxel system since its needed to UNDO voxels
		//to get back the exact total potential energy of the system as if they had never been added,
		//which happens in gradient calculation in each physics cycle which happens about 60 times
		//per second. Each gob (game object) is a function of vector to list of voxels.
		//Those voxels as of 2025-2-1 are older kinds that go in game.board and game.ground*,
		//but qvoxels are a new system you use with this Qget function.
		//If theres any accumulated roundoff then the simulated physics might explode cuz of the
		//game.qflo array being a relation between an exponential number of power of 2 size qvoxels.
		ptr = Qp(ptr); //parent square thats 2x2 times bigger
	}
	return z+color/64;
};


//will fail as of 2025-2-4 test_QEdgeWeightRaw_symmetryByOffsetYAndX();


//TODO cache of multiply of heights at each (y,x) of 2 ptrs by relative dy dx levelA levelB.
//const 


/*Err(`FIXME should i use tarps (1/4 of a tent) vs tents (whole bilinear kernel) as ptrs?
Im using 27 bit ptrs. I could put 4 more bits to refer to each tarp being there or not as a powerset,
or I could put just 2 more bits to specify 1 of them. Or use the extra 4 bits to mean its NOT there
so if they are all 0 its the complete form. 31 bit addresses like that could work.
27 bits quadheap index. 4 bits powerset of the 4 tarp childs. 6 bit color. 16 bit z. fits in uint53.
or i could: 27 bits quadheap index. 6 bits color. 20 bit z.
Color goes in 6 of the bits in game.qint, right? that leaves 26 bits for direct there, and 53 bits for cache from below.
`);*/



//use this one cuz its sorted by utf8 and ascii except = padding
const dvBase64Digits = '$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz=';
//This is whats made by javascript atob and btoa funcs. This one is only used internally for atob and btoa
const jsBase64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

// List of reserved keywords in JavaScript
const jsKeywords = new Set([
	'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 
	'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 
	'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 
	'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 
	'while', 'with', 'yield', 'let', 'static', 'enum', 'implements', 
	'package', 'protected', 'interface', 'private', 'public', 'await', 
	'abstract', 'boolean', 'byte', 'char', 'double', 'final', 'float', 
	'goto', 'int', 'long', 'native', 'short', 'synchronized', 'throws', 
	'transient', 'volatile'
]);

const maxNameSize = 100; //TODO choose a maxNameSize

//Var class, Var.name, else put it in Var.big and Var.name is generated from that to be much smaller.
const isValidVarName = s=>{
	if(s.length > maxNameSize) return false;
	if (!/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(s)) {
		return false;  // Check allowed characters and first character rule
	}
	return !jsKeywords.has(s);  // Check if it is a reserved keyword
};


//this uses js digits. i prefer dvBase64Digits cuz they are all valid in js var names and are in ascending order.
//dagball.bytesToBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

//bytesToBase64 = bytes=>jsBase64ToDvBase64(btoa(String.fromCharCode.apply(null, bytes))); //returns string


var bytesToJsBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

var jsBase64ToBytes = base64=>{ //returns Uint8Array
	const binaryString = atob(base64);
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
};

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

//dvBase64Digits and Uint8Array
var base64ToBytes = function(base64){
	return jsBase64ToBytes(dvBase64ToJsBase64(base64));
};
	
//dvBase64Digits and Uint8Array
var bytesToBase64 = function(bytes){
	return jsBase64ToDvBase64(bytesToJsBase64(bytes));
};

var digitJsToDv = {}; //transforms between 2 sets of base64 digits
var digitDvToJs = {};
for(let i=0; i<65; i++){ //last digit is = for padding, but dv base64 doesnt use it. js base64 does.
	let jsDigit = jsBase64Digits[i];
	let dvDigit = dvBase64Digits[i];
	digitJsToDv[jsDigit] = dvDigit;
	digitDvToJs[dvDigit] = jsDigit;
}

//dvbase64 has no = padding. expand to multiple of 4 size to convert back to js.
var jsBase64ToDvBase64 = function(jsBase64){
	let s = ''; //TODO char array or something is faster?
	let end = jsBase64.indexOf('=');
	if(end == -1) end = jsBase64.length;
	for(let i=0; i<end; i++){
		s += digitJsToDv[jsBase64[i]];
	}
	return s;
};

var dvBase64ToJsBase64 = function(dvBase64){
	let s = ''; //TODO char array or something is faster?
	for(let i=0; i<dvBase64.length; i++){
		s += digitDvToJs[dvBase64[i]];
	}
	while(s.length&3){ //while not a multiple of 4
		s += '='; //pad
	}
	return s;
};

const colorByteToChar = [];
for(let i=0; i<256; i++){
	colorByteToChar[i] = '!'; //error
}
for(let i=0; i<64; i++){
	colorByteToChar[i] = colorByteToChar[64+i] = dvBase64Digits[i]; //add 64 for wall bit
}
colorByteToChar[QTRANSPARENT] = '.';

byt=>{
	if(byt===QTRANSPARENT) return 
};

Quad.prototype.to2dColorString = function(){ //ignore wall bit
	let s = '';
	let siz = 1<<this.h;
	for(let y=0; y<siz; y++){
		if(y) s += '\n';
		for(let x=0; x<siz; x++){
			//if(x) s += ' ';
			//s += doubleHexDigits[this.yx(y,x)];
			s += colorByteToChar[this.yx(y,x)];
		}
	}
	return s;
};

Quad.prototype.toString = function(){
	if(this.h < 4){
		return this.toBigString();
	}else{
		return '[Quad h='+this.h+' len='+this.length+']';
	}
};

Quad.prototype.side = function(){ //height and width of the square pic
	return 1<<this.h;
};

/*//a Quad includes a byte array this.B and an offset this.i and may have 4 childs recursively
//which have such arrays too. This flattens it into a new nonbacking byte array of this.length bytes.
Quad.prototype.getBytes = function(optionalBytes, optionalOffset){
	let bytes = optionalBytes || new Uint8Array(this.length);
	let offset = optionalOffset|0;
	for(let i=0; i<this.length; i++) bytes[offset++] = this.B[this.i+i]; //my header or whole quad of bytes
	if(this.c[0]) for(let child of this.c){
	//fixme child and bytes can both exist (see .expand and .compress and .C funcs of Quad) if(!this.isLeaf()) for(let child of this.c){
		child.getBytes(bytes, offset);
		offset += child.length;
	}
	return bytes;
};*/
Quad.prototype.getBytes = function(){
	let bytes = new Uint8Array(this.length);
	for(let i=0; i<this.length; i++){
		bytes[i] = this.b(i);
	}
	return bytes;
};



var exampleQuad = function(){
	//let quad256x256OfBlueCircle = QEval((y,x,h)=>(h>0 ? QFORK : ((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : QTRANSPARENT), 8);
	//let quad256x256OfBlueCircle = QEval((y,x,h)=>(((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : 0b1111111), 8);
	//quad256x256OfBlueCircle.paintGame(DefaultSpawnY, DefaultSpawnX);
	//return QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 3);
	//quad.paintGame(DefaultSpawnY, DefaultSpawnX);
	//quad.paintGame(0,0);
	return QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 8);
};

var testQuad = function(){
	let quad = exampleQuad();
	//let voxels = quad.toVoxels(game.Y.p+1000,game.X.p+1000); //loses isWall bit, but u can paint open areas as ghostVox too with paintGame.
	quad.paintGame(game.Y.p-500, game.X.p-500); //near current view
};

//get byte (7 bit color, 1 bit isWall and 6 bit color, or other 1 byte symbols) at y x, from this quadtree,
//where y and x both range 0 to (1<<this.height)-1. All byte values under 128 are 7 bit color. 128 is transparent.
//This may also include other byte symbols, but the range 192 to 255 are quadtree 2x2 fork opcodes.
Quad.prototype.yx = function(y, x){
	const lg = !!game.QuadLogLev.p;
	let mid = 1<<(this.h-1); //half of width and half of height
	if(lg) console.log('quad.yx start, y='+y+' x='+x+' h='+this.h+' mid='+mid);
	if(this.h===0){
		let byt = this.b(0)
		if(lg) console.log('quad.yx end quad recursion the slow way, a Quad object of 1 byte cuz .h/height is 0, returning that byte='+byt);
		//first byte in a branch, end recursion. the more efficient way is to keep many branches
		//in each lowest Quad, but a Quad can be made that holds just 1 byte.
		return byt;
	}
	if(this.c[0]){ //has child Quad objects.
		if(y < mid){
			if(x < mid){
				if(lg) console.log('quad.yx recurse into top left quad (child 0), y='+y+' x='+x+' h='+this.h+' mid='+mid);
				return this.c[0].yx(y,x);
			}else{
				if(lg) console.log('quad.yx recurse into top right quad (child 1), y='+y+' x='+x+'-mid h='+this.h+' mid='+mid);
				return this.c[1].yx(y,x-mid);
			}
		}else{
			if(x < mid){
				if(lg) console.log('quad.yx recurse into bottom left quad (child 2), y='+y+'-mid x='+x+' h='+this.h+' mid='+mid);
				return this.c[2].yx(y-mid,x);
			}else{
				if(lg) console.log('quad.yx recurse into bottom right quad (child 4), y='+y+'-mid x='+x+'-mid h='+this.h+' mid='+mid);
				return this.c[3].yx(y-mid,x-mid);
			}
		}
	}else{ //no child Quad objects, but the bytes may still have childs in the other bytes in the same array.
		let ptr = this.i; //pointer into this.B byte array.
		for(let recurse=0; recurse<100; recurse++){
			/*let child0ByteIndex = firstChild(this.b,this.i);
			let child1ByteIndex = nextQuad(this.b,child0ByteIndex);
			let child2ByteIndex = nextQuad(this.b,child1ByteIndex);
			let child3ByteIndex = nextQuad(this.b,child2ByteIndex); //TODO only compute these if needed. only going into 1 of 4 childs.
			*/
			let val = this.B[ptr];
			if(lg) console.log('quad.yx bytes recurse='+recurse+' ptr='+ptr+' valHex='+QByteStr[val]+' mid='+mid+' y='+y+' x='+x+' len='+lenAtBytes(this.B,ptr)+
				'\nbytesFromPtr='+QBytesStr(this.B, ptr, this.B.length));
			if(!byteHasChilds(val)){
				if(lg) console.log('quad.yx end bytes cuz byteHasChilds, return valHex='+QByteStr[val]);
				return val;
			}
			if(y < mid){
				if(x < mid){
					if(lg) console.log('quad.yx bytes recurse into top left quad aka nthChild 0');
					ptr = nthChild(this.B, ptr, 0);
				}else{
					if(lg) console.log('quad.yx bytes recurse into top right quad aka nthChild 1');
					ptr = nthChild(this.B, ptr, 1);
					x -= mid; //skip left half horizontally
				}
			}else{
				if(x < mid){
					if(lg) console.log('quad.yx bytes recurse into bottom left quad aka nthChild 2');
					ptr = nthChild(this.B, ptr, 2);
				}else{
					if(lg) console.log('quad.yx bytes recurse into bottom right quad aka nthChild 3');
					ptr = nthChild(this.B, ptr, 3);
					x -= mid; //skip left half horizontally
				}
				y -= mid; //skip top half vertically
			}
			//divide height and width in half for next recursion into this.B byte array
			//which is bytes of pic compression by quadtree.
			mid >>= 1;
		}
		Err('Recursed too deep. Bytes are probably broken.');
	}
};

//compare 2 quads first by size then at all (y,x) pixels, return true/false. Useful for testing quad.compress().
Quad.prototype.picEquals = function(q){
	if(this.h !== q.h){
		return false;
	}
	let siz = 1<<this.h;
	for(let y=0; y<siz; y++){
		for(let x=0; x<siz; x++){
			let myPixel = this.yx(y,x);
			let otherPixel = q.yx(y,x);
			if(myPixel != otherPixel){
				return false;
			}
		}
	}
	return true;
};

//isRemove, similar to Gob.voxInGame is whats currently added into game.board and can get removed.
Quad.prototype.paintGame = function(optionalTopLeftY, optionalTopLeftX, optionalIsRemove, optionalGameG){
	let topLeftY = optionalTopLeftY|0; //default to (0,0)
	let topLeftX = optionalTopLeftX|0;
	const isRemove = !!optionalIsRemove;
	const gameG = optionalGameG || game;
	let size = 1<<this.h; //same as width
	for(let y=0; y<size; y++){
		for(let x=0; x<size; x++){
			let byt = this.yx(y,x);
			if(byt < 128){
				let isWall = (byt>>6)&1;
				let color6 = byt&63;
				let vox = YXC(topLeftY+y, topLeftX+x, color6); //13 bits y, 13 bits x, 6 bits color. no isWall bit.
				if(isRemove){
					gameG.remVox(vox);
				}else{
					//console.log('gameG.addVox(0b'+vox.toString(2)+')');
					gameG.addVox(vox);
				}
			}
		}
	}
};

//returns Uint32Array of int voxels you can use with IY(vox) IX(vox) IC(vox) IR IG IB for red green blue,
//and which you can make those kind of voxels with YXRGB or YXC, game.addVox, game.addVoxsWithTeam,
//game.remVoxs, game.remVoxsWithTeam, game.addVox (one int at a time), game.remVox, etc.
//Should be sorted by uint32s cuz is increasing y and inner loop of increasing x.
//WARNING: this loses the isWall bit. You can put a voxel without isWall using game.ghostVox.
//Maybe I should switch from 8kX8k to 4kX4k and put a bit in there.
//If this isnt working you can put a white square of 1000x1000 voxels centered around mouse using this:
//for(let dy=0; dy<1000; dy++) for(let dx=0; dx<1000; dx++) game.addVox(YXC(Controls.mouseY+dy-500, Controls.mouseX+dx-500, 63))
//or this one puts it at center of view:
//for(let dy=0; dy<1000; dy++) for(let dx=0; dx<1000; dx++) game.addVox(YXC(game.Y.p+dy, game.X.p+dx, 63))
//This one displays a 256x256 Quad near the view: game.addVoxs(QEval((y,x,h)=>WRGB(1,2,y&3,x&3), 8).toVoxels())
Quad.prototype.toVoxels = function(optionalTopLeftY, optionalTopLeftX){
	let topLeftY = optionalTopLeftY|0; //default to (0,0)
	let topLeftX = optionalTopLeftX|0;
	let size = 1<<this.h; //same as width
	let voxels = new Int32Array(size**2);
	let vSize = 0;
	for(let y=0; y<size; y++){
		for(let x=0; x<size; x++){
			let byt = this.yx(y,x);
			if(byt < 128){
				let isWall = (byt>>6)&1;
				let color6 = byt&63;
				let vox = YXC(topLeftY+y, topLeftX+x, color6); //13 bits y, 13 bits x, 6 bits color. no isWall bit.
				voxels[vSize++] = vox;
			}
		}
	}
	if(vSize === voxels.length){
		return voxels;
	}else{
		return voxels.slice(0, vSize);
	}
};



var lenAtBytes = (bytes, offset)=>{
	let b = bytes[offset];
	if(b < QFORKC){
		//FIXME check for QFORK and other invalid bytes?
		if(b === QFORK){
			Err('QFORK is a 1 byte opcode that means there is a 2x2 quadtree fork next but we dont know its size. It can occur in byteAtYXH(y,x,height) returning a byte but not in the bytes of a Quad directly.');
		}
		return 1; //lone byte, a leaf. FIXME use byteHasChilds(b)?
	}
	if(b < QFORKD){ //is a QFORKC, one of those 16 hex digits. theres 4 sets of 16 hex digits each. QFORKC+0 to QFORKC+15 is the lone byte one.
		return b-QFORKC; //0 to 15, length in bytes including length header
	}
	let len = 0
	while(bytes[offset] >= QFORKD){ //FIXME also verify it starts with a QFORKD+hex and ends with a QFORKF+hex, and in the middle can be 0 or more QFORKE+hex.
		len = (len<<4)|(bytes[offset++]&15)
	}
	return len;
};

//TODO rewrite these comments:
//return 192 <= bytes[offset];
//return QFORK <= bytes[offset]; //QFORK is just below the line, of things above fork and things below dont. its an opcode to fork without knowing the length yet.
var byteHasChilds = byt=>(QFORK <= byt);
//var hasChilds = (bytes, offset)=>byteHasChilds(bytes[offset]);

var hashStringToHex = function(str){
	return bytesToHex(sha256(stringToBytes(str)));
};
var hashStringToBase64 = function(str){
	//return dagball.bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
	return bytesToBase64(sha256(stringToBytes(str))); //fixme remove === padding at end.
};
var utf8TextEncoder = new TextEncoder('utf-8');
var utf8TextDecoder = new TextDecoder('utf-8');
var stringToBytes = function(s){ return utf8TextEncoder.encode(s); };
var bytesToString = function(bytes){ return utf8TextDecoder.decode(bytes); };
var hexDigits = '0123456789abcdef'.split('');
var mapOfHexDigitToInt = {}; //vals are 0 to 15. filled in boot.
var mapOfDoubleHexDigitsToInt = {}; //vals are 0 to 255. filled in boot.
var bytesToHex = function(bytes){ return bytesAndRangeToHex(bytes,0,bytes.length); };
var doubleHexDigits = [];
for(let i=0; i<16; i++){
	mapOfHexDigitToInt[hexDigits[i]] = i;
	for(let j=0; j<16; j++){
		let hh = hexDigits[i]+hexDigits[j];
		doubleHexDigits.push(hh);
		mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
	}
};
var bytesAndRangeToHex = function(bytes,from,toExcl){
	let s = '';
	for(let i=from; i<toExcl; i++) s += doubleHexDigits[bytes[i]];
	return s;
};

const QByteStr = new Array(256);
for(let byt=0; byt<256; byt++){
	QByteStr[byt] = doubleHexDigits[byt];
}
for(let byt=QFORKC; byt<QFORKC+16; byt++){
	let len = byt-QFORKC; //0..15
	//QByteStr[byt] = '['+hexDigits[len]
	QByteStr[byt] = 'x'+hexDigits[len]
}
for(let byt=QFORKD; byt<QFORKD+16; byt++){
	let len = byt-QFORKD; //0..15
	//QByteStr[byt] = '('+hexDigits[len]
	QByteStr[byt] = 'X'+hexDigits[len]
}
for(let byt=QFORKE; byt<QFORKE+16; byt++){
	let len = byt-QFORKE; //0..15
	QByteStr[byt] = '_'+hexDigits[len];
	//QByteStr[byt] = hexDigits[len];
}
for(let byt=QFORKF; byt<QFORKF+16; byt++){
	let len = byt-QFORKF; //0..15
	//QByteStr[byt] = hexDigits[len]+')'
	//QByteStr[byt] = hexDigits[len]+'):'
	QByteStr[byt] = hexDigits[len]+':'
}
//QByteStr[QTRANSPARENT] = 'QTRANSPARENT';
QByteStr[QTRANSPARENT] = 'TR';
//QByteStr[QWANTTOKNOW] = 'QWANTTOKNOW';
QByteStr[QWANTTOKNOW] = 'WA';
//QByteStr[QFORK] = 'QFORK';
QByteStr[QFORK] = 'FK';

var QBytesStr = (bytes, optionalFrom, optionalToExcl)=>{
	let from = optionalFrom|0;
	let toExcl = optionalToExcl!==undefined ? optionalToExcl : bytes.length;
	let s = '';
	for(let i=from; i<toExcl; i++){
		if(i != from) s += ' ';
		s += QByteStr[bytes[i]];
	}
	return s;
};


//given pointer at parent, returns pointer to its first child. use nextQuad after that 3 times.
var firstChild = (bytes, offset)=>{
	let b = bytes[offset];
	if(b < QFORKC){
			throw new Error('Is a lone byte, has no childs: '+b.toString(16));
	}
	if(b < QFORKD){ //is a QFORKC+hex
		return offset+1; //skip the 1 byte header to get to first child
	}
	while(bytes[offset] >= QFORKD){
		//skip variable size integer header. each byte is 1 hex digit of it.
		//D E E E F. D F. D E F. etc. QFORKD+hex QFORKD+hex QFORKF+hex.
		offset++;
	}
	return offset;
};

var nthChild = (bytes, offset, n)=>{ //n is 0..3. Returns pointer into same byte array.
	let c = firstChild(bytes,offset);
	while(n){
		c = nextQuad(bytes,c);
		n--;
	}
	return c;
};

var nextQuad = (bytes, offset)=>(offset+lenAtBytes(bytes,offset));

Quad.prototype.b = function(i){ //byteAt, viewing this tree as a list of bytes.
	if(i < 0){
		Err('Out of range, i='+i);
	}
	let j = this.i+i;
	if(j < this.B.length){
		return this.B[j];
	}
	j -= this.B.length;
	//if(this.c[0]) for(let c of this.c){
	for(let c of this.c){
		if(j < c.length){
			return c.b(j); //get byte from child recursively
		}
		j -= c.length;
	}
	Err('Out of range, i='+i);
};

//true if all my bytes are in this.B array
Quad.prototype.isFlat = function(){
	return this.length <= this.B.length-this.i;
};

Quad.prototype.isFlatPacked = function(){
	return this.i===0 && this.isFlat();
};

//copy all self's bytes into a new Quad, unless its already that way returns self. Remember to use as immutable. stays compressed.
Quad.prototype.flatPack = function(){
	if(this.isFlatPacked()){
		return this;
	}else{
		let arr = new Uint8Array(this.length);
		for(let i=0; i<arr.length; i++){
			arr[i] = this.b(i);
		}
		console.log('quad.flatPack to '+arr.length+' bytes');
		return new Quad(this.h, arr);
	}
};

const intFitsInHowManyHexDigits = i=>{ //1..8
	return ((32-Math.clz32(i)+3)>>>2);
};

//uses a loop to find this cuz length header includes its own length and is a vararg int.
//You can use the returned byte array with lenAtBytes func.
const headerBytesForChildsLength = totalChildsLength=>{
	if(totalChildsLength < 4){
		Err('Childs length must be at least 4 cuz the smallest possible child is 1 byte and theres either 0 or 4 childs');
	}
	let headerLen = 1;
	while(headerLen < intFitsInHowManyHexDigits(headerLen+totalChildsLength)){
		headerLen++;
	}
	let length = headerLen+totalChildsLength;
	if(headerLen == 1){ //if(length < 16){
		return ArraysOfOneByte[QFORKC+length]; //flyweight
	}else if(headerLen == 2){ //}else if(length < 256){
		return ArraysOfTwoBytes[((QFORKD+(length>>4))<<8)|(QFORKF+(length&15))]; //flyweight
	}else{ //at least 3 hex digits of length header
		let shiftedLen = length;
		let headerBytes = new Uint8Array(headerLen);
		for(let i=headerBytes.length-1; i>=0; i--){
			let add = QFORKE; //middle kind of hex digits
			if(i === 0) add = QFORKD; //start header with one of these kind of hex digits
			else if(i === headerBytes.length-1) add = QFORKF; //end header with one of these kind of hex digits
			let uint4PartOfLength = shiftedLen&15;
			shiftedLen >>= 4;
			headerBytes[i] = add+uint4PartOfLength;
		}
		return headerBytes;
	}
};

//make a new Quad from 4 Quads of the same height. its height/h will be 1 higher.
const Q = (a,b,c,d)=>{
	let childHeight = a.h;
	if(childHeight !== b.h || childHeight !== c.h || childHeight !== d.h){
		Err('Heights differ');
	}
	let childsLen = a.length+b.length+c.length+d.length;
	let headerBytes = headerBytesForChildsLength(childsLen);
	return new Quad(childHeight+1, headerBytes, 0, [a, b, c, d]);
	
	/*let childsLen = a.length+b.length+c.length+d.length;
	let headerLen = 1;
	while(headerLen < intFitsInHowManyHexDigits(headerLen+childsLen)){
		headerLen++;
	}
	let length = headerLen+childsLen;
	let headerBytes = new Uint8Array(headerLen);
	let shiftedLen = length;
	if(headerBytes.length == 1){ //lone byte header of 0..15 bytes including i ts own length
		headerBytes[0] = QFORKC+length;
	}else for(let i=headerBytes.length-1; i>=0; i--){ //multi byte length header including its own length
		let add = QFORKE; //middle kind of hex digits
		if(i === 0) add = QFORKD; //start header with one of these kind of hex digits
		else if(i === headerBytes.length-1) add = QFORKF; //end header with one of these kind of hex digits
		//wrong, its got to be 4 bits from headerLen: headerBytes[i] = add+i;
		let uint4PartOfLength = shiftedLen&15;
		shiftedLen >>= 4;
		headerBytes[i] = add+uint4PartOfLength;
	}
	return new Quad(a.h+1, headerBytes, 0, [a, b, c, d]);
	*/l
};

//make a byte as 1 bit of isWall, 2 bits of red, 2 bits of green, 2 bits of blue. You can get a Quad from this as QuadByte[WRGB(...)].
/*
const IR = voxel=>((voxel>>>4)&3); //get red as uint2
const IG = voxel=>((voxel>>>2)&3); //get green as uint2
const IB = voxel=>(voxel&3); //get blue as uint2
const IC = voxel=>(voxel&0x3f); //get color as uint6
*/
const WRGB = (isWall, red, green, blue)=>(((isWall&1)<<6)|((red&3)<<4)|((green&3)<<2)|(blue&3));

//make a byte as 1 bit of isWall and 6 bits of color.
const WC = (isWall, color6)=>(((isWall&1)<<6)|(color6&63));

var strongLogFirstTime_ = {};

var strongLogFirstTime = str=>{
	if(!strongLogFirstTime[str]){
		strongLogFirstTime[str] = true;
		console.error('strongLogFirstTime: '+str);
	}
};

//calls byteAtYXH(y,x,height) where y and x each range 0 to (1<<height)-1, and returns a Quad containing that.
//
//Example: QEval((y,x,h)=>(y*16+x), 2).B is these 22 bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33.
//d1 f6 means length is 0x16. c5 means length is 5. Its 4x4 pixels containing 4 2x2 pixels of 5 bytes each.
//nthChild(x.B,0,3) 17
//nthChild(x.B,0,0) 2
//nthChild(x.B,0,1) 7
//nthChild(x.B,0,2) 12
//nthChild(x.B,0,3) 17
//nthChild(x.B,12,0) 13
//nthChild(x.B,12,1) 14
//nthChild(x.B,12,2) 15
//nthChild(x.B,12,3) 16
//x.yx(0,0)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=0 x=0
//quad.yx bytes recurse=1 ptr=2 val=c5 mid=1 y=0 x=0
//quad.yx bytes recurse=2 ptr=3 val=00 mid=0 y=0 x=0
//0
//x.yx(0,1)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=0 x=1
//quad.yx bytes recurse=1 ptr=2 val=c5 mid=1 y=0 x=1
//quad.yx bytes recurse=2 ptr=4 val=01 mid=0 y=0 x=0
//1
//x.yx(3,2)
//quad.yx bytes recurse=0 ptr=0 val=d1 mid=2 y=3 x=2
//quad.yx bytes recurse=1 ptr=17 val=c5 mid=1 y=1 x=0
//quad.yx bytes recurse=2 ptr=20 val=32 mid=0 y=0 x=0
//50 (aka 16*3+2)
//
//The child 1 aka top right of the same QEval (x = QEval((y,x,h)=>(y*16+x), 3)) but at height 2 (8x8) is this:
// 02 03   04 05
// 12 13   14 15
//
// 22 23   24 25
// 32 33   34 35
//But FIXME that cant be right, it should have x range 4..7, not 2..5. Shift or mid or something is wrong.
//The y parts are correct, (y*16+x makes y the left hex digit and x the right hex digit), but not the x parts, 2024-12-11-8aET.
//
/*2024-12-11-844aET QEval and quad.yx are working for up to height 3 (8x8). (does it work for higher?)
x = QEval((y,x,h)=>(y*16+x), 3);
blobMonstersGame.html:359 QEval dy=0 dx=0 h=3 byteHere=00
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=2 byteHere=00
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33
blobMonstersGame.html:359 QEval dy=0 dx=4 h=2 byteHere=04
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:359 QEval dy=4 dx=0 h=2 byteHere=40
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:359 QEval dy=4 dx=4 h=2 byteHere=44
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
Quad {h: 3, B: Uint8Array(2), i: 0, c: Array(4), length: 1, …}
QByteStr[x.yx(6,7)]
blobMonstersGame.html:43 quad.yx start, y=6 x=7 h=3 mid=4
blobMonstersGame.html:65 quad.yx recurse into bottom right quad (child 4), y=6-mid x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=3 len=22
bytesFromPtr=d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=17 valHex=c5 mid=1 y=0 x=1 len=5
bytesFromPtr=c5 66 67 76 77
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=19 valHex=67 mid=0 y=0 x=0 len=1
bytesFromPtr=67 76 77
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=67
'67'
QByteStr[x.yx(1,5)]
blobMonstersGame.html:43 quad.yx start, y=1 x=5 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=5-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=1 len=22
bytesFromPtr=d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=2 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=6 valHex=15 mid=0 y=0 x=0 len=1
bytesFromPtr=15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=15
'15'
QByteStr[x.yx(5,1)]
blobMonstersGame.html:43 quad.yx start, y=5 x=1 h=3 mid=4
blobMonstersGame.html:62 quad.yx recurse into bottom left quad (child 2), y=5-mid x=1 h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=1 len=22
bytesFromPtr=d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=2 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=6 valHex=51 mid=0 y=0 x=0 len=1
bytesFromPtr=51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=51
'51'
*/
/*2024-12-11-850aET it appears to work for height=4 16x16 too,
but make sure for byteAtYXH not to return bytes outside range 0..127 which is pixel colors.
x = QEval((y,x,h)=>(Math.min(y,7)*16+x), 4);
blobMonstersGame.html:359 QEval dy=0 dx=0 h=4 byteHere=00
blobMonstersGame.html:389 QEval recurse h=4, making a 16x16 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=3 byteHere=00
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=0 h=2 byteHere=00
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 00 01 10 11 c5 02 03 12 13 c5 20 21 30 31 c5 22 23 32 33
blobMonstersGame.html:359 QEval dy=0 dx=4 h=2 byteHere=04
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 04 05 14 15 c5 06 07 16 17 c5 24 25 34 35 c5 26 27 36 37
blobMonstersGame.html:359 QEval dy=4 dx=0 h=2 byteHere=40
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 40 41 50 51 c5 42 43 52 53 c5 60 61 70 71 c5 62 63 72 73
blobMonstersGame.html:359 QEval dy=4 dx=4 h=2 byteHere=44
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 44 45 54 55 c5 46 47 56 57 c5 64 65 74 75 c5 66 67 76 77
blobMonstersGame.html:359 QEval dy=0 dx=8 h=3 byteHere=08
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=0 dx=8 h=2 byteHere=08
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 08 09 18 19 c5 0a 0b 1a 1b c5 28 29 38 39 c5 2a 2b 3a 3b
blobMonstersGame.html:359 QEval dy=0 dx=12 h=2 byteHere=0c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=0 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:359 QEval dy=4 dx=8 h=2 byteHere=48
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 48 49 58 59 c5 4a 4b 5a 5b c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:359 QEval dy=4 dx=12 h=2 byteHere=4c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=4 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 4c 4d 5c 5d c5 4e 4f 5e 5f c5 6c 6d 7c 7d c5 6e 6f 7e 7f
blobMonstersGame.html:359 QEval dy=8 dx=0 h=3 byteHere=70
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=8 dx=0 h=2 byteHere=70
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 70 71 70 71 c5 72 73 72 73 c5 70 71 70 71 c5 72 73 72 73
blobMonstersGame.html:359 QEval dy=8 dx=4 h=2 byteHere=74
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 74 75 74 75 c5 76 77 76 77 c5 74 75 74 75 c5 76 77 76 77
blobMonstersGame.html:359 QEval dy=12 dx=0 h=2 byteHere=70
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=0
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 70 71 70 71 c5 72 73 72 73 c5 70 71 70 71 c5 72 73 72 73
blobMonstersGame.html:359 QEval dy=12 dx=4 h=2 byteHere=74
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=4
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 74 75 74 75 c5 76 77 76 77 c5 74 75 74 75 c5 76 77 76 77
blobMonstersGame.html:359 QEval dy=8 dx=8 h=3 byteHere=78
blobMonstersGame.html:389 QEval recurse h=3, making a 8x8 quad using Q(quad,quad,quad,quad).
blobMonstersGame.html:359 QEval dy=8 dx=8 h=2 byteHere=78
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 78 79 78 79 c5 7a 7b 7a 7b c5 78 79 78 79 c5 7a 7b 7a 7b
blobMonstersGame.html:359 QEval dy=8 dx=12 h=2 byteHere=7c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=8 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 7c 7d 7c 7d c5 7e 7f 7e 7f c5 7c 7d 7c 7d c5 7e 7f 7e 7f
blobMonstersGame.html:359 QEval dy=12 dx=8 h=2 byteHere=78
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=8
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 78 79 78 79 c5 7a 7b 7a 7b c5 78 79 78 79 c5 7a 7b 7a 7b
blobMonstersGame.html:359 QEval dy=12 dx=12 h=2 byteHere=7c
blobMonstersGame.html:369 QEval h==2, making a 4x4 quad as 22 bytes, dy=12 dx=12
blobMonstersGame.html:386 QEval that same h==2, made these bytes: d1 f6 c5 7c 7d 7c 7d c5 7e 7f 7e 7f c5 7c 7d 7c 7d c5 7e 7f 7e 7f
Quad {h: 4, B: Uint8Array(1), i: 0, c: Array(4), length: 5, …}
QByteStr[x.yx(1,15)]
blobMonstersGame.html:43 quad.yx start, y=1 x=15 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=15-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=1 x=7 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=1 x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=1 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=1 x=3 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=7 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=11 valHex=1f mid=0 y=0 x=0 len=1
bytesFromPtr=1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=1f
'1f'
QByteStr[x.yx(2,15)]
blobMonstersGame.html:43 quad.yx start, y=2 x=15 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=15-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=2 x=7 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=7-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=3 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=3 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=17 valHex=c5 mid=1 y=0 x=1 len=5
bytesFromPtr=c5 2e 2f 3e 3f
blobMonstersGame.html:89 quad.yx bytes recurse into top right quad aka nthChild 1
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=19 valHex=2f mid=0 y=0 x=0 len=1
bytesFromPtr=2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=2f
'2f'
QByteStr[x.yx(2,12)]
blobMonstersGame.html:43 quad.yx start, y=2 x=12 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=12-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=2 x=4 h=3 mid=4
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=2 x=4-mid h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=2 x=0 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=2 x=0 len=22
bytesFromPtr=d1 f6 c5 0c 0d 1c 1d c5 0e 0f 1e 1f c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:95 quad.yx bytes recurse into bottom left quad aka nthChild 2
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=12 valHex=c5 mid=1 y=0 x=0 len=5
bytesFromPtr=c5 2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:86 quad.yx bytes recurse into top left quad aka nthChild 0
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=13 valHex=2c mid=0 y=0 x=0 len=1
bytesFromPtr=2c 2d 3c 3d c5 2e 2f 3e 3f
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=2c
'2c'
QByteStr[x.yx(7,9)]
blobMonstersGame.html:43 quad.yx start, y=7 x=9 h=4 mid=8
blobMonstersGame.html:57 quad.yx recurse into top right quad (child 1), y=7 x=9-mid h=4 mid=8
blobMonstersGame.html:43 quad.yx start, y=7 x=1 h=3 mid=4
blobMonstersGame.html:62 quad.yx recurse into bottom left quad (child 2), y=7-mid x=1 h=3 mid=4
blobMonstersGame.html:43 quad.yx start, y=3 x=1 h=2 mid=2
blobMonstersGame.html:78 quad.yx bytes recurse=0 ptr=0 valHex=d1 mid=2 y=3 x=1 len=22
bytesFromPtr=d1 f6 c5 48 49 58 59 c5 4a 4b 5a 5b c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:95 quad.yx bytes recurse into bottom left quad aka nthChild 2
blobMonstersGame.html:78 quad.yx bytes recurse=1 ptr=12 valHex=c5 mid=1 y=1 x=1 len=5
bytesFromPtr=c5 68 69 78 79 c5 6a 6b 7a 7b
blobMonstersGame.html:98 quad.yx bytes recurse into bottom right quad aka nthChild 3
blobMonstersGame.html:78 quad.yx bytes recurse=2 ptr=16 valHex=79 mid=0 y=0 x=0 len=1
bytesFromPtr=79 c5 6a 6b 7a 7b
blobMonstersGame.html:81 quad.yx end bytes cuz byteHasChilds, return valHex=79
'79'
*/
//
//Example: Use it to paint a circle of a chosen color and QTRANSPARENT everyewhere else, then merge that into another Quad.
//This never worked: QEval((y,x,h)=>(h>0 ? QFORK : ((y-105)**2 + (x-70)**2 < 50**2) ? WRGB(1,0,0,3) : QTRANSPARENT), 8)
//(fixme dont return QFORK cuz will be called at various heights as optimization)
//returns a 256x256 compressed quadtree pic containing a blue wall circle, in theory todo verify.
//FIXME its not compressed if all 4 childs, or 16 childs etc, are the same symbol. that should have been done higher for cheaper.
const QEval = (byteAtYXH, h, optionalDy, optionalDx)=>{
	const lg = !!game.QuadLogLev.p;
	let dy = optionalDy || 0;
	let dx = optionalDx || 0;
	let byteHere = byteAtYXH(dy,dx,h);
	if(lg) console.log('QEval dy='+dy+' dx='+dx+' h='+h+' byteHere='+QByteStr[byteHere]);
	//if(h === 0 || byteHere == QTRANSPARENT){ //end recursion
	//if(h === 0 || !byteHasChilds(byteHere)){ //end recursion
	if(h === 0){ //end recursion
		console.log('QEval h=0 return val='+QByteStr[byteHere]+', inefficient cuz should use more bytes per Quad');
		return QuadByte[byteHere];
	}else if(h == 1){
		//FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them.
		if(lg) console.log('QEval h=1, inefficient cuz should use more bytes per Quad');	
		return new Quad(1, Uint8Array.of(QFORKC+5,byteAtYXH(dy,dx,1),byteAtYXH(dy,dx+1,1),byteAtYXH(dy+1,dx,1),byteAtYXH(dy+1,dy+1,1)));
	}else if(h == 2){
		//FIXME if all child bytes are less than QFORK and are equal, use just 1 byte of that instead of forking 4 of them,
		//but 2 recursions deep 1 4 16.
		if(lg) console.log('QEval h==2, making a 4x4 quad as 22 bytes, dy='+dy+' dx='+dx);
		let quad = new Quad(2, Uint8Array.of(
			QFORKD+1, //22 bytes in total aka 0x16
			QFORKF+6,
				QFORKC+5, //top left
					byteAtYXH(dy+0,dx+0,2),byteAtYXH(dy+0,dx+1,2),
					byteAtYXH(dy+1,dx+0,2),byteAtYXH(dy+1,dx+1,2),
																	QFORKC+5, //top right
																		byteAtYXH(dy+0,dx+2,2),byteAtYXH(dy+0,dx+3,2),
																		byteAtYXH(dy+1,dx+2,2),byteAtYXH(dy+1,dx+3,2),
				QFORKC+5, //bottom left
					byteAtYXH(dy+2,dx+0,2),byteAtYXH(dy+2,dx+1,2),
					byteAtYXH(dy+3,dx+0,2),byteAtYXH(dy+3,dx+1,2),
																	QFORKC+5, //bottom right
																		byteAtYXH(dy+2,dx+2,2),byteAtYXH(dy+2,dx+3,2),
																		byteAtYXH(dy+3,dx+2,2),byteAtYXH(dy+3,dx+3,2),
		));
		if(lg) console.log('QEval that same h==2, made these bytes: '+QBytesStr(quad.B,quad.i,quad.B.length));
		return quad;
	}else{
		if(lg) console.log('QEval recurse h='+h+', making a '+(1<<h)+'x'+(1<<h)+' quad using Q(quad,quad,quad,quad).');
		let mid = 1<<(h-1); //half of width and half of height
		let ret = Q(
			QEval(byteAtYXH,h-1,dy,dx),
			QEval(byteAtYXH,h-1,dy,dx+mid),
			QEval(byteAtYXH,h-1,dy+mid,dx),
			QEval(byteAtYXH,h-1,dy+mid,dx+mid),
		);
		//strongLogFirstTime('TODO QEval should .compress()');
		//return ret;
		return ret.compress();
		//return ret.compress().flatPack();
	}
};

/*FIXME this isnt compressing as of 2025-1-5, but im about to do it the slow way using .expand first.
//If all 4 childs are the same single byte, replace self with that byte, recursively. May occur in some childs but not others in various combos.
//Remember to use QuadByte[byteVal] as flyweight.
Quad.prototype.compress = function(){
	let firstByte = this.b(0);
	if(firstByte < QFORK){
		return this; //already a 1 byte leaf
	}else{
		Err('TODO handle compressing in leaf that has nonleaf tree in array such as a 2x2 or 4x4');
		let compressA = this.c[0].compress();
		let compressB = this.c[1].compress();
		let compressC = this.c[2].compress();
		let compressD = this.c[3].compress();
		let firstByteA = compressA.b(0);
		let firstByteB = compressB.b(0);
		let firstByteC = compressC.b(0);
		let firstByteD = compressD.b(0);
		if(firstByteA < QFORK && firstByteA==firstByteB && firstByteA==firstByteC && firstByteA==firstByteD){
			return compressA; //merge 4 duplicate leafs by forkEdit/immutable, return 1 byte leaf
		}else{
			if(compressA===this.c[0] && compressA===this.c[0] && compressA===this.c[0] && compressA===this.c[0]){
				return this; //no change, already compressed that way
			}else{
				return Q(compressA, compressB, compressC, compressD); //1-4 childs replaced by their compressed form
			}
		}
	}
};*/

//same data but viewed as (2**addToHeight) times taller and wider. each +1 to height makes it 2x2 times bigger as quadtree.
Quad.prototype.plusH = function(addToHeight){
	if(addToHeight <= 0){
		if(addToHeight < 0){
			Err('Cant reduce height');
		}
		return this;
	}
	let q;
	if(this.c[0]){ //has 4 childs as Quad objects, not just array wrapper. may be both
		q = Q(this.c[0].plusH(addToHeight), this.c[1].plusH(addToHeight), this.c[2].plusH(addToHeight), this.c[3].plusH(addToHeight));
	}else{ //array wrapper. wrap same array with a .h/height field higher which is outside the array
		q = new Quad(this.h+addToHeight, this.B, this.i)
	}
	if(this.isCompressed) q.isCompressed = true;
	if(this.isExpanded) q.isExpanded = true;
	return q;
};


//If all 4 childs are the same single byte, replace self with that byte, recursively. May occur in some childs but not others in various combos.
//Remember to use QuadByte[byteVal] as flyweight.
Quad.prototype.compress = function(){
	if(this.isCompressed){
		return this;
	}
	let q = this.expand(); //slow but simple way to not have to deal with wrapping arrays
	let firstByte = q.b(0);
	if(firstByte < QFORK){
		return q; //already a 1 byte leaf
	}else{
		//Err('TODO handle compressing in leaf that has nonleaf tree in array such as a 2x2 or 4x4');
		let compressA = q.c[0].compress(); //.c will be filled cuz .expand()
		let compressB = q.c[1].compress();
		let compressC = q.c[2].compress();
		let compressD = q.c[3].compress();
		let firstByteA = compressA.b(0);
		let firstByteB = compressB.b(0);
		let firstByteC = compressC.b(0);
		let firstByteD = compressD.b(0);
		if(firstByteA < QFORK && firstByteA==firstByteB && firstByteA==firstByteC && firstByteA==firstByteD){
			//cant do this cuz Quad knows its own height: return compressA; //merge 4 duplicate leafs by forkEdit/immutable, return 1 byte leaf
			//this doesnt compress it cuz length is still big: let ret = Q(compressA, compressA, compressA, compressA); //since Quad is used as immutable, reuse 1 child 4 times. height/.h is 1 higher
			//ret.isCompressed = true;
			//return ret;
			return compressA.plusH(1); //+1 height is 2x2 bigger
		}else{
			if(compressA===q.c[0] && compressB===q.c[1] && compressC===q.c[2] && compressD===q.c[3]){
				q.isCompressed = true;
				return q; //no change, already compressed that way
			}else{
				let ret = Q(compressA, compressB, compressC, compressD); //4 childs replaced by their compressed form
				ret.isCompressed = true;
				return ret;
			}
		}
	}
};

Quad.prototype.isLeaf = function(){
	return this.length===1;
};

//this.c will contain. If this is only a wrapper of a range of byte array,
//reuses that array and makes a Quad view into it for all 4 childs then returns the one of them you asked for.
Quad.prototype.fillChilds = function(){
	//if(this.h===0){
	if(this.isLeaf()){
		Err('leaf cant have childs');
	}else if(!this.c[0]){
		let i = this.i;
		this.c[0] = new Quad(this.h-1, this.B, i=firstChild(this.B,i));
		for(let childIndex=1; childIndex<4; childIndex++){
			this.c[childIndex] = new Quad(this.h-1, this.B, i=nextQuad(this.B,i));
		}
	}
};

//get or create child. If this is only a wrapper of a range of byte array,
//reuses that array and makes a Quad view into it for all 4 childs then returns the one of them you asked for.
Quad.prototype.C = function(childIndex){
	if(!this.c[childIndex]){
		this.fillChilds(); //throws if this.h===0 aka is a leaf of 1 (powOf2 size square) pixel/voxel.
	}
	return this.c[childIndex];
};

//Expand to all reachable quads from here recursively with at most 1 pixel each, very slow,
//but can be useful for debugging compression problems etc. Shares array if expands a wrapper of array.
//Idempotent, but remember to use Quad as immutable.
Quad.prototype.expand = function(){
	//if(this.isExpanded || this.h == 0){
	if(this.isExpanded || this.length == 1){ //is leaf. .h/height can be 0 or positive and still have only 1 byte, if its compressed.
		return this;
	}else{
		let ret = Q(this.C(0).expand(), this.C(1).expand(), this.C(2).expand(), this.C(3).expand());
		ret.isExpanded = true;
		return ret;
	}
};

//FIXME the single byte prefix that says 0 more bytes are coming, is that multibyte too? its never used.
//Should I define lenAtBytes to be 1+integerOfTheBytes so that cant happen? There could still be invalid combos.
//var isMultiByte = byt=>(byt>=160);

//dont modify these after this boot loop
const QuadByte = new Array(256); //reuseable 1 byte literals, though not all of them are valid cuz some are a multi byte sequence.
const QuadByteArray = new Uint8Array(256);
const ArraysOfOneByte = new Array(256);
for(let i=0; i<256; i++) QuadByteArray[i] = i; //fill whole array before Quad sees it, in case of bugs
for(let i=0; i<256; i++){
	if(byteHasChilds(i)){
		QuadByte[i] = null; //would be invalid Quad
	}else{
		QuadByte[i] = new Quad(0, QuadByteArray, i);
	}
	ArraysOfOneByte[i] = Uint8Array.of(i);
}
const ArraysOfTwoBytes = new Array(0x10000);  
for(let ii=0; ii<0x10000; ii++){
	ArraysOfTwoBytes[ii] = Uint8Array.of(ii>>8,ii&255);
}
const QuadTransparent = QuadByte[QTRANSPARENT];



//throw new Error('TODO QuadtreeByteArray, see existing code in conversation.');


/*Opensource MIT license. View Source in browser to get the complete source code which is just 1 html file. Play my experimental Blob Monsters Game 023 at https://humanai.net/experiments/blobMonsterGame/blobMonstersGame_023.html It doesnt work very well yet, is not much fun yet, but I have shapeshifting turing complete constraint solver ability and am planning to scale up to massively multiplayer and make some basic game content. The many players, if they like the content I make, will help expand the game with new content. You can write javascript code of 1 lambda into the text box on the left, for whichever "blob monster" is selected with the mouse so is flashing.

Some parts made by the combo of me and GPT-4 GPT-o1-preview or similar versions of GPT, which by this legal statement has entirely transferred copyright of that to code to me, as I pushed it through the space of possible code, and similarly it pushed me, back and forth in javascript code changes, which I opensourced as MIT:
"Ownership of content. As between you and OpenAI, and to the extent permitted by applicable law, you (a) retain your ownership rights in Input and (b) own the Output. We hereby assign to you all our right, title, and interest, if any, in and to Output." -- https://openai.com/policies/row-terms-of-use/


an opensource (MIT) 2d video game made of Blob Monsters which are a bunch of shapeshifting voxels made by any javascript code. Planned to be massively multiplayer and peer to peer but you can run it local too. Each monster has its own code, and any player can change that code while playing. Each variable is a dimension and has position and velocity, like m.p is position and m.v is velocity in game.addFunc((m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; }); Play Blob Monsters Game now at https://humanai.net/experiments/blobMonstersGame.html in a desktop browser such as fastest in Chrome or OperaGX but works in many browsers slowly. Its not working very well yet and is not much fun yet but that will change soon. Players can create new game content already using the textarea on the left of the game, by selecting any monster (it keeps flashing) and editing that text, but make sure to copy/paste it cuz you might break the game and lose that text. You can paste it back in there while a monster is selected to transform that monster.
..
2024-11-26+ There is now an option to turn Rock Paper Scissors glowing color game on/off by "game.doRps.p = 1;" to turn it on and = 0 to turn it off, on browser console. They are shapeshifting blob monsters either way. -- https://www.facebook.com/groups/blobmonstersgame/posts/1762526854563236/
..
Blob Monsters Game is the result of advanced math research. Here's a 128x128 grid of 4SAT solver. It solves it so fast I paint it with 2 mouse buttons, and it forms into the turing-complete triangles of rule110. Now they've got a 8192x8192 grid, expanding to a million by a million for massively multiplayer, and each monster can paint voxels wherever it wants, not just right next to itself. When 2 monsters paint the same pixel at the same time, it repels them.

Video at: https://www.youtube.com/watch?v=ROF6ZtF3zVk
and at: https://www.facebook.com/groups/blobmonstersgame/posts/1759387181543870/
..
There are 4 teams: red, green, blue, and gray. Red green and blue each have 1 predator team and 1 prey team. Red becomes green becomes blue becomes red, around and around, when they touch.
RED touches GREEN -> both GREEN.
GREEN touches BLUE -> both BLUE.
BLUE TOUCHES RED -> both RED.
Touch is symmetric, doesnt matter who touches who. they're touching the same pixel at the same time or not. Each monster is made of 2d voxels that touch other voxels at the same pixel. Each voxel is an int32: 13 bits of y, 13 bits of x, 2 bits of red, 2 bits of green, 2 bits of blue. Its a color in an 8kX8k square. 64 possible colors.
var predatorOf = team=>{
 if(team == REDTEAM) return GREENTEAM;
 if(team == GREENTEAM) return BLUETEAM;
 if(team == BLUETEAM) return REDTEAM;
 throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
var preyOf = team=>{
 if(team == GREENTEAM) return REDTEAM;
 if(team == BLUETEAM) return GREENTEAM;
 if(team == REDTEAM) return BLUETEAM;
 throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
..
Any player can view or edit the javascript code of any monster by selecting it with mouse, then code is in the text box on the left. It changes live while you edit it. You can share these small javascript codes in this facebook group and others cvan paste them in to play them, even to interact multiple of them together. Later this will be automatic in the massively multiplayer game.
..
Its not just 1 kind of monster, or a million kinds of monsters. Its every possible kind. If you make a tiny graphics algorithm in the editor, that makes pics depending on vector input (Y, X, heightToWidthRatio, otherThingB, etc...)=>{...make int voxels...}, then the game automatically varies that vector looking around for possible pics it makes. At each moment in the game, each monster makes 1 pic, of the exponentially many possible pics it can make. Wherever 2 of those pics overlap, they repel. When pushed like that, a pic changes to another similar pic that the monster can also create. Its a high dimensional constraint solver. heightToWidthRatio.p is position of heightToWidthRatio, and heightToWidthRatio.v is its velocity, and similar for otherThingB.p and otherThingB.v. The game doesnt know what heightToWidthRatio and otherThingB are. You make up whatever names you want, and it turns them into dimensions and constraint solves them. And does the red green blue team logic as they capture eachother by Rock Paper Scissors per voxel. You make a pic generating algorithm, and the game brings it to life.
..
I'd like to eventually expand Blob Monsters Game to 1 million simultaneous players. in a 1 million X 1 million pixel game area. Its 8k X 8k now. The math says it can work. Player created content will keep things endlessly interesting, new patterns forever. Peer to peer so nobody controls it. Just a bunch of computers and people building and playing together. It does not surprise me that ppl dont like it yet, that hardly anyone notices it. Thats just how KFactor works. You keep improving something until it passes KFactor=1 then it goes viral. And I've got the math to make that happen. All I gotta do is double the number of players 20 times. From the moment I wrote the first line of code that was the plan. It was designed from the start to scale like that. I'm a pure-function expert. I can move functions faster than Big Tech cuz I'm not weighed down with bloat. https://en.wikipedia.org/wiki/K-factor_(marketing)
..
Blob Monsters Game has a feature that Dagball lacks (my 2 games). The monsters can touch eachother. In dagball monsters can only touch bouncing balls cuz its so inefficient, but its all voxels to all voxels now. It had better graphics, but I'm taking this all the way. I just released Dagball V2, since I probably wont be updating it for a long time. Some features will get copied into Blob Monsters Game, id especially like the GPU optimized neural shapeshifters (saves/nnet*.dagball files), but we dont need GPU for basic shapeshifters and new fun kinds of gameplay. There is far lower hanging fruit. https://github.com/benrayfield/dagball
Neural shapeshifter in dagball. I'd like to make a GPU plugin for Blob Monsters Game to include these. "Dagball_2024-5-7-9aET_recurrentSigmoidNeuralnetWith22NodesTrainedLiveInGPUShader.mp4" and is at https://www.youtube.com/watch?v=4boQ9OvRz5U .
..
I wrote this, not knowing if it would work out, about 6 weeks ago (2024-10), and now I'm getting ready to scale up a video game to massively multiplayer which computes the 2d form of it. 3d is just too much data, but if u wanna bring more computers it could be done the same way. I wasnt sure it was the right equation. but soon I tested it. If this game scales up to a million simultaneous players, it is still a single equation that many dimensional sparse dimensional gradient happens on. That is why it will sync at low lag and why it will work and why Im going to beat the Big Tech giants. The world appears to me as a giant cellular automata that I can now build on in the form of equations that people and computers interact with eachother thru. Once it expands it doesnt stop.
3d wavefunction: poten (game) = integral_x integral_y integral_z integral max(0,things-1). accel = -gradient(poten).
See the relevant code in Game.prototype.addVox = function(voxel), addVoxWithTeam, remVox, remVoxWithTeam, etc.
pic: https://www.facebook.com/photo?fbid=9151039754908623&set=pcb.1759567084859213
and at "blobMonstersGame_000_3dWavefunctionEquation_IMG_20241121_203003455.jpg"
and related "blobMonstersGame_000_3dWavefunctionEquation_IMG_20241121_203003455.jpg (B 002).jpg".
..
When I say online multiplayer I mean swarms. Blob Monsters Game wont be able to do exactly this cuz the math it is based on cant efficiently do friction (might have to simulate simplex-noise or something). All its surfaces are superconductors superfluids etc. No friction at all. It does have anyVar.kv as continuous decay rate (using Math.exp) of every dimension and variable, but it doesnt depend on things rubbing eachother. It just stops the world from exploding. https://www.youtube.com/watch?v=5TxGgmR7fgU "Shutter Crush - Marble Race Countries in Algodoo".
..
See zoom out to whole terapixel (1048576 X 1048576) game area at once, but its only repeating the 8192x8192 (64 megapixel) area that it loads and unloads game content in. I broke the red green and blue glows (distance caches for chasing/running from eachother) and it wont select monsters with the mouse anymore, but the world expanding is proceeding.
"blobMonstersGame_027_millionXmillionPixelSpaceRepeating8kX8k_butBrokeTheGlowingDistanceCacheAndWontSelectMonsters.mp4"
..
max(0,things-1) as a loss/potentialEnergy function means at most 1 thing here, and when used with the integral_x integral_y etc, it means the sum of those, where 0 means true and positive means false, and the more positive the more unlikely it is, as usual in a loss function. So in a 2d or 3d space, the equation means that at every possible 3d position there are either 0 or 1 things but not more than 1, and if more than 1, then repel that possible world in the multiverse space.

TODOS
-- make immutable object type (PartialGameState) thats any set of the game area (which is 2**20 X 2**20) but only the wall vs open area vs unspecified if its wall or open area. And similarly, each gob having a primaryKey of gob.big (or gob.name, see gob.text() which returns one or the other) which is basically primaryKey of the js code string of js lambda (gob.brain)... may make it inefficient to sync and would be more efficient if it was just content addressable with no primaryKey, its just wherever those gobs are (not even where they paint, but where their Y.p and X.p lambda params are in 2d game coords. Im thinking about using gob.name as primaryKey of the TYPE of "blob monster" but u can have any number of instances and they all gotta have Y and X as their first 2 lambda params. So every gob is at a specific 1 of the 2**40 pixels of game coords, at all times. But there can be multiple instances of it, and which such pixel theyre at would be part of their primaryKey (the other part being their js code). I want the Bloomtree/Bitpic (from dagball) kind of 2d compression to be expanded (fork it for Blob Monsters Game) to also have a Var's contents (such as a Gob, where gob.ob is the var of that gob, and gob.ob.bo===gob) as data and the floored (round down) 2**20 X 2**20 (pixelOfTera meaning 1 of terapixel number of pixels in the sparse voxel/pixel space) coordinate of it is part of its primaryKey. Lets also limit each pixelOfTera to at most 1 Gob at a time. That gob can have a more precise y and x position (thats rounded down to the pixel index its in) as they are float64s and have position and velocity and epsilon and accelMul and gp each (those last 3 are constants defined in the code string, but position and velocity vary many times per second when an object is not paused/frozen). Basically, i think ive found a way to turn this back into a pure cellular automata again, with all data being stored in individual pixels (of 2**40 sparse pixels), and that data is a js code string and a position and velocity (float64s), at each moment. It might also have t (utc time) like Var.t is a new field of Var, not used yet 2024-11-20 but is there cuz each Var is a vector stream of position and velocity at every possible time, so a mapping of time to position and velocity that is incomplete/transparent in the future, cached well at any NOW, and may be stored or not for THEPAST. But basically its just position velocity and the last t it was updated in case the object is frozen. Or maybe should just mark is it frozen or not. I want the Bloomtree (from dagball) kind of 2d image compression to be expanded to make sparse pieces of this fit together. ITS VERY IMPORTANT THAT THESE SPARSE PIECES SUCH AS B C, B.poten(C) -> amount of potentialEnergy/loss to add if both of these occur at once by merging them to their average high dimensional vector or something like that. Very high poten (repel force) between 2 "make immutable object type thats any set of the game area" (as written earlier in this paragraph) would happen if they are just incompatible, like if one of them has different game rules than the other or does not allow use of the 'Math.random' function which the other of B or C has in any of its code strings or whatever reason. Its important cuz thats how it will, by boltzmann or hopfield network with those poten as the weights the value of adding each will be a different field B.biasPoten C.biasPoten (todo choose a field name for it, is biasPoten ok?), will set each of them to -1 or 1 or maybe to 0 or 1, by that energy. The B.poten(C) function may be expensive but also only need be called once and other than roundoff should be deterministic. Those boltzmann or hopfield weights may also be adjusted by simulation finding that some of the objects tend to break eachother or cause vanishing/exploding gradient or something, but that should be coded as making another such object ExcludeThatStuffIDislike and including ExcludeThatStuffIDislike.poten(B) and ExcludeThatStuffIDislike.poten(C). And u can even call ExcludeThatStuffIDislike.poten(ExcludeThatStuffIDislike) to make sure its self consistent by its own rules. We are looking for a clique, as in NP-Complete math, of sparse pieces of the game world. How would this keep track of which gob is selected? Could just have that be one of the Var fields. its in Gob.m.isSelected and Gob.m.isSelectable. That could just be copied to the other pixel. But the bigger problem is, the peer to peer net wont be exactly in sync always, will disagree on gobs being where, and if a gob can be at multiple pixelOfTeras at once (y x coords) as it can have multiple instances, then when we see 1 of those in one PartialGameState and 2 of those near that in another PartialGameState, or just 1 of those but at a different position, or combos like that, then it could be they're disagreeing on how many of them there should be, or it could be they had another such gob from farther away come and be near a gob of its same type. The problem is in peer to peer net (which as of 2024-11-20 does not exist but is planned) its hard to tell the difference between disagreeing on positions vs disagreeing on how many gobs of a certain type (js code string) there are. Id like that to be in B.poten(C) where B and C are both PartialGameState's, but i need to define how to detect that, as math. .......... [[I have math for something better than https. Its pure-functions called on eachother in all possible pairs, which you'll navigate sparsely as each will look like a "blob monster" in a video game for example and be copy/pasteable. Some kinds of these could make every existing hash algorithm and every existing digital signature algorithm, hash and sign eachother in every combo. Not that I need it for that, I'll just use ed25519 and sha256 by default, but what I do need it for is that quicksaves/quickloads of nearby parts of my game world (PartialGameState) can disagree with eachother in a peer to peer network (in theory which doesnt exist yet 2024-11-20) but based on them each being called on eachother (B.poten(C) for example, see my other post), the entire system globally syncs to include every possible thing that could happen, might has well does happen as we can gradient against it,  It has no time. All possible pasts, presents, and futures are facts of math that can each allow vs repel eachother by NP-Complete math. I am trying to turn an existing prototype of my video game (Blob Monsters Game, which is 1 html file) into a massively multiplayer game-theory experiment. If my new kind of game-theory works, then the game will scale and expand and have KFactor > 1, go viral and be self sustaining past superintelligence. If not, nobody will care. i wrote at https://www.facebook.com/ben.f.rayfield/posts/pfbid0wJcNZZvS3wXAwi7C2dyDuw5cYCQSy87hwth7Yi6H5io7aQGU7vkbNxZdGd2HzVSl ]].
-- make BloomTree/BitPic based gobs/vars and use Var.searchYXR to find them, and make there be an easy way to know which to replace when painting with mouse 2 buttons 1 to paint walls and 1 to paint open areas aka delete walls.
-- Decide if I want mutid or not, where at most 1 of varnameABC.p can be nonzero (to say it exists) which have same mutid, so you can edit the code of a gob/blobMonster which means its primaryKey changes, so its 2 different gobs/vars, but thru mutid would automatically exclude eachother. Should it be in the Var.name, like mutidBob_sha256$sdfasdfasdfasdfasdf vs mutidBob_sha256$ssssssfdfddddddddddd or something like that? but mutidBob_sha256$sdfasdfasdfasdfasdf.mutid would be a string that would be derived from the name. Seems overly complex, but it does something useful. Figure out how to get it simple and useful, or choose not to use it. How else would it know to replace a powOf2 sized square of BloomTree compressed wall with another edited such wall? mutid is useful in dagball. It might be here too. But only within that namespace. Or maybe i should use V.theNamespace.theMutid.theJsCode?
-- use Var.searchYXR to find gobs/vars to display sparsely, and scroll the 8kX8k area by wrapping, not by copying. its already displaying that way, so simply remove some gobs/vars and add others, where gobnameABC.p==0 or ==1 determines if exists or if displays here. Maybe should be a separate gobnameABC.existsInView55 or something. or just use game.gobs which is a js [] list.
-- Done 2024-11-21 or earlier: fix the duplication bug in Vars that possibly involves V.testnet.gobname.vars (list) and .pu ({} map) and they seem to have duplicates and .p changes in one but not the other.
-- make game state loadable/saveable as json (V.toMap()). 2024-11-21 or earlier, toMap makes json, but not loading it yet.
-- start using V.testnet.gobnameABC.p==0 to mean delete that gobnameABC and ==1 to create or keep gobnameABC.
-- make 1 JSP file that remembers some basic serverMoney shortterm as a way to rate limit possible spammers and uploaders of huge amount of content, but start creating content in browser and uploading/downloading it there. Put searchYXR etc there too, have queries go by that.
-- Make a kind of object with an ed25519 publickey generated by a password (have code in Dagverse.js to modify) to put 1 mouse circle in the shared game area per publicKey. The rest are whatever gobs are there, but each mouse gets to move around. Will have more advanced controls later.


DONES:
-- done 2024-11-20 in version 023 possibly a version or few earlier. Rename Y and X funcs if Y and X will be the standard Var names for Var.searchYX. game.addFunc(`(Y/ *${targetY}* /, X/ *${targetX}* /, heightToWidthRatio) for example (without the spaces between / and *). Cuz Y and X strings are in DefaultAllowedClassDotFuncs.
*/







const DefaultQuadForTile = new Quad(tileHeight, ArraysOfOneByte[WRGB(0,1,1,1)]); //todo make this 0 0 0 0?




//
/*
checkForUnexpectedEvalsInJsParsingBeforeCrossSiteScriptingReactor

//quote from farther below 2024-11-17, in progress of making Var instances be a tree with V as its root then namespace...
//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var('V'); //var Var = function(optionalName, optionalGob, optionalParentVar, optionalBig)


TODO "or what if I divided them into each their own mini game world, in a 3kX3k square that mostly reads and syncs from outside the 2kX2k square in its
center (so border width 512). I could make these sizes parameters. But I think it would be more efficient to swarm many small ones"


[[[2024-11-11 https://x.com/benrayfield/status/1855944895057268971
Post
Conversation
Lambda Rick /acc
@benrayfield
·
5h
See that slightly jagged line between the 2 green blobs. Thats cuz its doing dijkstra shortest path finding, between each pixel and the 8 adjacent pixels. Thats where the colors come from. They estimate distance: 3 to up down left right. 4 to upleft upright downleft downright.
Image
Lambda Rick /acc
@benrayfield
·
1h
4/3 is a poor substitute for sqrt(2). Id have liked to use 7/5 but i only had 2 extra bits in 10 bit distance if i want about max distance of 256. I can compute ddistance squared exactly for every pixel to every voxel but its alot slower
Lambda Rick /acc
@benrayfield
·
1h
As long as the distance-like algorithm is the same within a peer to peer net sharing a 8k X 8k canvas, it will sync exactly. Theres a correct 10 bits for every pixel (times 3 teams) for each possible world state.
Lambda Rick /acc
@benrayfield
·
55m
It does 3 dijkstras at once in the same int array. State of dijkstra is entirely in that array and 2 loops, one forward then one backward, each reading 5 of the 9 ints as 3x3 (like in conways game of life) and writes the center int. All 9 ints are in CPU L1 cache, hella fast
Lambda Rick /acc
@benrayfield
·
49m
A world state is a set of javascript lambdas and a position and velocity for each param. The pambda returns an int array of any size, even varying the size based on params, 1 int per 2d voxel in 8k X 8k shared canvas and 64 possible colors. It changes by high dimensional gradient
Lambda Rick /acc
@benrayfield
·
38m
To approx high dimensional gradient, it removes a lambda (of n params) from world state, computes total potential energy, then calls lambda n+1 times to get n+1 arrays of voxels, counts collisions where pixels (of 64 megapixels) are written twice. Also can add to energy directly
Lambda Rick /acc
@benrayfield
·
25m
Each pixel can store, in just 9 bytes, up to 2^26-1 voxels which have the same (x,y) coordinate and may differ in color and team. There are 3 teams. Usually stores 0-2 voxels. It can do this cuz its entirely reversible by xor and counting of color and team mask.
Lambda Rick /acc
@benrayfield
I had to support 64 million voxels overlapping in the same pixel, without any slowdown in computing gradient, cuz some users will likely DoSAttack a shared canvas. They will fail.
7:05 AM · Nov 11, 2024
·
39
 Views
]]]
 I dont know what to call it, but its doing something like raytracing. But instead of the usual rays its a triple dijkstra per pixel, emitted from every voxel in all directions. Nothing in there is just for graphics. These rays will for teams to chase and run from eachother.
 I have 2 bits unused in the triple dijkstra. 10 bits per distance. 3 distances to nearest team (of 3 teams). So I could put a wall bit in there, which would make the raytracing curve around walls, take a longer path, and display darker the longer the path goes.
If I did this, and once i hook the blob monsters into it to chase and run from the other 2 teams, then they would automatically do basic pathfinding, would automatically take the correct path thru a maze, for example.
If I had 3 bits left I would have used 11 bits per distance instead of 10. but there is no int33. its int32.
but I'd have to go back to the priority-queue of what order to update the pixels, instead of the constant order it is now, which would make it take 3 times longer cuz i couldnt do 3 dijkstras at once, and would take log(numPixels) times longer cuz of the priority queue. nevermind.

also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints

[[[[2024-10-26 https://x.com/benrayfield/status/1850224874586837004
Lambda Rick /acc
@benrayfield
I'm building a cross-site-scripting reactor. Anything could come up in the form of small strings of javascript code. Basic thing, dont let them call functions except Math.exp Math.sin Math.pow etc. Check for number of flops, no infinite loops, so sub-turing but turing up as MMG
1:16 PM · Oct 26, 2024
·
29
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
Now
also need to check for combos of [] 0 null undefined true false {} '' etc, which + a[b] etc in combos with eachother, might be able to do eval of arbitrary string, and if so then this preprocessing step should replace them with such a literal code the redo the constraints.
Lambda Rick /acc
@benrayfield
·
10m
The power of a cross-site-scripting reactor is not supposed to be by security flaw, tho its designed to safely contain any bit strings even if theyre computer viruses (if given execute permission, so do ur own proofs 1st if u do that). The power is in the shared worlds it builds.

If such code is valid under the rules of the simulation (and which sim you want to do is up to you, its your billions of transistors), then in theory (if it ended up being coded this way, which im still in early research about) it just another way to write the same thing.
]]]]
<<<<<https://x.com/benrayfield/status/1850234847731527956
Lambda Rick /acc
@benrayfield
·
11m
Got a GPU doing nothing in your house? What if u could store GPU power in opensource peer to peer network in a tit-for-tat way, so that you could instead of just locally having a burst-rate of 1 teraflop, have a burst rate of 1 petaflop, but can only do so 1/1000'th of the time?
Lambda Rick /acc
@benrayfield
If 10^12 calculations per second isnt doing it for u then what good is 10^15? I went back to CPU only. I made turing complete autodiff using JS funcs as blackboxes and have 12 of em bouncing around using 2d voxels. And if ppl wanna burst-rate petaflops in certain forks, go for it
2:00 PM · Oct 26, 2024
·
7
 Views
View post engagements
>>>>>
{{{
t
Conversation
Lambda Rick /acc
@benrayfield
NP-complete game object in blue at the top
Image
12:59 PM · Nov 11, 2024
·
31
 Views
View post engagements
Lambda Rick /acc

Lambda Rick /acc
@benrayfield
·
4s
#TripleDijkstra graphics
Lambda Rick /acc
@benrayfield
·
13m
this is the most basic level of my new game system. CPU only. about a 100kB html file. only 1 file. and its currently running about 25FPS and doesnt have enuf objects on screen. but i do have teraflops available thru shaders
Lambda Rick /acc
@benrayfield
·
9m
every javascript function added can write sparsely to any address 0 to (2**26)-1, write to it by making a voxel there which repels any other voxels written there such as by 2 javascript functions trying to kick eachothers asses in a game or such as NSAT solving.
Lambda Rick /acc
@benrayfield
·
8m
even if distance calculations are only calculated in some parts (cuz expensive), the exact potential energy of the collisions part of the 64 megapixel canvas, is ALREADY how it works.
}}}
In #TripleDijkstra graphics, I compute the dijkstra shortest path between all pairs of about 50,000 voxels and 1,048,576 nodes (pixels), 25 (todo 60) times per second. Ok thats just normal optimizing. The advanced part is I do it 3 times in parallel, same order of nodes for all 3 --2024-11-11 https://x.com/benrayfield/status/1856040659221713292
*/
//
//The code anonymously shared and spread thru my tiny game engine should be thought of as an antivirus-quarantine but
//not a quarantine cuz its opensource and anyone can make copies and swarm and stream it. Just be warned,
//it might want to hack u so dont give it execute permission. Html can generate any file type and offer it for download
//or give you a string of hex to paste into a hex tool or something which can turn it into bytes in a file.
//If those are just other html or json files, fine, but dont trust executable types.
//js run in browser is not executing. js run in nodejs/npm is executing. Depends where you run it.
//Also it could run an infinite loop or redirect the page to a spammers website, but u can just close the browser tab if so.
//Files by themself are not dangerous, even if they contain viruses, as long as you dont give them execute permission.
//
//My tiny game engine does something the others dont: If you bend it certain ways, it will bend back in other ways,
//not just like a spring but like a computer thinking about how it wants to bend.
//I'm making a #web3 compatible system that runs in thousands of browsers at once, sharing a 8192x8192 (64 colors)
//interactive video at 60 FPS gaming-low-lag, which 2d voxels are painted by a high dimensional scalar-field simulation.
//Shapeshifting blobs move by constraint solving
//How many colors do you really need for a video game to be fun? If I use 6 bits for color I can expand the game area
//to 8192x8192 pixels, and voxel still fits in an int. If you can see a 512x512 area at a time, thats 16 screens wide
//and tall, so could fit a scrollable game level
//This 8192x8192 pixel object will be a #web3 data structure, sparse and gaming-low-lag and stored very compressed.
//It might have thousands of players per 8kX8k square. Physics happens in each pixel individually by accelerating
//away from gradient, might add differential equations.
//The voxels are general problem solvers though come in many tiny pieces. They are N-SAT solvers, fourier solvers,
//fractal solvers, and generally anything thats not TOO hard a puzzle, cuz they will get stuck in local minimums.
//But it works as a video game. We expand from there.
//My area of web3 is things that spread cuz they are fun or useful, instead of to buy and sell them. Any system,
//nomatter what it is, must produce at least as much as it consumes, to survive. I count progress in units of
//KFactor, will this spread more than it fades away?
//I have turing-complete autodiff, but just a little of it, not very deep, and I'm gonna have it paint 64 megapixels
//per shared virtual screen, per pixel. Each pixel has 6 bit color, 64 possible colors, and a 26 bit (8192x8192) address.
//What I'm about to build, a scaleable prototype of turing-complete-autodiff that paints 64 megapixels live, is the
//result of over and over asking myself, how could I raise KFactor of this tech while still being turing complete?
//So Cut off parts didnt need, adjusted bit sizes etc.
//Its CPU only for now. The older versions used GPU, but I optimized it so well I can do it  without,
//leaving GPU for more advanced stuff to add on later, maybe some neuralnets or something.
//The difference between AI and physics is not clear cut. Theres gradual levels between. I've been training small
//neuralnets with a physics algorithm in many dimensions. And when I make 2d shapeshifting game objects, thats a
//little like AI. They learn live, which is the gameplay.
//In turing-complete-autodiff, u make 1 mechanical part, which may be in multiple parts
//(return whatever set of voxels u want, no judgement on if theyre connected), and return an extra
//amount of loss (like neuralnet loss, more general) and physics is by automatic constraint solver
//Theres 67,108,864 pixels in 1 game state. Each keeps a count of number of objects currently
//touching/painting it, a count which can go up to 67,108,863 objects. Each pixel can store 1 NSAT bit
//and 6 color bits. 2**26 pixels can be 8k x 8k, 512 x 512 x 256, or 26 dimensions size 2
//Game state also TODO... includes a string of javascript code of a lambda of n float params, named
//whatever that function likes. Func object is scanned for its parameter list, and 1 dimension in the
//game world created for each, with a position and velocity. It returns an int array
//potential energy ranges 0 to 2**53-1 so fits in a float64. Add max(0,count-1) for each pixel,
//of counting number of objects which touch/paint that pixel. Each game object can also add an
//arbitrary integer to potential energy for things like springs, least squares. Multiverse...
//Turing-complete-autodiff will use this API:
//game.addFunc((centerY, centerX, varA, varB, nameVarsWhateverYouWant)=>{...return a list of int voxels...}).
//Doesnt matter what javascript function you put in there, as long as all its parameters
//are a Var instance, like centerY.p varA.p .
//I computed potential-energy across multiple black-boxes and the game survived and physics kept working. They are
//basically simulated graygoo if u didnt have to worry about how to physically make tiny computers,
//just a fun software API for it.
//
/*
My 36kB game engine will be a serious game-theory research platform with lots of AIs and people building and playing
and experimenting together. Each "blob monster" can include a loss function, used like:
centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract
All the .poten are summed. You only need 1 of them, and it doesnt matter which you add into. There was just nowhere
else to put it than in the Var objects that are auto generated as the params of any JS func you write.
--- https://x.com/benrayfield/status/1850497760463647137
*

In peer to peer network, the whole 8192x8192 shared canvas would be updated, each computer computing physics locally in the parts they're near. but its just on 1 computer for now. game state is very compressed, just the code strings of JS that make voxels and 2 numbers per param. -- https://x.com/benrayfield/status/1856413738741457180
*


I should probably make neural-shapeshifter plugin for Blob Monsters Game. I could fork out of dagball, built on my Ap.js GPU programming language, which is built on my TinyGLSL stateless synchronous (no async/await) way to call GPU from browser.
youtube.com
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
https://www.youtube.com/watch?v=4boQ9OvRz5U
this blob species "neural shapeshifter" would be just another JS func that happens to call the GPU thru my opensource local API,
but I'd have to upgrade Blob Monsters Game to have a parallel API where you can call monster.brain(...(monster.vars))
monster.length+1 times at once.
If i copy a 80x80 pic of 1 bit per pixel, into GPU, I can copy it into EVERY GPU core at once, or at least usefully 1000 of them,
and compute collisions inside the GPU cores, so return the loss function. 1001 GPU threads to compute the gradient of float[1000]
loss function.loss function.


The fun game content should come from that Blob Monsters Game is a turing-complete constraint solver that can solve about a million vars at once. Thats what I gotta build on. When you zoom out to 64 million it updates most of the 64 megapixels slower, those near the mouse fast.
Imagine players build forts or stacks or chains and other simple machines, of combos of these shapeshifting blob monsters (which can shapeshift in far more advanced ways than shown here). 50 players in one fort. 70 players in another. Try to invade cuz colors spread exponentially -- https://x.com/benrayfield/status/1857501980366672174
What kinda "simple machines" could u build? Maybe... catapult, gearbox with stick shift and realistic torque, 2 squares that if u turn them relative to eachother they wormscrew closer/farther from eachother, a wrench to grab such a square, 3 elevators which total constant height.
The game is open-ended. In general a team wins by turning the game world to their own color (red, green, or blue), but as its turing-complete and has a code editor on every player's screen (select any object), I cant know all the possible ways to win. I will be surprised.

Blob Monsters Game 019 has decentralized sync built in among its hundreds of megabytes of memory (in browser) already. Doesnt update all the pixels at once, but does update all of them soon and those near mouse instantly and near any random voxel of any random game object #web3 -- https://x.com/benrayfield/status/1857518756324585793

...
TODO still use ints in gob.brain but have it check game.offsetY game.offsetX or something like that, or put it in Var instances in params somehow
maybe but dont complicate them. Define it in math this way?...
binheapY 21 bits, binheapX 21 bits, 6 bits color, mask 5 bits, fits in uint53 which fits in float64.
The 5 bits are for teams REDTEAM GREENTEAM BLUETEAM WALLTEAM and a bit for is it moveable vs constant,
which it should be constant (todo fix mouse gob to have more than 0 params, and set those params
by Var.mn and Var.mx (min and max truncation) by Controls.mouseY etc, so anything which has 0 params automatically is marked as constant in that bit,
so 53 bit voxels in the expanded form that can handle powOf2 aligned voxels in a 1 terapixel space (2**20 each of y and x, with an extra bit for binheap).
Dont do variable size voxels. Use 2 voxels if u wanna do that, to define a top left and bottom right corner, or something like that.
How about y22 x22 color6 teamMask3, where neutralTeam is teamMask of 0?
Or I could just use 2 bits for team, for 4 teams red green blue wall.
Probably best to leave a few extra bits for future expansion.
Go with y20 x20 color6 teamMask4 reservedForFutureExpansion3. fits in uint53 that fits in float64.
Choose a place to put offsetY and offsetX which are each uint20 and never get too close to the millionXmillion square for the 8kX8k to fall off or wrap.
1mX1m space, 64 colors, and 4 team bits, comes to 50 bits.
I could use just 2 team bits if its 1 of 4 specific teams (red green blue wall), but what if i want more teams for powerups or something later?
I should just put Var.m.offsetY Var.m.offsetX as a place to put extra variables like this?
I like using 5 hex digits for y and x as coords. that seems like something players would prefer over a partial hex digit which u get with
2million or 4milllion or 8million but next hex digit as 16million. 1million seems a good size to snap that to.
or should offsetY and offsetX just be global vars? var offsetY = 0x576bb;
Go with 20 bits of y, 20 bits of x.
Do I want to shrink the 8kX8k to 4kX4k so it fits in 3 hex digits? i could fit 2 bits of team in there, but gob.brain shouldnt have to know its team.
8kX8k works already (2024-11-16). The 4kx4k area in its center, or maybe 6kX6k area in its center, would be computed here but border of 1k to 2k wide
would just read whats nearby in the huge game world. 1mX1m world.
See game.oy and game.ox and game.ns.
--------
[[[2024-11-16 https://x.com/benrayfield/status/1857893345617437061
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
Quote
Lambda Rick /acc
@benrayfield
Replying to @benrayfield
If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
Earth's diameter is 42 light-milliseconds. "chevron 8 is locked" (normally 7). metaphorically. I'm about to run shared turing-complete million X million size canvases (sparse voxels), across earth where diff areas of canvas are separated by lightspeed lag. https://youtu.be/z72GiUz2VI8?si=9TmsSznuKxFLIRKG&t=84
We might in some ways of using the system be able to ballpark estimate lightspeed by max internet speed, like recursive dijkstra. not that we need to. but half or so of lag in games is generally cuz of lightspeed.
I can do alot of steps and a few network hops before light reaches between the multiple computers I'm controlling.
These coordinates in million X million pixels should be used in saved and loaded game states. I havent made those files yet
but this seemed an important thing to do before it.
..
I want 1 million simultaneous players in my Blob Monsters Game. So I expanded address space to exactly 1048576x1048576 pixels (1 terapixel),
sparsely as voxels, 6 bit color, 10 bit glowing distance cache for each of 3 Rock Paper Scissors teams, 1 bit per team is it touching pixel
-- https://x.com/benrayfield/status/1857920330532028545
Within a namespace, everyone can see all 2^40=1099511627776 (1.1 trillion) pixels and scroll and zoom in/out but some things will
look blurry or missing as they're loading. 60 FPS if u play at 512x512 resolution not zoomed out too far, or u can fiddle with it. Swarm the games.
Game state is turing-complete compressed in the form of each game object (Gob)'s primaryKey is a string of JS code of a lambda that returns an
int array of int voxels, with data of a vector of a position and velocity per lambda param. Will soon expand to 1048576x1048576 addresses.
its 1024 times wider and 1024 times taller than this (pic of 1024x1024 resolution with a 768x768 in it).
Even those its sparse, I hope to live fill at 60 FPS every one of those pixels, though in more relaxed games u could leave stuff unexplored. Each player can fill a million or so.
Imagine r/place but with a shortage of people willing to expand ever bigger, and balance it kind of, and throw in turing complete shapeshifting blobs battling eachother.
the uint10 glowing distance caches would not be copied. only the JS code strings and positions and velocities would be copied, and less often,
the recursive quadtree based 1 terapixel sparse image at 2 bits per 2x2 fork or wall or nonwall or transparent/unspecifiedIfItsWallOrNot.
As far as I know, nobody has ever made a massively multiplayer video game that is entirely decentralized. The hundreds of megabytes of RAM it uses is decentralized.
It updates random areas of 64k numbers at a time, and they converge to exactly the same thing nomatter that order. -- https://x.com/benrayfield/status/1857940083254411506
There is a likely opensource upgrade path to swarm the combined exaflop/sec of those computers GPUs plus whatever even greater cloud supercomputers some fewer users might
hook in thru digital signatures, to scale up my neural-(playdough-like) blob monster like in this video https://www.youtube.com/watch?v=4boQ9OvRz5U
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained...
My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet. It does 
Dagball 2024-5-7 recurrent sigmoid neuralnet with 22 nodes trained live in GPU shader (GLSL)
<<My dagball/lib/Ap.js GPU programming language is used in the textarea on the left to define the neuralet.
It does gradient descent with momentum and annealing automatically of
whatever you type in there. By dragging around the icons, some bright and some dark, I shape the bright
and dark areas. It does at least 1 training batch per video frame 1/60
second, sometimes around 6 batches per 1/60 second. This will in theory scale up to doing live neural qlearning
in a GPU shader on tiny neuralnets and to fit many such
neuralnets together to do bigger things, or at least to make the dagball game more curvy, bouncy, bendy, and fun.
>>
]]]

GPT-o1-mini and -preview helped me with 8-way-manhattan distance cache algorithm that I now use in 64 megapixels per computer. U can read that conversation
here "We [OpenAI] hereby assign to you all our right, title, and interest, if any, in and to Output" -- https://x.com/benrayfield/status/1858279962559565830
https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js.txt
*/


const dagball = {}; //only some parts copied from Dagball.html, didnt want to rename their function calls. Maybe will modify them.






//TODO rename toBig to toMid or something like that, and rename this toMega to toBig. Find 3 good names of the
//existing sizes (which are exactly 2048**2, 8192**2, 1048576**2, aka small=(2**11)**2 big=(2**13)**2 mega=(2**20)**2).
//const bigToMega = yx=>(IY(yx)*(2**33)+IX(yx)*(2**13)));

//throw new Error('TODO make game.rps.tridist be 4x4 smaller, so 2048x2048, and update redByteAtYX etc to use that size.')

const Controls = {
	mouseY: 0,
	mouseX: 0,
	mouseButton0: 0,
	pause: 0, //toggled by pause button on keyboard
};

//list of lists of SigmoidNumEditor which is editing things like Var.p Var.pr Var.ps Var.cv etc.
//whatever editors go on the top left of screen in selectedGobVarsDiv_table, these are the rows/cols as a 2d list.
const VarEditors = [];

//there are 2 kinds of voxels which can be uses interchangibly.
//Both kinds are nonnegative integer. One kind ranges 0 to (2**32)-1 (or -2**31 to (2**31)-1, same thing).
//The other kind is that with 21 higher bits of integer for z, range 0 to (2**53)-1.
//If you voxel|0 or voxel&0xffffffff or any other bit math on the bigger (float64) kind, it just sets z to 0.
//All voxels with the same y x are summed into game.board which is an 8192x8192 array.
//game.board[voxel>>>6] += IZ(voxel)<<6; //add into 26 bit sum.
//game.board[voxel>>>6] ^= IC(voxel); //xor 6 bit color

const IY = voxel=>(voxel>>>19);
const IX = voxel=>((voxel>>>6)&0x1fff);

/*think im gonna go with 53 bit voxels, fit in javascript number, that can choose
from 8 sizes 1x1 2x2 4x4 8x8 16x16 32x32 64x64 128x128 aka 4**tileSize of 3 bits,
18 bits thickness (mult 4**tileSize so bilinear interpolation is always an integer),
13 bits y, 13 bits x, 6 bit color
*/
//const ZMUL = 2**32; //must be a power of 2
//const ZDIV = 1/ZMUL; //must be a power of 2
const ZMUL = 2**35; //must be a power of 2. //18 bits of zDigits in uint53 (float64) voxel.
const ZDIV = 1/ZMUL; //must be a power of 2
if(ZMUL*ZDIV !== 1) Err('Roundoff error in ZMUL vs ZDIV');

//must be a power of 2. tile size exponent, as in z = (4**tileSize) * zDigits at corner of tile like 1x1 2x2 .. 128x128.
const TMUL = 2**32;
const TDIV = 1/TMUL; //must be a power of 2
if(TMUL*TDIV !== 1) Err('Roundoff error in TMUL vs TDIV');

//const ZSize = 1<<21;
const ZSize = 1<<18;
const ZMask = ZSize-1;

const TSize = 1<<3; //8
const TMask = TSize-1; //7

const DefaultZ = 1024;

const DefaultT = 0;

const DefaultC = 0b101010; //light gray

//const IZ = voxel=>((voxel*ZDIV)&ZMask); //get z coordinate of a voxel, which ranges 0 to (2**21)-1 and stacks with overlapping voxels at same x y.
const IZRaw = voxel=>(((voxel*ZDIV)&ZMask) || DefaultZ); //FIXME until the int voxels are replaced by float64 voxels we will need DefaultZ and cant have z of 0.

const IT = voxel=>((voxel*TDIV)&TMask);

//depending on the t/tileSize 3 bits in voxel, returns 1, 4, 16, 64, 256, 1024, 4096, or 16384, aka 4**IT(voxel).
const ITileArea = voxel=>(1<<(IT(voxel)<<1)); //4**tileSizeExponent where tileSizeExponent is 0..7

const ITileSide = voxel=>(1<<IT(voxel)); //2**tileSizeExponent where tileSizeExponent is 0..7

const IZ = voxel=>(ITileArea(voxel)*IZRaw(voxel));

//IZAtYX(voxel,IY(voxel),IX(voxel))==IZ(voxel). But if y and x differ from the voxel,
//its bilinear interpolation (just 1 corner of it as a center between 4 tiles of that size)
//
//bilinear interpolated.
//The basics of bilinear interpolation in a 2d grid. If you put a copy of this at every integer
//coordinates (x,y) x+1 x+2 x+3 y+1 y+2..., then it sums to 1.0 height everywhere.
//graph z = max(0, 1 - abs(x)) * max(0, 1 - abs(y)), x=-3..3, y=-3..3
//https://www.wolframalpha.com/input?i=graph+z+%3D+max%280%2C+1+-+abs%28x%29%29+*+max%280%2C+1+-+abs%28y%29%29%2C+x%3D-3..3%2C+y%3D-3..3
//
const IZAtYX = (voxel,y,x)=>{
	let zRaw = IZRaw(voxel);
	let tileSide = ITileSide(voxel);
	let dy = IY(voxel)-y;
	let dx = IX(voxel)-x;
	let dyAdjusted = Math.max(0, tileSide-Math.abs(dy));
	let dxAdjusted = Math.max(0, tileSide-Math.abs(dx));
	return dyAdjusted*dxAdjusted*zRaw; //always an integer
};


const IR = voxel=>((voxel>>>4)&3); //get red as uint2
const IG = voxel=>((voxel>>>2)&3); //get green as uint2
const IB = voxel=>(voxel&3); //get blue as uint2
const IC = voxel=>(voxel&0x3f); //get color as uint6
//0b1010101*0b11==0b11111111. Im using this to turn 2 bits of red, green, or blue into 8 bits.
//if u multiply 0..3 by 85, it becomes 0, 85, 170, or 255. It hits the min and max brightness.
const RR = voxel=>(IR(voxel)*85); //get red as uint8, which is 1 of: 0, 85, 170, 255.
const GG = voxel=>(IG(voxel)*85); //get green as uint8, which is 1 of: 0, 85, 170, 255.
const BB = voxel=>(IB(voxel)*85); //get blue as uint8, which is 1 of: 0, 85, 170, 255.
//Shape/color code adds voxels like this:
//game.addFunc((m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; });
//Makes the bending parabola. Search for game.addFunc in the html.
const YXC = (y,x,color)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|(color&0x3f));
//const ZYXC = (z,y,x,color)=>((z&ZMask)*ZMUL+((y&0x1fff)<<19)+((x&0x1fff)<<6)+(color&0x3f));
const ZTYXC = (z,t,y,x,color)=>((z&ZMask)*ZMUL+(t&TMask)*TMUL+((y&0x1fff)<<19)+((x&0x1fff)<<6)+(color&0x3f));
const ZYXC = (z,y,x,color)=>ZTYXC(z,0,y,x,color);
const PC = (yx,color)=>(((yx&0x3ffffff)<<6)|(color&0x3f));
const IP = voxel=>(voxel>>>6); //get yx position without color, 0 to 2**26-1
const YXRGB = (y,x,r,g,b)=>(((y&0x1fff)<<19)|((x&0x1fff)<<6)|((r&3)<<4)|((g&3)<<2)|(b&3));
//const ZYXRGB = (z,y,x,r,g,b)=>((z&ZMask)*ZMUL+((y&0x1fff)<<19)+((x&0x1fff)<<6)+((r&3)<<4)+((g&3)<<2)+(b&3));
const ZTYXRGB = (z,t,y,x,r,g,b)=>((z&ZMask)*ZMUL+(t&TMask)*TMUL+((y&0x1fff)<<19)+((x&0x1fff)<<6)+((r&3)<<4)+((g&3)<<2)+(b&3));

//const SetC = (voxel,color)=>((voxel&0xffffffc0)|(color&0x3f)); //replace color get new voxel
//replace color get new voxel. works with int and float64 voxels, which only differ in 21 bits of z
//starting at and above the low 2**32 range up to (2**53)-1.
const SetC = (voxel,color)=>(voxel-IC(voxel)+color);

const IColorStr = voxel=>('#'+doubleHexDigits[RR(voxel)]+doubleHexDigits[GG(voxel)]+doubleHexDigits[BB(voxel)]); //like 0b011011 -> #55aaff

const randInt = max=>Math.floor(Math.random()*max);

const randTeam = ()=>(1<<randInt(3)); //random one of REDTEAM, GREENTEAM, or BLUETEAM. Never returns BLACKTEAM cuz that means no gob is there.



const INF = 1<<29;
//orthogonal adds 3. diagonal adds 4. so 4 is shorter than 3+3. See computeUint10Distances.
//The best ratio of these is orthogonal*Math.sqrt(2)=diagonal, but we dont have enuf bits of precision for that.
const TINF = (1<<10)-1; //1 uint10 max aka 1023. used with game.rps.tridist, either the first second or third 10 bits, so it uses its low 30 bits.
const TRINF = (1<<30)-1; //3 uint10s each 1023. used with game.rps.tridist.
//const INF = 0x7FFFFFFF; //max int, infinity-like. used in game.rps.boardR, .boardG, and .boardB to say distanceSquared has not been computed
//const newRpsArray = ()=>(new Int32Array(Area).fill(INF));
const newRpsArray = ()=>(new Int32Array(Area).fill(TRINF));

const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers.
const REDTEAM = 1;
const GREENTEAM = 2;
const BLUETEAM = 4; //const BLUETEAM = 3;
//A gob should be counted as nonmoving if it has 0 params as gob.brain aka gob.vars.length, but since "mouse" a js var whose value is a Gob,
//uses Controls.mouseY and Controls.mouseX, as of 2024-11-17, which makes it stateful, that contradicts that design. Should add params for that.
//If there are things that need defining for optimizations, put them in gob.m such as gob.m.isSelected, gob.m.isSelectable, gob.m.team, etc,
//which are more of primary data storage than optimization but theres things to untangle and redesign here todo.
//
//GRAYTEAM created cuz: TODO 2024-11-17 this is new. its meant as a neutral team, made of walls that may be moving or nonmoving. if nonmoving, dont call gob.nextState(dt)
//on them as they wouldnt change state anyways, so an optimization of reaching the same result.
//This is needed for the Rock Paper Scissors teams to use as shields to do more strategic gameplay
//Remember, this is built on a turing complete sparse-dimensional many-dimensional constraint solver. We can build many possible kinds of gameplay and mix them.
//There are only 7 teams available in uint53 voxels (an inefficient form of oy and ox and oshift used with int arrays of int32 voxels),
//of which 4 are used so far 2024-11-17: REDTEAM, GREENTEAM, BLUETEAM, GRAYTEAM. BLACKTEAM does not count cuz is just the name of the lack of any teams at a pixel.
//This is cuz in 53 bits (which fits in a float64 as nonnegative integers): y 20 bits, x 20, color 6, teamMask 7. Have used 4 of the 7 bits available for teamMask.
//Maybe should use those other 3 for some simple categories of powerups or wall pic compression or generally... 3 bits Reserved For Future Expansion. is 50 bits so far 2024-11-17.
//float64 can hold absolute voxel 2d coordinates and color and set of teams there (that are not cancelled out by an even number of the same team being there),
//but for efficiency oy and ox and oshift should define where in terapixel coordinates it goes (40 bits) and the 26 bits of local coords (8k square) are relative to that.

const GRAYTEAM = 8;

/*This isnt gonna work cuz scrolling the 8kX8k game.board over the much bigger area would require copying it. I want it stored as 1 bit per pixel.
Maybe I should use blocks of 8kX8k bits which is 8mB each, or 1kX1k bits which is 128kB each, and have a sparse array of 1024x1024 of those. Call it WallTile.
//TODO like GRAYTEAM but optimized for nonmoving walls. we put those walls TODO using powOf2 aligned blocks compressed by BitPic/BloomTree from dagball caode.
//WALLTEAM will go in game.board to count that theres a wall, so theres no extra collision detection code, its already using that.
//All we gotta do 
const WALLTEAM = 16;
const WallColor = 0b010101; //of WALLTEAM
*/

const teamShift = new Int32Array(5); //holds REDTEAM, GREENTEAM, and BLUETEAM, but not higher teams.
//const teamShift = new Int32Array(16);
teamShift[REDTEAM] = 0;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 20;
//GRAYTEAM should not go in tridist so shouldnt shift: teamShift[GRAYTEAM] = 30; //there are 2 bits left, though we should probably leave them unusued.
/*
teamShift[REDTEAM] = 20;
teamShift[GREENTEAM] = 10;
teamShift[BLUETEAM] = 0;
*/
//(game.rps.tridistSmall[(smallY<<SmallSizeBits)|smallX]>>>teamShift[BLUETEAM])&mask10
//is the uint10 of approx cached distance (with some max) to nearest BLUETEAM voxel, from (smallY,smallX) pixel.
const teamName = [];
teamName[BLACKTEAM] = 'BLACKTEAM';
teamName[REDTEAM] = 'REDTEAM';
teamName[GREENTEAM] = 'GREENTEAM';
teamName[BLUETEAM] = 'BLUETEAM';
teamName[GRAYTEAM] = 'GRAYTEAM';
while(teamName.length < 256) teamName.push('NOTEXIST'+teamName.length+'TEAM'); //all byte values have a team name.
teamName[REDTEAM|GREENTEAM] = 'REDTEAM|GREENTEAM';
teamName[GREENTEAM|BLUETEAM] = 'GREENTEAM|BLUETEAM';
teamName[REDTEAM|BLUETEAM] = 'REDTEAM|BLUETEAM';
teamName[REDTEAM|GREENTEAM|BLUETEAM] = 'REDTEAM|GREENTEAM|BLUETEAM';
teamName[REDTEAM|GREENTEAM|GRAYTEAM] = 'REDTEAM|GREENTEAM|GRAYTEAM';
teamName[GREENTEAM|BLUETEAM|GRAYTEAM] = 'GREENTEAM|BLUETEAM|GRAYTEAM';
teamName[REDTEAM|BLUETEAM|GRAYTEAM] = 'REDTEAM|BLUETEAM|GRAYTEAM';
teamName[REDTEAM|GREENTEAM|BLUETEAM|GRAYTEAM] = 'REDTEAM|GREENTEAM|BLUETEAM|GRAYTEAM';
teamHtmlColorName = [];
teamHtmlColorName[REDTEAM] = 'red';
teamHtmlColorName[GREENTEAM] = 'green';
teamHtmlColorName[BLUETEAM] = 'blue';
teamHtmlColorName[GRAYTEAM] = 'gray';


//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js
var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};

//Returns the amount of free memory (bytes) in a browser tab. countFreeMem() 8588886016 8gB for example.
//This is a slow func. You have to fill it with a nonzero value so it actually gets allocated.
//"const BLACKTEAM = 0; //so it costs less memory in unoccupied areas, in some browsers." makes use of that if available.
const countFreeMem = ()=>{
	let arrays = [];
	let siz = 1<<20;
	while(true) try{
		arrays.push(new Uint8Array(siz).fill(arrays.length+1));
	}catch(e){
		return arrays.length*siz;
	}
};

//const DefaultIsLocal = true;
const DefaultNamespaceName = 'testnet';
/*wrap instead. const MinOy = 0x00000;
const MaxOy = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const MinOx = 0x00000;
const MaxOx = 0xfffff-Size; //FIXME should this be 0x100000-Size?
const DefaultOy = MinOy; //TODO should this be in the middle of the space instead of its top left corner?
const DefaultOx = MinOx;
const DefaultGobOy = 1<<19; //approx the middle of a 1<<20 size space, approx cuz Size (1<<13) of it is reduced so the 8kX8k game.board must not hang off edge of the 1<<20.
const DefaultGobOx = 1<<19;
*/


/*2024-12-3+ Shrinking Blob Monsters Game to 256k X 256k canvas cuz of new kind of wall (vs open area) voxels.
Each fits in a float64 and is an integer from 2**16 to (2**53)-1. 0 is null. Each has a payload of 16 bits for 4x4,
scaled to any powOf2 size. Each has 37 bits of binheap address.
It can only display 8k X 8k at a time which is 64 megapixels, but it wraps. You get 1024 blocks of 64 megapixels each
so 64 gigapixels. 32 blocks wide and 32 blocks tall. Theres no loading time to move across them cuz it wraps.
My new kind of 53 bit voxels (that fit in a normal javascript number) will be useful for video compression,
can each define up to 68,719,476,736 pixels, of 1 bit color each (wall vs open area).
1x1 2x2 4x4 8x8 ... 131072x131072 262144x262144, and defines 4x4 squares inside that.
I'm literally going to use them to define walls vs open areas in the 262144x262144 pixel game area
in massively multiplayer, which cuz of this will allow the terrain shape to change during the game,
depending what kind of game rules it is. This is a kind of number, where every integer thats at least 65536, without limit
toward infinity, is a voxel. It just keeps getting bigger. You could use them as bigints, but I'm using float64s for speed.
*/
const MinY = 0;
//const MaxY = 0xfffff;
const MaxY = 0xffffff; //(2**24)-1 cuz Square, SquareY, SquareX, and SquareH funcs all use uint53 this way.
const MinX = 0;
//const MaxX = 0xfffff;
//const MaxX = 0x3ffff; //(2**18)-1
const MaxX = MaxY;

//var Game = function(optionalIsLocal, optionalNamespaceString, optionalY_uint20, optionalX_uint20){
//var Game = function(namespaceVar, optionalY_uint20, optionalX_uint20){
//gameVarInNamespaceVar is a Var whose name is "game" and which is a child of a namespace Var,
//var Game = function(gameVarInNamespaceVar, optionalY_uint20, optionalX_uint20){
//like V.testnet.game is in the namespace V.testnet. TODO V.testnet.game.Y.p and .x.p and .zoom.p etc.
var Game = function(gameVarInNamespaceVar){
	if(!(gameVarInNamespaceVar instanceof Var)) throw new Error('gameVarInNamespaceVar is not a Var: '+gameVarInNamespaceVar);
	this.bo = gameVarInNamespaceVar; //self var should always be named q?
	this.bo.ob = this; //Var.ob is Game or Gob or null
	//throw new Error('TODO some kind of variable recursion bloomtree considering its 2**40 pixels and we dont want to lockstep which causes lag across earths diameter is 42 light-milliseconds (and thats straight line distance in 3d so its more than that).');
	//TODO changing namespace, oy, and ox, should in theory connect you to different games across the world
	//and different 8kX8k 2d areas inside them, computed by whatever players are near that part of the game.
	//As this is opensource, anyone can create a namespace of any name they want, but if theres collisions
	//you'd join the existing game, in theory. You might generate this by a hash of the human readable rules of the game
	//or of a publicKey or just a random name you make up.
	//If I get this API working, every namespace has pixel indexs ranging 0x0000000000 to 0xffffffffff aka 1 teravoxel.
	//As a turing complete constraint solver, it can only make constraints in the nearby few megapixels,
	//such as 8kX8k at the most, or probably will define a limit like the middle 6kX6k or middle 4kX4k of that,
	//where it just reads game state from network in the 1k-2k border around that
	//
	//this.ns = optionalNamespaceString || DefaultNamespace;
	//this.ns = namespaceVar || NS; //NS is the default namespace as a Var.
	//by default, run local game instead of on network. TODO this is not used as of 2024-11-16 and its been all local so far.
	//in theory, works with any namespace, even if you've already downloaded from it then switch this to local,
	//it means dont use ajax or img src=downloadFromUrl or iframe src=downloadFromUrl etc. No networking.
	//Should probably have a separate setting or value/level of this where ur running a localhost server that this ajaxes to
	//but which tells that server to not network outside the computer. but that would depend on your firewall cuz a server,
	//even if localhost, doesnt normally check where its coming from and it may be unreliable to verify,
	//at the most basic level. So this var game.isLocal should probably draw the line at allowing ajax or not, instead of that.
	//not using this as of 2024-11-18, had never used it: this.isLocal = optionalIsLocal!==undefined ? !!optionalIsLocal : DefaultIsLocal;
	//like 0x00000. global offset y, a uint20 which adds 7 bits to y in 32 bit voxels which have uint13 y, so a 1048576x1048576 game area sparsely.
	//wrap instead of: this.oy = optionalY_uint20!=undefined ? optionalY_uint20 : DefaultOy;
	//wrap instead of: this.ox = optionalX_uint20!==undefined ? optionalX_uint20 : DefaultOx; //like 0x00000. similar to oy but for x
	//2024-11-17 todo: Use game.oy and game.ox with gob.oy and gob.ox. The gob returns voxels whose 13 bit y and 13 bit x are relative to gob.oy and gob.ox.
	//If game.oy!=gob.oy andOr game.ox!=gob.ox, that creates complexity but can still be computed, TODO.
	//Depending on gob.oy and gob.ox, gob.brain(...(gob.vars)) should return only the voxels within some square centered on gob.oy gob.ox,
	//even if it could generate other voxels. This is basically a view rectangle that it should only display in that.
	//Im undecided if gob.oy and gob.ox should be allowed to be any integers in that range vs only on some tile size thats a powOf2.
	//if(Math.random()<.01) throw new Error('should every gob be required to have centerY and centerX Vars? that seems it would interfere with wall gobs having 0 params to mark that they dont need to be recomputed. But with centerY and centerX vars we could automaticly update gob.oy and gob.ox. Id like to but theres still the issue of rounding. Var.p (such as centerY.p) is a float64 and changes smoothly. If voxels are relative to that, theyd have to round/floor/ceil it (such as |0). I could make a func similar to YXC(y,x,color) that takes numbers bigger than the 8kX8k, relative to gob.oy gob.ox, but it would likely cost some speed. It seems the output format should change so that ints oy ox go with the int[numVoxels]. {oy: 323633, ox: 800000, ints: Int32Array(numVoxels)}, or could put oy and ox as fields in the Int32Array. I want things to appear in whole near the sides of the 8kX8k, and disappear when they cross out of it, so the size it can touch should be alot less than that. Maybe 2kX2k, since 4 of those wide can fit in 8k. they would partially overlap. I need some minimum space for interesting patterns to form. is 2kX2k enuf? If so, any 2kX2k that at all overlaps the middle 2kX2k must be included, and any 2kX2k that goes even slightly outside the current 8kX8k must be removed for sparsity. therefore i can mask it with 22 bits (11 of each 13 bits for y and x) so that it automatically only generates within some 2kX2k square. So AND it with 0b00111111111110011111111111111111. That will put it in 1 of the corners of the 8kX8k thats exactly 2kX2k. But how to offset it from there? and how to know what such ints to generate? Working on the million X million pixel addressing in Blob Monsters Game. It fits 8kX8k in RAM. If I limit each monster to a moving 2kX2k square, that it can only put voxels in that, then I could have these 2kX2k squares come in from the sides when they entirely fit in the 8kX8k. ... generalize that to powers of 2, so a wall gob could have a size of 64x64 for example, and its oy and ox be powOf2 aligned so they fit as tiles simply, and in the js code string include base64 of the compressed pic format BitPic/BloomTree that i use in dagball. ... it seems oy and ox would be the top left corner, so centerY.p and centerX.p are not the same (center vs top left), and need another o var like oshift. oy+(voxel&((1<<oshift)-1)) or something like that. but it would actually get optimized to just adding an int voxel to everything in the int voxels list, since an int voxel has 13 bits y 13 bits x 6 bits color. ... Find a way to make the whole game state, including interactive gobs and walls, be a vector where every dimension has position and velocity, including .influence (like in dagball.Circ.influence and dagball.Ball.influence) as a dimension but a lower precision one cuz its either on or off in Blob Monsters Game. When you edit a wall with circular paintbrush using 2 mouse buttons, one to paint wall and one to paint open area removing wall, that should navigate the vector space of possible game states. game.rps.distToPoten is 1024 ints (might switch to uint16s?). that should be 1024 dimensions. Theres various other params in game too, excluding the caches that can be derived from vector state of the game. A particular player viewing an area of the game at an x y zoom, that seems like vector dimensions. Where could ed25519 pubkeys controlling some monsters (a player controls a character in the game) be represented as vector of game state? Every dimension should have a Var instance, so theres some new Var instances to create. I should in theory be able to represent the vectors as a set of Var instances. But its not so simple, cuz theyre spread around various object types. Every Var should have a global id by hash, though these wont be copied thru network every time. Should a Var have an optional parent Var, which gob.influence would be such a Var for the whole gob, and gob.vars would be its childs? Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var. ... Vars are becoming a tree, like V/namespaceABC/monster567sHashId/heightToWidthRatio exists if V/namespaceABC/monster567sHashId has position 1, and does not exist if it has position 0. In theory, if u paint a small area of the huge game world with mouse, the thing you painted is a Var which contains that compressed pic data, and its name is the hash of that, and if its value/var.p/position is 1 then it exists and that displays, else doesnt display, across world. If u want to screw with it, just make up a new namespace like V/kj4w3e5q3ew45rtdsfg43534e5 u just make up a random string and copy the relevant parts into there in new Var objects, and explore variants of the global game state. multiverse vectors. ... ot sure where the tree of Var objects goes in the OSI Model of the internet, which is an attempt to map whats out there. I want 1 million simultaneous players, using turing-complete compression of voxel generating lambdas to game together. Experiment, turing completeness expands (SEE PIC "2024-11-17 where does the tree of Var objects fit into the OSI model.png"). most data will be transferred in filenames. file content is constant size, float64s for position velocity etc. Kinda like OpenCogs TruthValue but more limited, simpler, not well organized. But will stream hella fast from everywhere to everywhere. megabyte filenames shrink by hash. The tree of Var objects is a level below constraint solving, but levels above that, Blob Monsters Game does play as a game, not very fun yet, but it works by constraint solving among many millions of bits.');

	//(y,x) is a top left corner (UPDATE 2024-11-16: is it the center of the 8kX8k area, not top left?
	//i recently adjusted some code to do that somewhere in here),
	//that canvas would display. maybe its a 512x512 canvas, or whatever size.
	//board is 8192x8192 and has color and count at each pixel, so can display any of those.
	//its not using .y and .x as of 2024-11-9, always in top left corner of the 8k x 8k space.
	//this.y = Size>>1;
	//this.x = Size>>1;
	//this.y = (optionalY_uint20 || 0)&0xfffff; //now its 2**20 but 8192 in memory wrapped. OLD: since it wraps around 8192, it can start anywhere
	//this.x = (optionalX_uint20 || 0)&0xfffff;
	this.ns = this.bo.up;
	this.Y = this.bo.Y.if0(DefaultSpawnY); //FIXME make sure to call y.p (position of y) instead of just y, even though y's valueOf func slowly evals to y.p.
	this.X = this.bo.X.if0(DefaultSpawnX);
	
	//this.QuadLogLev = this.bo.QuadLogLev.setNow(1);
	this.QuadLogLev = this.bo.QuadLogLev.setNow(0); //0 is dont log. 1 is log. maybe will have multiple levels later.
	
	
	//this.Y.if0(Size/2); //FIXME fix the coordinate system, top left corner vs center, and Size X Size wrapping.
	//this.X.if0(Size/2);
	
	
	//this.zoom = 1; //changed by mouse wheel, how far you zoom in/out the view whose top left corner in game coords (0 to 8191) is this.y and this.x.
	//this.zoom = 5;
	this.zoom = this.bo.zoom.if0(5); //zoom.p
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.01);
	
	
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.03);
	//extremely increasing rpsAccelMul cuz added this code:
	//	let normedPredatorPoten = predatorPoten/voxels.length;
	//	let normedPreyPoten = preyPoten/voxels.length;
	//	gamePoten += rpsAccelMul*(normedPreyPoten-normedPredatorPoten);
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(300);
	this.rpsAccelMul = this.bo.rpsAccelMul.if0(300);
	
	//do rock paper scissors?, using teams REDTEAM, BLUETEAM, GREENTEAM, and of course GRAYTEAM is neutral and not directly part of that
	this.doRps = this.bo.doRps.setNow(0); //off
	//this.doRps = this.bo.doRps.setNow(1); //on
	console.log('Game.doRps.p='+this.doRps.p+' (1 to do Rock Paper Scissors with REDTEAM, BLUETEAM, GREENTEAM, 0 not to)');
	//TODO also (not just doRps) this.doYXRps which will be a simpler far more efficient kind of RPS, that just uses Y and X, not per voxel.
	//You would normally do doRps or doYXRps or neither, but technically you could do both.

	this.isDisplayFullVarNamesInTable = this.bo.isDisplayFullVarNamesInTable.setNow(0);
	//this.isDisplayFullVarNamesInTable = this.bo.isDisplayFullVarNamesInTable.setNow(1);
	
	
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.3);
	//this.rpsAccelMul = this.bo.rpsAccelMul.if0(.1);
	//this.rpsAccelMul.p = 0; //FIXME
	
	
	//the original, the linear counterpart of collideSqMul. Until 2024-11-25 it was all collideLinMul, then adding collideSqMul experimentally.
	//collideLinMul is like "L1 norm". collideSqMul is like "L2 norm". But its not a norm here.
	//FIXME i want 0 to be a valid value for this, but Var.if0 doesnt work that way. Maybe add Var.defaultP (find shorter name).
	this.collideLinMul = this.bo.collideLinMul.if0(1); //normal
	//this.collideLinMul.p = 0; //experimenting 2024-11-25 to use collideSqMul instead
	//this.collideLinMul = this.bo.collideLinMul.if0(.000000001); //experimental, near 0 but cant be 0 cuz incompatible with if0
	
	//Diff of game.poten between a gob being there or not, is squared and multiplied by this to compute actual poten,
	//or leave this as 0 to only use the linear poten (game.poten) directly which will happen either way by collideLinMul.
	//FIXME i want 0 to be a valid value for this, but Var.if0 doesnt work that way. Maybe add Var.defaultP (find shorter name).
	//this.collideSqMul = this.bo.collideSqMul.if0(.05);
	//this.collideSqMul = this.bo.collideSqMul.if0(.01);
	//this.collideSqMul = this.bo.collideSqMul.if0(.002);
	this.collideSqMul = this.bo.collideSqMul.if0(.01);
	//this.collideSqMul = this.bo.collideSqMul.if0(1);
	//this.collideSqMul.p = 0; //FIXME
	
	
	//this.collideSqMul = this.bo.collideSqMul.if0(.000000001); //near 0, basically no effect but cant be 0 cuz incompatible with if0
	this.board = new Uint32Array(Area); //26 bit count as high bits, 6 bit color as low bits.
	
	//512x512 bilinear interpolated 16x16 areas, totalling the 8192x8192 Size/Area
	//of whats loaded nearby centered around mouse or game.Y.p game.X.p.
	//this.ground = new Uint16Array(GroundArea);
	//this.ground = new Float64Array(GroundArea); //TODO Int32Array or Uint16Array, after fix the bugs.
	this.groundA = new Int32Array(GroundArea); //sum of 16x16 voxels (ITileSide(voxel)==16) at a ground index.
	//amount of mass (z sum) at a ground index, that total poten changes per change of groundA there.
	this.groundB = new Int32Array(GroundArea);
	for(let i=0; i<GroundArea; i++){ //random ground height for testing
		//let gy = i>>9;
		//let gx = i&511;
		let gy = i>>10; //2025-1-26+ changing from 512x512 of 16x16 ground tiles to 1024x1024 of 8x8.
		let gx = i&1023;
		let isDiagonal = gy==gx;
		//let diagonalManhattanDistance = Math.abs(gy-gx)*16;
		let diagonalManhattanDistance = Math.abs(gy-gx)*8;
		let z = isDiagonal ? DefaultZ*3 : 0;
		//let z = isDiagonal ? DefaultZ*20 : 0;
		//let z = isDiagonal ? (DefaultZ*3) : ((diagonalManhattanDistance*64)&0xffff);
		
		
		//let z = (DefaultZ*Math.random()*5)&0xffff; //random terrain heightmap. for testing, not very interesting.
		
		
		//this.ground[i] = z;
		this.groundA[i] = z;
		//this.ground[i] = (Math.random()*DefaultZ*3)&0xffff;
	}
	
	/*TODO 2025-1-28 im gonna get rid of board, groundA, and groundB, but not right away. Have to make the quadheap system first.
	Its easier to compute change in total potential energy (stacks of joule-cubes) if you lift the stack from the bottom
	and insert new cubes under it, paying change in height times stack size (joules) to lift, and paying the usual cost
	for a new stack under them. Recursive bilinear? See game.qboard.
	*/
	
	//when this is 1 (else 0), displays using game.qint as sum of log (limited to QMinPtr)
	//number of bilinear interpolations at each (y,x) where y and x range 0 to 8191.
	//this.displayModeQvoxel = this.bo.displayModeQvoxel.setNow(1); //on
	this.displayModeQvoxel = this.bo.displayModeQvoxel.setNow(0); //off
	
	//qint and qflo are replacement for this.board (2025-1-28+ todo...). Use quadheap indexing aka
	//parent of i is i>>2, and 4 childs of i are (i>>2), (i>>2)|1, (i>>2)|2, and (i>>2)|3,
	//and to compute wrapped left right up or down sibling
	//you use https://en.wikipedia.org/wiki/Z-order_curve with Math.clz for high 1 bit to get quad level.
	//The even binheap levels (1, 4..7, 16..31, and so on) are used in this.qint,
	//and the odd binheap levels (2..3, 8..15, 32..63, and so on) are used in this.qflo as int54's.
	//There is no odd binheap level for the lowest qint level (8192x8192)
	//cuz those are leafs and you dont need a count of joules from below.
	//So every index in this.qint.buffer is used except the first int at index 0.
	//For this.qint[ptr], the int54 that goes with it is at this.qflo[ptr] cuz binheap indexing says
	//the 2 childs of ptr are ptr*2 and ptr*2+1, which the Float64Array already happens to have that mapping
	//in the shared buffer since float64 is 8 bytes and int32 is 4 bytes.
	//
	this.qint = new Int32Array(Qarsiz); //1<<27 ints
	this.qflo = new Float64Array(this.qint.buffer); //1<<26 float64s, doesnt have one for biggest (8192x8192) layer.
	
	this.stats = {
		fpsVal: 60,
		callsOfQvox: 0,
	};
	this.logMap = {
		FPS: ()=>this.stats.fpsVal,
	};
	
	Qvox(DefaultZ, 0b111111, 0, 333,444); //touch the qint and qflo arrays so their booting doesnt count toward testQvoxels_startTime
	
	//add some qvox voxels into qint/qflo for testing, near the top left corner,
	//so set enableSpawnNearTopLeft before boot to see it
	//for(let i=0; i<1000; i++){
	//let numTestQvoxels = 10000;
	//let numTestQvoxels = 100;
	//let numTestQvoxels = 1000;
	let numTestQvoxels = 600;
	//let numTestQvoxels = 60;
	let testQvoxels_startTime = time();
	for(let i=0; i<numTestQvoxels; i++){
		let zThicknessInt20 = randInt(1000);
		//let zThicknessInt20 = DefaultZ;
		//let color = 0b001011; //rrggbb
		let color = 0b111111; //rrggbb
		//let y = randInt(800);
		//let x = randInt(800);
		//y = i;
		//x = i+50;
		//x = i;
		let angle = 2*Math.PI*i/numTestQvoxels;
		let centerY = 400, centerX = 400, radius = 150;
		let y = (centerY+radius*Math.sin(angle))|0;
		let x = (centerX+radius*Math.cos(angle))|0;
		let yOriginal = y;
		let xOriginal = x;
		
		//let qlev = randInt(6);
		//let qlev = 0;
		//let qlev = 3;
		//let qlev = randInt(6);
		//let qlev = randInt(12);
		let qlev = randInt(6);
		//let qlev = 5;
		//let qlev = 2;
		//Qvox(zThicknessInt20,colorUint6,qlev0To13,yUint13,xUint13)
		
		let mask = ~((1<<qlev)-1);
		let half = (1<<qlev)>>1;
		y += half; //trying to make the big squares align on square center not their top left
		x += half;
		y &= mask;
		x &= mask;
		
		/*let yUint13 = i*i&8191;
		let xUint13 = i*19+123;
		let half = (1<<(qlev0To13-1)); //cuz (y,x) is the top left corner of the square. i want to align on its center.
		yUint13 -= half;  
		xUint13 -= half;
		let mask = ~((1<<qlev0To13)-1);
		mask &= 8191; //dont go outside range 0 to 8191 for y or x
		*/
		
		let qvoxel = Qvox(zThicknessInt20, color, qlev, y, x);
		
		//if(i<100) console.log('About to add generated qvoxel='+qvoxel+' for testing, '+
		//	'Qvox('+zThicknessInt20+', '+color+', '+qlev+', '+y+', '+x+'),'+
		//	' enableSpawnNearTopLeft='+enableSpawnNearTopLeft);
		//add voxel to this.qint and this.qflo.
		//As of 2025-2-1 im about to hook it into redByteAtYX, greenByteAtYX, and blueByteAtYX.
		let changeOfPotentialEnergy = this.qvox(qvoxel);
		//if(i<100) console.log('Added it, qvoxel='+qvoxel+' changeOfPotentialEnergy='+changeOfPotentialEnergy);
		
		color = randInt(64);
		this.addVox(YXC(y,x,color)); //also add it in the old kind of voxels, so i can track down bugs
		this.addVox(YXC(yOriginal,xOriginal,color)); //also add it in the old kind of voxels, so i can track down bugs
	}
	let testQvoxels_seconds = time()-testQvoxels_startTime;
	console.log('(its faster if u do more at a time, generally they take about 1 microsecond each and are a power of 2 size so u can cover alot of area with that). testQvoxels, added '+numTestQvoxels+' qvoxels in '+testQvoxels_seconds+' seconds aka '+
		(numTestQvoxels/testQvoxels_seconds)+' qvoxels/sec. Its fast to display them but slow to add/remove them cuz they do calculus during add/remove, but it costs nothing at all to just have other voxels there already added. Theyre just sitting in memory. The quadtree bilinear interpolation heightmap has a height everywhere. It doesnt change the array size to add or remove voxels, even if theres more voxels than bits in the array.');
	
	
	
	/*
	//2025-1-18 an experiment, thats probably gonna replace this.board, or maybe should just use this.board as is
	//and put a different amount of poten in it. Instead of max(0,game.board[i]-1) with the linear and squared sums of
	//its diffs per gob, loss aka potentialEnergy is defined as var.poten sum (as usual in case it wants to add more)
	//but dont add that part here, and most importantly, the sum of game.sqBoard[pixelIndex]**2 forall pixels,
	//and update the display to show its smooth curves like in dagball andOr as a 3d isomorphic heightmap from 2d floor.
	//Dagball has color but leaves brightness to the heightmap. Id prefer 3d isomorphic form of it maybe,
	//but colorDirectionOnly with height being brightness is easier to get started displaying it.
	//Make sure to include "walls" as just adding arbitrary amount to the .board or .sqBoard (whichever i end up using)
	//as an actual heightmap.
	//sqPoten might be too small to store the sum of squares for all pixels,
	//but i could do it as the sum of 2 numbers, one thats an integer multiple of 2**52 and the other thats the low bits,
	//and when the low one rolls over
	//potential energy at 2d pixel, summing number or total weight of voxels overlapping there = (height^2)/2
	this.sqBoard = new Uint32Array(Area)
	this.sqPoten = 0;
	
	im thinking of making a new kind of voxel: z 21 bits, y 13 bits, x 13 bits, color 6 bits. total 53 bits so it
	fits in a float64 number range 0 to (2**53)-1 without roundoff. I have a 2d 8192x8192 array to sum these in.
	All voxels at same x y, stack on eachother, forming hills.
	If z is 21 bits that means theres about 2 million possible heights, so you can view the heightmap as stacks
	of rectangles that are 1x1x(1/256), so if you stack 256 of them you get a 1x1x1, very thin vertically so
	the hill smoothness does good physics.
	x and y already have practically unlimited range but I wrap it around whatever 8k X 8k is nearest
	and load/unload the other parts of game as needed
	*
	this.sqBoardLow = 0; //low bits of sqBoardHigh+sqBoardLow. sqBoardHigh is an integer multiple of 2**52, for when sqBoardLow rolls over.
	this.sqBoardHigh = 0; //multiple of 2**52
	Err('todo sqboard');*/
	
	/*
	//Immutable 1 terapixel pic of walls vs opens.
	//TODO this is a WallQuad which is an immutable forkEditable compressed 1 terapixel 1-bit-per-pixel pic of WQWALL vs WQOPEN vs for sparsity WQFORK.
	//TODO if i choose this wall data structure design then code it in a big Int32Array where half the array
	//is literal bits and the other half is pairs of int pointers, and use it as a binary tree of sparse
	//powOf2 aligned squares of WQWALL vs WQOPEN vs WQTRAN.
	this.wal = null;
	*/
	
	this.wallDisplayDist = this.bo.wallDisplayDist.if0(Size*3/4); //normal
	
	/* 2024-12-22 ive decided to go with 128x128 Tile objects in a BigTile stored here,
	so Quad doesnt go here, its a BigTile which is mutable and contains tiles containing Quads,
	and Quad is used as immutable.
	*/
	this.wal = new BigTile(); //empty at first, see game.wal.tiles[square] contains a Tile.
	
	/*
	2024-12-16 ive decided to proceed with Quad, not more complex kind with isComplexFork. make terrain asap
	but todo bring in some of the features of the more advanced kind, like bits to say which of 4 childs are included,
	and maybe some of the symbols mean heights 0..24. Or maybe QTRANSPARENT being only 1 byte we dont need an optimization for it?
	Leave quad as it is and just start using it. Make game.wal be a Quad instance of whole 2**24 X 2**24 game area
	or whichever parts we know about.
	*/
	//this.wal = QuadTransparent;
	//this.wal = Todo('put Qtransparent here by default, whole game world 2 pow 24 by 2 pow 24');
	
	//wall binary, tells where the walls are, 1 bit per pixel.
	//16m slots that can each be a Int32Array(1<<11). If all were filled thats 2**40 bits. Sparse.
	//this.wab is filled as needed from this.wall which is the Bloomtree/Bitpic compressed pic data format from dagball,
	//always of size 2**40 pixels. Each pixel can be 10 meaning wall, 01 meaning open/nonwall,
	//or 00 meaning it does not make any statement about that (transparent),
	//in case you dont have data for parts of the million X million game area and dont want to assume.
	//In an Int32Array(1<<11), high 8 bits of index choose which of 256 y values / rows. Low 3 bits choose which of 8 ints.
	//Next 5 bits (not in the index) choose a bit in an int (todo endian?). 2048 ints are a 256 X 256 of 1 bit per wall vs nonwall.
	//First you choose which of 2**24 indexs in this.wab, which gives you either null or a Int32Array(1<<11).
	//If its null, recurse in this.wal to create it.
	//If this.wal changes, set those parts to null here. In the worst case, thats setting 16m things to null,
	//but usually it will be at most at 16k X 16k area so 4096 of these,
	//which is 2x2 times bigger than the 8kX8k which would be in the middle of that, or some similar size, so this seems practical for those uses,
	//which will happen by having a prev and next this.wal which are both immutable, and diffing them to know what to set to null in this.wab.
	//2024-12-16 nevermind this; this.wab = new Array(1<<24);
	
	//this.wal = new Array(1<<20); //1024x1024 of WallTile which is each sparse 1024x1024 pixels.
	//this.wall.fill(null);
	//potentialEnergy, which is sum of max(0,countAtPixel-1) forall pixels.
	//maybe add a squaring of that later? or is linear good enuf cuz usually its just 0, 1, or 2 count?
	//This changes when you add or remove a voxel.
	this.poten = 0;
	this.gobs = [];
	//this.maxSpeed = this.bo.maxSpeed.if0(1000);
	//max angled Y X speed per Var. 2024-11-23 its getting way too big (500 sometimes) when gob.setExists(true) comes back during game.sparseUpdate().
	//this.maxSpeed = this.bo.maxSpeed.if0(10);
	//this.maxSpeed = this.bo.maxSpeed.if0(100);
	//this.maxSpeed = this.bo.maxSpeed.if0(1000);
	this.maxSpeed = this.bo.maxSpeed.if0(10000);
	//max gradient per Var. 2024-11-23 its getting way too big (20k sometimes) when gob.setExists(true) comes back during game.sparseUpdate().
	//this.maxGr = this.bo.maxSpeed.if0(100);
	//this.maxGr = this.bo.maxGr.if0(1000); //normal
	//this.maxGr = this.bo.maxGr.if0(1000000000); //FIXME
	this.maxGr = this.bo.maxGr.if0(1000000); //FIXME
	this.rps = {
		//rock paper scissors. these are big arrays, 256mB each, same size as game.board,
		//that each contain distanceSquared at each pixel, to the nearest voxel of the R/red G/green or B/blue team.
		//They should be updated sparsely using computeSquaredDistances, such as a 512x512 area near where things are changing,
		//but dont use the whole 512x512, leave some area around the edges so its more accurate.
		//Maybe later we will expand this to be always accurate everywhere, but thats for research into the sparse updates.
		//game.board is always accurate in the whole 8k x 8k area, but rps is a more expensive calculation.
		//The 512x512 or 1024x1024 or 128x128 etc that computeSquaredDistances makes is exact
		//(TODO fix bugs, it shouldnt have a Float32Array, which may make it inexact) but if the actual game world is partly outside
		//it, then it wouldnt be exact, but would be closer to accurate maybe in the 700x700 in the middle of a 1024x1024 for example.
		//boardR: newRpsArray(), //distanceSquared from each pixel to nearest voxel on red team
		//boardG: newRpsArray(), //to green team
		//boardB: newRpsArray(), //to blue team
		//tridist: newRpsArray(), //use computeUint10Distances
		tridistSmall: new Int32Array(SmallArea).fill(TRINF), //use computeUint10Distances in 4x4 smaller 2d array than this.board
		
		//team (BLACKTEAM, REDTEAM, GREENTEAM, or BLUETEAM, and todo GRAYTEAM is neutral for walls and shields,
		//maybe other teams later). no need to .fill(BLACKTEAM) cuz BLACKTEAM==0.
		//store the number of voxels of each team which touches each pixel, as 1 bit. It only measures if the number of your team's voxels
		//there is even or odd. But hopefully this will be good enuf cuz it only takes 1 such collision, between all pairs of voxels.
		/*In Blob Monsters Game, I store number of voxels of each team which touches each pixel, as 1 bit. Only measures even odd.
		It has to be reversible. If I was to expand it to full count, that would be 3 ints instead of 3 bits that fit in 1 byte.
		U can make monsters that dont collide (in team changing by rock paper scissors, but they still collide in game.poten so repel).
		This could be defended against by sorting then deduping voxels returned by a "blob monster" (Gob). I cud do it in constant
		time using the VoxStream class which is 1 bit per pixel for 64 megapixels and is a reversible stack and set of voxels for
		deduping. Dont wanna pay for that.
		*/
		team: new Uint8Array(Area),
		//teamSmall: new Uint8Array(SmallArea),
		
		//how fast do gobs accelerate based on game.rps.tridistSmall, by multiplying the chance in
		//potential energy (poten) from that by this. Set to 0 to not react to the glowing colors.
		//Since game.rps.distToPoten is int32s (or TODO uint16s?), which is required so potentialEnergy is exactly reversible without roundoff,
		//game.rps.accelMul has to be small to balance that. FIXME should accelMul have to be a powOf2, a negative power? Even if so,
		//that could break the potential energy calculation. but maybe it will be ok as long as its not the collisions thing in game.board vs game.poten?
		//accelMul: .0000000000000001,
		//accelMul: 0,//.0001,
		//accelMul: 1,
		//accelMul: .1,
		//accelMul: .01,
		//cant do this cuz Var.accelMul. TODO make a list of fields that dont get auto created as Var childs. Moving this to game.rpsAccelMul. accelMul: this.bo.rps.accelMul.if0(.01),
		//accelMul: .3,
		//can differ across different Games, peer to peer nets, etc.
		//for every possible uint10 distance, add accelMul*distToPoten[dist] to poten,
		//so predator chases prey which runs from predator. See predatorOf and preyOf functions.
		distToPoten: (()=>{ //TODO put this in as 1 or 1024 Vars?
			/*GPT4 says newtonian gravity, so basically just make it proportional to 1/dist plus.
			function gravitationalPotentialEnergy(m1, m2, r) {
				const G = 6.67430e-11; // Gravitational constant in m^3 kg^-1 s^-2
				return -G * m1 * m2 / r;
			}*/
			let distToPoten = new Int32Array(1024); //TODO to not take up too much of CPU L1 cache, maybe this should be a Uint16Array?
			for(let dist=0; dist<1024; dist++){
				//TODO like newtonian gravity, cuz see rock paper scissors video in dagball. distToPoten[dist] = ((2**30)/(dist+1))|0;
				//distToPoten[dist] = dist; //FIXME
				
				//"distToPoten[dist] = Math.min(dist,1019);" sometimes or partially fixes bug 2024-11-25-1p_rpsAccelMul_isInterferingWith_collideSqMul which
				//was caused by using multiple constants for max distance, those constants being 1019 and 1023.
				//distToPoten[dist] = Math.min(dist,1019);
				//distToPoten[dist] = Math.min(dist,900); //FIXME this is way too big a flat area at the end.
				distToPoten[dist] = Math.min(dist,980); //FIXME this is way too big a flat area at the end.
				//distToPoten[dist] = Math.min(dist,700); //FIXME this is way too big a flat area at the end.
			}
			return distToPoten;
		})(),
	};
	
	this.paintColor = this.bo.paintColor.setNow(randInt(Colors)); //FIXME start as what color? 0b111111 white?
	
	//dont allow Math.random, but since its not in the whitelist...
	this.allowedClassDotFuncs = new Set(DefaultAllowedClassDotFuncs);
};

Game.prototype.setPaintColor = function(color6){
	console.log('setPaintColor '+color6);
	this.paintColor.p = color6&ColorMask;
	updatePaintControls();
};

//z ranges 0 to ZSize-1 ((2**21)-1), though in game.board it has 26 bits. Unsure what the range will end up being,
//cuz adding thickness (like in dagball the background is smooth) to voxels is experimental as of 2025-1-20.
//zBrightFrac chooses a number 0 to 1 to view a z. This has to be fast cuz is called 1-3 times per pixel 60 times per second.
Game.prototype.zBrightFrac = function(z){
	//return sigmoid(z/1000); //FIXME needs to be measured statistically.
	//return sigmoid(z/300-3); //FIXME needs to be measured statistically.
	return sigmoid(z/100-2); //FIXME needs to be measured statistically.
	//return 1-300/(300+z);
	//return 1-300/(300+Math.sqrt(z));
	//return z>0 ? Math.random() : 0;
	//return 1-1/Math.log1p(z); //FIXME needs to be measured statistically.
	//return Math.random();
};

//returns 0..((2**16)-1) as game.ground is a Uint16Array(512**2 aka GroundArea) stretched to the 8192x8192.
//just rounds down to the top left one, instead of bilinear interpolation which .groundZ(y,x) would do.
//Also, does not multiply by 256 like groundZ does,
//cuz this will be an integer directly from the top left 16x16 corner its in a ground tile.
Game.prototype.groundZCheapYX = function(y,x){
	return this.groundZCheap(((y&8191)<<13)|(x&8191));
	//return this.ground[((y&0x1ff0)<<9)|((x&0x1ff0)>>4)]; //8192 is 13 bits. ground 512 is 9 bits. 4 bit diff.
	//TODO use GR(y) andOr GR(x)?
};
/*Game.prototype.groundZCheap = function(yx){
	return this.groundZCheapYX(IY(yx<<6),IX(yx<<6)); //todo optimize with bit math
};*/
Game.prototype.groundZCheap = function(yx){
	//yx is 13 bits of y, and below that is 13 bits of x.
	//When the 4 low bits of y and x are 0s, its a corner of the ground grid in the 8192x8192,
	//but to get the index in the groundA and groundB arrays you turn that into 9 bits of y and below that 9 bits of x.
	//return game.groundA[((yx>>8)&0b111111111000000000)|((yx>>4)&0b111111111)];
	//
	//2025-1-26+ changing from 512x512 of 16x16 ground tiles to 1024x1024 of 8x8.
	return game.groundA[((yx>>6)&0b11111111110000000000)|((yx>>3)&0b1111111111)];
};

//yx ranges 0 to (2**26)-1 aka index in the 8192**2 game.board, despite the ground array is 16x16 times smaller.
Game.prototype.groundZ = function(yx){
	return this.groundZAtYX((yx>>13)&0x1fff, yx&0x1fff);
};

//bilinear interpolation in a 16x16 of 4 integer heights at the corners.
//Is 256 times whatevers in those 4 corners so the bilinear interpolation always gives an integer.
//If you do it in the last row/column it will wrap.
Game.prototype.groundZAtYX = function(y,x){
	let intY = y&SizeMask;
	let intX = x&SizeMask;
	//let bucketYLow = (intY>>GroundTileBits)&GroundMask;
	//let bucketXLow = (intX>>GroundTileBits)&GroundMask;
	let bucketYLow = intY>>GroundTileBits;
	let bucketXLow = intX>>GroundTileBits;
	let bucketYHigh = (bucketYLow+1)&GroundMask;
	let bucketXHigh = (bucketXLow+1)&GroundMask;
	let topLeftCornerZ = this.groundA[(bucketYLow<<GroundBits)|bucketXLow]; //-y is up on screen, as usual in reading order in most apps.
	let topRightCornerZ = this.groundA[(bucketYLow<<GroundBits)|bucketXHigh];
	let bottomLeftCornerZ = this.groundA[(bucketYHigh<<GroundBits)|bucketXLow];
	let bottomRightCornerZ = this.groundA[(bucketYHigh<<GroundBits)|bucketXHigh];
	//0 to 15 for bilinear interpolation. If it was 16, it would be the 0 in the next 16x16 ground tile.
	let yMix = y&GroundTileSizeMask;
	let xMix = x&GroundTileSizeMask;
	let flipYMix = GroundTileSize-yMix;
	let flipXMix = GroundTileSize-xMix;
	//return 64*topRightCornerZ;
	return (topLeftCornerZ*flipXMix + xMix*topRightCornerZ)*flipYMix +
		yMix*(bottomLeftCornerZ*flipXMix + xMix*bottomRightCornerZ); //exact integer bilinear interpolation 256 times bigger
};

//yx is (y<<SizeBits)|x aka IP(voxel). This is sum of whats in game.board and game.ground.
Game.prototype.sumZ = function(yx){
	let boardZ = this.board[yx]>>>6; //high 26 bits are z sum from voxels. low 6 bits are xor of color of all those voxels.
	//boardZ = 0;
	//let groundZ = this.groundZCheap(yx);
	let groundZ = .001*this.groundZ(yx);
	//groundZ += this.groundZCheap(yx); //for testing
	//todo groundZ which is bilinear interpolated, but groundZCheap is alot faster. Use which?
	return boardZ+groundZ;
};

var lastTouchOrder = 0;

//Returns 1 if wall, 0 if not. y and x each range 0 to 0xfffff. Its sparse using this.wal (WallQuad)
//and this.wab (1d array used as 4096x4096 of null or 256x256 BitPic, todo put bitPic.touchOrder = ++lastTouchOrder;).
Game.prototype.wallAtYX = function(y, x){
	Err('use tileHeight and the 128x128 tiles, a BigTile instance, that maybe goes in this.wal, not a WallTile instance which is older class.');
	//return this.wal.get(y,x)==WQWALL; //is WQWALL, WQOPEN, or WQTRAN.
};

Game.prototype.shouldDisplayTile = function(tile){
	return tile.yxDist(this.Y.p,this.X.p) <= this.wallDisplayDist.p;
};

/*//4 child indexs in WallQuad.childs
const WQUPLEFT = 0;
const WQUPRIGHT = 1;
const WQDOWNLEFT = 2;
const WQDOWNRIGHT = 3;
*/

//constants for indexs in WallQuad.childs and for each uint2 in the base64 compressed form.
const WQTRAN = 0b00;
const WQOPEN = 0b01;
const WQWALL = 0b10;
const WQFORK = 0b11;
//const WQMaxHeight = 40;

/*throw new Error(`monstPaintableWallsVsOpenAreaLikeInDagball_mustSaveIntoWorldStateJsonFileAlongWithGobBrainsAndPositionsAndVelocitiesEtc
It cant be done efficiently in game.board, which has a uint26 count per pixel, cuz when it scrolls in the terapixel space, it would have to be copied, and its too much memory to do that fast. So the data structure has to be separate for walls. Make it 1 bit per pixel in small areas, base64 BloomTree/BitPic compressed  before expanding to such small areas. Maybe make 2**24 areas of 256x256, thats a single 2**40 pixel immutable BloomTree stored in game.wal as the top WallQuad. Yes, do that. Store only the base64 string form compressed as big or small as it needs to be, but always do the expanded dense form as 256x256 blocks. If the whole million X million game area is all wall or all nonwall, that only takes 1 char to store, and dont pad it since the bloomtree/bitpic datastruct can detect when its done at a certain bit index.
`);*/

//Immutable. To efficiently navigate this in a mutable way, use new WallNav(wallQuad, 0).
//see Game.wal which is a 4096x4096 array (1d used as 2d) of nulls that can become BitPics that are from wallQuad.bitpic.
//
//OLD...
//
//TODO Each WallTile is stored as compressed by the Bitpic/Bloomtree code in dagball
//which is good pic compression for 1 bit color with transparency.
//11 means fork 2x2. 10 means wall. 01 means nonwall/openArea. 00 means transparent/unspecified.
//It compressions to a size proportional to the total curve lengths of the borders between wall and nonwall.
//You'll find examples of these base64 data structures in https://github.com/benrayfield/DagBall/tree/main/saves like this //{"type":"dagball_bitpic","wallPoten":50,"wallThick":5,"height":1024,"width":1024,"bloomtree":"/7q7q6u6m5W7vqVe5XmVv5l5lflVW7 (base64 continues...).
//If its all wall or all nonwall, that would be just 2 bits, so plus padding that would probably be 4 chars. That one ended with "qq91raqqqqgA==".
//tileIndex ranges 0 to 0xfffff, high 10 bits of y, low 10 bits of x, then inside that use the base64 for sparse bits in 1024x1024.
//TODO hook this into the V/Var tree, where Var.big contains tileIndex and this base64, maybe as a string of json,
//or maybe tileIndex should be part of the base64 as it can specify that in 10 recursions, leaving 3 out of each 4 as transparent/00,
//and when it zooms in far enuf (from 2**20 X 2**20 zoom in to a 2**10 X 2**10).
//Lets do that. Get rid of the game.wal array and make that val be an immutable WallQuad.
//WallQuad is immutable, so you modify it by forkEdit only.
//Use data OR childs but not both. WallQuad is a quadtree.
//var WallQuad = function(height, stringDataOrFourChilds){
var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr){
	throw new Error('As of 2024-12-11 WallQuad was never finished and Quad, which is a more efficient design, is proceeding instead');
	//256x256 bit cache of this WallQuad if this.height==8, created as needed.
	//This can be reused in game.wab[((12 high bits of y)<<12)|(12 high bits of x)]
	this.bitpic = null;
	this.height = Math.max(0, Math.min(height|0, 20)); //height 0 is a single pixel in the 2**20 X 2**20 space. Height 20 is the whole space.
	this.base64 = optionalBase64!==undefined ? optionalBase64 : null;
	//could instead be WQOPEN, WQWALL, or WQTRAN, a giant pixel of squareSide==(1<<this.height).
	//If this.base64 is a string (compressed pic), this must be the first uint2 in it. TODO is that the low 2 bits or high 2 bits of the first 6 bit char?
	//this.val = val&3; //this.val = WQFORK;
	if(optionalVal === undefined){
		if(this.base64 == null){
			this.val = WQTRAN; //transparent/unspecified, since they didnt give base64 of compressed pic or uint2 val.
		}else{
			if(this.base64.length > 4){
				//cuz firstUint2InBase64 isnt working yet (2024-12-1) and its gotta be WQFORK if it has childs. The base64 comes in blocks
				//of 4 chars that means 3 bytes. The 4 chars are padded with = if needed. So smallest base64 in this system is 4 chars.
				//Even if height is big, there could still be a leaf uint2 here (WQTRAN, WQOPEN, WQWALL) if the base64 is size 4
				//or if base64 is not given but val is given.
				this.val = WQFORK;
			}else{
				this.val = firstUint2InBase64(this.base64);
			}
		}
		//this.val = optionalVal!==undefined ? (optionalVal&3) : 
	}else{
		this.val = optionalVal&3; //TODO if base64
	}
	this.ul = optionalUl || null; //up left child in 2x2 quadtree
	this.ur = optionalUr || null; //up right
	this.dl = optionalDl || null; //down left
	this.dr = optionalDr || null; //down right
	//this.isLeaf = !ul;
	/*if(typeof(stringDataOrFourChilds) == 'string'){
		this.base64 = stringDataOrFourChilds;
		this.childs = [];
		//this.height = 10; //FIXME should it always be 10 aka 1024X1024 aka 2**10 X 2**10?
		//this.walls = FIXME; //range 0 (inclusive) to 2**40 (inclusive), so need 41 bits to store this. That fits in a float64.
		//this.opens = FIXME; //range 0 (inclusive) to 2**40 (inclusive)
		this.walls = 0; //FIXME
		this.opens = 0; //FIXME
		this.trans = 0; //FIXME
		if(this.trans != 0){
			throw new Error('at this leaf, it must be all WQWALL or WQOPEN (and of course WQFORK for inner nodes in the base64)');
		}
	}else{
		this.base64 = '';
		this.childs = stringDataOrFourChilds;
		if(this.childs.length != 4){
			throw new Error('Must be 4 childs');
		}
		this.walls = this.childs[0].walls + this.childs[1].walls + this.childs[2].walls + this.childs[3].walls;
		this.opens = this.childs[0].opens + this.childs[1].opens + this.childs[2].opens + this.childs[3].opens;
		this.trans = this.childs[0].trans + this.childs[1].trans + this.childs[2].trans + this.childs[3].trans;
		let total = this.walls+this.opens+this.trans;
		if(total != (2**this.height)){
			throw new Error('total != (2**this.height), walls='+this.walls+' opens='+this.opens+' trans='+this.trans+' height='+this.height);
		}
	}*/
};
/*var WallTile = function(tileIndex, base64){
	this.tileIndex = tileIndex;
	this.base64 = base64;
};*/
//WallQuad.prototype.
//WallTile.prototype. = function(tileIndex, base64){
//var WallTile = function(base64)

//Mutable. Navigates through a WallQuad tree, including WallQuad objects and pointers into WallQuad.base64
//in units of 2 bits so 3 of those per char (last few chars each have 1 or 0 of those. = is char that has 0).
//i is 0 if there is no wq.base64, and it means WQFORK. This can go into any of the 4 childs,
//whether its a WallQuad or changing this.i to point at a child in that same string.
//When you navigate from a WallQuad to one of its childs and that child is another WallQuad, replaces this.WallNav.
//
//Instead of OLD[[this.i is added to wq.i in case wq is a view of somewhere inside wq.base64]],
//should this.i start at wq.i?
//
//which can be caused by making a new WallQuad from 4 WallNavs in a way that reuses existing base64 strings
//since those strings can get big enuf that their memory matters when theres a million of them or so.
//There will be millions of them sometimes in game.wab, and the root WallQuad is in game.wal.
var WallNav = function(wq, i){
	this.wq = wq;
	this.i = i;
};

//gets WQTRAN, WQOPEN, WQWALL, or WQFORK.
WallNav.prototype.val = function(){
	Todo();
};

/*WallNav.prototype.isLeaf = function(){
	return this.val()!=WQFORK;
};*/

//modify self to point at the up left child of what self was pointing at.
WallNav.prototype.ul = function(){
	Todo();
};

WallNav.prototype.ur = function(){ //up right child
	Todo();
};

WallNav.prototype.dl = function(){ //down left child
	Todo();
};

WallNav.prototype.dr = function(){ //down right child
	Todo();
};

//set union of wall pixels
WallQuad.prototype.or = function(wq){
	throw new Error('TODO');
};

//set intersection of wall pixels
WallQuad.prototype.and = function(wq){
	throw new Error('TODO');
};

var byteArrayRange = (byteArray, start, end)=>{
	if(start == 0 && end == byteArray.length) return byteArray;
	if (start < 0 || end > byteArray.length || start > end) {
		throw new Error("Invalid start or end index");
	}
	return new Uint8Array(byteArray.buffer, byteArray.byteOffset + start, end - start);
};

Quad.prototype.bytesToBase64 = function(){
	return dagball.bytesToBase64(byteArrayRange(this.B, this.i, this.length));
};

//content of this tile to hash to make a Var.big string which Var.name is made from,
//and 'mutid$tile34534534543$' etc goes before it, the number being the Square uint53.
Tile.prototype.contentToHash = function(){
	this.syncSparseDense();
	return this.sparse.bytesToBase64();
};

//Like in dagball, a mutid is any arbitrary short name (no whitespace etc)
//that there can be at most 1 instance of per namespace at a time, so if you edit it,
//it automatically replaces older versions with the same mutid, a mutable variable.
Tile.prototype.mutid = function(){
	return 'tile'+this.square;
};

//Tile is mutable and its content can change based on painting wall/open and 64 colors in it,
//so which Var it is can change. Its mutid wont change, but the hash after it will.
//This is an expensive calculation cuz hashes the pic content every time. todo cache the Var until changes?
Tile.prototype.toVar = function(){
	this.syncSparseDense();
	let quad = this.sparse;
	if(!quad) Err('no quad');
	//return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(sha256(byteArrayRange(this.B, this.i, this.length)))];
	//Err('need to modify Var so when get from it some content it auto generates the mutid prefix. put that prefix in the content');
	//return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(byteArrayRange(quad.B, quad.i, quad.length))]; //todo make it grab the mutid from the prefix
	//return NS['mutid$'+this.mutid()+'$'+dagball.bytesToBase64(quad.getBytes())];
	let mutid = this.mutid();
	let ret = NS[mutid+'$'+bytesToBase64(quad.getBytes())];
	console.log('Tile.toVar ret='+ret.path());
	let prefixToFind = mutid+'$'; //like tile23453344$
	for(let idB of Object.keys(NS.pu)){
		//delete the Tile(s) this replaces if any, even if theres multiple of them that somehow didnt get deleted before.
		//u could leave them, is valid in Var tree, but it accumulates alot of json size fast if u dont while painting with
		//mouse cuz of every change to a 128x128 tile is a Var.
		//let childVar = NS.pu[idB]; //NS[idB] would work too but is slower cuz of Proxy
		if(idB.startsWith(prefixToFind) && idB != ret.name){
			console.log('Deleting '+NS[idB].path()+' cuz Tile.toVar is making another Var to replace it, painted differently.');
			delete NS.pu[idB];
		}
	}
};

dagball.bytesToBase64 = bytes=>btoa(String.fromCharCode.apply(null, bytes)); //returns string

dagball.base64ToBytes = base64=>{ //returns Uint8Array
	const binaryString = atob(base64);
	const len = binaryString.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binaryString.charCodeAt(i);
	}
	return bytes;
};

//set this.bitpic to a 256x256 instance of dagball.BitPic, normally when this.height==8 and it doesnt already have this.bitpic
WallQuad.prototype.makeBitpic = function(){
	if(this.base64 == null){ //in case its all WQTRAN which is 0b00, cant use if(this.base64).
		Err('No base64');
	}
	//let bytes = (typeof(base64StringOrBytes)=='string') ? dagball.base64ToBytes(this.base64) : base64StringOrBytes;
	let bytes = dagball.base64ToBytes(this.base64);
	let bloomtree = new dagball.BloomTree(bytes);
	let squareSide = 1<<this.height;
	let area = squareSide**2;
	//let area = (1<<(this.height<<1));
	let wallPoten = DefaultBitPicWallPoten;
	let wallThick = DefaultBitPicWallThick;
	let aftrans = null; //FIXME? thats from dagball. we use game.Y.p, game.X.p, and game.zoom.p instead.
	let bitpic = new dagball.BitPic(wallPoten, wallThick, squareSide, squareSide, bytes, aftrans);
	bloomtree.paintOntoBitPic(bitpic);
	return this.bitpic = bitpic;
};

var DefaultBitPicWallPoten = 50; //FIXME
var DefaultBitPicWallThick = 5; //FIXME

/*
//heights 0..20 inclusive. (height<<2)|uint2, so if its a smallest pixel then its just the uint2 cuz height is 0.
const onePixelWallQuad = [];
for(let height=0; height<=20; height++) for(let uint2=0; uint2<4; uint2++){
	onePixelWallQuad[(height<<2)|uint2] = new WallQuad(height, null, uint2);
}*/

//Makes a base64 for a WallQuad of the given height, by calling hyxToUint2(height,y,x) -> WQTRAN or WQOPEN or WQWALL,
//where y and x each range 0 to (1<<height)-1. yFrom and xFrom are only used as offsets in params of yxToUint2.
//Default height for making base64 is 8 so is 256x256. Sparse pic goes up to height 20.
var funcToBase64Walls = function(hyxToUint2, optionalHeight, optionalYFrom, optionalXFrom){
	let height = optionalHeight!==undefined ? optionalHeight : 8; //
	let yFrom = optionalYFrom!==undefined ? optionalYFrom&SizeMask : 0;
	let xFrom = optionalXFrom!==undefined ? optionalXFrom&SizeMask : 0;
	let squareSide = 1<<height;
	let area = squareSide**2;
	let wallPoten = DefaultBitPicWallPoten; //FIXME
	let wallThick = DefaultBitPicWallThick; //FIXME
	let aftrans = null; //FIXME? thats from dagball. we use game.Y.p, game.X.p, and game.zoom.p instead.
	let bitpic = new dagball.BitPic(wallPoten, wallThick, squareSide, squareSide, bytes, aftrans);
	let yTo = yFrom+squareSide;
	let xTo = xFrom+squareSide;
	for(let dy=0; dy<squareSide; dy++){
		for(let dx=0; dx<squareSide; dx++){
			let uint2 = yxToUint2(height, yFrom+dy, xFrom+dx);
			bitpic.writeYXRaw(dy, dx, (uint2==WQWALL)?1:0)
		}
	}
	let bloomtree = bitpic.toBloomTree();
	return dagball.bytesToBase64(bloomtree.bytes);
};

var randomWallQuad256x256 = fractionWall=>(
	new WallQuad(8, funcToBase64Walls((y,x)=>(Math.random()<fractionWall ? WQWALL : WQOPEN))));

//WallQuad is a tree. Starts hyxToUint2 at the top of tree (1 terapixel) and recurses it wherever it says WQFORK.
//Creates 256x256 BitPic then converts to compressed base64 to make the wallquad
//(FIXME make funcToBase64Walls return the BitPic too for WallQuad.bitpic as cache?)
//but only at height 8 or less (128x128 at height 7, 4x4 at height 2, and uses onePixelWallQuad if gets that low),
//but should end at height 8 (256x256). If you start it below height 8, it will do that, else it chooses 8 as the limit.
//May ignore hyxToUint2 at heights 1..7, which would normally be WQFORK, and go straight to height 0 and call it
//256x256 times to make a height 8 WallQuad containing that generated compressed base64.
//Func hyxToUint2 takes height, y, x, where y and x are powOf2 aligned, normally starting at height 20 (terapixel).
//hyxToUint2(y,x,height) -> [[WQTRAN or WQOPEN or WQWALL] to end recursion] or [WQFORK to recurse]. Must not recurse at height 0.
//optionalHeight defaults to 20, the 2**20 X 2**20 terapixel game size.
//
var funcToWallQuad = (hyxToUint2, optionalHeight, optionalYFrom, optionalXFrom)=>{
	let height = optionalHeight!==undefined ? optionalHeight : 20;
	let yFrom = optionalYFrom!==undefined ? optionalYFrom&SizeMask : 0;
	let xFrom = optionalXFrom!==undefined ? optionalXFrom&SizeMask : 0;
	if(height < 0 || 20 < height || (height|0)!=height){
		Err('height='+height);
	}
	let uint2 = hyxToUint2(height, yFrom, xFrom);
	if(height == 0){
		return onePixelWallQuad[uint2];
	}else if(height <= 8){
		//make BitPic then base64 from it, of squareSide (1<<height).
		let base64 = funcToBase64Walls(hyxToUint2, height, yFrom, xFrom);
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(height, base64);
	}
};

/* Replacing get with hyx cuz hyx is more general as it can get internal tree nodes too.
//returns WQTRAN or WQOPEN or WQWALL (each is 2 bits) if in range, else (TODO?) throws cuz out of range.
//Y and x each range 0 to (1<<this.height)-1 which is at the most 0xfffff.
//returns 10 if WQWALL, 01 if WQOPEN, 00 if transparent/unspecified. Wont return 11/WQFORK cuz would recurse.
//WallQuad.prototype.bbAtYX = function(y, x){
//};
WallQuad.prototype.get = function(y,x){
	if(this.bitpic || (this.height==8 && this.makeBitpic())){
		return this.bitpic.readBit(((y&0xff)<<8)|(x&0xff)) ? WQWALL : WQOPEN;
	}else if(this.height > 8){
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.ul.get(y,x);
			}else{
				return this.ur.get(y,x-halfSize);
			}
		}else{
			if(x < halfSize){
				return this.dl.get(y-halfSize,x);
			}else{
				return this.dr.get(y-halfSize,x-halfSize);
			}
		}
	}else{
		Err('Dont call WallQuad.get where the WallQuad.height < 8 cuz at 8 we expand the cache to a 256x256 bit BitPic');
	}
};*/
//
//
//get uint2 at height, y, x. Height ranges 0 to this.height inclusive. y and x range 0 to (1<<this.height)-1 inclusive.
WallQuad.prototype.hyx = function(height, y, x){
	if(this.val !== WQFORK){
		return this.val;
	}else if(this.bitpic){
		return this.bitpic.readBit(((y&0xff)<<8)|(x&0xff)) ? WQWALL : WQOPEN;
	}else if(this.height <= 8){ //should use compressed base64 pic, to generate BitPic
		//there should never be a bitpic in a parent and in a child or any child reachable.
		//1 level only, normally always at height 8 as that makes 256x256, which up to 2**24=16777216 of can go in game.wab sparsely.
		this.makeBitpic();
		return this.hyx(height,y,x);
	}else{ //higher than 8 so should be a tree
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.ul.hyx(height-1,y,x);
			}else{
				return this.ur.hyx(height-1,y,x-halfSize);
			}
		}else{
			if(x < halfSize){
				return this.dl.hyx(height-1,y-halfSize,x);
			}else{
				return this.dr.hyx(height-1,y-halfSize,x-halfSize);
			}
		}
	}
};

//WallQuad is used as immutable, so this forkEdits to return another WallQuad with the given wq WallQuad's
//top left corner at y x, but y x must be powOf2 aligned to wq.height.
WallQuad.prototype.putYXWq = function(y, x, wq){
	if(wq.height == this.height){
		return wq; //since its immutable, reuse it as completely overwriting this WallQuad by forkEdit. Both still exist.
	}else if(wq.height < this.height){
		let halfSize = 1<<this.height;
		if(y < halfSize){
			if(x < halfSize){
				return this.setUl(ul.put(y,x,wq));
			}else{
				return this.setUr(this.ur.put(y,x-halfSize,wq));
			}
		}else{
			if(x < halfSize){
				return this.setDl(this.dl.put(y-halfSize,x,wq));
			}else{
				return this.setDr(this.dr.put(y-halfSize,x-halfSize,wq));
			}
		}
	}else{
		Err('wq is bigger (height '+wq.height+') than this WallQuad (height '+this.height+')');
	}
};

//forkEdits this to return new WallQuad, unless this.ul already === ul.
//FIXME check if all 4 childs are leaf uint2s, and merge them if so.
WallQuad.prototype.setUl = function(ul){
	if(this.ul === ul){
		return this;
	}else if(this.base64 != null){
		Todo();
	}else{
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(this.height, null, WQFORK, ul, this.ur, this.dl, this.dr);
	}
};

WallQuad.prototype.setChilds = function(ul, ur, dl, dr){
	if(this.ul === ul){
		return this;
	}else if(this.base64 != null){
		Todo();
	}else{
		//var WallQuad = function(height, optionalBase64, optionalVal, optionalUl, optionalUr, optionalDl, optionalDr)
		return new WallQuad(this.height, null, WQFORK, ul, ur, dl, dr);
	}
};

//for dedup. key is wallQuad.base64, val is that wallQuad.
//Used where alsoDedupBase64 is true in WallQuad.prototype.dedup = function(alsoDedupBase64)
//var mapBase64ToWallQuad = {};
//TODO make hash ids using sha256 of some combo of height and base64, or of height and the 4 childs.
//See WallQuad.prototype.toString and make a variant of that which returns the whole string to be hashed,
//or maybe use a normed json of it like in Dagverse.js/DV but dagverse has too much

//If all 4 childs, each deduped by this func, are leaf uint2s (not WQFORK) and are the same uint2, then that uint2
//replaces this WallQuad. Returns either this WallQuad or a forkEdited one, with the same content but possibly uses less memory.
//Warning: deduping by 
WallQuad.prototype.dedup = function(alsoDedupBase64){
	if((alsoDedupBase64 && this.isDeduped_alsoDedupBase64) || (!alsoDedupBase64 && this.isDeduped_not_alsoDedupBase64)){
		return this;
	}
	if(alsoDedupBase64){
		Todo('alsoDedupBase64, see comments: TODO make hash ids using sha256 of some combo of height and base64, or of height and the 4 childs');
	}
	let ret;
	if(this.val == WQFORK){
		let dedupedUl = this.ul.dedup(alsoDedupBase64);
		let dedupedUr = this.ur.dedup(alsoDedupBase64);
		let dedupedDl = this.dl.dedup(alsoDedupBase64);
		let dedupedDr = this.dr.dedup(alsoDedupBase64);
		let anyChildsChanged = this.ul!==dedupedUl || this.ur!==dedupedUr || this.dl!==dedupedDl || this.dr!==dedupedDer;
		let v = dedupedUl.val;
		if(v === WQFORK){
			ret = anyChildsChanged ?
				new WallQuad(this.height, null, WQFORK, dedupedUl, dedupedUr, dedupedDl, dedupedDr) : this;
			//mark this as deduped (in 1 of 2 ways depending on alsoDedupBase64) and return this
			if(alsoDedupBase64){
				ret.isDeduped_alsoDedupBase64 = true;
			}else{
				ret.isDeduped_not_alsoDedupBase64 = true;
			}
			return ret;
		}else{
			let childsAreAllSameUint2 = v===dedupedUr.val && v===dedupedDl.val && v===dedupedDr.val;
			ret = childsAreAllSameUint2 ? onePixelWallQuad[(this.height<<2)|v] : Todo('still need to check anyChildsChanged, merge that code');
		}
		return ret;
	}else{
		return onePixelWallQuad[this.val];
	}
};

const uint2ToChar = [];
uint2ToChar[WQTRAN] = 't';
uint2ToChar[WQOPEN] = 'o';
uint2ToChar[WQWALL] = 'w';
uint2ToChar[WQFORK] = 'f';

WallQuad.prototype.toString = function(){
	if(this.height == 0){
		return uint2ToChar[this.val];
	}else if(this.base64 != null){
		if(this.base64.length > 50){
			return 'wqPart$h'+this.height+'$'+this.base64.substring(0,20)+'..len'+this.base64.length+'..'+this.base64.substring(this.base64.length-20);
		}else{
			return 'wq$h'+this.height+'$'+this.base64;
		}
	}else{
		return 'wq$h'+this.height;
	}
};

/*
//WallQuad is used as immutable, so this forkEdits to return another WallQuad that reuses
//all branches not changed, with val&3 set at a pixel. OptionalHeight defaults to 0 aka single pixel
//or you can give it at a height 0..40 inclusive to overwrite whatevers there with a powOf2 size square.
WallQuad.prototype.put = function(y, x, val, optionalHeight){
	let putHeight = optionalHeight|0;
	if(this.height <= putHeight){
		Todo('return a new WallQuad of 1 giant pixel that is val, at putHeight');
	}else{
		
	}
	Todo();
};*/

//makes a WallQuad thats WQWALL or WQOPEN at the given circle and is WQTRAN everywhere else.
//You make this when painting or erasing a circle area with mouse to modify game.wab (tree)
//which then modifies game.wal (grid) by the diff between previous and next game.wal,
//considering that WQTRAN is unspecified/transparent areas. Uses squareCirc in recursion.
const wqCirc = ()=>{
	Todo();
};

//return 1 if circle is completely outside circle, -1 if completely inside, or 0 if its part inside part outside.
//TODO choose what behaviors I want for if its exactly on the line as in <= vs <.
const squareCirc = (squareMinY, squareMinX, squareSide, circleY, circleX, radius) => {
	const squareMaxY = squareMinY + squareSide;
	const squareMaxX = squareMinX + squareSide;
	if(squareMaxX < circleX - radius || squareMinX > circleX + radius ||
			squareMaxY < circleY - radius || squareMinY > circleY + radius){ //fast check before squaring
		return 1; // Square is completely outside the circle
	}
	const radiusSquared = radius * radius;
	const dx1 = (squareMinX - circleX)**2;
	const dx2 = (squareMaxX - circleX)**2;
	const dy1 = (squareMinY - circleY)**2;
	const dy2 = (squareMaxY - circleY)**2;
	if(	dx1 + dy1 > radiusSquared || //Top-left corner
		dx2 + dy1 > radiusSquared || //Top-right corner
		dx1 + dy2 > radiusSquared || //Bottom-left corner
		dx2 + dy2 > radiusSquared) { //Bottom-right corner
		return 0; // Square is partly inside, partly outside
	}
	return -1; // All corners are inside the circle
};


var setDifference = function(setA, setB){
	return new Set([...setA].filter(x => !setB.has(x)));
};


//FIXME 2024-11-20 this is making either all the gobs or none of them appear, depending on if move past around maxDistance.
//Replaces this.gobs which is a [] list of Gob instances, those near this.y.p this.x.p
Game.prototype.sparseUpdate = function(){
	//return; //cuz is broken.
	//console.log('FIXME game.sparseUpdate gotta deal with game.gobs list, that no Gob has ever been removed from that as of 2024-11-20, and this might be a good time to use quadtree or redesign that?');
	let myNamespace = this.bo.up;
	//let maxDistance = 500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 2000; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 3500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 4500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	//let maxDistance = 24500; //FIXME should be around 8192/2*Math.sqrt(2), but for testing its smaller.
	let y = this.Y.p, x = this.X.p;
	//y += Size>>1; //FIXME fix the coordinate system, top left corner vs center. Shouldnt have to add Size/2.
	//x += Size>>1;
	let maxDistance = Size/2;
	
	
	//compute objects that are near mouse, instead of center view.
	y = mouse.y();
	x = mouse.x();
	
	let newGobs = myNamespace.searchYXRGoal(y, x, maxDistance, gobVar=>{
		return gobVar !== this.bo;
	}).map(gobVar=>gobVar.getOb()); //getOb returns a Gob (UPDATE: or a QuadTile, or some dont have an ob), reuses it if exists
	if(!newGobs.includes(mouse)) newGobs.push(mouse); //always include mouse gob
	//if(!newGobs.includes(cShapedGob)) newGobs.push(cShapedGob); //always include	cShapedGob, for testing. FIXME remove this.
	let newGobsSet = new Set(newGobs);
	let oldGobsSet = new Set(this.gobs);
	let gobsToAddSet = setDifference(newGobsSet,oldGobsSet);
	let gobsToRemoveSet = setDifference(oldGobsSet,newGobsSet);
	for(let gob of gobsToAddSet){
		//gob.setGameVoxs(gob.think());
		gob.setExists(true); //FIXME linear cost of game.gobs.length
	}
	for(let gob of gobsToRemoveSet){
		//gob.setGameVoxs(null); //modifies game.board and game.rps.team but not game.rps.tridistSmall cuz thats an expensive calculation.
		gob.setExists(false); //FIXME linear cost of game.gobs.length
	}
	this.gobs = newGobs;
};

const DefaultAllowedClassDotFuncs = new Set('Math.abs Math.acos Math.acosh Math.asin Math.asinh Math.atan Math.atan2 Math.atanh Math.cbrt Math.ceil Math.clz32 Math.cos Math.cosh Math.exp Math.expm1 Math.floor Math.fround Math.hypot Math.imul Math.log Math.log1p Math.log2 Math.log10 Math.max Math.min Math.pow Math.round Math.sign Math.sin Math.sinh Math.sqrt Math.tan Math.tanh Math.trunc IY IX IR IG IB IC YXC PC IP YXRGB SetC ret.push sigmoid'.split(' '));
//FIXME only allow ret.push if ret is a [] created in that func. Should probably use a shared VoxStream instance VS instead.

/*
//voxel coordinates range 0x00000 to 0xfffff for each of y and x. Thats 128x128 times bigger than fit in game.board which is 8kX8k,
//more if the tiles partially overlap. This is for sparse updates as that 8kX8k window in game.board moves around.
//Maybe a tile should overlap in 1/8 of its width on each border, like ive been doing with updating tridist using a 768x768 in the middle of a 1024x1024,
//but tile will probably be bigger than that.
//Id rather have a powerset of gobs being included or not.
//Need to define primaryKey of gob as ''+gob.brain (aka js code) AND an instance id so u can have multiple instances of the same compiled js code,
//and primaryKey should be hash of that code with that instance id, so primaryKey is shorter.
var Tile = function(shift, oy, ox){
	this.shift = shift; //this is a (1<<shift) x (1<<shift) 2d area
	this.oy = oy;
	this.ox = ox;
	this.gobs = [];
	this.wall = null; //a BloomTree/BitPic (like in dagball), but only up to the powOf2 size
};*/

/*2024-11-20 if you want a Game object just type V.someNamespace55.getGame(),
and similar for V.someNamespace55['(Y,X,varABC,varD)=>{...js code here...}'].getOb() returns a Gob.
//fork this Game object by moving to another y and x, in the approx million X million space that we can only overlap 8k X 8k of at a time per Game object.
//Copies any overlapping parts, in the game.board array and game.rps.tridistSmall and game.rps.team (or was it named teams? TODO was thinking of renaming it to team or teams) etc,
//which are all 2d arrays of int or byte, so just copy the overlapping parts
//and mark the other parts as unknown (max distance 1023 in tridistSmall each int containing 3 uint10s) for example.
//These 2 Game objects, this and what this.forkYX(...) returns, will have no overlapping parts, all copied, can be used mutably.
//Lambdas should be used as immutable, do not store data in them
//(like my Wikibinator203 does store a little data in fields of JS lambda objects it creates
//as u can see in lambdize func which adds lambdaX.n.lam==lambdaX fields and lambdaX(lambdaX)->someLambda).
//I have not included such lambdas here cuz they're very inefficient, but this "Blob Monster Game" is for mass-producing sharing and using javascript lambdas that
//make voxels as a sparse dimensional space that a million players can play together in 1 namespace at once or many namespaces however they wanna organize the computing.
Game.prototype.forkYX = function(optionalY_uint20, optionalX_uint20){
	throw new Error('TODO');
};*/

var MaxCodeLen = 2**16; //chars of what goes in Var.big aka js code evaled to become a gob.brain.

Game.prototype.canEvalClassDotFunc = function(classDotFunc){
	//Do NOT allow 'Math.random', but since its not in this.allowedClassDotFuncs dont need to check for it here,
	//but as opensource u can do it, and gob jumps around randomly and kind of works but when other gobs
	//touch that gob they are thrown really fast.
	return this.allowedClassDotFuncs.has(classDotFunc);
};

//This firewalls JS code to allow it to eval some of it and not others. Replace this func in game instance
//if you prefer a different infinite set of possible js code to eval in your browser.
//WARNING: This software is designed to share untrusted js code across internet, and this is where
//to put the inner sandbox code. The browser sandbox is the outer sandbox. This is the sandbox inside that
//which should block code like '()=>{ while(true); }' cuz it does an infinite loop and crashes the browser tab,
//or it could send the webpage to a spam site or something.
//Browser sandbox blocks execute permission either way, even if uses WebGL2 GLSL ES 300 GPU shaders
//(TODO those shaders using dagball/lib/Ap.js or just dagball/lib/TinyGLSL.js which Ap.js calls),
//and TODO fix TinyGLSL.js to work on linux, is some buffer type error as seen in this pic:
//https://github.com/benrayfield/DagBall/blob/main/doc/gpu/ubuntuTestFailed2023-11-24/tinyGLSLNotWorkInUbuntu2023-11-24.jpg
//which says "WebGL warning: readPixels: Format and type RED/FLOAT incompatible with this R32F attachment. This framebuffer requires either RGBA/FLOAT or getParameter(IMPLEMENTATION_COLOR_READ_FORMAT/_TYPE) RGBA/FLOAT."
//and says "correct5678=32239684 observed5678=0" which I remember it was returning all 0s in the float array,
//and is caused by this code "gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, canvasWidth, canvasHeight, 0, http://gl.RED, gl.FLOAT, null);".
//So thats how to upgrade Blob Monster Game to GPU to work in windows browsers and how to fix a bug so it works in linux too.
//GPU can give you more speed for neuralnet monster types.
Game.prototype.canEval = function(jsCode){
	if(typeof(jsCode) != 'string') throw new Error('Not a string');
	if(jsCode.length > MaxCodeLen) throw new Error('Too long: '+jsCode.length);
	return true; //FIXME
};

Game.prototype.tryEval = function(jsCode){
	if(this.canEval(jsCode)){
		return eval(jsCode);
	}else throw new Error('NOT_canEval jsCode='+jsCode);
};

Game.prototype.onTextareaInput = function(text){
	let textarea = document.getElementById('mainTextarea');
	let selectedGobs = this.selectedGobs();
	if(selectedGobs.length == 1){
		let sel = selectedGobs[0];
		try{
			/*
			//FIXME either require the ( ) be in the code itself or  find a way to make it work here without that.
			//it doesnt like some kind of functions function(){} or ()=>{} or ()=>(...) or something.
			let evaled = eval('('+text+')');
			//FIXME check for number of names of params changing. might be a completely new func.
			//else its editing the selected gob.brain func.
			sel.brain = evaled;
			*/
			//nevermind, replace gob, dont mod it. sel.setBig(text); //evals. replaces sel.brain and sel.bo and mods Var tree, if it works, else throws.

			let evaled = this.tryEval(text); //FIXME its wasteful to eval it once here then again during Var.eval()
			if(typeof(evaled) != 'function'){
				Err('evaled but not to a function, its a '+typeof(evaled));
			}
			let ns = this.bo.ns();
			let prevVar = sel.bo;
			let newVar = ns[text];
			if(newVar != prevVar){
				console.log('TODO delete? Replacing gob prevVar='+prevVar.path()+' newVar='+newVar.path());
				let newGob = newVar.getOb();
				newGob.copySomePartsFromPrevGob(sel);
				sel.bo.p = sel.bo.v = 0; //delete by setting position to 0, though this might leave it in Var tree cuz was used recently
				let newPath = newGob.bo.path();
				console.log('onTextareaInput deleting '+sel.bo.path()+' cuz replaced with '+newPath+' old isSelected='+sel.m.isSelected+' new isSelected='+newGob.m.isSelected);
				sel.m.isSelected = false;
				sel.bo.del();
				setVarPathTxt(newPath); //cuz otherwise it waits for mouse to select it again to display its updated name
			}
			textarea.style.backgroundColor = 'black'; //ok
		}catch(e){
			textarea.style.backgroundColor = '#220000'; //error
			console.error(e);
		}
	}
};

//var varPathTxtWidthSmallerBy = 0;
var varPathTxtWidthSmallerBy = 60;

Game.prototype.onTextareaResize = function(){
	//console.log('onTextareaResize');
	let textarea = document.getElementById('mainTextarea');
	let varPathTxt = document.getElementById('varPathTxt');
	varPathTxt.style.width = (textarea.clientWidth-varPathTxtWidthSmallerBy)+'px'; //varPathTxt stays same width as textarea. Its where the name of the Var of that Gob goes, theGob.bo
};

var testFlipTerrainColors = ()=>{
	for(let tile of Object.values(game.wal.tiles)){
		tile.syncSparseDense();
		tile.copySparseToDense();
		for(let i=0; i<tile.dense.length; i++) if(tile.dense[i] < 128){ //0..127 are isWall and 6 bits of color.
			tile.dense[i] ^= ColorMask; //flip low 6 bits
		}
		tile.copyDenseToSparse();
	}
	game.wal.paintGame();
};

var testFlatPackTerrain = ()=>{
	for(let tile of Object.values(game.wal.tiles)){
		tile.syncSparseDense();
		tile.sparse = tile.sparse.flatPack();
	}
	game.wal.paintGame();
};

Game.prototype.onMouseWheelChange = function(amount){
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 50));
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 2000));
	//this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 10000));
	this.zoom.p = Math.max(.05, Math.min(this.zoom.p*Math.exp(.001*amount), 640000));
	//this.zoom.p = Math.max(.01, Math.min(this.zoom.p*Math.exp(.001*amount), 2000));
};

/*wrong, its supposed to be 0b1111111111 aka TINF where theres no voxel: const teamsToTridistInt = Int32Array.of(
	0b00111111111111111111111111111111, //TRINF, cuz 
	0b00000000000000000000001111111111, //REDTEAM
	0b00000000000011111111110000000000, //GREENTEAM
	0b00000000000011111111111111111111, //REDTEAM|GREENTEAM
	0b00111111111100000000000000000000, //BLUETEAM
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
	0b00000000000000000000000000000000,
);*/
/*[...teamsToTridistInt].map(x=>[getDistance1(x),getDistance2(x),getDistance3(x)])
(8) [Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3), Array(3)]
0: (3) [1023, 1023, 1023]
1: (3) [1023, 1023, 0]
2: (3) [1023, 0, 1023]
3: (3) [1023, 0, 0]
4: (3) [0, 1023, 1023]
5: (3) [0, 1023, 0]
6: (3) [0, 0, 1023]
7: (3) [0, 0, 0]

game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
42351
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
40826
game.rps.team.reduce((sum,x)=>((x?1:0)+sum));
43329

game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
27755
game.rps.team.reduce((sum,x)=>(((x==BLUETEAM)?1:0)+sum));
23285
game.rps.team.reduce((sum,x)=>(((x==GREENTEAM)?1:0)+sum));
6317
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10531
game.rps.team.reduce((sum,x)=>(((x==REDTEAM)?1:0)+sum));
10654
*/
const teamsToTridistInt = new Int32Array(8);
//2024-11-20 theres about to be a GRAYTEAM which we dont do tridist for. Its for walls and moving shields.
//Its neutral, doesnt interact with Rock Paper Scissors teams but does repel by normal game.board trying
//to have at most 1 voxel per pixel but counts up to (2**26)-1 voxels per pixels. Doesnt change its team.
//teamsToTridistInt[r*REDTEAM + g*GREENTEAM + b*BLUETEAM] could have a problem if we included that here.
//Just leave it as part of game.rps.team byte.
for(let r=0; r<2; r++){ //include REDTEAM or not
	for(let g=0; g<2; g++){ //include GREENTEAM or not
		for(let b=0; b<2; b++){ //include BLUETEAM or not
			//const setDistances = (d1, d2, d3) => ((d1 & mask) | ((d2 & mask) << 10) | ((d3 & mask) << 20));
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = (r?0:1023) | ((g?0:1023)<<10) | ((b?0:1023)<<20);
			//teamsToTridistInt[(r<<2) | (g<<1) | b] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
			teamsToTridistInt[r*REDTEAM + g*GREENTEAM + b*BLUETEAM] = ((r?0:1023)<<teamShift[REDTEAM]) | ((g?0:1023)<<teamShift[GREENTEAM]) | ((b?0:1023)<<teamShift[BLUETEAM]);
		}
	}
}

const redByteAtYX_shift = teamShift[REDTEAM]+2;
const greenByteAtYX_shift = teamShift[GREENTEAM]+2;
const blueByteAtYX_shift = teamShift[BLUETEAM]+2;

Game.prototype.mixZIntoColorByte = function(z,prevColorByte){
	//return (this.zBrightFrac(z)*255+prevColorByte)&0xff;
	return (this.zBrightFrac(z)*prevColorByte)&0xff;
};

/*The whole 8192x8192 canvas displays a color computed in game.redByteAtYX(y,x), game.greenByteAtYX(y,x), and game.blueByteAtYX(y,x).
Thats how I display the voxels, of 64 possible colors, over the distance fields of 16 million possible colors. AIs could get access to pixel colors
*/
Game.prototype.redByteAtYX = function(y,x){
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let boardInt = this.board[i]; //high 26 bits are z sum. low 6 bits are xor of all colors painted here.
	let color6 = this.board[i]&ColorMask;
	if(color6) return RR(color6);
	if(this.displayModeQvoxel.p){ //only if theres nothing else displayed the simpler faster way
	
	
		return 0; //FIXME
		//let zc = this.qget(y,x); //z+color/64
		//let zc = this.qget(y, x, Ql); //z+color/64
		//let zc = this.qget(y, x, ptr=>(Qu(Ql(Ql(Ql(ptr)))))); //z+color/64
		let z = Math.floor(zc);//zc|0;
		let color = (zc*64)&63;
		//FIXME use color. make colorIntAtYX so dont have to duplicate the call 3 times for 3 bytes.
		//return (this.zBrightFrac(z*10)*255)&255;
		//return zc ? 255 : 0; //FIXME
		return (this.zBrightFrac(z*.15)*255)&255;
		
		//return randInt(256); //FIXME
	}else{
		//return ++this.board[(y<<13)|x]); //TODO range check?
		//const i = (y<<13)|x;
		//const i = (y<<SizeBits)|(x&SizeMask); //wrap
		//const i = ((y&SizeMask)<<13)|(x&SizeMask); //wrap
		//const i = ((y&8191)<<13)|(x&8191); //wrap
		//let boardInt = this.board[i]; //high 26 bits are z sum. low 6 bits are xor of all colors painted here.
		//let color6 = this.board[i]&ColorMask;
		//color6 = 0b111111; //FIXME remove this. turns everything white, so only z color will show as brightness of that.
		//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
		let ret = (color6 || !this.doRps.p) ? RR(color6) :
			255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>redByteAtYX_shift)&255)*10,255));
		if(intVoxelsOnly) return ret; //FIXME testing RPS
		//let z = boardInt>>>6;
		let z = this.sumZ(i); //includes this.board[i] and either this.groundZ (bilinear interpolated) or this.groundZCheap (truncate)
		return this.mixZIntoColorByte(z,ret);
			//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>2)&255)*10,255));
			//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
			//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)>>2,255));
			//255-Math.max(0,Math.min(((this.rps.tridist[i]>>2)&255)*5.1,255));
			//Math.max(0,Math.min(((this.rps.tridist[i]>>255)&255)*1.0534,255))|0;
			//Math.max(0,Math.min((this.rps.tridist[i]&1023)*.0534,255))|0;
			//(255-Math.max(0,(((this.rps.tridist[i]>>>2)&255)*3)));
		//|| a display of distance of RED team as in rock paper scissors
		//return RR(this.board[i]) || (255-((this.rps.tridist[i]>>>2)&255)); //|| a display of distance of RED team as in rock paper scissors
		//return (this.rps.tridist[i]>>>2)&255;
		//return (this.rps.tridist[i]&1023)*.2;
		//return 200;
	}
};

Game.prototype.greenByteAtYX = function(y,x){
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let boardInt = this.board[i]; //high 26 bits are z sum. low 6 bits are xor of all colors painted here.
	let color6 = this.board[i]&ColorMask;
	if(color6) return GG(color6);
	if(this.displayModeQvoxel.p){ //only if theres nothing else displayed the simpler faster way
		//if(((y>>5)^(x>>5))&1){ //dont display it, in alternating checkerboard squares
		//	return 40;
		//}
	
		let zc = this.qget(y,x); //z+color/64
		let z = Math.floor(zc);//zc|0;
		let color = (zc*64)&63;
		//FIXME use color. make colorIntAtYX so dont have to duplicate the call 3 times for 3 bytes.
		return (this.zBrightFrac(z*.15)*255)&255;
		//return color*3;
		//return z*200;
		//return zc ? 255 : 0; //FIXME
		
		//return randInt(256); //FIXME
	}else{
		//return GG(this.board[(y<<13)|x]); //TODO range check?
		//const i = (y<<13)|x;
		//const i = (y<<SizeBits)|(x&SizeMask); //wrap
		//const i = ((y&8191)<<13)|(x&8191); //wrap
		//let boardInt = this.board[i]; //high 26 bits are z sum. low 6 bits are xor of all colors painted here.
		//let color6 = this.board[i]&ColorMask;
		//color6 = 0b111111; //FIXME remove this. turns everything white, so only z color will show as brightness of that.
		//return color6 ? GG(color6) : (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
		let ret = (color6 || !this.doRps.p) ? GG(color6) :
			255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>greenByteAtYX_shift)&255)*10,255));
		if(intVoxelsOnly) return ret; //FIXME testing RPS
		//let z = boardInt>>>6;
		let z = this.sumZ(i); //includes this.board[i] and either this.groundZ (bilinear interpolated) or this.groundZCheap (truncate)
		return this.mixZIntoColorByte(z,ret);
			//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)*10,255));
			//255-111.01*Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>12)&255)**.5,255));
			//255-Math.max(0,Math.min(((this.rps.tridist[i]>>12)&255)*5.1,255));
		//return GG(this.board[i]) || (255-((this.rps.tridist[i]>>>12)&255)); //|| a display of distance of GREEN team as in rock paper scissors
	}
};

//Game.prototype.ns = 

Game.prototype.blueByteAtYX = function(y,x){
	//const i = (y<<13)|x;
	//const i = (y<<SizeBits)|(x&SizeMask); //wrap
	const i = ((y&8191)<<13)|(x&8191); //wrap
	let boardInt = this.board[i]; //high 26 bits are z sum. low 6 bits are xor of all colors painted here.
	let color6 = boardInt&ColorMask;
	//color6 = 0b111111; //FIXME remove this. turns everything white, so only z color will show as brightness of that.
	//return color6 ? BB(color6) : (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	let ret = (color6 || !this.doRps.p) ? BB(color6) :
		255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>blueByteAtYX_shift)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridistSmall[toSmall(i)]>>22)&255)*10,255));
		//255-Math.max(0,Math.min(((this.rps.tridist[i]>>22)&255)*5.1,255));
	if(intVoxelsOnly) return ret; //FIXME testing RPS
	//let z = boardInt>>>6;
	let z = this.sumZ(i); //includes this.board[i] and either this.groundZ (bilinear interpolated) or this.groundZCheap (truncate)
	return this.mixZIntoColorByte(z,ret);
	//return ((this.zBrightFrac(z)*255+ret)/2)&0xff; //average
	//return (this.zBrightFrac(z)*255+ret)&0xff; //average
	
	//return BB(this.board[i]) || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
	//const voxel = this.board[i]; //TODO range check?
	//const blueByteOfVoxel = BB(voxel);
	
	//This is how gptVoxelDijkstra_011.html colors it: const blueValue = (distSq === 0xFFFFFFFF) ? 0 : Math.max(0, 255-Math.min(distSq,255));
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i]>>2,255)); //if theres a nonblack voxel, display it, else display distSq	
	//return blueByteOfVoxel || Math.max(0, 255-Math.min(this.rps.boardR[i],255)); //if theres a nonblack voxel, display it, else display distSq	
	
	//if theres a nonblack voxel, display it, else display a uint10 from game.rps.tridist which is written by computeUint10Distances.
	//RED=0 GREEN=1 BLUE=2 ALPHA=3, used in ByteRect. Use that same order but as uint10s. Just get the high 8 bits of that uint10, dropping its low 2 bits.
	//It would be a little better to add 1 or 2 to it in case distance is only 3 (cuz of orthogonal=3 diagonal=4) so 0 and 3 dont look the same.
	//|| a display of distance of BLUE team as in rock paper scissors
	//return 0; //return blueByteOfVoxel || (255-(this.rps.tridist[i]>>>22)); //boardB uint10 is >>>20. boardG uint10 is >>>10 &0b1111111111. boardR is &0b1111111111.
};

//func is the kind that goes in a gob.brain and takes params of ...gob.vars which is a list of Var instances.
Game.prototype.addFunc = function(funcOrCodeOfFunc){
	if(typeof(funcOrCodeOfFunc)=='string'){
		console.log('game.addFunc evaling: '+funcOrCodeOfFunc);
		funcOrCodeOfFunc = eval(funcOrCodeOfFunc);
	}
	//this.gobs.push(new Gob(this,funcOrCodeOfFunc));
	return new Gob(this,funcOrCodeOfFunc); //pushes itself into this.gobs
	//let gob = new Gob(this,funcOrCodeOfFunc);
	//gob.setExists(true);
	//return gob;
};

Game.prototype.addAndSelectFunc = function(funcOrCodeOfFunc){
	return this.setSelectedGob(this.addFunc(funcOrCodeOfFunc));
};

/*didnt work cuz theyre still in the V/Vars tree: Game.prototype.addAsOnlyFunc = function(funcOrCodeOfFunc){
	while(this.gobs.length){
		this.gobs[this.gobs.length-1].setExists(false);
	}
	return this.setSelectedGob(this.addFunc(funcOrCodeOfFunc));
};*/

//voxel stream, where they are added 1 at a time but not added if that YX (primaryKey) is already there.
//Uses 2**26 bits in 2**21 ints, 1 bit per pixel, to mark if thats already been written.
//So if you want to paint over a YX, make sure you do that part first and the "covered up" layers later which get ignored.
//
//you do a bunch of this.addVox(voxel) and it returns true if added, false if that repeats a yx (primaryKey) aka tries to paint the same pixel more than once.
//You then call this.end() to get a Uint32Array of the voxels added in the order added, keeping only the first per yx.
//
//You normally reuse 1 VoxStream for all Gobs, cuz it uses a few mB of RAM, and most gobs will be far smaller than that. Its sparse optimized.
//
//This works in a 8192x8192 2d area sparsely. So this might be a good place to put basic paint functions like circles, lines, etc.
//
var VoxStream = function(){
	this.set = new Uint32Array(Area>>>5); //1 bit per pixel in Area.
	this.vox = new Uint32Array(MaxVoxPerGob);
	this.size = 0; //what indexs in this.vox are used?
};

VoxStream.prototype.addVox = function(voxel){
	let yx = IP(voxel);
	//As of 2024-11-12 i am not using VoxStream but might use it later. Its use is to dedup voxels created in different ways in the same Gob.
	let high = yx>>>5; //bits packed into an int. int has (1<<5)==32 bits. This saves alot of memory to only store 1 bit.
	let low = yx&31;
	let lowMask = 1<<low;
	if(this.set[high] & lowMask){ //FIXME is that reversed? should it be 31 minus that?
		return false; //not add voxel cuz that primaryKey/yx was already added (may be a different color)
	}else{
		this.set[high] |= lowMask; //add the yx of the voxel to the set, but not its color.
		if(this.size == this.vox.length) throw new Error('Full. MaxVoxPerGob.');
		this.vox[this.size++] = voxel;
		return true; //added voxel
	}
};

//ends the stream, undoes whatevers in it, and returns the voxels that were in it, copied to a new Uint32Array(this.size)
VoxStream.prototype.end = function(){
	let ret = new Uint32Array(this.size);
	for(let i=0; i<ret.length; i++){
		let voxel = this.vox[i];
		ret[i] = voxel;
		//TODO? this.vox[i] = 0;
		//let yx = IP(voxel);
		//let high = yx>>>5;
		this.vox[voxel>>>11] = 0; //this.vox[high] = 0; //erase all bits in this.vox that could be nonzero
	}
	this.size = 0;
	return ret;
};

//This adds or removes a voxel in the 1x1 to 8192x8192 quadtree
//and returns the change in total potential energy of the game
//(TODO without roundoff in int54 which fits in float64).
//
//Each voxel is shaped as z = max(0, 1 - abs(x)) * max(0, 1 - abs(y)),
//for y and x in any range but is 0 outside range -1 to 1,
//which is a "tent function" or pyramid shaped function that is the basics of bilinear interpolation.
//You can make a square with 4 or 9 or 16 or 25 of them or curves.
//These are affine transformed to overlap eachother in combos to form the game world as a heightmap,
//and a simple 6 bit color displayed with them so you can see which blobs made of these voxels
//are from the same object approximately.
//Its not all possible affine transforms, just the kind that puts 4 child squares per square as a quadtree
//and each square is 1/4 of the function z(y,x), called a "tarp" (search code for that),
//so you use ptr as the bottom right (x from 0 to 1) tarp (which is a square) aka that square itself,
//and the other 3 tarps of ptr are adjacent/sibling squares: Ql(ptr) is its left sibling,
//Qu(ptr) is its up sibling, and either Qu(Ql(ptr)) or Ql(Qu(ptr)) (they return the same int)
//is its up left sibling. So up from these 4 squares/tarps it computes integrals of
//"z = max(0, 1 - abs(x)) * max(0, 1 - abs(y))" as this square overlaps log number of parent squares,
//so it does that 4*log4(game size 8192**2 or just inside QMinPtr) times.
//
//Whatever the heightmap made of many "z = max(0, 1 - abs(x)) * max(0, 1 - abs(y))" sums to at each (y,x),
//we use potential energy = sum forall y forall x (z(y,x)**2)/2 which is a triangle integral,
//the amount of potential energy of solid mass from height 0 to z in units of 1/g kilograms per 1.0**3 volume.
//Potential energy of lifting 1 unit of volume by 1 distance, is 1 joule. See my writing about jouleCube
//which is a 1 meter cube of mass 1/g kilograms whose center of gravity is at the center of its top face,
//and the total potential energy of a stack of 2 jouleCubes beside a stack of 5 jouleCubes
//is 1+2+1+2+3+4+5=18 joules. They're made to always give an integer number of joules.
//This function returns the change in total potential energy of the game in joules.
//This is also true of the smooth bilinear kind, which I tested in funcs bilinearMult and bilinearPotentialEnergy.
//bilinearMult "//Very important: if all 8 params are nonnegative multiples of 6, then potential energy is an integer."
//Always use multiples of 6 for val to add or subtract at each voxel ptr,
//and scale it by the power of 2 of that quadtree level, like 6 for a 1x1 (times 4 tarps that size) voxel,
//12 for a 2x2, 24 for a 4x4, 48 for a 8x8, and so on, though as of 2025-1-31 QAdd hasnt been tested with that
//to do it all together, but it works in bilinearMult and bilinearPotentialEnergy tests as integers or scalars.
//
//The return value is most of the compute cost so make sure to use it in
//gradient calculations in blob monsters game physics. If you just want to use the
//quadtree heightmap without physics use QAddIgnorePoten which will be ALOT faster
//but if you do then you cant use QAdd (the slower way that returns change in potential energy)
//on that same array (qint and qflo) cuz qflo wont have been updated which is derived only from qint.
//Despite that qflo is derived only from qint, to derive it again all at once would be very slow.
//The advantage of QAdd is it costs only log compute time to do a full update across the whole game
//and should, in theory if you use multiples of 6 as val (or 12 if twice as big a level, or 24 if 4x as big...)
//then change in potential energy will always be an integer and will fit in an int54 by using
//only the first n layers like maybe 1x1 2x2 4x4 8x8 16x16 32x32 64x64 but not anything bigger,
//or im not sure where it should be cut off but thats in QMinPtr.
//You could do it all the way to 8192x8192 as its still just a log cost,
//but you'd need more digits of precision than is in float64 and would need to use bigints like 1n 2n 3n...
//or to use maybe 4 ints as an int128 and do it with Math.imul,
//those ints would go in game.qint of 4096x4096 (cuz max array size is 1gB).
//
//Use negative val to remove.
//Ptr 1 is the root quadtree node. Use Qp to get parent of ptr. Qu Qd Ql Qr get siblings and wrap.
//Qul Qur Qdl Qdr get childs. This goes 13 levels so the last level is 1<<26 to (1<<27)-1.
//
//2025-1-31+ am about to replace game.addVox game.remVox etc with a quadtree kind using game.qint, game.qflo, and QAdd,
//but will keep addVox etc around for a while until I see if the quadtree is so slow that I have some uses for it
//and some uses for the old kind. Quadtree has calculus on bilinear interpolation of log levels.
//
//It might be possible to optimize this in GPU shaders (WebGL2 GLSL ES 300 for example) but youd
//have to be very careful in how its batched and the cache updating cuz it would be memory bottlenecked
//in GPU but be compute bottlenecked in CPU as its on CPU for now (2025-1-31).
//qint is straightforward to update. Its low 6 bits is xor of all voxels overlapping here,
//and its high 26 bits are added to z aka thickness there, as mountains and valleys in the heightmap
//can be summed of many voxels each of different position and powOf2 size and thickness multiplier.
//So that explains that qint is straightforward to update. The hard part is updating qflo,
//where the QEdgeWeight update between ptrs. So I'm not sure if this will ever be efficient on GPU
//as its based on complex pointer arithmetic and reading and writing memory there.
//
Game.prototype.qvox_ptr_val_color = function(ptr,val,color){
	return QAdd(this.qint, this.qflo, ptr, val, color);
};

//Adds or removes a quadtree voxel that fits in a float64 number.
//Use float64 voxel as uint53, its low 27 bits are ptr, next higher 6 bits are color,
//next higher 20 bits are val, as in Game.prototype.qvox_ptr_val_color = function(ptr,val,color)
Game.prototype.qvox = function(qvoxel){
	this.stats.callsOfQvox++;
	return Qad(this.qint, this.qflo, qvoxel);
};

//Get heightmap height as the integer part and color as the fraction part, at a chosen (y,x).
//Using the qvoxel system, get z+color/64 at a y x, where y and x range 0 to 8191,
//and color ranges 0 to 63. Does log number of bilinear interpolations.
Game.prototype.qget = function(y,x,optionalTestPtrFunc){
	return Qget(this.qint, y, x, optionalTestPtrFunc);
};

//xors the color but does not count it toward potentialEnergy. This is how you paint the background with no effect on physics.
//Doing this again undoes it cuz its xor graphics. The same voxel can be added by addVox too, which would make it black but still count in energy.
Game.prototype.ghostVox = function(voxel){
	this.board[voxel>>>6] ^= (voxel&63); //xor the uint6 color
};

//add voxel. adjusts this.poten and this.board.
Game.prototype.addVox = function(voxel){
	let yx = IP(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	//this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] += (intVoxelsOnly ? DefaultZ : IZ(voxel))<<6;
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
};

//voxel is an int. team is a byte.
Game.prototype.addVoxWithTeam = function(voxel, team){
	let yx = IP(voxel);
	//console.log('addVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten++;
	}
	//this.board[yx] += Colors; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	let z = intVoxelsOnly ? DefaultZ : IZ(voxel);
	//if(z===0) z = DefaultZ; //FIXME remove this?
	this.board[yx] += z<<6; //add to the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	//this.rps.team[yx] = team; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible. BLACKTEAM is 0. Anything else is some powerset of teams, by default only REDTEAM, GREENTEAM, and BLUETEAM which are masks.
};

//remove voxel. adjusts this.poten and this.board.
Game.prototype.remVox = function(voxel){
	let yx = IP(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	//this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	this.board[yx] -= (intVoxelsOnly ? DefaultZ : IZ(voxel))<<6;
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--;
		//FIXME use "let z = intVoxelsOnly ? DefaultZ : IZ(voxel);" etc
	}
};

//TODO voxels can be Float64Array or [] of float64, or ints. if ints then all z is 0.
Game.prototype.remVoxWithTeam = function(voxel, team){
	let yx = IP(voxel);
	//console.log('remVox yx='+yx+' color='+C(voxel)+' count was: '+IP(this.board[yx]));
	let prevCount = this.board[yx]>>>6;
	if(prevCount == 0){
		throw new Error('Remove voxel at yx='+yx+' but count is 0 there.');
	}

	//this.board[yx] -= Colors; //remove the uint26 in the high 26 bits, which counts up to 64million objects intersecting there at once.
	//this.board[yx] -= IZ(voxel)<<6;
	this.board[yx] -= (intVoxelsOnly ? DefaultZ : IZ(voxel))<<6;
	this.board[yx] ^= (voxel&ColorMask); //xor graphics
	let countAfter = this.board[yx]>>>6;
	if(countAfter){ //potentialEnergy is not changed by just 1 Gob touching a pixel. It starts adding at the second Gob there.
		this.poten--; //FIXME need to use bigint for sum of squared z sums (board[yx]>>>6) and adjust by squares not plus/minus 1.
		//FIXME use "let z = intVoxelsOnly ? DefaultZ : IZ(voxel);" etc
	}
	//this.rps.team[yx] = BLACKTEAM; //FIXME this is not reversible. but if we use bit mask where each team number is a power of 2, could xor that and it be reversible
	this.rps.team[yx] ^= team; //reversible but probably buggy unless each team number is a power of 2, and should BLACKTEAM (empty, no gob there) have such a pow of 2?
};

//TODO voxels can be Float64Array or [] of float64, or ints. if ints then all z is 0.
//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.addVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.addVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			this.addVox(voxels[i]);
		}
	}
	return this.poten;
};

//return change that would happen in this.poten if called this.addVoxs(voxels), but without actually doing it
//cuz its faster, BUT warning if the voxels write the same empty pixel 2 or more times it
//wont count that cuz is not looking for collisions between the voxels and themself.
//This is number of colliding voxels. TODO Used during gradient calculations.
Game.prototype.potenDiffIfNoCollisionsBetweenParamVoxels = function(voxels){
	let collisions = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		if(this.board[voxel>>>6]&0xffffffc0){ //high 26 bits count how many voxels are at that pixel
			collisions++;
		}
	}
	return collisions;
};

Game.prototype.potenDiffFromRpsDistanceCache_team_voxels = function(team, voxels){
	const shift = teamShift[team]; //0, 10, or 20, to get a uint10 out of tridistSmall.
	const tridistSmall = this.rps.tridistSmall;
	//uint10 dist -> change of poten. distToPoten can differ as a param of Game, in diff peer to peer nets etc.
	//distToPoten should fit in CPU L1 cache so not slow things down much, though maybe i should make it 
	const distToPoten = this.rps.distToPoten;
	let poten = 0;
	for(let i=0; i<voxels.length; i++){
		let voxel = voxels[i];
		let smallI = toSmall(voxel>>>6);
		//uint10. it maxes out around 1019 or 1023, but below that its computed by dijkstra with 8 adjacent pixels,
		//costing 3 for orthogonal and 4 for diagonal.
		let tridistInt = tridistSmall[smallI];
		let distUint10 = (tridistInt>>>shift)&mask10;
		poten += distToPoten[distUint10];
	}
	return poten;
};


//param can be a [] or Uint32Array of 32 bit voxels. optionalTeam is REDTEAM, GREENTEAM, or BLUETEAM, if you give that param.
Game.prototype.remVoxs = function(voxels, optionalTeam){
	if(optionalTeam !== undefined){
		for(let i=0; i<voxels.length; i++){
			this.remVoxWithTeam(voxels[i], optionalTeam);
		}
	}else{
		for(let i=0; i<voxels.length; i++){
			//this.addVox(voxels[i]);
			this.remVox(voxels[i]);
		}
	}
	return this.poten;
};

var generatedNameCounter = 0;

//var DefaultEpsilon = .01;
var DefaultEpsilon = 2**-7;

//This should be a little more than the common epsilon of 1 for pixel coordinates (1 pixel over)
//so it can jump a little past that. If its 1, it moves a little too slow. If 2 its noticably jumpy.
//var DefaultGp = 1.5; //normal
var DefaultGp = .2;
//var DefaultGp = 0; //experimental, trying setting this to 0 2024-11-25 to experiment with game.collideSqMul.
//var DefaultGp = 5.5;
//var DefaultGp = 15.5;

const CharToNum = {};
const NumToChar = [];
for(let num=0; num<65; num++){
	let ch = dvBase64Digits[num];
	CharToNum[ch] = num;
	NumToChar[num] = ch;
}

const TwoPow53 = 2**53;

const NineCharsToInt54 = (str,optionalOffset)=>{
	let offset = optionalOffset|0;
	let ret = 0;
	let neg = false;
	for(let i=0; i<9; i++){
		let num0To63 = CharToNum[str[offset+i]];
		//if(i===8 && 32 <= num0To63){
		if (i === 0 && num0To63 >= 32) { //Check if the most significant digit has a sign bit
			num0To63 -= 32;
			neg = true;
		}
		ret = ret*64+num0To63;
	}
	if(neg){
		ret -= TwoPow53; //like in twos complement integers, an int54
	}
	return ret;
};

/*I convert between 9 chars and int54.
NEW as of 2025-1-31+: this kind of voxel was never built on screen
but is a working encoding of that subset of float64 numbers,
and could be useful for storing Qvox voxels which are uint53's.
OLD: Each will be a 4x4 voxel of 4x4 to 256kX256k magnify.
*/
const Int54ToNineChars = int54=>{
	let s = '';
	if(int54 < -TwoPow53 || TwoPow53 <= int54 || Math.floor(int54)!==int54){
		//TODO also check for NaN?
		Err('Invalid int54: '+int54);
	}
	let neg = int54<0;
	if(neg){
		int54 += TwoPow53; //is now in range 0 to (2**53)-1
	}
	for(let i=0; i<9; i++){
		let digit0To63 = int54%64;
		int54 = (int54-digit0To63)/64;
		if(i===8 && neg){
			digit0To63 += 32; //sign bit
		}
		s = NumToChar[digit0To63]+s;
	}
	return s;
};
TestEvalEqq('Int54ToNineChars(4328196882455350)', 'EN6YSg_gq');
TestEvalEqq('NineCharsToInt54("EN6YSg_gq")', 4328196882455350);
TestEvalEqq('Int54ToNineChars(-7829852537175394)', 'ZAgdZsB9T');
TestEvalEqq('NineCharsToInt54("ZAgdZsB9T")', -7829852537175394);

for(let i=0; i<10000; i++){
	let int54 = Math.floor((Math.random()*2-1)*(2**53));
	let nineChars = Int54ToNineChars(int54);
	let rebuiltInt54 = NineCharsToInt54(nineChars);
	if(i<20){
		console.log('int54='+int54+' nineChars='+nineChars+' rebuiltInt54='+rebuiltInt54);
	}
	if(int54 !== rebuiltInt54){
		Err('Test failed. int54='+int54+' nineChars='+nineChars+' rebuiltInt54='+rebuiltInt54);
	}
}
console.log('Int54ToNineChars and NineCharsToInt54 basic tests passed');

/*
//returns first float64
const Wall = NineCharsToInt54;

//base64.length is a multiple of 9 chars since each uint53 voxel
//(37 bits of binheap for quadtree, and low 16 bits of payload of 4x4 wallVsOpenArea) fits in that.
//Use like this: (Y/*72000*,X/*78005*)=>Walls('thebase64......................3453453454334534534645645')
//normally very long. If such a Gob lambda returns a Float64Array,
//its used as wall voxels. If Int32Array its the normal kind of voxels.
//TODO code will scam for that and just grab the base64 out of it without evaling, for efficiency.
const Walls = base64=>{
	if(base64.length%9){
		Err('Walls base64 must be a multiple of 9 chars but is '+base64.length);
	}
	let ret = new Float64Array(base64.length/9);
	for(let i=0; i<ret.length; i++){
		ret[i] = Wall(base64,(i<<3)+i); //aka i*9
	}
	return ret;
};

//inverse of Walls. Param is a Float64Array of int53s. Returns a base64 string 9 times as many chars.
const Wally = int54s=>{
    let parts = [];
    for(let int54 of int54s){
        parts.push(Int54ToNineChars(int54));
    }
    return parts.join('');
};
if(Wally(Float64Array.of(3761487178300722,0,1,2,3,-1)) != 'CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz'){
	Err('Wally(nums) test failed');
}else console.log('Wally(nums) test pass');
if(Wally(Walls('CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz')) != 'CMFpv4jom$$$$$$$$$$$$$$$$$0$$$$$$$$1$$$$$$$$2zzzzzzzzz'){
	Err('Wally(Walls(str)) test failed');
}else console.log('Wally(Walls(str)) test pass');
console.log('Int54ToNineChars and NineCharsToInt54 all tests passed');
*/

//this is a named var in gob.brain(...vars). It may modify .kv .dp .dv .mn .mx and .poten
//but NOT .p and NOT .v cuz that happens after a block of calculations in var.nextState(dt)
//so order of calling gob.brain(...vars) of many gobs and Vars, has no effect except float64 roundoff.
//Also dont modify prevP, epsilon, accelMul, or gp. Those are set externally.
//TODO over time, remove this.gob/optionalGob and use ONLY Var, and same for Game and other classes.
//They were made first, then redesigned as Var is their data format but its also a fast param like centerY.p.
//So far the tree is entirely organized by root.namespace.object.field, which is a Var tree 3 deep, as you see
//in the pic of json, but it can be any tree shape. Each var has a position, velocity, and 0 or more named childs.
//https://x.com/benrayfield/status/1877462454222958657 2025-1-9.
//
//To add new code, you move in a many dimensional space. Each possible code string is hashed to name
//it as a dimension. Position in that dimension means does the code exist or not. Child dimensions are its
//parameters, part of the high dimensional game state vector. It returns list or Int32Array of int voxels.
//You just write a javascript function of any parameters you want (Var instances which have
//position and velocity) and generate whatever pic you want based on that. The params will automatically
//change so the pics come to life.
//
const Var = function(optionalParentVar, optionalName, optionalBig, optionalGob){

	this.brain = null; //where compiled (this.big || this.name) goes, normally a js func of Var's to list/array of int voxels.
	this.vars = null;
	
	//If this.name is a hash id (or might be prefixed with something? todo), then its the hash of this.big which is probably a string of json (see Dagverse json norming, in dagball, TODO).
	//This must be verifiable. Dont just make up a name and make up a big that cant prove that its name is the hash of that.
	this.big = optionalBig || null;
	this.t = 0; //TODO actual current time //TODO? this.t = utc time as float64 so has at least microsecond precision for 100+ more years.
	
	//TODO? this.ch = [] child vars list (gob.vars if this is gob.influence), if this is a .influence var
	//that is 1 for this thing exists and 0 for does not exist.
	//so there is 1 correct answer, or it should converge, to what .p and .v should a var be at time t
	//TODO? this.ns = string namespace, like game.ns.
	//TODO? this.pk = primaryKey of this Var. or should that be per scalar instead of per Var?
	//should pk depend on namespace? be concat to that? or what? pk certainly should not depend on t/time.
	this.name = optionalName || 'v'+(++generatedNameCounter);

	/*Should Var also have a namespace (game.ns) so can make up new vectors without affecting the current game? ... TODO something like this?... /namespaceABC/game/distToPoten0 /namespaceABC/game/distToPoten1023 /namespaceABC/monster567sHashId/centerY /namespaceABC/monster567sHashId/centerX /namespaceABC/monster567sHashId/heightToWidthRatio, and each of those refers to a Var. That could be its primaryKey. /namespaceABC/monster567sHashId would also be a Var and is the .influence of that gob, and thatGob.vars would be its childs including /namespaceABC/monster567sHashId/heightToWidthRatio which is a Var.
	*/
	this.up = optionalParentVar || null;
	if(!this.up && this.name != 'V'){ //FIXME remove this. The V global var is root of all Vars, but someone might rename it something else, who knows. This is a test to find those not in the tree at all 2024-11-21.
		throw new Error('Var not in the tree: '+this.path());
	}
	//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
	//Gobs normally go at height 2. Gob fields height 3.
	this.h = this.up ? this.up.h+1 : 0;
	
	if(this.name=='Y' && this.h==2){
		throw new Error('Var named '+this.name+' as child in namespace. should be 1 deeper.');
	}
	
	//pu is opposite of up aka down.
	//TODO make a {} whose Object.getPrototypeOf is custom built so any field that doesnt exist automatically creates
	//a Var instance as that child with that name and this Var as its parent and its .p of 0 and .v of 0 and other defaults.
	this.pu = {}; //mape of childVar.name to childVar.//this.down = {}; //mape of childVar.name to childVar.
	
	//2025-2-6+ will probably keep Var.ob as it can be Gob or Game instance
	//(like V.testnet.game.getOb() is a Game and sets V.testnet.game.ob and returns from that on next call of getOb()),
	//maybe other types later too. If you just type V.someOtherNamespace567.game.getOb() that should also make a Game instance.
	//TODO this field Var.gob will be removed???, Var class replaces Gob class. parent is this.up. childs are in this.pu.
	//can put same fields in Var as long as they're deriveable by Var.p Var.v Var.name Var.big etc.
	//The root (V) Var, and a namespace Var (like V/blobMonstersGameDefaultNamespace), dont have a Gob.
	//Its 1 layer deeper (theGobVar itself instead of gob.instance), and inside that is gob.vars.
	this.ob = null; //Gob or Game instance, whose parent Var is the same such as V.testnet: this.gob = optionalGob || null;
	
	this.p = 0; //position
	this.v = 0; //velocity
	this.kv = 0; //velocity continuous decay per second, using this.v *= Math.exp(-dt*this.kv)
	this.dp = 0; //diffeq, extra change of p per second See pinballBumper in dagball.
	this.dv = 0; //diffeq, extra change of v per second. See pinballBumper in dagball.
	this.gr = 0; //same as (negative) .dv but duplicates it cuz this stores gradient separately, and .dv can be set by gob.brain(...vars).
	this.mn = -Infinity; //for truncating this.p to Math.max(this.mn, Math.min(this.p, this.mx)). mn is min. mx is max.
	this.mx = Infinity; //for truncating this.p
	//you only need to add to poten in 1 Var but could do it in all of them. will just get summed.
	//This is extra poten, not including game.poten. Normally you just add to the first var's poten, if you do it at all.
	//You can put things here like spring forces or up to NP-complete and fourier math etc, anything by least-squares etc.
	this.poten = 0;
	this.prevP = 0; //stores the prev value of this.p while an epsilon is added to this.p during a gradient calculation, then restore it
	this.epsilon = DefaultEpsilon; //FIXME, replacement for indexToEpsilon
	this.accelMul = 1; //FIXME, replacement for indexToAccelMul
	//use this.brain instead: this.evaled = null; //eval of this.big || this.name, a js lambda whose params are all Var objects, those in this.influence.vars or gob.vars
	
	//gp works. it makes the gobs voxels overlap eachother less and bounce better. keep it. now is 2025-1-16.
	//gp: Like -dt*gr (gradient) usually goes into velocity, this part goes into position. p += -dt*gp.
	//This is an experimental field of Var added 2024-11-13 to try to solve that gobs overlap too much, take too long to accel away from eachother,
	//so this should slightly make them instantly jump away from eachother too.
	//I just doubled constraint solving efficiency of Blob Monster Game in 2 lines of code, in Var class:
	//"this.gp = 1.5; //TODO this.gp = 0;" and "let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);".
	//Now they overlap less. https://pic.x.com/7OjEWfA9hC (2024_pic.x.comSLASH7OjEWfA9hC.png)
	//This might be useful as a neuralnet param, built on the loss function it solves toward lower. Ive already live trained a 22 node sigmoid RNN
	//whose output is to recurse 15 cycles then take one node's output as potentialEnergy. Bent it like neural playdough. Havent tried this on it 2024-11-13.
	//--https://x.com/benrayfield/status/1856780041985687963
	//this.gp = 2.3; //TODO this.gp = 0;
	this.gp = DefaultGp;
	if(this.up && this.up.pu[this.name]){
		throw new Error('Duplicate Var, same name, same parent Var');
	}
	if(this.up) this.up.pu[this.name] = this;
	
	/*doesnt work, need Proxy: this.get = function(fieldName){
		console.log('fieldName='+fieldName);
		return this[fieldName]!==undefined ? this[fieldName] : this.Pu(fieldName); //creates fieldName
	};*/
	
	//has no effect if ps==0. position taRget, like in dagball.Ed having a target ave and strength as a parabola
	this.pr = 0;
	//strength of p toward pr, as pr and ps define a parabola of poten
	this.ps = 0;
	this.cv = 0; //base kv. its cv+kv, not just kv, but kv is set by code dynamicly, and cv is set in the Var.
	
};

//delete me from the local V/Var tree
Var.prototype.del = function(){
	if(!this.up){
		Err('Already is root V/Var, cant del: '+this.path());
	}
	console.log('Deleting Var path='+this.path());
	delete this.up.pu[this.name];
	//FIXME this.up still exists, so if this.abc.def.ghi still exists then ghi.up.up... will still find this and parents.
};

//copy copyMe.p to this.p, copyMe.v to this.v, etc, but nothing in this.pu (childs) cuz thats not local.
//Its only the fields that count as longterm game state, not temp vars used DURING a physics cycle like this.gr.
//Does not copy .epsilon or .accelMul cuz those are set once in code in the varName/*p v e a*/ syntax,
//which I might change to include pr ps cv and maybe more, but i might leave that to the fieldEditor UI etc.
Var.prototype.copyLocalFrom = function(copyMe){
	this.p = copyMe.p;
	this.v = copyMe.v;
	this.pr = copyMe.pr;
	this.ps = copyMe.ps;
	this.cv = copyMe.cv;
};

Var.prototype.Mn = function(val){
	this.mn = Math.max(this.min,val);
};

Var.prototype.Mx = function(val){
	this.mx = Math.min(val, this.mx);
};

//does both Mn and Mx. Same as setting this.p (after this.nextState(dt)) but if others have set this.mn or this.mx
//and the value this sets it to is not in that allowed range, it does not get set at all. Thats to keep it independent
//of the order Var's are updated, which is less important in Blob Monsters Game than it was in dagball cuz Var is so
//far 2024-11-23 only used in 1 Gob/monster at a time, but in dagball they have EdJoint's. Might add EdJoints here later.
//Var.prototype.MnMx = function(val){
Var.prototype.set = function(val){
	this.mn = Math.max(this.mn,val);
	this.mx = Math.min(val, this.mx);
};

//get namespace
Var.prototype.ns = function(){
	if(this.h <= 1){
		if(this.h == 0) throw Error('This is root Var, which namespaces are childs of.');
		return this;
	}
	return this.up.ns();
};

//gets the Game (like V.testnet.game) of the namespace, even if this is like V.testnet.someGob555
Var.prototype.getGameVar = function(){
	return this.ns().game; //TODO multiple views, each a Game instance.
};

Var.prototype.getGame = function(){
	return this.getGameVar().getOb(); //Game instance
};

//used on Var.name or Var.big of a tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
//or the longer form that goes in .big or the shorter form thats a literal instead of a hash after the first $.
var isTileString = s=>/^tile\d{1,15}\$/.test(s);

var tileStringToQuadTile = s=>{ //returns a QuadTile containing all the info in the string. TODO merge some of the code from Tile.toVar() into this.
	/*let i = s.indexOf('$');
	let base64 = s.substring(i+1);
	let tileNum = parseFloat(s.substring('tile'.length, i)); //0 to (2**53)-1, an integer.
	let height = SquareH(tileNum);
	let quadBytes = base64ToBytes(base64);
	return new Quad(height, quadBytes);
	*/
	let square = tileStringToSquare(s);
	return new QuadTile(square, new Quad(SquareH(square), tileStringToBytes(s)));
};

//0 to (2**53)-1, an integer. Use with SquareY SquareX SquareH and Square(h,y,x)
var tileStringToSquare = s=>parseFloat(s.substring('tile'.length, s.indexOf('$')));

var tileStringToH = s=>SquareH(tileStringToSquare(s));

//top Y. 1<<height is y height and x width.
var tileStringToY = s=>SquareY(tileStringToSquare(s));

//left X. 1<<height is y height and x width.
var tileStringToX = s=>SquareX(tileStringToSquare(s));

//is either the sha256 of the .big form or is the bytes for a Quad, so check if its the Var.name vs Var.big.
var tileStringToBytes = s=>base64ToBytes(s.substring(s.indexOf('$')+1));


//lazy create ob (Gob or Game, depending on var path ends with .game or not, todo multiple views/games).
Var.prototype.getOb = function(){
	if(this.ob){
		return this.ob;
	}else{
		if(this.h == 2){
			let text = this.text();
			if(text.startsWith('(') || text.startsWith('gob$')){
				let game = this.getGame(); //likely a sibling, and game.influence===this.getGameVar()
				//text is a js lambda (brain) whose params if evaled should be Var objects, returns list of int voxels
				//fails cuz text is not evaled, is still a string: return this.ob = new Gob(game, text);
				let jsLambdaAsGobBrain = game.tryEval(text);
				return this.ob = new Gob(game, jsLambdaAsGobBrain);
			}else if(text == 'game'){
				//like V.testnet.game is the default path of the game,
				//but todo multiple games/views at once of each namespace.
				return this.ob = new Game(this);
			}else if(isTileString(this.name)){
				return this.ob = tileStringToQuadTile(this.big || this.name);
			}else{
				throw new Error('Uknown object type: '+text);
			}
		}else{
			throw new Error('this.h/height is '+this.h+' but Gob and Game go at height 2 (right after namespace at height 1)');
		}
	}
};

//copies from map to Var recursively. Overwrites where existed.
//You can fork world state by loading the part just past the namespace into another namespace you make up,
//which you can do many times per second such as for harmony-search of game states to look for lower poten/potentialEnergy.
//a json map of the kind V.toMap() creates, or subset of it, like you might do V.testnet.load({..parts inside V.testnet..})
//or you might V.load({testnet:{...},otherNamespace5:{...}}). This only copies it into the Var system,
//doesnt eval it (TODO should it? Maybe it will later and this comment not be updated FIXME?)
Var.prototype.loadMap = function(map){
	this.p = map.p || 0; //position
	this.v = map.v || 0; //velocity
	if(map.pu){ //childs of any names
		for(let id in map.pu){
			let childMap = map.pu[id];
			//let childVar = this[id]; //reuses if exist, else creates using varProxyHandler as Var is a js Proxy object.
			let childVar = this.pu[id];
			if(!childVar){
				let big = childMap.big || id;
				childVar = this[big];
				if(childVar.name != id){
					Err('Wrong hash. big did not generate expected id of '+id+', from big='+big);
					//you could just do this[id] but that wouldnt create this[id].big which id is derived from.
				}
			}
			childVar.loadMap(childMap);
		}
	}
};

Var.prototype.loadJson = function(json){
	this.loadMap(JSON.parse(json));
};

Var.prototype.clear = function(map){
	this.nextState(0);
	this.pu = {}; //empty this.pu
};

Var.prototype.toJson = function(excludeBig){
	return JSON.stringify(this.toMap(excludeBig));
};

var Load = json=>{
	V.loadJson(json);
};

var State = excludeBig=>V.toJson(excludeBig);

/*todo var Save = name=>{
	if(name === undefined){
		name = 'blobMonstersGame_'+time();
	}
	if(!name.includes('.')) name += '.vartree';
	let json = State();
	
};*/

var quicksave = function(name){
	localStorage.setItem('monst.'+name, State());
};

var quickload = function(name){
	let json = localStorage.getItem('monst.'+name);
	if(json){
		Load(json);
	}
};



//If this is a Tile, like tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF,
//then loads it into game.wal (BigTile) and game.board (64 megapixel array of nearest 8k x 8k square
//to game.Y.p game.X.p 2d coordinate where viewing, so careful not to load tile where it would wrap around that as its farther away.
//TODO also load gob if its that, aka its name starts with gob$ . Careful about remote code injection,
//check it for infinite loops, spam redirects of window.location, etc.
Var.prototype.eval = function(){
	if(this.name.startsWith('gob$')){
		Todo();
	}else if(isTileString(this.name)){
		let quadTile = this.getOb();
		game.wal.tile(quadTile.square).writeSparse(quadTile.quad); //idempotent and fast if that same quad is already there
	}else{
		console.warn('TODO how to load Var='+this.path());
	}
};

/*//path height. V is height 0. V.testnet aka namespace is height 1. and so on.
//Gobs normally go at height 2. Gob fields height 3.
Var.prototype.h = function(){
	return this.up ? (this.up.pathHeight()+1) : 0;
};*/

Var.prototype.toMap = function(excludeBig){
	let ret = {
		p: this.p,
		v: this.v,
		//name: this.name,
		//pu: {},
	};
	if(this.t){
		ret.t = this.t; //UTC time updated. not all code will use this. but each Var is a time-series of 2 numbers: position and velocity.
	}
	if(this.pr){
		ret.pr = this.pr; //target position to spring toward
	}
	if(this.ps){
		ret.ps = this.ps; //spring strength of p toward pr
	}
	if(this.cv){
		ret.cv = this.cv; //base velocity decay, which kv is reset to in Var.nextState(dt)
	}
	if(this.big && !excludeBig){
		ret.big = this.big;
	}
	for(let childName in this.pu){
		let pu = ret.pu || (ret.pu = {});
		pu[childName] = this.pu[childName].toMap(excludeBig);
	}
	return ret;
};

Var.prototype.text = function(){
	return this.big || this.name;
};

const DefaultMaxResults = 2**16;
const DefaultRadiusResults = 2**12;

Var.prototype.allVars = function(optionalListToFill){
	let list = optionalListToFill || [];
	list.push(this);
	for(let childName in this.pu){
		this.pu[childName].allVars(list);
	}
	return list;
};

//returns a list of Var in descending (or is it ascending? is positive good or bad? choose one.) order of goal(theVar)
//which returns a number for how good a match it is. Also limit by exclude negatives (or positives?) from if score is too low?
//Theres an optimization that if optionalMaxResults==1 it doesnt sort an array but just keeps the best in a loop,
//but either way it calls goal on every Var reachable from here.
//TODO optimize more in that case to not even create the array of all Var.
Var.prototype.searchTree = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	let vars = this.allVars();
	if(maxResults == 1){ //n cost
		let bestScore = -Infinity; //FIXME is this reversed from how i vars.sort it?
		let bestVar = null;
		for(let v of vars){
			let score = goal(v);
			if(bestScore < score){
				score = bestScore;
				bestVar = v;
			}
		}
		return bestVar ? [bestVar] : [];
	}else{ //n*log(n) cost
		vars.sort((varA,varB)=>Math.sign(goal(varA)-goal(varB))); //FIXME is this reversed?
		while(vars.length > maxResults) vars.pop();
		return vars;
	}
};

//TODO rename search to searchChilds and have another func searchTree.
//goal(anyVar)->score (FIXME or should it be loss which is -score or someConstant-score?
//As goal, any positive number passes, and any 0 or negative number does not match.
//Sort by that descending, of those which pass.
Var.prototype.search = function(goal, optionalMaxResults){
	let maxResults = optionalMaxResults || DefaultMaxResults;
	//if(maxResults === undefined) maxResults = DefaultMaxResults;
	let scores = new Map();
	let ret = [];
	for(let n in this.pu){
		let childVar = this.pu[n];
		let score = goal(childVar);
		if(score > 0){
			scores.set(childVar, score);
			ret.push(childVar);
		}
	}
	ret.sort((a,b)=>{
		let scoreA = scores.get(a), scoreB = scores.get(b);
		if(scoreA < scoreB) return -1;
		if(scoreA > scoreB) return 1;
		return 0;
	});
	while(ret.length > maxResults) ret.pop();
	//console.log('Var.search got '+ret.length+' results, goal='+goal);
	if(game.gobs.length > 0 && ret.length == 0){ //FIXME remove this
		lastGoalWhenEmpty = goal;
		lastGobsListWhenEmptying = [...(game.gobs)];
	}
	return ret;
};

var lastGoalWhenEmpty = null; //FIXME remove this
var lastGobsListWhenEmptying = null; //FIXME remove this

//FIXME rename centerY and centerX in existing game content to Y and X, like game.Y and game.X TODO game.Y and game.X.
//if its on the line, is not included. Has to be less than r distance. This is cuz sorts by a relative distance, and 0 must not be included.
Var.prototype.searchYXR = function(y, x, r, maxResults){
	if(r === undefined) r = DefaultRadiusResults;
	const rr = r*r;
	return this.search(
		vr=>{
			return rr - ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		},
		maxResults);
};

Var.prototype.searchYX = function(y, x, maxResults){
	return this.searchYXR(y, x, undefined, maxResults);
};

//makes a new goal that also  requires it be within r distance of (y,x) (not on the line).
Var.prototype.searchYXRGoal = function(y, x, r, goal, maxResults){
	const rr = r*r;
	return this.search(vr=>{
		let isNear = rr > ((vr.Y.p-y)**2 + (vr.X.p-x)**2);
		if(!isNear) return 0;
		return goal(vr);
	}, maxResults);
};

Var.prototype.if0 = function(newP){
	if(!this.p) this.p = newP;
	return this;
};

Var.prototype.setNow = function(newP){
	this.p = newP;
	return this;
};

//const hashIdLen = ('sha256$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
const hashIdLen = ('gob$'.length+64); //64 hex chars. todo base58 or base64 or something. have code in Dagverse.js.
//
//FIXME theres gob$hash and tile9007199254595405$hash and tile9007199254595405$literalIfSmall,
//so should hashIdLen be renamed to minHashIdLen?


//TODO what should this limit be?
//If its longer  than this, auto hashes it and uses the hash (prefixed by what, in case it starts with a digit etc?)
//as the Var.name and the content hashed as the Var.big.
//so u can know if its a hash or not by its length. or could check for any chars then $ like sha256$thehash.
const MaxLiteralNameLen = hashIdLen-1;

//get or create child Var
Var.prototype.Pu = function(nameOrBig){
	let ret;
	if(nameOrBig.length <= MaxLiteralNameLen && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(nameOrBig)){ //TODO make this condition be a func
		ret = this.pu[nameOrBig] || new Var(this, nameOrBig, null, this.ob||null); //auto puts it in this.pu[string]
	}else{
		//let hash = hashStringToHex(nameOrBig);
		let name = hashStringToBase64(nameOrBig); //todo dont hash if its small enuf to be a literal id (dont use .big)
		/*if(nameOrBig.startsWith('mutid$')){ //FIXME 2025-1-9 removed the mutid$ prefix of tiles, so am not using it for anything.
			let i = nameOrBig.indexOf('$','mutid$'.length);
			if(i!=-1){ //found next $ like in mutid$tile3534523423$...
				name = nameOrBig.substring(i+1)+name; //mutid$tile3534523423$234324hash345345
			}else Err('no second $ found in mutid$...');
		*/
		if(nameOrBig.startsWith('tile')){ //like tile1971583262467328$ then base64 of its Quad bytes, if small, else then base64 of hash of that.
			if(isValidVarName(nameOrBig) && nameOrBig.length < 64){
				//considering size of tile1971583262467328$ (size 21) and 43 digits of sha256 base64 (21+43==64),
				//if its smaller then use it directly, else hash it.
				//isValidVarName might let vars be bigger like 100, but i havent used it much and am experimenting. Might need those bigger vars.
				name = nameOrBig;
			}else{
				let i = nameOrBig.indexOf('$');
				if(i == -1) Err('No $ after tile in var name');
				let prefix = nameOrBig.substring(0,i+1); //like tile1971583262467328$
				name = prefix+name; //like tile1971583262467328$thenbase64ofsha256ofdotbig
				
				//example:
				//tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF is the name of big:	//tile1971585409951104$qjB$pzN$oUR$$$2GwV$$$Bo$$$28$$$$lF$$$3k$pUg$oz$$oUc$nRJ$$$0BIBJ$I3lBIBZ$lF$$$3k$I3k$oUAClF$$$3lBlF0B$3lBI3lB$CArnF28$$$$lF$$$3k$$3k$oUQ8I3n4I3k$I3lBmRJ$I$0BI$0BI$2HyF2Hx$2Gzk2GygZ$lJlB$3k$$3k$nRJ$I$0BI$24I3k$I$$$$$$$$$
			}
			//TODO generate this.Y.p and this.X.p to be derived from SquareY and SquareX of 1971585409951104 like in tile1971585409951104$,
			//but dont let them change and dont spend time computing what if they change during physics. Tiles are constants.
			
			//My 128x128 game tiles have hash ids like this. The first number tells a power
			//of 2x2 size, y, and x: tile1971585409951104$tsLwEmG1RXpu2SgiNDErGbSemnRdoj2eTL1FNBOjstF
			//Then 43 base64 digits of sha256 of the quadtree compressed content, which is normally a few hundred bytes.
		}else{
			//name = 'sha256$'+name; //no special prefixing
			name = 'gob$'+name; //no special prefixing
		}
		//ret = this.pu[name] || new Var(this, name, nameOrBig, this.gob||null); //auto puts it in this.pu[string]
		ret = this.pu[name] || new Var(this, name, nameOrBig, this.ob||null); //auto puts it in this.pu[string]
	}
	if(ret.big && ret.big.startsWith('(')){ //likely a js function string
		let listOfLists = getParamNames(ret.big);
		if(listOfLists.length){
			ret.vars = []; //same order as in gob.vars, a list instead of the .pu {} of paramName to Var. Vars either way.
			for(let list of listOfLists){
				let paramName = list[0]; //TODO if theres more stuff in it, do whats normally done after getParamNames, fill in .p .v .epsilon andOr .accelMul etc.
				ret.vars.push(ret.Pu(paramName));
			}
		}
	}
	return ret;
};

Var.prototype.think = function(){
	let brain = this.brain || (this.brain = eval(this.big || this.name));
	return brain(...(this.vars)); //list or Int32Array of int voxels. See YXC IY IX YXRGB etc funcs for int voxels.
};

const varProxyHandler = {
	get(target, prop, receiver){ //works
		if(typeof(prop) === 'symbol'){
			return Reflect.get(target, prop, receiver);
		}
		return target[prop] || receiver.Pu(prop);
	},
};

Var.prototype = new Proxy(Var.prototype, varProxyHandler);

//Var.prototype.pushEpsilon = function(epsilon){
Var.prototype.pushEpsilon = function(){
	this.prevP = this.p;
	this.p += this.epsilon;
};

Var.prototype.popEpsilon = function(){
	this.p = this.prevP;
	this.prevP = 0;
};

//TODO test this.
Var.prototype.valueOf = function(){ //the position, this.p, though calling this.p is probably more efficient.
	return this.p;
};

Var.prototype.path = function(){
	return this.up ? this.up.toString()+'.'+this.name : this.name;
};

Var.prototype.toString = function(){
	return this.path();//return this.up ? this.up.toString()+'.'+this.name : this.name;
	//return '{type:"vox_var",p:'+this.p+',v:'+this.v+',kv:'+this.kv+',dp:'+this.dp+',dv:'+this.dv+',mn:'+this.mn+',mx:'+this.mx+'}';
};

Var.prototype.nextState = function(dt){
	if(dt){
		//use someVar.nextState(0) to clear someVar.kv someVar.dp etc, without modifying someVar.p or .v etc.
		//For use during gradient of things that might happen but have not decided to make them happen.
		
		//this.v = 0; //FIXME
		//let nextP = this.p + dt*(this.v+this.dp);
		if(this.pr){
			//this.gr += TODO something about this.pr and this.ps as parabola.
			//let positionDiff = this.pr-this.p; //FIXME is this backward? accel negative gradient
			let positionDiff = this.p-this.pr; //FIXME is this backward? accel negative gradient
			let partOfGradientFromParabola = positionDiff*this.ps; //TODO divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ???
			//let partOfGradientFromParabola = positionDiff/2*this.ps; //TODO verify this /2 is correct (vs /4 or *2 or sqrt2, etc, or just leave it as is): divide by 2 like potentialenergy of stack of z tall mass is z*z/2. ???
			this.gr += partOfGradientFromParabola;
			//this.poten += this.ps*positionDiff*positionDiff;
		}
		let nextP = this.p + dt*(this.v+this.dp-this.gp*this.gr);
		if(this.mn <= this.mx){
			nextP = Math.max(this.mn, Math.min(nextP, this.mx)); //truncate into range
		}
		let nextV = (this.v+dt*this.accelMul*(this.dv-this.gr))*Math.exp(-dt*this.kv);
		//let nextV = 0; //FIXME
		
		
		//let changePAmount = Math.abs(this.p-nextP);
		//if(changePAmount > 100 && this.ob==cShapedGob){ //FIXME remove this
		//	console.log('Var '+this.path()+' changePAmount='+changePAmount);
		//}
		
		this.p = nextP;
		this.v = nextV;
	}
	//this.kv = this.dp = this.dv = this.gr = this.poten = 0;
	this.kv = this.cv; //cv is base kv
	this.dp = this.dv = this.poten = 0; //leave this.gr as is, since its not a sum, is just set all at once in one of the doPhysics funcs.
	this.mn = -Infinity;
	this.mx = Infinity;
};

/*var getParamNames = func=>{
	const fnStr = func.toString().replace(/[\r\n]/g, '');
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\s,]+)/g);
	return params === null ? [] : params;
};*/

//getParamNames((a/*2 3 4*/, b/*5 6*/, c)=>(a+b)) returns [['a',2,3,4],['b',5,6],['c']].
var getParamNames = funcOrStr=>{
	const fnStr = funcOrStr.toString().replace(/[\r\n]/g, '').trim();
	if(fnStr.startsWith('()=>')){
		return [];
	}
	const params = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',')
		.map(param => param.trim().match(/(\w+)(?:\/\*([^*]+)\*\/)?/));
	return params.map(match => {
		const [_, name, comment] = match;
		const numbers = comment ? comment.match(/\d+/g) : [];
		return [name, ...(numbers || []).map(Number)];
	});
};

//gob.brain(...gob.vars) may check this to decide to do diffeq and poten fields in Vars or not.
//You dont need this during the gob.size+1 number of calls to just get 32 bit voxels
//for collision detection, that part of the potential energy math.
//You only need this once per gob per physics cycle to choose to add extra change to var.p andOr var.v
//like how the "pinball bumpers" work in dagball by diffeq.
//should I use this.diffeq instead? do i want the func to have access to a this? var Diffeq = true;
//var Diffeq = true;

//Game OBject. brain(...floatVars) returns Uint32Array of voxels. It can be a different number of voxels depending on those float vars.
//brain returns an Out.
//var Gob = function(game, brain, optionalInfluence){
var Gob = function(game, brain){
	let big = ''+brain;
	//let name = hashStringToHex(big);
	//this.influence = optionalInfluence || new Var(null, name, big, this);
	
	//this.influence.p is 1 for this to exist, else is 0 for this not to exist.
	//other values, i guess try to converge to one of those.
	//This is how you add or delete game content in a live multiplayer game or local.
	//this.influence = NS.Pu(''+brain).setOb(this);
	//this.bo = NS.Pu(''+brain).setOb(this); //Var.ob is a Gob or Game or null. Gob.bo is a Var. Game.bo is a var. gobA.bo.ob===gobA.
	let namespaceVar = game.bo.up;
	this.bo = namespaceVar.Pu(''+brain).setOb(this); //Var.ob is a Gob or Game or null. Gob.bo is a Var. Game.bo is a var. gobA.bo.ob===gobA.
	this.Y = this.bo.Y;
	this.X = this.bo.X;
	
	this.game = game;
	//dont use oy or ox, cuz wrap around 8k instead using centerY.p and centerX.p: this.oy = DefaultGobOy; //FIXME??
	//dont use oy or ox: this.ox = DefaultGobOx; //FIXME??
	game.gobs.push(this);
	this.brain = brain;
	//this.diffeq = false;
	if(typeof(this.brain)!='function'){
		Err('Not a function: '+brain);
	}
	this.size = this.brain.length; //number of params in this.brain. You use this.brain(...this.pos) for example.
	//this.pos = new Float32Array(this.size); //position
	//this.vel = new Float32Array(this.size); //velocity
	this.vars = [];
	let names = getParamNames(brain); //names[index][0] is the name. [1] is first number right after that, if any. 0-4 numbers for position, velocity, epsilon, accelMul.
	if(names.length != this.size) throw new Error('names='+JSON.stringify(names));
	//let accelMulMul = 10; //cuz i removed the dt*10, back to dt*1.
	//let accelMulMul = 5; //normal? cuz i removed the dt*10, back to dt*1.
	let accelMulMul = 3;
	//let accelMulMul = 5000; //FIXME
	for(let i=0; i<this.size; i++){
		
		//broken cuz gives null parent: let v = new Var(null, names[i][0], null, this); //function(optionalParentVar, optionalName, optionalBig, optionalGob)
		//duplicate Var: let v = new Var(namespaceVar, names[i][0], null, this); //function(optionalParentVar, optionalName, optionalBig, optionalGob)
		let lambdaParamName = names[i][0];
		//console.log('Gob constructor, lambdaParamName='+lambdaParamName);
		let v = this.bo[lambdaParamName].setOb(this);
		
		if(i<2){ //Y and X params. FIXME, this is for centerY and centerX vars, but not every Gob/func will have those or in same order. for testing.
			//v.p = Math.random()*400; //FIXME
			v.p = Math.random()*400; //FIXME
			v.v = Math.random()*200-100; //FIXME
			//v.accelMul = .001;
			//v.accelMul = .0001;
			//v.accelMul = .0000001;
			//v.accelMul = .1*accelMulMul;
			v.accelMul = .3*accelMulMul;
			v.epsilon = 1;
		}else if(i == 2){ //ratio
			v.p = .5+Math.random();
			v.accelMul = 12*accelMulMul;
			v.epsilon = .01;
		}
		//v.accelMul = 1;
		v.accelMul = 1*accelMulMul;
		if(names[i].length > 1){
			v.p = names[i][1]; //it gave a default position
		}
		if(names[i].length > 2){
			v.v = names[i][2]; //it gave a default velocity
		}
		if(names[i].length > 3){
			v.epsilon = names[i][3]; //it gave a default epsilon
		}
		if(names[i].length > 4){
			v.accelMul = names[i][4]; //it gave a default accelMul
		}
		this.vars.push(v);
	}
	//js {} map of extra data, whatever else might get added to the Gob later.
	//Gob must be deriveable from the string of js code in gob.brain and from
	//the .p and .v and .epsilon and .accelMul in each Var in gob.vars and gob.m.
	//Keep it organized this way so its easy to store and load state.
	this.m = {
		//TODO move gob.brain and gob.vars in here?
		//Not all parts of a Var are primary data. Some parts are derived/cache other than roundoff.
		isSelected: false,
		isSelectable: true, //you might want to make the mouse gob, if its used, not selectable.
		
		//256 bits, 1 bit per portal, 2**256 possible worlds, each a 256k tall 128k wide rectangle.
		//cross at x=(2**17). 256 y portals in blocks of 1024. (this.Y.p>>>10)&255 is which portal, 0 to 255,
		//crossed when crossing this.X.p==(1<<17) the horizontal midpoint. Near the borders of portals nothing should be allowed
		//to cross there cuz theres too many things intersecting it to be viewed as a flat 2d space, so just put walls near portal edges.
		//To block a portal, just put a 1024 tall wall touching it. They wont be able to come thru from either side.
		//gate: new Uint32Array(8),
		//TODO should gate be 8 Var's using Var.p as 32 bits or 5 of them using 52 or 51 bits?
		//V.testnet.hashOfSomeBrainCode435345345.gatesA.p .gatesB.p etc?
		//Or maybe should use a bigint in just 1 of those? seems like it would cause problems in code that uses float64s or ints.
		
		/* found a 256 bit multiverse address THAT IM NOT EVEN USING, in 8 32-bit Vars in my V . testnet . any . var
		. name . abc545553 . etc tree, or so the code says. Thats a powerset of 256 coins, as an address space.
		//8 Var's using Var.p|0 as 32 bits each, total 256 bits for 256 gates and 2**256 possible mutable worlds.
		ga: this.bo.ga, //gates 0 to 31
		gb: this.bo.gb, //gates 32 to 63 in, for example, V.testnet.idOfThisObject345345.gb.p|0
		gc: this.bo.gc, //gates 64 to 95
		gd: this.bo.gd, //gates 96 to 127
		ge: this.bo.ge, //gates 128 to 159
		gf: this.bo.gf, //gates 160 to 191
		gg: this.bo.gg, //gates 192 to 223
		gh: this.bo.gh, //gates 224 to 255
		*/
		
		
		team: randTeam(), //see game.rps aka rock paper scissors. Each gob is 1 of REDTEAM, GREENTEAM, or BLUETEAM. Theres also BLACKTEAM or is it GRAYTEAM?
		//team: REDTEAM, //FIXME
		//team: BLUETEAM, //FIXME
		//team: GREENTEAM, //FIXME
		//oy: DefaultGobOy,
		//ox: DefaultGobOx,
		displayText: '',
	};
	if(Math.random()<.1){
		this.m.team = GRAYTEAM; //experimental 2024-11-20+. Doesnt have glowing distance cache / tridist. Is neutral wall or shield. TODO change its voxel colors or something so users can see its GRAYTEAM.
	}
	this.voxInGame = null; //If this is in game.board (2**26 ints), remember them here so can remove them during gradient calculation or just to remove the object. null if not in game.board.
	this.voxLast = null; //last output from this.brain(...this.vars). the other output is it modifies fields in Vars in this.vars.
	this.stats = {};
};

//when you edit js code in the textarea on the left, thats editing gob.brain code of selected Gob.
//The new Gob copies Var.p Var.v gob.m.isSelected etc from prev Gob, but be careful that it might have a different set of Vars
//or be nonworking code or have infinite loops in the code etc.
//This gets Var's that are and are not in gob.vars list, as it uses gob.bo.pu instead which contains all of those and maybe more.
Gob.prototype.copySomePartsFromPrevGob = function(prevGob){
	this.m.isSelected = prevGob.m.isSelected;
	this.m.team = prevGob.m.team;
	//TODO? this.m.displayText = prevGob.m.displayText;
	let prevVar = prevGob.bo;
	let myVar = this.bo;
	for(let childVarName in myVar.pu){
		if(prevVar.pu[childVarName]){ //dont use prevVar[childVarName] cuz that creates if not exist
			myVar.pu[childVarName].copyLocalFrom(prevVar.pu[childVarName]);
		}
	}
};

/*like BitPic but just in a Uint32Array without object.
dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.bytes[index>>3]>>(index&7))&1;
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.bytes[index>>3] |= (1<<(index&7));
	}else{
		this.bytes[index>>3] &= ~(1<<(index&7));
	}
};*/


/*2025-2-5 have not been using the 256 bit multiverse addresses
and have commented out their code (in gob.m[8 specific 2 char names todo what were those?]) for efficiency.
Gob.prototype.crossGate = function(gateByte){ //flips a bit in this.m.gate, of 256 gates which are at x=(1<<17), 1024 tall each stacked.
	this.m.gate[gateByte>>5] ^= (1<<(gateByte&31));
};
Gob.prototype.gateBit = function(gateByte){ //0 or 1
	return this.m.gate[gateByte>>5]>>>(gateByte&31);
};
Gob.prototype.setGateBit = function(gateByte, newBit){
	let readBit = this.gateBit(gateByte); //TODO optimize this so it doesnt call gateBit, just does &= or |=
	if(readBit != newBit){
		this.crossGate(gateByte);
	}
};*/

var MustExist = x=>{
	if(!x){
		Err('NOT exist');
	}
	return x;
};

/*nevermind, just replace the Gob, not changing gob.bo

//big is a string of js lambda code that normally goes in like V.testnet.gob$ekYSvbJNZRbhy5JUXR_o6c6VRDwE6rS2SuYFN5C6zTR.big
//If it finishes evaling in here, this.brain is set to what it evals to (a js lambda of n Var params),
//and this.bo is replaced, and the prev this.bo.ob is replaced by this as Gob.bo and Game.bo are the Var form of those objects.
Gob.prototype.setBig = function(big){
	/*
	//FIXME either require the ( ) be in the code itself or  find a way to make it work here without that.
	//it doesnt like some kind of functions function(){} or ()=>{} or ()=>(...) or something.
	let evaled = eval('('+text+')');
	//FIXME check for number of names of params changing. might be a completely new func.
	//else its editing the selected gob.brain func.
	sel.brain = evaled;
	*
	let prevVar = MustExist(this.bo);
	let namespace = prevVar.ns();
	let nextVar = namespace[big]; //its (prefix$ then) hash name (or small literal) is in nextVar.name, hash of big
	if(prevVar !== nextVar){
		//in case it was this Gob, its not anymore cuz this Gob is mutable as u can edit its code
		//in text box on left of screen and it keeps its var values if they were same number of them and order.
		prevVar.ob = null;
		
	}
};*/

Gob.prototype.setAllVars0Speed = function(){
	for(let vr of this.vars) vr.v = 0;
};

Gob.prototype.getVar = function(name){ //Example: this.getVar('Y').p is y position, and 'X', normally the first 2 in this.vars.
	try{
		//return this.bo.up[name];
		return this.bo[name];
	}catch(e){
		console.error(e); //put breakpoint here
		throw e;
	}
};

Var.prototype.setOb = function(gobOrGame){
	this.ob = gobOrGame;
	return this;
};

Gob.prototype.y = function(){
	//return this.getVar('Y').p;
	return this.Y.p;
};

Gob.prototype.x = function(){
	//return this.getVar('X').p;
	return this.X.p;
};

//uses Y X vars, not per voxel. does not wrap.
Gob.prototype.simpleDist = function(y,x){
	return Math.hypot(this.y()-y, this.x()-x);
};


//FIXME use this.Y.p and this.X.p rounded down to blocks of 8192 (Size) and add voxel position to those,
//but TODO??? until that fix im gonna mod y and x by that? but FIXME that will be buggy near the borders of each 8k X 8k wrapped.
//uses this.voxInGame. minimum distance from any voxel to the given y x. will wrap around Size=8192 but this.simpleDist does not wrap so can do the full millionXmillion.
Gob.prototype.dist = function(y,x){
	y = y%Size; //FIXME that will be buggy near the borders of each 8k X 8k wrapped
	x = x%Size;
	let minDistSq = Infinity;
	if(this.voxInGame) for(let voxel of this.voxInGame){
		let dy = IY(voxel)-y;
		let dx = IX(voxel)-x;
		let distSq = dy*dy+dx*dx;
		minDistSq = Math.min(minDistSq,distSq);
	}
	return Math.sqrt(minDistSq);
};

Gob.prototype.varPotens = function(erase){
	let poten = 0;
	for(let v of this.vars){
		poten += v.poten;
		if(erase) v.poten = 0;
	}
	return poten;
};

//update this.voxLast and some of the fields in Var's in this.vars, but do not update this.voxInGame and not the Game itself.
Gob.prototype.think = function(){
	return this.voxLast = this.modVoxels(this.brain(...this.vars));
};

var modVoxelsPutThisColorInSomeButNotAll = (voxels,newColor)=>{
	for(let i=0; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
		voxels[i] = SetC(voxels[i],newColor);
		voxels[i+1] = SetC(voxels[i+1],newColor);
	}
	return voxels;
};

//changes the pixels that modVoxelsPutThisColorInSomeButNotAll doesnt change, so could do both.
var modVoxelsPutThisColorInSomeButNotAllB = (voxels,newColor)=>{
	for(let i=2; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
		voxels[i] = SetC(voxels[i],newColor);
		voxels[i+1] = SetC(voxels[i+1],newColor);
	}
	return voxels;
};

var modAllVoxelsPutThisColor = (voxels,newColor)=>{
	for(let i=0; i<voxels.length; i++){
		voxels[i] = SetC(voxels[i],newColor);
	}
	return voxels;
};

var DefaultGrayTeamColor = 0b101010; //light gray, of the 64 possible colors.

//This is how you create overlay graphics, show a gob flashing cuz its selected, etc.
//Normally this returns its param (voxels) with no changes.
//voxels is a Uint32Array (Int32Array?) of int voxels or a [] list of those. May modify voxels content, such as to change
//their colors to show this gob is selected, or replace them with a different list/array. Either way, returns it.
//Be careful if u return a new list/array of int voxels cuz some code might assume its the same list/array as the param.
Gob.prototype.modVoxels = function(voxels){
	/*
	if(this.m.isSelected){
		let newColor = randInt(Colors);
		for(let i=0; i<voxels.length; i++){
			voxels[i] = SetC(voxels[i],newColor);
		}
	}else if(this.m.team == GRAYTEAM){
		let newColor = DefaultGrayTeamColor;
		//for(let i=0; i<voxels.length; i++){
		for(let i=0; i<voxels.length-3; i+=4){ //only some of the voxels, set to grayteam color
			voxels[i] = SetC(voxels[i],newColor);
			voxels[i+1] = SetC(voxels[i+1],newColor);
		}
	}
	return voxels;
	*/
	if(this.m.isSelected){
		return modAllVoxelsPutThisColor(voxels,randInt(Colors));
	}else if(this.m.team == GRAYTEAM){
		return modVoxelsPutThisColorInSomeButNotAll(voxels,DefaultGrayTeamColor);
	}else return voxels;
};

/*this doesnt count if game.gobs contains this, so am commenting it out and doing it all in setExists. Gob.prototype.exists = function(){ //exists in game?
	return !!(this.voxInGame);
};*/

var listRemoveFirst = (list,removeThis)=>{
	let i = list.indexOf(removeThis);
	list.splice(i, 1);
	return list;
};

//both in this.game.gobs list and this.voxInGame
Gob.prototype.setExists = function(shouldExist){ //shouldExist is true/false. exists in game or not. can still exist as Gob either way.
	let existsInGameGobsList = this.game.gobs.includes(this);
	let existsVoxelsInGame = !!(this.voxInGame);
	let exists = existsInGameGobsList && existsVoxelsInGame;
	if(exists != shouldExist){
		if(shouldExist){ //add
			console.log('Add gob '+this);
			if(!existsInGameGobsList){
				this.game.gobs.push(this);
			}
			if(!existsVoxelsInGame){
				this.setGameVoxs(this.think()); //voxels
			}
		}else{ //remove
			console.log('Remove gob '+this);
			
			//2024-11-23 This is an ugly hack. Gobs have been getting high gradients (like gob.Y.gr) and high speeds (like gob.Y.v)
			//instantly when they come back after being removed for game.sparseUpdate() which removes gobs that arent near enough to
			//the mouse (or game center view, was the earlier code).
			//this.setAllVars0Speed();
			
			if(existsVoxelsInGame){
				this.setGameVoxs(null); //remove voxels
			}
			if(existsInGameGobsList){
				listRemoveFirst(this.game.gobs,this);
			}
		}
	}
};

//each Gob can have at most 1 list of voxels in the Game at once. If there is such a list in game already, remove it,
//then either way add this one, unless voxels is null or undefined then dont add any, so thats how to remove it.
//this.voxInGame will be this param voxels either way at the end (null if not exist).
Gob.prototype.setGameVoxs = function(voxels){
	//FIXME game.gobs is a list which could get expensive adding and removing gobs but Gob.setExists is changing the design that its gotta be removed from that.
	if(this.voxInGame){
		this.game.remVoxs(this.voxInGame, this.m.team);
		this.voxLast = null;
	}
	if(voxels){
		//this.game.addVoxs(voxels);
		this.game.addVoxs(voxels, this.m.team);
	}
	this.voxInGame = voxels || null;
	return this.game.poten;
};

//Returns a byte. get the OR aka | of the team byte of all voxels this.voxInGame touches.
//This should always include (as mask) this.m.team if this.voxInGame exists.
Gob.prototype.getTeamsImTouching = function(){
	const voxels = this.voxInGame;
	let teams = 0;
	if(voxels){
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teams |= teamsArray[voxels[i]>>>6];
		}
	}
	return teams;
};

//updates this.m.team and this.game.rps.team, if newTeam differs from this.m.team.
//Does not update this.game.rps.tridist, which should happen in next physics cycle.
Gob.prototype.setTeam = function(newTeam){
	//throw new Error('FIXME how to mark a team in a 4x4 grid if 0-16 voxels might be in here? Should team still be big size (Area) not SmallSize (SmallArea)?');
	const xor = newTeam^this.m.team;
	const voxels = this.voxInGame;
	if(xor && voxels){
		//TODO rename to this.game.rps.teams cuz its xor of all teams touching it such as REDTEAM|BLUETEAM.
		//Also, it only shows up if odd number of a team is touching there.
		//if even, it cancels out. so its parity. cuz i only wanted to spend a byte on it.
		const teamsArray = this.game.rps.team;
		for(let i=0; i<voxels.length; i++){
			teamsArray[voxels[i]>>>6] ^= xor;
		}
	}
	this.m.team ^= xor; //remove this.m.team, add newTeam.
	if(this.m.team != newTeam) throw new Error('The team xor algorithm didnt work'); //TODO remove this test after know this basic thing is working?
};

//A capture happens when 2 teams touch at the same pixel and a random weighted coin
//is heads cuz otherwise it sometimes wont break ties. Its per pixel,
//so if they slightly squeeze by in any strange shape without touching, even while reshaping, theres no capture.
//This works whether the distance cache (game.rps.tridist) has been updated or not. Its a big cache of 64 megapixels,
//normally only updated on the screen you're viewing at the time, and stays that way until you look near there again.
//The distance cache game.rps.tridist is where the ambient-light-like colors come from, showing the distance from
//each pixel to nearest voxel of REDTEAM, GREENTEAM, and BLUETEAM. Thats for chasing and running from eachother.
//Detecting collisions is easier. If you are on BLUETEAM your goal is to turn the whole game world blue
//before REDTEAM or GREENTEAM turn it those colors instead. Each team captures 1 color and is captured by the
//other color, around and around. Or maybe the amount of time the game world is mostly blue. I dont know.
//The game is supposed to produce a continuous stream of fun, that you can jump in for a minute, join a team,
//and leave, or 10 minutes. Its not longterm accumulation of items like in a RPG. Nobody gets kicked out for being
//captured or losing. They just change teams when captured.
//but the game should accumulate new species over long times, pieces of javascript code that bend into different
//shapes and move differently. This is the cambrian-explosion, that the game gets more and more fun over time cuz
//of player created content, including content by LLMs.
var predatorOf = team=>{ //reverse it so red chases green chases blue chases red.
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == GREENTEAM) return REDTEAM;
	if(team == BLUETEAM) return GREENTEAM;
	if(team == REDTEAM) return BLUETEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

var preyOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == REDTEAM) return GREENTEAM;
	if(team == GREENTEAM) return BLUETEAM;
	if(team == BLUETEAM) return REDTEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};
/*var predatorOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == REDTEAM) return GREENTEAM;
	if(team == GREENTEAM) return BLUETEAM;
	if(team == BLUETEAM) return REDTEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};

var preyOf = team=>{
	//if(team == GRAYTEAM) return GRAYTEAM; //FIXME there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
	if(team == GREENTEAM) return REDTEAM;
	if(team == BLUETEAM) return GREENTEAM;
	if(team == REDTEAM) return BLUETEAM;
	throw new Error('team='+team+' but expected it to be 1 of 3 teams. is it multiple teams, or what?');
};*/

//teams is a mask such as REDTEAM or REDTEAM|BLUETEAM
Game.prototype.countTeam = function(teams){
	let count = 0;
	for(let gob of this.gobs){
		if(gob.m.team&teams) count++;
	}
	return count;
};

Gob.prototype.doTeamLogic = function(){
	let touchingTeams = this.getTeamsImTouching();
	let myTeam = this.m.team;
	if(myTeam == GRAYTEAM){
		//there is no predator or prey of GRAYTEAM. its for walls and shields and is neutral.
		return;
	}
	let predatorTeam = predatorOf(myTeam);
	if(touchingTeams&predatorTeam){
		//console.log(teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) captured a '+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)');
		//console.log('%cGreen %cBlue', 'color: green;', 'color: blue;');
		console.log('%c'+teamName[predatorTeam]+' ('+game.countTeam(predatorTeam)+'+1) %ccaptured a %c'+teamName[myTeam]+' ('+game.countTeam(myTeam)+'-1)%c.\nOK.',
			'color: '+teamHtmlColorName[predatorTeam], '', 'color: '+teamHtmlColorName[myTeam], '');
		if(Math.random()<.9){ //so they dont get deadlocked when all 3 teams are touching eachother somewhere, someone has to become the other team first
			this.setTeam(predatorTeam);
		}
	}
};

const squaredKeepSign = x=>(x<0 ? -x*x : x*x);

//After calling this, gob.vars[eachIndex].gr is set to the gradient,
//by difference of total potentialEnergy, combining game.poten and this.vars[anyIndex].poten,
//but there are adjustments to it based on game.collideLinMul.p and game.collideSqMul.p.
//TODO update gradient in this.vars and compute this.vars.length+1 separate lists of voxels (which may be different sizes).
//Does not change var.p (position) or var.v (velocity) but does set var.gr (gradient), and TODO maybe also xpoten (todo should that go in here),
Gob.prototype.doPhysicsA = function(){
	let relTimeFrom = performance.now();
	let g = this.game;
	try{
		//create this.size+1 lists of voxels to compute the part of gradient of collision detection in game.board
		let gamePotenWithoutThisGob = this.setGameVoxs(null);
		let potenOfFork = new Float64Array(this.size+1); //each should always be an integer 0 to 2**53-1.
		for(let fork=0; fork<=this.size; fork++){
			/*for(let v=0; v<this.size; v++){ //mod var positions by epsilon
				//let epsilon = .01; //FIXME see indexToEpsilon and indexToAccelMul
				if(v == fork){
					this.vars[v].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
				}
			}*/
			if(fork < this.size){
				this.vars[fork].pushEpsilon(); //uses this.vars[v].epsilon. mods var.p by adding that
			}
			//let voxels = fork<this.size ? this.think() : null; This is wrong cuzthe last fork should have voxels, just the voxels as it is now unmodified.
			let voxels = this.think();
			
			
			//the accurate way that considers collisions even within voxels list: let gamePoten = this.setGameVoxs(voxels); //if voxels is null, removes it from game.
			let collidePotenDiff = g.potenDiffIfNoCollisionsBetweenParamVoxels(voxels);
			//let gamePoten = this.game.poten + potenDiff; //the fast way. does not modify game. just reads it.
			let gamePoten = g.poten + g.collideLinMul.p*collidePotenDiff +
				g.collideSqMul.p*squaredKeepSign(collidePotenDiff); //the fast way. does not modify game. just reads it.
			//let rpsAccelMul = this.game.rps.accelMul;
			//let rpsAccelMul = this.game.rps.accelMul.p;
			let rpsAccelMul = g.rpsAccelMul.p;
			let myTeam = this.m.team;
			if(g.doRps.p && myTeam != GRAYTEAM && rpsAccelMul){ //if its set to 0, dont spend on this calculation
				let predatorTeam = predatorOf(this.m.team);
				let preyTeam = preyOf(this.m.team);
				if(predatorTeam&myTeam){
					throw new Error('i am my own predator, predatorTeam='+predatorTeam+' myTeam='+myTeam);
				}
				if(preyTeam&myTeam){
					throw new Error('i am my own predator, predatorTeam='+predatorTeam+' myTeam='+myTeam);
				}
				//let rpsPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(this.m.team, voxels);
				//TODO optimize by doing just 1 call of a variant of potenDiffFromRpsDistanceCache_team_voxels that does both predator and prey at once.
				let predatorPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(predatorTeam, voxels); //accelerate away from predator voxels
				let preyPoten = this.game.potenDiffFromRpsDistanceCache_team_voxels(preyTeam, voxels); //accelerate toward prey voxels
				//gamePoten += rpsAccelMul*rpsPoten;
				let normedPredatorPoten = predatorPoten/voxels.length;
				let normedPreyPoten = preyPoten/voxels.length;
				gamePoten += rpsAccelMul*(normedPreyPoten-normedPredatorPoten);
				//gamePoten += rpsAccelMul*(preyPoten-predatorPoten);
				//let rpsPotenDiff = preyPoten-predatorPoten;
				//gamePoten += rpsAccelMul*(rpsPotenDiff + .00000001*squaredKeepSign(rpsPotenDiff));
			}
			
			
			
			
			//this.varPotens() gets the sum of var.poten for all this.vars. The true param makes it erase those potens to 0 after that.
			potenOfFork[fork] = gamePoten + this.varPotens(true);
			//potenOfFork[fork] = gamePoten; //FIXME also include this.varPotens(true). just testing why its accelerating for no apparent reason.
			if(fork < this.size){
				this.vars[fork].popEpsilon(); //undo "mod var positions by epsilon"
			}
		}
		//if(gamePotenWithoutThisGob != potenOfFork[this.size]){
		//	throw new Error('gamePotenWithoutThisGob != potenOfFork[this.size], but those should be duplicate. TODO redesign to not duplicate that calculation, so its faster. But still, they should be exactly equal cuz potentialEnergy is always an integer from 0 to 2**53-1.');
		//}
		let maxGr = this.game.maxGr.p;
		for(let i=0; i<this.size; i++){
			let vr = this.vars[i];
			vr.nextState(0); //clear parts that were modified during what-if calculations during gradient, that we are not actually going to do, just measure.
			//let epsilon = v.epsilon;
			//let accelMul = v.accelMul;
			let oneDimOfGradient = (potenOfFork[i]-potenOfFork[this.size])/vr.epsilon; //gradient
			vr.gr = oneDimOfGradient;
			if(maxGr < vr.gr){
				let newGr = maxGr;
				console.log(vr.path()+'.gr limited by maxGr to '+newGr+', was '+vr.gr); //TODO merge duplicate code
				vr.gr = newGr;
			}else if(vr.gr < -maxGr){
				let newGr = -maxGr;
				console.log(vr.path()+'.gr limited by maxGr to '+newGr+', was '+vr.gr); //TODO merge duplicate code
				vr.gr = newGr;
			}
		}

		//document.title = 'gob_poten='+potenOfFork[this.size];
		//console.log('potenOfFork='+JSON.stringify([...potenOfFork]));

		//this last .think() puts back what was cleared by v.nextState(0).
		this.setGameVoxs(this.think()); //not gradient. just whatever it is now. paint that onto game, and leave it there for other gobs to collision against.
	}finally{
		this.stats.lastPhysicsASecs = (performance.now()-relTimeFrom)*.001;
	}
};

Gob.prototype.speedYX = function(){
	return Math.hypot(this.Y.v, this.X.v);
};

//updates var.p (position) and var.v (velocity)
Gob.prototype.doPhysicsB = function(dt){
	let relTimeFrom = performance.now();
	try{
		let speed = this.speedYX();
		let maxSpeed = this.game.maxSpeed.p;
		if(speed > maxSpeed){
			let mul = maxSpeed/speed;
			this.Y.v *= mul;
			this.X.v *= mul;
			//console.log('Limiting speed of '+this.bo.path()+' to maxSpeed='+maxSpeed+', was '+speed);
		}
		for(let v of this.vars){
			v.nextState(dt);
		}
		this.Y.p = Math.max(MinY, Math.min(this.Y.p, MaxY)); //TODO use this.Y.mn and this.Y.mx instead? They'd get set
		this.X.p = Math.max(MinX, Math.min(this.X.p, MaxX));
	}finally{
		this.stats.lastPhysicsBSecs = (performance.now()-relTimeFrom)*.001;
	}
};

//update gob.m.displayText etc. for debugging as of 2024-11-23 but seems a useful place to put stuff in general so keep it for other things later.
Gob.prototype.stepC = function(){
	//if(this != mouse && this != cShapedGob) return;
	//let s = 'Y.gr='+this.Y.gr+' Y.v='+this.Y.v;
	//let s = 'Y.gr='+this.Y.gr+' yv='+this.Y.v;
	//let s = 'distG='+this.simpleDist(game.Y.p, game.X.p);
	//if(this != mouse) s = 'y='+this.getVar('Y').p+' x='+this.getVar('X').p+'\n'+s;
	//let s = 'y='+this.Y.p+' x='+this.X.p+'\n';
	//this.m.displayText = s;
	this.m.displayText = '';
	//this.m.displayText = 'y='+this.getVar('Y').p+' x='+this.getVar('X').p+'\ndistG='+this.simpleDist(game.Y.p, game.X.p);
	
};


const randOf = list=>list[randInt(list.length)];

var isInGameNextState = false;

var numCallsGameNextState = 0;

//Example fields 'p' 'v' 'kv'. someVar.fieldGetter('p')() returns someVar.p
Var.prototype.fieldGetter = function(field){
	const thisVar = this;
	return ()=>(thisVar[field]);
};

//Example fields 'p' 'v' 'kv'. someVar.fieldSetter('p')(someVar.fieldGetter('p')+1) increments someVar.p
Var.prototype.fieldSetter = function(field){
	const thisVar = this;
	return val=>(thisVar[field] = val);
};

/*This makes (the next version of todo) the editor at the top left appear with input type=range sliders
of the selected Gob, in the selectedGobVarsDiv_table code, similar to this:
V.testnet.gob$Zxbv95B$dT3MVDu7Akt8PZNHAMeB4ZwNeats2TeDchR
Var.name	                       .p                              	.pr	.ps	.cv
Y	min=0 max=16777215
74972.52934667701
min=0 max=16777215
0	min=0 max=100
0	min=0 max=3
0
X	min=0 max=16777215
75182.65197622102
min=0 max=16777215
0	min=0 max=100
0	min=0 max=3
0
heightToWidthRatio	min=-5 max=5
0.9336636940953708	min=-5 max=5
0	min=0 max=100
0	min=0 max=3
0
make a new SigmoidNumEditor of that field in this Var such as to edit thisVar.cv or thisVar.p.
Theres some arbitrary interpretation involved in which var names (Y and X especially) get scaled how much
in the display of the editor, how much of the range of the slidebar (input type=range) means which number ranges,
but if you call fieldEditor again later it will use updated Var values to give you a more relevant editor.
*/
Var.prototype.fieldEditor = function(field){
	//the first 2 params of every gob.brain func should be Y and X which range 0 to 0xffffff.
	let isYX = this.name=='Y' || this.name=='X';
	let add = 0;
	let mul = 1;
	let hardMin = -(2**30);
	let hardMax = 2**30;
	if(field == 'name'){ //string name so uses a StringViewer instead of a SigmoidNumEditor. Its just for displaying the string in the table.
		return new StringViewer(this.name);
	}else if(field == 'path'){ //string name so uses a StringViewer instead of a SigmoidNumEditor. Its just for displaying the string in the table.
		return new StringViewer(this.path());
	}else if(field == 'p'){ //position
		if(isYX){
			add = this.p|0;
			mul = 300; //FIXME?
			hardMin = 0;
			hardMax = 0xffffff;
		}else{
			if((field.startsWith('is') || field.startsWith('do')) && (this.p===0 || this.p===1)){
				return new CheckboxVarEditor(this); //like for V.testnet.game.doRps
			}
			//add = this.p;
			add = 0; //FIXME?
			mul = 10; //FIXME?
			hardMin = -100;
			hardMax = 100;
		}
	}else if(field == 'v'){ //velocity
		add = 0;
		if(isYX){
			mul = 100; //FIXME?
		}else{
			mul = 10; //FIXME?
		}
		hardMin = -1000; //FIXME?
		hardMax = 1000; //FIXME?
	}else if(field == 'pr'){ //target position, that a simulated spring pushes toward
		if(isYX){
			add = this.p|0;
			mul = 500; //FIXME?
			hardMin = 0;
			hardMax = 0xffffff;
		}else{
			add = this.p;
			mul = 10; //FIXME?
			hardMin = -100; //FIXME
			hardMax = 100; //FIXME
		}
	}else if(field == 'ps'){ //strength of the pr spring
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else if(field == 'cv'){ //bases velocity decay
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else if(field == 'kv'){ //dynamic velocity decay, that in Var.nextState is reset to Var.cv
		//This should be a log scale from 0 up
		add = -5; //FIXME
		mul = 10; //FIXME
		hardMin = 0;
		hardMax = 30;
	}else{
		ave = 0; //FIXME?
		mul = 10; //FIXME?
		hardMin = -100;
		hardMax = 100;
	}
	return new SigmoidNumEditor(new NumEditor(this.fieldGetter(field), this.fieldSetter(field)), add, mul);
};

//returns a list of them which normally goes in VarEditors which is a list of lists of editors
Var.prototype.fieldEditors = function(){
	return [
		this.fieldEditor(game.isDisplayFullVarNamesInTable.p ? 'path' : 'name'),
		this.fieldEditor('v'),
		this.fieldEditor('p'),
		this.fieldEditor('pr'),
		this.fieldEditor('ps'),
		this.fieldEditor('cv'),
	];
};

//var LogScale = function(mul){
//	this.mul = mul;
//};
//LogScale.prototype.forward = function(val){
//	//FIXME how do i get it into range 0 to 1? Just use sigmoid? Use tanh for range -1 to 1?
//	return this.mul*Math.log(val);
//};

//set(get()+1) increments the val, for example.
var NumEditor = function(get, set){
	this.get = get;
	this.set = set;
};

//wrapMe is a NumEditor such as wrapping a raw Var.ps or Var.p or Var.kv
var SigmoidNumEditor = function(wrapMe, optionalAdd, optionalMul, optionalMin, optionalMax){
	this.add = optionalAdd || 0;
	this.mul = optionalMul || 1;
	this.min = optionalMin || (-(2**30));
	this.max = optionalMax || (2**30);
	this.wrapMe = wrapMe;
};

SigmoidNumEditor.prototype.get = function(){
	//return sigmoid(this.add+this.mul*this.wrapMe.get());
	return sigmoid((this.wrapMe.get()-this.add)/this.mul);
};

SigmoidNumEditor.prototype.set = function(val){
	//this.wrapMe.set((inverseSigmoid(val)-this.add)/this.mul);
	//this.wrapMe.set(inverseSigmoid(val+this.add)*this.mul);
	this.wrapMe.set(Math.max(this.min, Math.min(this.add+this.mul*inverseSigmoid(val), this.max)));
};

SigmoidNumEditor.prototype.updateDom = function(){
	if(!this.dom){
		Err('Have no dom');
	}
	let slider = document.getElementById(this.idPrefix+'_slider');
	let label = document.getElementById(this.idPrefix+'_label');
	let newVal = this.get();
	if(newVal != slider.valueAsNumber){ //less dom events, only if changed, cuz might interfere with mouse drag events of the slider
		slider.valueAsNumber = newVal;
		label.textContent = this.wrapMe.get();
	}
};

var NextIdNum = 1000;

SigmoidNumEditor.prototype.putInDom = function(dom){
	const thisEditor = this;
	this.idPrefix = 'sigmoidNumEditor_'+(NextIdNum++);
	let s = '';
	
	s += '<font color=gray>add='+this.add+' mul='+this.mul+'</font><br>';
	s += '<input type=range id='+this.idPrefix+'_slider min=0, max=1 step=.001></input><br>';
	s += '<label id='+this.idPrefix+'_label value='+this.wrapMe.get()+'></input><br>';
	
	/*
	for(let i=0; i<selectedGob.vars.length; i++){
		let v = selectedGob.vars[i];
		for(let field of fields){
			let slider = document.getElementById('slider_'+v.name+'_'+field);
			//dont mod dom nodes, which causes event problems if mouse is acting on it, unless it actually changed
			let changed = slider.valueAsNumber != v[field];
			if(changed){
				slider.valueAsNumber = v[field];
			}
			let isBigDim = (v.name == 'Y' || v.name == 'X') && field=='p';
			if(!isBigDim){
				//if(changed){
					let label = document.getElementById('label_'+v.name+'_'+field);
					//label.innerHTML = ''+v[field];
					label.textContent = ''+v[field];
				//}
			}
		}
	}
	*/
	
	
	//dom.innerHTML = 'SigmoidNumEditor, add='+this.add+' mul='+this.mul; //FIXME
	dom.innerHTML = s;
	
	let slider = document.getElementById(this.idPrefix+'_slider');
	slider.addEventListener('input', function(){
		let val = this.valueAsNumber;
		//let prevVal = v[field];
		//v[field] = val;
		let prevVal = thisEditor.get();
		thisEditor.set(val);
		//console.log('Set '+v.path()+'.'+field+' from '+prevVal+' to '+val);
		console.log('SigmoidNumEditor changed from '+prevVal+' to '+val);
	});
	
	this.dom = dom;
};

//like SigmoidNumEditor but made for viewing its string Var.name. Goes in VarEditors (list of lists of editor).
var StringViewer = function(str){
	this.str = str;
};

StringViewer.prototype.putInDom = function(dom){
	dom.innerHTML = this.str;
	this.dom = dom;
};

StringViewer.prototype.updateDom = function(){
	//do nothing. updateDom is just here for compatibility with SigmoidNumEditor
};

//for Var's whose value is 0 or 1, like V.testnet.game.doRps turns Rock Paper Scissors mode on/off.
//Puts a checkbox on screen that mods that var.p when clicked and updates itself on screen if Var changes
//after polling using this.updateDom();
var CheckboxVarEditor = function(theVar, optionalText){
	this.bo = theVar; //bo is opposite spelling of ob (object). object.bo gets Var. Var.ob gets object.
	this.text = optionalText || theVar.path();
};

CheckboxVarEditor.prototype.putInDom = function(dom){
	const thisEditor = this;
	this.idPrefix = 'checkboxVarEditor_'+(NextIdNum++);
	let firstVal = !!theVar.p;
	let s = '<input type=checkbox id='+this.idPrefix+'_chk '+(firstVal?'checked':'')+'></input><label for='+this.idPrefix+'_chk value="'+this.text+'"></label>';
	dom.innerHTML = s;
	this.dom = dom;
	let chk = document.getElementById(this.idPrefix+'_chk');
	slider.addEventListener('input', function(){
		this.bo.p = this.checked ? 1 : 0;
		console.log('CheckboxVarEditor '+this.bo.path()+'.p = '+this.bo.p);
	});
};

CheckboxVarEditor.prototype.updateDom = function(){
	if(!this.dom){
		Err('Have no dom');
	}
	let chk = document.getElementById(this.idPrefix+'_chk');
	let newVal = !!this.bo.p;
	if(chk.checked !== newVal){
		chk.checked = newVal;
	}
};

CheckboxVarEditor.prototype.deleteDom = StringViewer.prototype.deleteDom = SigmoidNumEditor.prototype.deleteDom = function(){
	if(this.dom){
		this.dom.innerHTML = '';
		delete this.dom;
	}
};


Game.prototype.nextState = function(dt){
	numCallsGameNextState++;
	if(isInGameNextState){
		throw new Error('Already in game.nextState. Probably a thread error');
	}
	try{
		isInGameNextState = true;

		this.sparseUpdate(); //replace game.gobs with near Gobs from the Var tree.
		
		let mouseMoved = (game.prevMouseY===undefined || game.prevMouseY!==Controls.mouseY || game.prevMouseX!==Controls.mouseX);
		if(enableTestGroundPaintMouse && mouseMoved){
			testGroundPaintAtMouse(); //FIXME remove this. it paints game.ground
		}
		if(enableTestPaintMouse && mouseMoved){
			testPaintAtMouse(); //FIXME remove this. it paints a pixel on game.wal (a BigTile) to test the terrain system.
		}
		game.prevMouseY = Controls.mouseY;
		game.prevMouseX = Controls.mouseX;
		//
		game.wal.sync();
		game.wal.paintGame();

		//if(game.rps){ //rock paper scissors per voxel
		if(this.doRps.p){
			let tridistComputeHAndW = 256;
			let border = 32;
			for(let repeat=0; repeat<2; repeat++){ //normal
			//for(let repeat=0; repeat<1; repeat++){ //for testing
				//let smallCenterY = Controls.mouseY>>MagnifyShift;
				//let smallCenterX = Controls.mouseX>>MagnifyShift;
				
				let smallCenterY = (Controls.mouseY&SizeMask)>>MagnifyShift;
				let smallCenterX = (Controls.mouseX&SizeMask)>>MagnifyShift;
				
				//if(Math.random()<.5){
				if(repeat==1){
					if(this.gobs.length && Math.random()<.5){ //pick a gob at random, then pick a voxel in it at random, and center there, so gobs are updated more often
						//tridistComputeHAndW /= 2; //FIXME remove this?
						//border /= 2; //FIXME remove this?
						let randGob = randOf(this.gobs);
						let voxels = randGob.voxInGame;
						if(voxels && voxels.length){ //if its displaying at least 1 voxel in game.board
							let randVoxel = randOf(voxels); //only has 8k X 8k position, even if its bigger and wrapped around that, so dont need to &SizeMask.
							smallCenterY = IY(randVoxel)>>>MagnifyShift;
							smallCenterX = IX(randVoxel)>>>MagnifyShift;
						}
					}else{ //random in whole game area
						smallCenterY = randInt(SmallSize); //FIXME what if it hangs off the edge?
						smallCenterX = randInt(SmallSize);
					}
				}
				let smallFromY = smallCenterY-(tridistComputeHAndW>>1);
				let smallToY = smallFromY+tridistComputeHAndW;
				let smallFromX = smallCenterX-(tridistComputeHAndW>>1);
				let smallToX = smallFromX+tridistComputeHAndW;
				//console.log('smallFromY='+smallFromY);
				this.updateTridist(smallFromY, smallToY, smallFromX, smallToX, border); //arbitrary rectangle. can be any rect in the 2048x2048 board. game.rps.tridistSmall, not .tridist.
			}
		}

		for(let gob of this.gobs){
			gob.doPhysicsA();
		}
		for(let gob of this.gobs){
			//gob.setAllVars0Speed(); //FIXME remove this. in theory it makes it only update positions without velocities, by Var.gp
			gob.doPhysicsB(dt);
		}
		for(let gob of this.gobs){
			gob.stepC(); //update gob.m.displayText etc. debug stuff.
		}
		if(this.doRps.p){
			for(let gob of this.gobs){
				gob.doTeamLogic();
			}
		}
		
		//select gob by distance to mouse
		//FIXME use different coordinates for mouse relative to screen or canvas vs relative to game coords which are an 8192 side square.
		let bestGob = null;
		let bestDist = Infinity;
		for(let gob of game.gobs){
			if(gob.m.isSelectable){ //normally this only excludes the mouse gob
				let dist = gob.dist(Controls.mouseY,Controls.mouseX);
				if(dist < bestDist){
					bestGob = gob;
					bestDist = dist;
				}
			}
		}
		let maxDistToSelectGob = 50;
		if(bestDist < maxDistToSelectGob){
			console.log('Select gob '+bestGob);
			game.setSelectedGob(bestGob);
		}
		
		/*for(let smallY=0; smallY<SmallSize; smallY++){
			let smallX = smallY;
			let smallI = ((smallY<<SmallSizeBits) | smallX);
			this.rps.tridistSmall[smallI] = randInt(1<<30); //3 random uint10s
		}*/
		
		//let fpsMul = Math.exp(-dt*this.stats.fpsDecay);
		//this.stats.fpsVal = this.stats.fpsVal*fpsMul+(1-fpsMul)/dt; //*1 cuz its 1 more frame
		//this.stats.fpsVal = this.stats.fpsVal*Math.exp(-dt*this.stats.fpsDecay)+this.stats.fpsDecay;
		this.stats.fpsVal = this.stats.fpsVal*(1-dt)+1;
		
		/*let s = 'Game.logMap eval:';
		for(let k in game.logMap){
			s += '\n'+k+': '+game.logMap[k](); //TODO shouldnt have to write game twice. see how i did it in dagball. was it a global instance (dagball.something...)?
		}
		console.log(s);
		*/
		//document.title = 'M'+game.rps.boardR[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame';
		//document.title = 'Tridist'+game.rps.tridist[mouseI()]+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
		//let tridist = game.rps.tridist[mouseI()];
		
		/*//FIXME remove distStr logging, added 2024-11-21 cuz sparseUpdate is making gobs appear and disappear in confusing ways
		let distStr = 'game.Y.p='+game.Y.p+' game.X.p='+game.X.p;
		for(let gob of game.gobs){
			distStr += '\n'+gob.dist(game.Y.p, game.X.p);
		}
		console.log(distStr);
		*/
		
		
		let tridist = game.rps.tridistSmall[toSmall(mouseI())];
		
		//if(Math.random()<.0001) console.log('FIXME put a string filtering function (should be Game.prototype.canEval = function(jsCode), search for that) as part of game.something game.jsFirewall or something. game.jsFirewall("while(true);") false, dont wanna infinite loop, if knew to check for that. but i just wanna define a pattern of JS code that is complex enough to be interesting as game content and to make things very strategic and lead to combos of AI experiments, but which doesnt allow calling just any arbitrary function. I want it sandboxed enough to know how many flops at most it can do, or some max it could do, that it cant ever do more, but it may always do alot less, proof based. Thats future research to do in javascript, after i have done it in Wikibinator203. The.whole.game.state.across.the.earth will be a sparse dimensional vector, and you can literally dot-product it with other game states, though i wouldnt expect that to be very useful cuz of some dimensions having far more effect in some combos than others. [anything to the contrary adding to loss function and accelerated by negative gradient] includes every possible algebra equation. \nTODO putLiveBlobMonstersGameOnlineAtSomeWebsite');
		//console.log('cShapedGob.y='+cShapedGob.Y.p+' yv='+cShapedGob.Y.v);
		
		//if(numCallsGameNextState&8){ //less often, so it doesnt slow things down
		if(numCallsGameNextState){
			let fields = ['p', 'pr', 'ps', 'cv'];
			let selectedGob = SEL();
			if(selectedGob){
				let table = document.getElementById('selectedGobVarsDiv_table');
				if(table){
					for(let row of VarEditors){
						for(let editor of row){
							editor.updateDom();
						}
					}
					/*todo SigmoidNumEditor should do this.
					for(let i=0; i<selectedGob.vars.length; i++){
						let v = selectedGob.vars[i];
						for(let field of fields){
							let slider = document.getElementById('slider_'+v.name+'_'+field);
							//dont mod dom nodes, which causes event problems if mouse is acting on it, unless it actually changed
							let changed = slider.valueAsNumber != v[field];
							if(changed){
								slider.valueAsNumber = v[field];
							}
							let isBigDim = (v.name == 'Y' || v.name == 'X') && field=='p';
							if(!isBigDim){
								//if(changed){
									let label = document.getElementById('label_'+v.name+'_'+field);
									//label.innerHTML = ''+v[field];
									label.textContent = ''+v[field];
								//}
							}
						}
					}*/
				}else if(numCallsGameNextState&8){ //less often, so it doesnt slow things down{
					let s = '';
					//let s = '<div id=selectedGobVarsDiv_table>';
					//let s = selectedGob.bo.path();
					//TODO use Var.fieldEditor
					//they go in VarEditors. Todo('use Var.fieldEditor. Decide where to store them. in the Gob? In the Var? In game? In some {} like Controls?');
					s += '<table id=selectedGobVarsDiv_table border=0>';
					s += '<thead><tr><th>Var.name</th><th>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;velocity .v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th><th>&nbsp;&nbsp;&nbsp;&nbsp;position .p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th><th>target position .pr</th><th>spring strength .ps</th><th>base velocity decay .cv</th></tr></thead>';
					/*for(let i=0; i<selectedGob.vars.length; i++){
						let v = selectedGob.vars[i];
						let min = -5, max = 5; //FIXME what range?
						let step = .01;
						let isBigDim = v.name == 'Y' || v.name == 'X';
						if(isBigDim){
							min = 0;
							max = 0xffffff;
							step = 1;
						}
						let cvMin = 0;
						let cvMax = 3;
						let cvStep = .01;
						
						let vPath = v.path();
						//if(i) s += '<br>\n';
						s += '<tr><td>';
						//s += '<nobr>';
						
						//s += '<div style="background-color:gray">';

						s += v.name;
						
						s += '</td><td>';
						
						myMin = min;
						myMax = max;
						myStep = step;
						//s += '<div style="background-color:red;float:left">';
						//s += '<input type=range id=slider_'+v.name+'_p onchange="console.log(\'event=\'+event+\' vPath=+'+vPath+'\'); '+vPath+'.p = Math.random();"></input><br>';
						s += 'min='+myMin+' max='+myMax+'<br>';
						s += '<input type='+(isBigDim?'number':'range')+' id=slider_'+v.name+'_p  min='+min+' max='+max+' step='+step+' value='+v.p+'></input><br>';
						if(!isBigDim) s += '<label id=label_'+v.name+'_p value='+v.p+'></label>';
						//s += '</div>';
						
						s += '</td><td>';
						
						myMin = min;
						myMax = max;
						myStep = step;
						//myMin = (v.p/1.1)|0;
						//myMax = (v.p*1.1)|0;
						myStep = step;
						//s += '<div style="background-color:green;border:2;float:left">';
						s += 'min='+myMin+' max='+myMax+'<br>';
						s += '<input type=range id=slider_'+v.name+'_pr min='+myMin+' max='+myMax+' step='+myStep+' value='+v.pr+'></input><br>';
						s += '<label id=label_'+v.name+'_pr '+v.pr+'></label>';
						//s += '</div>';
						
						s += '</td><td>';
						
						myMin = 0;
						myMax = 100; //FIXME do log scale
						myStep = .1;
						//s += '<div style="background-color:blue;float:left">';
						s += 'min='+myMin+' max='+myMax+'<br>';
						s += '<input type=range id=slider_'+v.name+'_ps min='+myMin+' max='+myMax+' step='+myStep+' value='+v.ps+'></input><br>';
						s += '<label id=label_'+v.name+'_ps>'+v.ps+'</label>';
						//s += '</div>';
						
						s += '</td><td>';
						
						//s += '<div style="background-color:orange;clear:both">';
						myMin = 0;
						myMax = 3;
						myStep = .01;
						s += 'min='+myMin+' max='+myMax+'<br>';
						s += '<input type=range id=slider_'+v.name+'_cv min='+myMin+' max='+myMax+' step='+myStep+' value='+v.cv+'></input><br>';
						s += '<label id=label_'+v.name+'_cv value='+v.cv+'></label>';
						//s += '</div>';
						
						//s += '</div>';
						//s += '<br>';
						
						s += '</td></tr>\n';
						//s += '</nobr><br>';
					}
					s += '</table>';
					//s += '</div>';
					console.log('Replacing table');
					let selectedGobVarsDiv = document.getElementById('selectedGobVarsDiv');
					selectedGobVarsDiv.innerHTML = s;
					//doesnt work makeDomNodeSizeConstant(selectedGobVarsDiv);
					for(let i=0; i<selectedGob.vars.length; i++){
						let v = selectedGob.vars[i];
						for(let field of fields){
							//document.getElementById('slider_'+v.name+'_'+field).addEventListener('change', function(){
							document.getElementById('slider_'+v.name+'_'+field).addEventListener('input', function(){
								let val = this.valueAsNumber;
								let prevVal = v[field];
								v[field] = val;
								console.log('Set '+v.path()+'.'+field+' from '+prevVal+' to '+val);
								//console.log('event at slider_'+v.name+'_'+field);
							});
						}
					}*/
				
				
					while(VarEditors.length){ //list of lists of editors displayed at top right. TODO get rid of older ones before
						let lastRow = VarEditors.pop();
						while(lastRow.length){
							let lastEditor = lastRow.pop();
							lastEditor.deleteDom();
						}
					}
					for(let i=0; i<selectedGob.vars.length; i++){
						let row = selectedGob.vars[i].fieldEditors();
						if(row.length != 6){
							Err('row.length='+row.length+' so need to update thead tag and this IF');
						}
						s += '<tr>';
						for(let e=0; e<row.length; e++){
							s += '<td id=td_'+i+'_'+e+'></td>';
						}
						s += '</tr>\n';
						VarEditors.push(row);
					}
					
					s += '</table>';
					console.log('Replacing table');
					let selectedGobVarsDiv = document.getElementById('selectedGobVarsDiv');
					selectedGobVarsDiv.innerHTML = s;
					for(let i=0; i<VarEditors.length; i++){
						for(let e=0; e<VarEditors[i].length; e++){
							let dom = document.getElementById('td_'+i+'_'+e);
							VarEditors[i][e].putInDom(dom); //TODO puts input type=range, a label, and events in the <td>, like to edit Var.pr
						}
					}
				}
			}
			
			//let s = 'MouseY '+Controls.mouseY+'X'+Controls.mouseX+' '+'R'+getDistance1(tridist)+' G'+getDistance2(tridist)+' B'+getDistance3(tridist)+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
			//let s = 'gameyxDist='+mouse.simpleDist(game.Y.p, game.X.p)+' FPS='+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
			let s = (game.Y.p|0)+','+(game.X.p|0)+' FPS'+(this.stats.fpsVal|0)+' BlobMonsterGame'; //TODO display R G B each as a uint10 from tridist.
			if(Controls.pause) s = 'Paused '+s;
			document.title = s;
		}
		
	}finally{
		isInGameNextState = false;
	}
};

/*doesnt work var makeDomNodeSizeConstant = node=>{
    var computedStyle = window.getComputedStyle(node);
    node.style.width = computedStyle.width;
    node.style.height = computedStyle.height;
    node.style.overflow = 'auto'; // Add overflow auto to handle content that might exceed the set dimensions
};*/


var VS = new VoxStream();

var getNamespace = nameOrBig=>(V[nameOrBig]);

//V is the root Var of the tree of Vars. Each Var is a time-series of .p/position and .v/velocity and .t/time. gob.influence like dagball.Circ.influence
//and dagball.Ball.influence is a Var that if its .p/value is 1 it exists and if 0 does not exist, in that namespace.
const V = new Var(null, 'V'); //var Var = function(optionalParentVar, optionalName, optionalBig, optionalGob)
//child of V which is the root Var for all possible namespaces
//(make up any string, or hash a bigger string) and use the hash as the namespace string.
var NS = getNamespace(DefaultNamespaceName);

//paint them using ghostVox onto game.board's color in low 6 bits of relevant ints.
Game.prototype.addCoordinateLines = function(){
	//paint coordinate lines, horizontal and vertical, as a 32x32 grid of 256x256 pixels each.
	//for(let y=0; y<Size; y+=256){
	//for(let y=0; y<Size; y+=1024){
	for(let y=0; y<Size; y+=Size){
		for(let x=0; x<Size; x++){
			//for(let thick=0; thick<25; thick++){
				//game.ghostVox(YXC(y+thick,x,randInt(Colors)));
				//for(let i=0; i<15; i++) game.ghostVox(YXC(y+randInt(21)-11,x,randInt(Colors)));
				for(let i=0; i<55; i++) game.ghostVox(YXC(y+randInt(500)-250,x,randInt(Colors)));
			//}
		}
	}
	for(let y=0; y<Size; y+=256){
		for(let x=0; x<Size; x++){
			game.ghostVox(YXC(y+randInt(21)-11,x,randInt(Colors)));
		}
	}
	//for(let x=0; x<Size; x+=256){
	//for(let x=0; x<Size; x+=1024){
	for(let x=0; x<Size; x+=Size){
	//for(let x=0; x<Size; x+1000){
		for(let y=0; y<Size; y++){
			//game.ghostVox(YXC(y,x,randInt(Colors)));
			//game.ghostVox(YXC(y,x+randInt(21)-11,randInt(Colors)));
			for(let i=0; i<55; i++) game.ghostVox(YXC(y,x+randInt(500)-250,randInt(Colors)));
		}
	}
	for(let x=0; x<Size; x+=256){
		for(let y=0; y<Size; y++){
			game.ghostVox(YXC(y,x+randInt(21)-11,randInt(Colors)));
		}
	}
};

//V.testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(.0001*(m.p*x*x+b.p), x, 0b000011)); return voxs; }'] === V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8
//But it only works if you give it the big string first.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p and .v are the
//m var's position and velocity. still buggy, seems to be duplicating some of the Var objects. but .think()
//should use those .m and .b vars cuz theyre in the code string hashed.
//V.testnet.sha256$ea1b94321c7384133138e7e4a75cee3cef24fa2ec0a1a829827ee878193b15f8.m.p would be a global var,
//that exists across the earth could be updated at gaming low lag. The tree of Var's is potentially endless.
//put whatever strings in there u want. turing complete game sync
//http://V.this.is.a.turing.complete.vector.system['(sideA,sideB)=>([Math.hypot(sideA,sideB)])'].testnet['(m,b)=>{ let voxs = []; for(let x=0; x<500; x++) voxs.push(YXC(0, 0, 0b000011)); return voxs; }'].think() returns int voxels & worldwide shared high dimensional vectors.
//The vectors already do sparse dimensional high dimensional gradients. Huge swarms of dimensions.
//This worldwide vector system should be used as a constraint solver aka potential energy or loss minimizer.
//V.turing.complete.poten += amount to add to loss.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].big
'(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].path()
//'V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e'
//V.testnet.big
//null
//even tho it was smaller than the generated hash, it couldnt be a js var name. had ( and other chars not allowed. so hashed it.
//V.testnet['(sideA,sideB)=>([Math.hypot(sideA.p,sideB.p)])'].shittyVarName would work too, even though theres no such variable.
//Its just a tree. It doesnt care what you name things or how big it is. If its big or not a valid JS var name, it will hash it
//and use that instead.
//what im trying to build across the world is that anyone anywhere can run a peer to peer swarm to all have the same number
//for V.testnet.sha256$7acc8fd3d907471879f10c4a4e617db06b3ab29328d8c8d1329ef2971c78995e.shittyVarName or any other made up
//path, swarms streams of sparse vectors

var game = new Game(NS.game);
if(paintCoordinateLinesAtBoot){
	game.addCoordinateLines();
}



const sigmoid = x=>(1/(1+Math.exp(-x)));

const inverseSigmoid = x=>{
	x = Math.max(0, Math.min(x, 1)); //so outside that range its -Infinity or Infinity, instead of NaN
	return Math.log(x/(1-x));
}

//const numReshapingRects = graphicsLev>1 ? 50 : 12; 
const numReshapingRects = graphicsLev>1 ? 30 : 12; 
//const numReshapingRects = graphicsLev>1 ? 20 : 10; 
for(let i=0; i<numReshapingRects; i++){
//let targetY = 504250;
//let targetX = 504400;
let targetY = 74250;
let targetX = 74400;
if(10 <= i && i < 500){
	targetY += randInt(2000)-1000;
	targetX += randInt(2000)-1000;
}
if(500 <= i){
	targetY += randInt(5000)-2500;
	targetX += randInt(5000)-2500 + Size; //1 8kX8k to the right, test wrapping
}
game.addFunc(`(Y/*${targetY}*/, X/*${targetX}*/, heightToWidthRatio)=>{
	let i = ${i};
	//const m = centerY.gob.m;
	//const oy = m.oy, ox = m.ox;
	//dont use this, wrap instead: const [oy,ox] = centerY.oyx();
	//let area = 400;
	let area = 2400;
	//let area = 8400;
	/*if(gob.m.isSelected){
		area *= 5; //experiment. FIXME remove this
	}*/
	let ratio = .2+2*sigmoid(heightToWidthRatio.p*.2-.1);
	//let ratio = Math.tanh(heightToWidthRatio.p*.3);
	//let ratio = Math.exp(heightToWidthRatio.p*.5);
	//let ratio = Math.max(.2, Math.min(heightToWidthRatio.p, 5));
	//let ratio = 1;
	
	//FIXME this doesnt look like the right calculation. should ratio go in the sqrt? do algebra.
	//Use my NsatDesignToolGpu https://tinyurl.com/NsatDesignToolGpu if needed,
	//can brute force up to 40 bit vars, which u can mount uintN's in totalling at most 40 bits.
	
	let h = Math.ceil(ratio*Math.sqrt(area));
	
	let w = Math.ceil(area/h);
	/*let fromY = (centerY.p|0) - 20;
	let fromX = (centerX.p|0) - 20;
	let toY = fromY+40;
	let toX = fromX+40;
	*/
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array. Update: Float64Array if has nonzero z.
	let maxDistToEdge = Math.max(1,Math.min(toY-fromY,toX-fromX)/2);
	for(let y=fromY; y<toY; y++){
		let distToEdgeY = Math.min(y-fromY,toY-1-y);
		for(let x=fromX; x<toX; x++){
			let distToEdgeX = Math.min(x-fromX,toX-1-x);
			let distToEdge = Math.min(distToEdgeY,distToEdgeX);
			let distanceFraction = distToEdge/maxDistToEdge; //distance to edge as fraction of max distance to edge
			let color = 63-i;
			ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			//z is uint21 but careful that multiple voxels from other gobs dont sum to more than that
			//let z = Math.random()*3000;
			//let z = (y<<8)&0xfff;
			//let z = (distanceFraction*DefaultZ*2)&0xfff;
			//let z = (distanceFraction*DefaultZ*2)|0;
			
			//let z = (distanceFraction*DefaultZ*2 + 1)|0;
			//ret.push(ZYXC(z,y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
		}
	}
	Y.poten += .01*Math.hypot(Y.p-${targetY},X.p-${targetX})**2; //attract to that
	heightToWidthRatio.poten += .03*(heightToWidthRatio.p-1)**2;
	//centerY.kv += 3;
	//centerX.kv += 3;
	//centerY.kv += .1;
	//centerX.kv += .1;
	Y.kv += .3;
	X.kv += .3;
	//heightToWidthRatio.kv += .003;
	heightToWidthRatio.kv += .01141;
	return ret;
}`);
}

//game.addFunc((centerY=VarP(700), centerX=VarPV(700,100), heightToWidthRatio=VarP(1))=>{
game.addFunc((Y/*74310*/, X/*74300 10*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 4000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//Y.poten += .1*Math.hypot(Y.p-4150,X.p-4175)**2; //attract to that
	Y.poten += .1*((Y.p-74150)**2 + (X.p-74175)**2); //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

game.addFunc((Y/*4710*/, X/*4700 10*/)=>{
	//in top left 8kX8k block. for debugging.
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*((Y.p-4650)**2 + (X.p-4675)**2); //attract to that
	Y.kv += .1;
	X.kv += .1;
	return ret;
});

/*const cShapedGob = game.addFunc((Y/*74300*, X/*74800 100*, areaMul, angle)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	//let area = 90000; //before cut circle out of it
	let area = 20000*(1+9*sigmoid(areaMul.p*.01)); //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX+40;
	//let otherRR = rr*sigmoid(rrMul.p)*.5;
	let otherRR = rr*.8;
	let otherR = Math.sqrt(otherRR);
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			//let otherDx = otherX-x;
			//let otherSquaredDist = dy*dy + otherDx*otherDx;
			let dist = Math.sqrt(squaredDist);
			let distFraction = dist/radius;
			let middleRadiusFract = .8;
			//let ang = yxAngle+angle.p*5;
			//let angFrac = .6+.4*Math.cos(ang);
			//zFraction *= .6+.4*Math.cos(ang);
			//let yxAngle = Math.atan2(dy,dx);
			let middleRadiusThick = .2; //TODO make it vary by angle
			let zFraction = Math.max(0,1-Math.abs((distFraction-middleRadiusFract)/middleRadiusThick));
			//zFraction *= .6+.4*Math.cos(ang);
			//if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
			if(zFraction){ //fixme removing z going back to intVoxelsOnly
				let color = 0b111111;
				//ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
				//let fraction = (squaredDist-otherSquaredDist)/(rr-otherRR);
				//let fraction = squaredDist/rr;
				//let fraction = (rr-squaredDist)/rr;
				//let fraction = (squaredDist-otherSquaredDist)/(rr-otherRR);
				//let distA = Math.sqrt(squaredDist);
				
				
				
				/*let distB = Math.sqrt(otherSquaredDist);
				//let zFraction = (distB-distA)*.03; //FIXME not a fraction
				let zFraction = (distB-otherR)*.03; //FIXME not a fraction
				zFraction = Math.max(0, Math.min(zFraction, 1));
				*
				//let zFraction = Math.min(fraction,1-fraction)*2;
				//let zFraction = Math.min(fraction,1-fraction)*2;
				//ret.push(ZYXC((.001*DefaultZ*zFraction)&0xfffff,y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
				
				
				//ret.push(ZYXC((DefaultZ*zFraction)&0xfffff,y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*Math.hypot(Y.p-74200,X.p-74375)**2; //attract to that
	areaMul.poten += 11.01*areaMul.p**2;
	areaMul.kv += .9;
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .2;
	X.kv += .2;
	//heightToWidthRatio.kv += .003;
	return ret;
});
*/
const cShapedGob = game.addFunc((Y/*74300*/, X/*74800 100*/, areaMul, angle)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 20000*(1+9*sigmoid(areaMul.p*.01)); //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX+40;
	let otherRR = rr*.8;
	let otherR = Math.sqrt(otherRR);
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			let otherDx = otherX-x;
			let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b110011;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	Y.poten += .1*Math.hypot(Y.p-74200,X.p-74375)**2; //attract to that
	areaMul.poten += 11.01*areaMul.p**2;
	areaMul.kv += .9;
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .2;
	X.kv += .2;
	//heightToWidthRatio.kv += .003;
	return ret;
});



const donutShapedGob = game.addFunc((Y/*74000*/, X/*74000*/)=>{
	//P or P V or P V E or P V E A. position velocity epsilon accelMul. You specify the first 0, 1, 2, 3, or 4 of those.
	let area = 120000; //before cut circle out of it
	//let ratio = .2+2*sigmoid(heightToWidthRatio.p*.04-.02);		
	//let h = Math.ceil(ratio*Math.sqrt(area));
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	let otherX = actualCenterX;
	let otherRR = rr*.58;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			let otherDx = otherX-x;
			let otherSquaredDist = dy*dy + otherDx*otherDx;
			if(squaredDist < rr && !(otherSquaredDist < otherRR)){ //paint circle
				let color = 0b111111;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//Y.poten += .1*Math.hypot(Y.p-4200,X.p-4375)**2; //attract to that
	//TODO something like this instead of hypot: startY.poten += .1*((centerY.p-400)**2 + (centerX.p-750)**2); //attract to that
	//heightToWidthRatio.poten += 2.671*(heightToWidthRatio.p-1)**2;
	Y.kv += .1;
	X.kv += .1;
	//heightToWidthRatio.kv += .003;
	return ret;
});

const Ave = floats=>{
	if(!floats.length) return 0;
	let sum = 0;
	for(let i=0; i<floats.length; i++) sum += floats[i];
	return sum/floats.length;
};

const Dev = (floats, optionalAve)=>{
	let ave = optionalAve===undefined ? Ave(floats) : optionalAve;
	let sumOfSquares = 0;
	for(let i=0; i<floats.length; i++) sumOfSquares += floats[i]**2;
	return Math.sqrt(sumOfSquares/floats.length);
};

const AveDev = floats=>{
	let ave = Ave(floats);
	return [ave,Dev(floats,ave)];
};















/* Dagball quicksaves are way too big (250kB) cuz dense pic of 1 bit pixels of wall vs open area. Sparse quadtree bloom filter
of 2 bits per node so sync easy across net. 00 means transparent / leave it as it is.
01 means 0. 10 means 1. 11 means 4 way branch https://en.wikipedia.org/wiki/Quadtree
A feature of this kind of image compression is its deterministic and has no room to sneak in metadata.

a sparse matrix of bits optimized for 2d powOf2 aligned powOf2 sized squares
//that are all 0s, all 1s, or all transparent (to leave it as it is).
//The max size is 8/3 bits per pixel. It will usually be closer to .01 bits per pixel
//if the shapes are simple, lots of thick areas of all 0s and other areas of all 1s.
//This is meant to be used with dagball.BitPic of size 1024x1024 or 4096x4096 or 32x32 etc.
//This will normally be stored in wholeGameState instead of a BitPic cuz this will
//make the .dagball/json files many times smaller (they are around 253kB now, and most of that is bitpic).
//
//Data format: Its a list of blocks. Each block is 2 bits and is 1 of these symbols:
//00 - transparent/unspecified, leave it as it is.
//01 - all 0s in this square and recursively smaller down to infinitely small.
//10 - all 1s in this square and recursively smaller down to infinitely small.
//11 - branch with 4 blocks.
//This often wont align on byte or int sizes so pad with 00s.
//
//This is called BloomPic cuz its a kind of bloomFilter but with disproofByContradiction built in
//per bit (which is 2 bits) so across network if there is disagreement
//on where the walls (10) vs open areas (01) are, so both cant be true.
//
//FIXME use 2 bits per wall/open pixel in BitPic?
//
dagball.BloomPic = function(ints){
	this.height = height;
	this.width = width;
	this.ints = ints;
};

It uses 2-bit blocks. 11 is followed by 4 nodes as 2x2. 10 is white. 01 is black. 00 is transparent. At any depth,
it can color the whole thing white, black, or transparent, any power of 2 aligned and sized square. And thats it.
Just recurse that and it cuts away huge solid areas.
*/
dagball.BloomTree = function(bytes){
	this.bytes = bytes;
};

//it only cares about the first char. but which endian?
var firstUint2InBase64 = function(base64){
	Todo();
};

dagball.BloomTree.prototype.type = 'dagball_bloomtree';

dagball.BloomTree.prototype.read = function(index){ //returns 0 1 2 or 3. Index is in units of uint2s.
	//index = index*2;
	//return (this.bytes[index>>3]>>(index&7))&3;
	let b = this.bytes[index>>2];
	let lowestBitIndexInByte = 6-((index&3)<<1);
	return (b>>lowestBitIndexInByte)&3;
};

//index is in units of int2s.
dagball.writeInt2IntoBytes = function(bytes, index, int2){
	let byteIndex = index>>2;
	let prevByte = bytes[byteIndex];
	//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
	let lowestBitIndexInByte = 6-((index&3)<<1);
	//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
	let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
	bytes[byteIndex] = prevByteWithoutThose2Bits | (int2<<lowestBitIndexInByte);
};

dagball.BloomTree.prototype.write = function(index, num){ //write 0 1 2 or 3
	return dagball.writeInt2IntoBytes(this.bytes, index, num);
	/*
	//let highBit = (num>>1)&1;
	//let lowBit = num&1;
	//TODO optimize by writing 2 bits at a time
	//this.writeBit(index*2, lowBit); //FIXME should this endian be swapped?
	//this.writeBit(index*2+1, highBit); //FIXME should this endian be swapped?
	let byteIndex = index>>2;
	let prevByte = this.bytes[byteIndex];
	//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
	let lowestBitIndexInByte = 6-((index&3)<<1);
	//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
	let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
	this.bytes[byteIndex] = prevByteWithoutThose2Bits | (num<<lowestBitIndexInByte);
	*/
};

dagball.BloomTree.prototype.toMap = function(){
	return {
		type: this.type,
		base64: dagball.bytesToBase64(this.bytes),
	};
};

dagball.mapToBloomTree = function(map){
	if(!map || !map.base64){
		Err('Some stuff missing: '+JSON.stringify(map));
	}
	if(map.type != 'dagball_bloomtree'){
		Err('Not a dagball_bloomtree: '+JSON.stringify(map));
	}
	return new dagball.BloomTree(dagball.base64ToBytes(map.base64));
};

/*dagball.bloomTransparent = 0b00; //leaf transparent / leave the bitpic pixel as it is
dagball.bloomOpen = 0b01; //leaf open
dagball.bloomWall = 0b10; //leaf wall
dagball.bloomBranch = 0b11; //4 way branch
*/
dagball.bloomTransparent = WQTRAN; //leaf transparent / leave the bitpic pixel as it is. Same constants in Dagball and Blob Monsters Game.
dagball.bloomOpen = WQOPEN; //leaf open
dagball.bloomWall = WQWALL; //leaf wall
dagball.bloomBranch = WQFORK; //4 way branch

dagball.isPowOf2 = function(x){
	return (x&(x-1))==0;
};

/* use BigPic instead.

//Mutable, normally 2**20 X 2**20 pic of 2 bits per pixel that can be WQTRAN, WQOPEN, WQWALL, or internal nodes WQFORK as quadtree,
//with parts 256x256 and smaller compressed by dagball.Bloomtree base64.
//FIXME if WallQuad is immutable then i cant share BitPics between it and game.wab if I modify them in game.wab
//to then convert them to WallQuad which is used as immutable. I could do it with twice as many, still sparse, BitPics 256x256.
//Id like to, but its probably too slow, use uint53 voxels, 41 bits of binheap for 2**20 X 2**20, 6 bit color,
//2 bit WQTRAN, WQOPEN, WQWALL, or internal nodes WQFORK, 4 bit team mask, totals 53 bits,
//which is slow cuz of recursing 1-2 bits at a time for quadtree all the way down those 41 bits as binheap indexing,
//and using it in float64 makes it slower. Im sticking with the int voxels (13 bits y, 13 bits x, 6 bits color) in 8192 X 8192
//that wrap around (&8191) so you can view 8kX8k areas of the 1mX1m whole game area.
//BitPic, WallQuad, etc, are for walls, which I want to not be wrapped around 8k but be the whole 1m X 1m space at once sparsely.
//As Im building it im finding WallQuad hard to use cuz it doesnt let you modify just 1 pixel at a time
//which is cuz it stores base64 compressed form of 256x256 (or smaller).
//Im thinking of turning them all into (y,x,height) funcs.
dagball.SparseBitPic = function(){
	Todo();
};
*/


//UPDATE: 2024-1-1+ changing this.ints to this.bytes to avoid having to deal with endian.
//This is for painting walls that balls bounce and lay on. Circs are an expensive game object.
//You can have alot of 1 bit wall pixels compared to that, such as 4k x 4k of them is 2mB.
//Circs have infinite (actually up to float32 precision) resolution similar to SVG. These walls dont.
//a pic of 1 bit color per pixel. stored in Int32Array. Wall is 1. Open area is 0.
//For physics, this should be used in gradient/potens func and add to potentialEnergy
//right after GPU comnputes potentialEnergy, but this is done by CPU.
//For each ball, sum over near pixels the bellcurve height of the distance between ball center and that pixel,
//or something like that.
dagball.BitPic = function(wallPoten, wallThick, height, width, bytes, aftrans){
	this.wallPoten = wallPoten;
	this.wallThick = wallThick;
	this.height = height;
	this.width = width;
	this.bytes = bytes;
	this.aftrans = aftrans;
};
dagball.BitPic.prototype.type = 'dagball_bitpic';
dagball.BitPic.prototype.toMap = function(){
	return {
		type: this.type,
		wallPoten: this.wallPoten,
		wallThick: this.wallThick,
		height: this.height,
		width: this.width,
		//bytes: dagball.bytesToHex(this.bytes),
		bloomtree: dagball.bytesToBase64(this.toBloomTree().bytes), //deterministic lossless-compressed same bytes as in this.bytes
		aftrans: this.aftrans.toMap(),
	};
};
dagball.mapToBitPic = function(map){
	if(!map || !map.wallPoten || !map.height || !map.width || (!map.bloomtree && !map.bytes && !map.ints) || !map.aftrans){ //2024-1-1 changed from ints to bytes
		Err('Some stuff missing: '+JSON.stringify(map));
	}
	if(map.type != 'dagball_bitpic'){
		Err('Not a dagball_bitpic: '+JSON.stringify(map));
	}
	let bytes;
	let bloomTreePaintsBitPic = false; //in case bloomtree isnt the default (use map.bytes from older code) later
	if(map.bloomtree){
		if(!dagball.isPowOf2(map.height) || map.height != map.width){
			Err('Invalid height and width combo (must be a powOf2 and both equal if bloomtree), h'+map.height+' w'+map.width);
		}
		bytes = new Uint8Array(Math.ceil(map.height*map.width/8)); //start as all 0s, fill in after create BitPic
		bloomTreePaintsBitPic = true;
	}else if(map.bytes || map.ints){
		bytes = dagball.hexToBytes(map.bytes || map.ints);
	}else Err('Does not have bloomtree or bytes (OLD) or ints (OLDEST): '+JSON.stringify(map));
	let bitpic = new dagball.BitPic(
		map.wallPoten,
		map.wallThick || 5,
		map.height,
		map.width,
		bytes, //dagball.hexToBytes(map.bytes || map.ints), //2023-12-31 map.ints existed but then changed it to map.bytes so dont have to deal with endian.
		dagball.mapToSimpleAftrans(map.aftrans)
	);
	if(bloomTreePaintsBitPic){
		let bloomtree = new dagball.BloomTree(dagball.base64ToBytes(map.bloomtree));
		bloomtree.paintOntoBitPic(bitpic);
	}
	return bitpic;
};
dagball.BitPic.prototype.fillRandom = function(){
	for(let i=0; i<this.bytes.length; i++){
		this.bytes[i] = Math.floor(Math.random()*256)&255;
	}
};
/*dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.ints[index>>5]>>(index&31))&1; //littleEndian
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.ints[index>>5] |= (1<<(index&31)); //littleEndian
	}else{
		this.ints[index>>5] &= ~(1<<(index&31)); //littleEndian
	}
};*/
dagball.BitPic.prototype.readBit = function(index){ //returns 1 or 0. doesnt check bounds.
	return (this.bytes[index>>3]>>(index&7))&1;
};
dagball.BitPic.prototype.writeBit = function(index, bit){ //write 1 or 0
	if(bit){
		this.bytes[index>>3] |= (1<<(index&7));
	}else{
		this.bytes[index>>3] &= ~(1<<(index&7));
	}
};

dagball.BitPic.prototype.toBloomTree = function(){
    if(!dagball.isPowOf2(this.height)){
        throw new Error('BitPic height is not a power of 2');
    }
    if(this.height !== this.width){
        throw new Error('BitPic height and width must be equal');
    }

    // Recursive function for both computing size and filling the array
    let bitCount = 0;
    let bloomByteArray;

    const process = (x, y, size, fillArray)=>{
        let isUniform = true;
        let firstBit = this.readBit(y*this.width+x);

        for(let row=y; row<y+size; row++){ //TODO optimize this. it runs log times more than needs to.
            for(let col=x; col<x+size; col++) {
                if(this.readBit(row*this.width+col) !== firstBit){
                    isUniform = false;
                    break;
                }
            }
            if(!isUniform) break;
        }

        if(fillArray){
			/*this is littleEndian, index 0 being at low 2 bits in byte. 2024-1-1 switching to bigEndian inside byte, so at index 6 and 7.
            //let position = bitCount>>5; //divide by int32 size
			let position = bitCount>>3; //divide by byte size
            //let shift = bitCount%32;
			//let shift = bitCount&31;
			let shift = bitCount&7;
            let value = isUniform ? (firstBit ? dagball.bloomWall : dagball.bloomOpen) : dagball.bloomBranch;
            bloomByteArray[position] |= value << shift;
			*/
			/*//code copied from dagball.BloomTree.prototype.write
			let byteIndex = index>>2;
			let prevByte = this.bytes[byteIndex];
			//If (index&3)==0 then lowestBitIndexInByte is 6. if ==1 then 4. If ==2 then 2. If ==3 then 0.
			let lowestBitIndexInByte = 6-((index&3)<<1);
			//let prevByteWithoutThose2Bits = (prevByte & ~((lowestBitIndexInByte<<1)|lowestBitIndexInByte));
			let prevByteWithoutThose2Bits = (prevByte & ~((1<<lowestBitIndexInByte)*3));
			this.bytes[byteIndex] = prevByteWithoutThose2Bits | (num<<lowestBitIndexInByte);
			*/
			let value = isUniform ? (firstBit ? dagball.bloomWall : dagball.bloomOpen) : dagball.bloomBranch;
			dagball.writeInt2IntoBytes(bloomByteArray, bitCount>>1, value); //bitCount>>1 cuz index is in units of int2s
        }
        
        bitCount += 2; //2 bits for every node

        if(!isUniform){
            const halfSize = size/2;
            process(x, y, halfSize, fillArray); //top left
            process(x+halfSize, y, halfSize, fillArray); //top right
            process(x, y+halfSize, halfSize, fillArray); //bottom left
            process(x+halfSize, y+halfSize, halfSize, fillArray); //bottom right
        }
    };

    // First Pass: Compute the size in bits
    process(0, 0, this.width, false);

    // Allocate the array based on computed size
    //let maxPossibleIntSize = Math.ceil(bitCount/32);
	let maxPossibleByteSize = Math.ceil(bitCount/8);
    bloomByteArray = new Uint8Array(maxPossibleByteSize);

    // Second Pass: Fill the array
    bitCount = 0; // Reset bit counter for the second pass
    process(0, 0, this.width, true);

    return new dagball.BloomTree(bloomByteArray);
};

//like readYX many times in parallel in a 2d grid. uses 2 aftrans, one as param and one in this bitpic.
dagball.BitPic.prototype.paintOntoPotens = function(addHere, addHereHeight, addHereWidth, secondAftrans){
	let i = 0;
	const addY = -secondAftrans.addY/(secondAftrans.magnifyY*this.aftrans.magnifyY)-this.aftrans.addY/this.aftrans.magnifyY;
	const mulY = 1/(secondAftrans.magnifyY*this.aftrans.magnifyY);
	const addX = -secondAftrans.addX/(secondAftrans.magnifyX*this.aftrans.magnifyX)-this.aftrans.addX/this.aftrans.magnifyX;
	const mulX = 1/(secondAftrans.magnifyX*this.aftrans.magnifyX);
	let yy = addY;
	let thisWallPoten = this.wallPoten;
	//xx = (canvasX*mulX+addX)|0;
	//const startCanvasX = Math.max(0, Math.min(Math.ceil(-addX), addHereWidth)); //when canvasX is 0
	/////////////////const startCanvasX = Math.max(0, Math.min(Math.ceil(addX), addHereWidth)); //when canvasX is 0
	//////const startCanvasX = Math.max(0, Math.min(Math.ceil(-addX), this.width)); //when canvasX is 0
	//end, when canvasX*mulX+addX is just past addHereWidth
	//canvasX*mulX+addX==addHereWidth
	//canvasX==(addHereWidth-addX)/mulX
	//const endCanvasXExcl = Math.max(0, Math.min(Math.ceil((addHereWidth-addX)/mulX), addHereWidth));
	//////const endCanvasXExcl = Math.max(0, Math.min(Math.ceil((addHereWidth-addX)/mulX), this.width));
	//for(let canvasY=0; canvasY<addHereHeight; canvasY++){
	for(let canvasY=0; canvasY<addHereHeight; canvasY++){
		//let yy = (canvasY*mulY+addY)|0;
		let xx = addX;
		//let xx = startCanvasX*mulX+addX;
		let yyInt = (yy|0);
		if(0 <= yyInt && yyInt < this.height){
			let yyIntTimesWidth = yyInt*this.width;
			//let yyIntTimesWidth = (yy|0)*addHereWidth; //FIXME?
			//This wraps the game world horizontally when past its edges: for(let canvasX=0; canvasX<addHereWidth; canvasX++){
			//////i += startCanvasX; //skip these xx on left of screen
			//i += startCanvasX; //skip these canvasX on left of screen
			//let i = yyIntTimesWidth+startCanvasX;
			//////for(let canvasX=startCanvasX; canvasX<endCanvasXExcl; canvasX++){
			//for(let canvasX=0; canvasX<addHereWidth; canvasX++){
			//for(let canvasX=startCanvasX; canvasX<addHereWidth; canvasX++){
			for(let canvasX=0; canvasX<addHereWidth; canvasX++){
				//let xx = (canvasX*mulX+addX)|0;
				let xxInt = (xx|0);
				if(0 <= xxInt && xxInt < this.width){
					let index = yyIntTimesWidth+xxInt;
					let readThisBit = (this.bytes[index>>3]>>(index&7))&1;
					let poten = readThisBit*thisWallPoten;
					addHere[i] += poten;
				}
				i++;
				xx += mulX;
			}
		}else{
			i += addHereWidth;
		}
		//////i += addHereWidth-endCanvasXExcl; //skip these xx on right of screen
		yy += mulY;
	}
};

//in game coordinates returns potentialEnergy added by this bitpic there. jagged. if you want the
//smooth bellcurvelike potentialEnergy used for balls, TODO use another func (TODO make one) for that.
dagball.BitPic.prototype.readYX = function(y,x){
	//return .3; //FIXME
	//return x; //FIXME
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	//return y; //FIXME
	//return x; //FIXME
	//return ((Math.hypot(y,x)-2.5)<.02) ? this.wallPoten : 0; //FIXME
	//return Math.hypot(y,x); //FIXME
	//return Math.hypot(yy,xx); //FIXME
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	if(yy < 0 || yy >= this.height || xx < 0 || xx >= this.width){
		return 0; //out of range, its 0s there
	}
	let index = yy*this.width+xx;
	return this.readBit(index)*this.wallPoten;
};
dagball.BitPic.prototype.bilinearReadYX = function(y,x){ //TODO test this (now is 2023-12-30)
	//return x; //FIXME
	let rawYY = this.aftrans.reverseY(y);
	let rawXX = this.aftrans.reverseX(x);
	//return y; //FIXME
	//return x; //FIXME
	//return ((Math.hypot(y,x)-2.5)<.02) ? this.wallPoten : 0; //FIXME
	//return Math.hypot(y,x); //FIXME
	//return Math.hypot(yy,xx); //FIXME
	yy = Math.floor(rawYY);
	xx = Math.floor(rawXX);
	if(yy < 0 || yy >= (this.height-1) || xx < 0 || xx >= (this.width-1)){
		return 0; //out of range, its 0s there
	}
	let y0x0 = this.readBit(yy*this.width+xx);
	let y0x1 = this.readBit(yy*this.width+(xx+1));
	let y1x0 = this.readBit((yy+1)*this.width+xx);
	let y1x1 = this.readBit((yy+1)*this.width+(xx+1));
	let yFraction = rawYY-yy;
	let xFraction = rawXX-xx;
	let bilinear =
		(y0x0*(1-yFraction)*(1-xFraction))+
		(y0x1*(1-yFraction)*(xFraction))+
		(y1x0*(yFraction)*(1-xFraction))+
		(y1x1*(yFraction)*(xFraction));
	return bilinear*this.wallPoten;
};
dagball.BitPic.prototype.writeYXRaw = function(y,x,bit){ //no aftrans
	let index = y*this.width+x;
	this.writeBit(index, bit);
}
dagball.BitPic.prototype.writeYX = function(y,x,bit){
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	if(yy < 0 || yy >= this.height || xx < 0 || xx >= this.width){
		return; //out of range
	}
	let index = yy*this.width+xx;
	this.writeBit(index, bit);
};
dagball.BitPic.prototype.writeYXR = function(y,x,r,bit){
	let yy = this.aftrans.reverseY(y);
	let xx = this.aftrans.reverseX(x);
	let rr = r/this.aftrans.magnifyY; //FIXME magnifyX and magnifyY? theyre probably equal.
	if(rr > dagball.maxRadiusOutToReadOrWriteInBitpicRR){
		Err('Its gonna be very slow. Something likely went wrong. rr='+rr+' and about to double loop 2*rr each')
	}
	yy = Math.floor(yy);
	xx = Math.floor(xx);
	rr = Math.ceil(rr);
	let rr2 = rr*rr;
	for(let yyy=yy-rr; yyy<=yy+rr; yyy++){
		for(let xxx=xx-rr; xxx<=xx+rr; xxx++){
			if(yyy < 0 || yyy >= this.height || xxx < 0 || xxx >= this.width){
				continue; //out of range
			}
			let dy = yyy-yy;
			let dx = xxx-xx;
			if(dy*dy+dx*dx > rr2){
				continue; //not in circle shape of paintbrush
			}
			let index = yyy*this.width+xxx;
			this.writeBit(index, bit);
		}
	}
};
//This is potentialEnergy that balls roll up to make them bounce on the wall or lay on it
//This is _OLD cuz its not using bilinear interpolation (bilinearReadYX) which is making the balls bounce jumpy.
dagball.BitPic.prototype.readSmoothYXR_OLD = function(y,x,r,optionalNumStdDevs){
	let stdDevs = optionalNumStdDevs || 2;
	let stdDevs2 = stdDevs*stdDevs;
	let rawYY = this.aftrans.reverseY(y);
	let rawXX = this.aftrans.reverseX(x);
	//FIXME? let rawRR = (r*stdDevs)/this.aftrans.magnifyY; //FIXME magnifyX and magnifyY? theyre probably equal.
	let rawRR = (r*stdDevs); //FIXME? why doesnt this multiply or divide by magnifyY or magnifyX?
	yy = Math.floor(rawYY);
	xx = Math.floor(rawXX);
	rr = Math.ceil(rawRR);
	if(rr > dagball.maxRadiusOutToReadOrWriteInBitpicRR){
		Err('Its gonna be very slow. Something likely went wrong. rr='+rr+' and about to double loop 2*rr each')
	}
	let rr2 = rr*rr;
	let sumBellHeights = 0;
	for(let yyy=yy-rr; yyy<=yy+rr; yyy++){
		for(let xxx=xx-rr; xxx<=xx+rr; xxx++){
			if(yyy < 0 || yyy >= this.height || xxx < 0 || xxx >= this.width){
				continue; //out of range
			}
			let index = yyy*this.width+xxx;
			let observedBitThere = this.readBit(index);
			if(observedBitThere){
				//let dy = yyy-yy;
				//let dx = xxx-xx;
				let dy = yyy-rawYY;
				let dx = xxx-rawXX;
				let distSq = dy*dy+dx*dx;
				let observedStdDevSquared = distSq/rr2;
				let bellHeight = Math.exp(-.5*observedStdDevSquared); //is height 1 at observedStdDevSquared==0, unlike a normed height bellcurve
				//sumBellHeights += bellHeight*observedBitThere;
				sumBellHeights += bellHeight;
			}
		}
	}
	let weightedAveBellHeights = sumBellHeights;
	weightedAveBellHeights /= rr2; //FIXME is this right? somewhere around there i think.
	return weightedAveBellHeights*this.wallPoten;
	//return weightedAveBellHeights; //already includes this.wallPoten thru 
};
//This is potentialEnergy that balls roll up to make them bounce on the wall or lay on it
//Uses using bilinear interpolation (bilinearReadYX) to (TODO verify this works???) make balls not bounce so jumpy (bounce smooth).
//dagball.BitPic.prototype.readSmoothYXR = function(y,x,r,optionalNumStdDevs)


dagball.BitPic.prototype.readSmoothYXR = function(y,x){
	let r = this.wallThick;
	/*if(!dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap){
		let apeCode = dagball.addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap;
		let ape = Ap.lazyEvalOld(apeCode).ape;
		let jsLambdaCode = ape.jsLambdaCode();
		let jsLambda = TinyGlsl.cachedJsEval(jsLambdaCode);
		dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap = jsLambda;
		console.log('bitpic.readSmoothYXR caching dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap (wont be updated if you change that string) =\n'+
			dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap);
	}*/
	let dist = this.distanceToClosestWall(y,x,r);
	//TODO return dagball.cacheJsFunc_addToEnergyPerBallDistanceCodePerPairOfBallsForSingleHeightmap(dist);
	if(dist == Infinity) return 0;
	let distFraction = dist/r;
	let closenessFraction = 1-distFraction;
	return this.wallPoten*closenessFraction*closenessFraction;
	//return .3;

	//return 10/(1+dist);
};












































if(graphicsLev>1) game.addFunc(function(Y/*74300*/, X/*74500*/, ay/*10 0 1*/, ax/*20 0 1*/, by/*34 0 1*/, bx/*19 0 1*/, cy/*-10 0 1*/, cx/*-35 0 1*/, dy/*15 0 1*/, dx/*-27 0 1*/, ey/*40 0 1*/, ex/*-20 0 1*/, fy/*-58 0 1*/, fx/*30 0 1*/, gy/*-80 0 1*/, gx/*28 0 1*/){ //hypercubewave
	const sideBits = 5;
	//const sideBits = 8;
	//const sideBits = 9;
	const side = 1<<sideBits;
	const mid = side/2;
	const stdDev = mid/10;
	//const stdDev = mid/5;
	const stdDevSquared = stdDev**2;
	const sideMask = side-1;
	const square = side**2;
	const squareMask = square-1;
	let picA = new Float32Array(square);
	//let xyMul = 52;
	//let xyMul = .5;
	let xyMul = 1.3;
	let offsets = [
		(((ay*xyMul)&sideMask)<<sideBits) | ((ax*xyMul)&sideMask),
		(((by*xyMul)&sideMask)<<sideBits) | ((bx*xyMul)&sideMask),
		(((cy*xyMul)&sideMask)<<sideBits) | ((cx*xyMul)&sideMask),
		(((dy*xyMul)&sideMask)<<sideBits) | ((dx*xyMul)&sideMask),
		(((ey*xyMul)&sideMask)<<sideBits) | ((ex*xyMul)&sideMask),
		(((fy*xyMul)&sideMask)<<sideBits) | ((fx*xyMul)&sideMask),
		(((gy*xyMul)&sideMask)<<sideBits) | ((gx*xyMul)&sideMask),
	]
	let sumDy = 0, sumDx = 0;
	//for(let offset of offsets){
	for(let i=0; i<offsets.length; i++){
		let offset = offsets[i];
		sumDy += offset>>>sideBits; //y from 0 to side-1
		sumDx += offset&sideMask; //x from 0 to side-1
	}
	//let maxCenterAdjust = mid*.7; //dont move center outside the picA/picB square
	let maxCenterAdjust = mid*.9; //dont move center outside the picA/picB square
	//let maxCenterAdjust = mid*1.7; //dont move center outside the picA/picB square
	sumDy = Math.max(-maxCenterAdjust, Math.min(sumDy, maxCenterAdjust));
	sumDx = Math.max(-maxCenterAdjust, Math.min(sumDx, maxCenterAdjust));
	for(let i=0; i<square; i++){ //fill in 1 bellcurve at center of picA
		let y = i>>>sideBits;
		let x = i&sideMask;
		//let bellY = mid+sumDy*2;
		//let bellX = mid-sumDx*0;
		//let bellY = -sumDy/2;
		//let bellX = -sumDx/2;
		let bellY = mid-sumDy/2;
		let bellX = mid-sumDx/2;
		//let devSquared = ((y-mid)**2 + (x-mid)**2)/stdDevSquared;
		let devSquared = ((y-bellY)**2 + (x-bellX)**2)/stdDevSquared;
		let bellHeight = Math.exp(-devSquared);
		picA[i] = bellHeight;
	}
	for(let offset of offsets){
		if(offset==0) Y.poten += 10; //resist the params being exactly 0 after roundoff, cuz they dont copy picA when they are.
	}
	let picB = new Float32Array(square);
	for(let dup=0; dup<offsets.length; dup++){
		let offset = offsets[dup];
		if(offset){ //cant copy 2 of them to the exact same place, one positive and one negative, cuz it cancels out.
			for(let i=0; i<square; i++){
				//copy picA 2 times onto picB,
				//once as is and once 2d position offset and negated brightness
				picB[i] = picA[i] - picA[(i+offset)&squareMask]; //wrap. TODO dont wrap
			}
			[picA, picB] = [picB, picA];
		}
	}
	for(let i=0; i<square; i++) picA[i] = Math.abs(picA[i]);
	let sum = 0;
	for(let i=0; i<square; i++) sum += picA[i];
	let ave = sum/square;
	let vox = [];
	//let limit = ave*3.5;
	let limit = ave*1.5;
	let magnify = 4;
	let addA = YXC(2,0,0); //make 4 voxels instead of 1, cuz magnify is 2.
	let addB = YXC(0,2,0);
	let addC = YXC(2,2,0);
	for(let i=0; i<square; i++){
		//if(limit < picA[i] || i==0 || i==square-1){ //i==0 || i==square-1, is 2 corners to show the square its painting in.
		if(limit < picA[i]){
			let localY = i>>>sideBits;
			let localX = i&sideMask;
			let y = Y + (localY - mid)*magnify;
			let x = X + (localX - mid)*magnify;
			let color = 0b011111;
			let voxel = YXC(y,x,color);
			vox.push(voxel);
			vox.push(voxel+addA);
			vox.push(voxel+addB);
			vox.push(voxel+addC); //FIXME might wrap around at edges
		}
	}
	Y.poten += .1*((Y.p-74100)**2 + (X.p-74425)**2); //attract to that
	Y.kv += .315;
	X.kv += .315;
	//let flatZone = mid/8.5; //each (y,x) param pair, except the first 2, is a vector. we dont push on it if its within the flatZone radius. We do if it gets too big.
	let flatZone = 7;
	for(let i=2; i<arguments.length; i+=2){
		let kv = .2;
		let varY = arguments[i], varX = arguments[i+1];
		varY.kv += kv;
		varX.kv += kv;
		let len = Math.hypot(varY.p,varX.p);
		if(len > flatZone){
			varY.poten += .7*(len-flatZone)**2;
		}
		//varY.dp += 10; (Math.random()*2-1)*10;
		//varY.dp += (Math.random()*2-1)*.31;
	}
	//for(let i=2; i<arguments.length; i+=2){
	//	arguments[i].dp += (Math.random()*2-1)*.11;
	//}
	return vox;
});



//game.addFunc(function(Y/*505000*/, X/*506000*/, momentum/*5 0 1*/, shift/*15 0 1*/, pulse/*25 0 1*/, wave/*35 0 1*/, flicker/*45 0 1*/, doorAngle/*30 0 1*/) {

/*if(graphicsLev>1) game.addFunc(function(Y/*75000*, X/*76000*, momentum/*5 0 1*, wave/*35 0 1*, doorAngle/*30 0 1*) {
	const baseSize = 300; // Base size of the structure
	const wallThickness = 40; // Wall thickness
	const doorThickness = wallThickness / 2; // Door thickness, half that of the wall
	const voxels = [];
	// Define the three remaining sides of the box (excluding the side where the door will be)
	const sides = [
		{ start: 0, end: baseSize, orientation: 'horizontal', displacement: 0 }, // Top side
		{ start: 0, end: baseSize, orientation: 'vertical', displacement: 0 }, // Left side
		{ start: 0, end: baseSize, orientation: 'vertical', displacement: baseSize } // Right side
	];
	// Create walls
	sides.forEach(side => {
		for (let i = side.start; i < side.end; i++) {
			for (let j = 0; j < wallThickness; j++) { // Apply set thickness
				let y = (side.orientation === 'horizontal') ? Y.p + side.displacement : Y.p + i;
				let x = (side.orientation === 'horizontal') ? X.p + i : X.p + side.displacement;
				if (side.orientation === 'horizontal') {
					y += j; // Expand thickness horizontally
				} else {
					x += j; // Expand thickness vertically
				}
				const color = 0b101010; // Consistent color for the structure
				voxels.push(YXC(y, x, color));
			}
		}
	});
	// 6-way rotating door replacing the bottom wall, spans the entire length of the wall
	const doorLength = baseSize; // Door spans the entire wall length
	const doorCenterY = Y.p + baseSize; // Positioning the door at the bottom
	const doorCenterX = X.p + baseSize / 2;
	const angle = doorAngle.p * Math.PI / 180; // Convert angle from degrees to radians
	for (let k = 0; k < 6; k++) { // Six arms
		const armAngle = angle + k * Math.PI / 3; // Dividing 360 degrees into six parts
		for (let l = 0; l < doorLength / 2; l++) { // Length of each arm, adjusted to fit
			for (let m = 0; m < doorThickness; m++) { // Apply half thickness
				const y = doorCenterY + l * Math.sin(armAngle) + m * Math.cos(armAngle); // Offset for thickness
				const x = doorCenterX + l * Math.cos(armAngle) - m * Math.sin(armAngle); // Offset for thickness
				const color = 0b010101; // Color for the door
				voxels.push(YXC(Math.round(y), Math.round(x), color));
			}
		}
	}
	// Increase sensitivity to interaction by lowering the rotational inertia
	doorAngle.dv += momentum.p * 0.0001; // Lower inertia for easier rotation
	// Velocity decay
	Y.kv += .3;
	X.kv += .3;
	momentum.kv += .1;
	doorAngle.kv += 1.7;
	// Potentially attract to the center position
	Y.poten += 0.01 * (75000 - Y.p)**2; // Gradually attract Y to the center position
	X.poten += 0.01 * (76000 - X.p)**2; // Gradually attract X to the center position
	return voxels;
});*/


var mouse = game.addFunc((Y, X)=>{
	//let Y = {p:Controls.mouseY};
	//let X = {p:Controls.mouseX};
	let area = 4000; //before cut circle out of it
	let h = Math.ceil(Math.sqrt(area));
	let w = Math.ceil(area/h);
	let fromY = (Y.p|0) - 10;
	let fromX = (X.p|0) - 10;
	let toY = fromY+h;
	let toX = fromX+w;
	let actualCenterY = (fromY+toY)/2;
	let actualCenterX = (fromX+toX)/2;
	let ret = []; //TODO optimize using VoxStream to generate a Uint32Array.
	let radius = (toY-fromY)/2;
	let rr = radius**2;
	for(let y=fromY; y<toY; y++){
		for(let x=fromX; x<toX; x++){
			let dy = y-actualCenterY;
			let dx = x-actualCenterX;
			let squaredDist = dy*dy+dx*dx;
			if(squaredDist < rr){ //paint circle
				//let color = 0b110011;
				let color = 0b000111;
				//let dist = radius-Math.sqrt(squaredDist); //distance from edge of circle, not from center
				//let distFrac = dist/radius;
				ret.push(YXC(y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
				//let z = distFrac*DefaultZ*2;
				//ret.push(ZYXC(z,y,x,color)); //create voxel. y and x are uint13's. C param is 6 bit color.
			}
		}
	}
	//centerY.poten += .1*Math.hypot(centerY.p-300,centerX.p-300)**2; //attract to that
	//heightToWidthRatio.poten += .1*(heightToWidthRatio.p-1)**2;
	//Y.kv += .1;
	//X.kv += .1;
	//heightToWidthRatio.kv += .003;
	Y.set(Controls.mouseY);
	X.set(Controls.mouseX);
	return ret;
});
mouse.m.isSelectable = false;
//mouse.m.displayText = 'mouse';


//const ExampleWallVoxels = Float64Array.of(3761487178300722,0,1,2,3,-1);
//game.addFunc("(Y/*75000*/, X/*76000*/)=>Walls('"+Wally(ExampleWallVoxels)+"')");











//Canvas and ByteRect code are opensource MIT licensed
//(parts from benrayfield's various other projects including https://jsfiddle.net/q687fcrk/1/ and
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html )

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA;

//modified https://github.com/benrayfield/jsutils/blob/master/src/FullScreenCanvasPrototype.html
var FullScreenCanvas = function(optionalHeight, optionalWidth, optionalParentDom){ //FullScreenCanvas opensource MIT licensed by Ben F Rayfield
	let parentDom = optionalParentDom  || document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	this.dom.style.position = 'absolute';
	this.dom.style.left = '0px';
	this.dom.style.top = '0px';
	
	//else uses window size. FIXME also 
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		let targetHeight = optionalHeight || window.innerHeight;
		let targetWidth = optionalWidth || window.innerWidth;
		if(this.dom.height != targetHeight) this.dom.height = targetHeight;
		if(this.dom.width != targetWidth) this.dom.width = targetWidth;
	};
	
	/*//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	//FIXME reuse some of these vars. might be slowing it down doing getContext and imageData every time, for example,
	//but careful with that cuz canvas doesnt update if you do this wrong.
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		
		//this.context = this.dom.getContext('2d');
		//cuz got this warning 2023-9-2: ForestCurveFit004.html:1503 Canvas2D: Multiple readback operations using getImageData
		//are faster with the willReadFrequently attribute set to true.
		//See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
		this.context = this.dom.getContext('2d', {willReadFrequently: true});

		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};*/
	this.beforePaint = function(){
		if(this.dom == null) throw new Error('No canvas');

		// Create the context if it doesn't exist
		if(!this.context){
			this.context = this.dom.getContext('2d', {willReadFrequently: true});
		}

		//Only create image data if it doesn't exist or if the canvas size has changed
		if(!this.imageData || this.imageData.width !== this.dom.width || this.imageData.height !== this.dom.height){
			this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
			this.pixels = this.imageData.data;
			this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
		}
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw new Error('No canvas');
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)];
};


ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(y*this.width+x)*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	if(x < 0 || this.width <= x || y < 0 || this.height <= y) return;
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

var canv = null;

var endingCanv = false;

/** get bellcurve height on a chosen bellcurve thats stretched and moved */
var bell = function(ave, dev, maxHeight, observe){
	let diff = (observe-ave)/dev;
	return Math.exp(-diff*diff);
};

/*var sigmoid = function(x){
	return .5+.5*Math.tanh(x);
};*/

//0 to 255
var backgroundRed = 0;
var backgroundGreen = 0;
var backgroundBlue = 0;


//age in seconds since transition started. Just paints onto ByteRect
var doGraphicsDtAgeByterect = function(dt, age, byteRect){

	//dt *= 20;
	//dt *= 10;
	//2024-11-26 moving this to just before doGraphicsDtAgeByterect is called so speed profiler in browser can measure them separately easier: game.nextState(dt);

	let bytes = byteRect.bytes;
	let offset = Math.floor(Math.sin(time()*5*2*Math.PI)*100+100);
	let w = byteRect.width;
	let h = byteRect.height;
	let cx = Math.floor(w/2); //center x
	let cy = Math.floor(h/2); //center y
	/*for(let i=0; i<bytes.length; i+=4){
		bytes[i+RED] = backgroundRed;
		bytes[i+GREEN] = backgroundGreen;
		bytes[i+BLUE] = backgroundBlue;
		bytes[i+ALPHA] = 255;
	}*/
	let i = 0;
	//let viewRect = game.getViewRect
	//let fromY = game.Y;
	//let toY = fromY+h;
	//let fromX = game.X;
	//let toX = fromX+w;
	
	let screenH = canv.dom.height;
	let screenW = canv.dom.width;
	let centerYGameCoords = game.Y.p; //FIXME until 2024-11-14-1206pET game.Y and game.X were top left corner. i might want it to be center of view.
	let centerXGameCoords = game.X.p; //FIXME until 2024-11-14-1206pET game.Y and game.X were top left corner. i might want it to be center of view.
	let gameDisplayH = screenH*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameDisplayW = screenW*game.zoom.p; //FIXME divide vs multiply by zoom?
	let gameFromY = game.Y.p-gameDisplayH/2;
	let gameFromX = game.X.p-gameDisplayW/2;
	let gameDy = game.zoom.p;
	let gameDx = game.zoom.p;
	//for(let y=fromY; y<toY; y++){
		//for(let x=fromX; x<toX; x++){
	let zoomedY = gameFromY;
	//const wrap = true; //display around the 8kX8k window
	//const wrap = false; //display only 1 8kX8k window without wrapping
	for(let screenY=0; screenY<screenH; screenY++){
		let zoomedX = gameFromX;
		for(let screenX=0; screenX<screenW; screenX++){
			//if(wrap || (0 <= zoomedY && zoomedY < Size && 0 <= zoomedX && zoomedX < Size)){ //in game area
			//	bytes[i+RED] = game.redByteAtYX(zoomedY,zoomedX);
			//	bytes[i+GREEN] = game.greenByteAtYX(zoomedY,zoomedX);
			//	bytes[i+BLUE] = game.blueByteAtYX(zoomedY,zoomedX);
			if(MinY <= zoomedY && zoomedY <= MaxY && MinX <= zoomedX && zoomedX <= MaxX){ //in game area which is about a million by a million (2**20)
				bytes[i+RED] = game.redByteAtYX(zoomedY,zoomedX);
				bytes[i+GREEN] = game.greenByteAtYX(zoomedY,zoomedX);
				bytes[i+BLUE] = game.blueByteAtYX(zoomedY,zoomedX);
			}else{
				bytes[i+RED] = 40; //very dark gray background outside the 8kX8k square
				bytes[i+GREEN] = 40;
				bytes[i+BLUE] = 40;
			}
			/*bytes[i+RED] = game.redByteAtYX(y,x);
			bytes[i+GREEN] = game.greenByteAtYX(y,x);
			bytes[i+BLUE] = game.blueByteAtYX(y,x);
			*/
			bytes[i+ALPHA] = 255; //visible, not transparent
			i += 4;
			zoomedX += gameDx;
		}
		zoomedY += gameDy;
	}

};

var setVarPathTxt = txt=>{
	document.getElementById('varPathTxt').value = txt;
};

Game.prototype.setSelectedGob = function(gob){
	let i = this.gobs.indexOf(gob);
	if(i == -1) this.gobs.push(gob); //selecting a gob that wasnt added yet
	for(let g of this.gobs){
		g.m.isSelected = (g===gob);
	}
	setVarPathTxt(gob.bo.path());
	document.getElementById('mainTextarea').value = ''+gob.brain;
	document.getElementById('selectedGobVarsDiv').innerHTML = ''; //make new table in a fraction of a second
	return gob;
};

Game.prototype.searchGobs = function(query){
	return this.gobs.filter(query);
};

Game.prototype.selectedGobs = function(){
	return this.searchGobs(g=>(g.m.isSelected));
};

var SEL = function(){ //get first selected gob or null
	return game.selectedGobs()[0] || null;
};

var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;

//get array index mouse last touched, for game.board[mouseI()] and game.rps.boardR[mouseI()] and boardG and boardB.
var mouseI = ()=>((Controls.mouseY<<SizeBits)|Controls.mouseX);

var DefaultTextColor = '#33ff55';

/*canv.dom.addEventListener('mousemove', event=>{
	let prevRawMouseY = Controls.rawMouseY;
	let prevRawMouseX = Controls.rawMouseX;
	Controls.rawMouseY = event.offsetY;
	Controls.rawMouseX = event.offsetX;
	let mouseDy = Controls.rawMouseY-prevRawMouseY;
	let mouseDx = Controls.rawMouseX-prevRawMouseX;
	if(Controls.mouseButton0){ //dragging the ground to move view
		game.Y.p -= mouseDy*game.zoom.p;
		game.X.p -= mouseDx*game.zoom.p;
		//game.Y = Math.max(0, Math.min(game.Y, Size-canv.dom.height))&SizeMask;
		//game.X = Math.max(0, Math.min(game.X, Size-canv.dom.width))&SizeMask;
		//console.log('game.Y='+game.Y+' x='+game.X);
	}
	Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)&SizeMask;
	Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)&SizeMask;;
});
*/
var afterAfterPaint = canv=>{ //doOverlays. canv is the FullScreenCanvas instance. canv.dom is the canvas. canv.context is the canvas context object.
	let ctx = canv.context;
	let g = game; //FIXME could be multiple games, one per namespace like V.testnet.game and V.otherNamespace.game.
	for(let gob of g.gobs){ //those displayed. normally should be alot more of them in the namespace. those displayed are also in that namespace.
		let displayText = gob.m.displayText;
		//if(displayText && gob == mouse){
		if(displayText){
			//throw new Error('FIXME gob.getVar(\'Y\') is causing error with Proxy or something');
			let gobY = gob.Y.p;
			let gobX = gob.X.p;
			//let canvasY = ((gobY-game.Y.p)*game.zoom.p)&SizeMask;
			//let canvasX = ((gobX-game.X.p)*game.zoom.p)&SizeMask;
			//let canvasY = (((gobY-game.Y.p)*game.zoom.p)+canv.dom.height/2)|0;
			//let canvasX = (((gobX-game.X.p)*game.zoom.p)+canv.dom.width/2)|0;
			//let canvasY = (((gobY-game.Y.p)*game.zoom.p))|0;
			//let canvasX = (((gobX-game.X.p)*game.zoom.p))|0;
			let cH = canv.dom.height;
			let cW = canv.dom.width;
			let canvasY = (((gobY-game.Y.p)/game.zoom.p)+cH/2)|0;
			let canvasX = (((gobX-game.X.p)/game.zoom.p)+cW/2)|0;
			canvasX += 12;
			//canvasY += 7;
			canvasY -= 3;
			//canvasY = 300;
			//canvasX = 300;
			//ctx.fillStyle = '#33ff55'; //green
			ctx.fillStyle = (gob.voxInGame && gob.voxInGame.length) ? IColorStr(gob.voxInGame[0]) : DefaultTextColor; //color of first voxel
			//ctx.fillText("Hello world "+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world cY="+canvasY+'_cX='+canvasX+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' zoom='+game.zoom.p+' '+gob.bo.name, 300, 300);
			//ctx.fillText("Hello world gY="+gobY+'_gX='+gobX+' cY='+canvasY+'_cX='+canvasX+' zoom='+game.zoom.p+' '+gob.bo.name, canvasX, canvasY);
			//ctx.fillText(displayText, canvasX, canvasY);
			for(let line of displayText.split('\n')){
				ctx.fillText(line, canvasX, canvasY);
				canvasY += 15;
			}
			//ctx.fillText("Hello world", 10, 50);
		}
	}
};

var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		//canv = new FullScreenCanvas();
		//let magnify = 2; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		//let magnify = 3;
		let magnify = 5;
		if(graphicsLev < 2) magnify *= 2; //half the width and height so it runs faster
		//let magnify = 4; //raising this decreases resolution, for speed. set this to 1 to use actual screen resolution or at least the window in the screen.
		let h = window.innerHeight/magnify;
		let w = window.innerWidth/magnify;
		canv = new FullScreenCanvas(h, w);
		let dom = canv.dom;
		dom.style.display = 'block';
		dom.style.transformOrigin = '0 0';
		dom.style.position = 'absolute';
		dom.style['z-index'] = -1;
		dom.style.top = '0';
		dom.style.left = '0';
		dom.setAttribute('tabIndex', 0); //make canvas focusable
		dom.style.transform = `scaleX(${magnify}) scaleY(${magnify})`;
		//dom.style.cursor = 'none'; //hide mouse pointer when over canvas cuz mouseball (in game.addFunc theres one that checks Controls.mouseY etc) is there.
		document.body.addEventListener('keyup', event=>{
			if(event.key == 'Pause'){
				Controls.pause = Controls.pause ? 0 : 1; //toggle
				if(!Controls.pause){
					console.log('Unpause');
					requestAnimationFrame(doGraphicsDtAgeByterectAndMore);
				}
			}
		});

		
		canv.dom.addEventListener('mousemove', event=>{
			let prevRawMouseY = Controls.rawMouseY;
			let prevRawMouseX = Controls.rawMouseX;
			Controls.rawMouseY = event.offsetY;
			Controls.rawMouseX = event.offsetX;
			let mouseDy = Controls.rawMouseY-prevRawMouseY;
			let mouseDx = Controls.rawMouseX-prevRawMouseX;
			if(Controls.mouseButton0){ //dragging the ground to move view
				game.Y.p -= mouseDy*game.zoom.p;
				game.X.p -= mouseDx*game.zoom.p;
				//game.Y = Math.max(0, Math.min(game.Y, Size-canv.dom.height))&SizeMask;
				//game.X = Math.max(0, Math.min(game.X, Size-canv.dom.width))&SizeMask;
				//console.log('game.Y='+game.Y+' x='+game.X);
			}
			//Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)&SizeMask;
			//Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)&SizeMask;;
			//dont limit to SizeMask cuz it wraps around SizeXSize aka 8192X8192.
			Controls.mouseY = (game.Y.p+(Controls.rawMouseY-canv.dom.height/2)*game.zoom.p)|0;
			Controls.mouseX = (game.X.p+(Controls.rawMouseX-canv.dom.width/2)*game.zoom.p)|0;
		});
		document.body.addEventListener('mousedown', event=>{
			//console.log('mousedown button='+event.button);
			if(event.button==0){ //dragging the ground to move view
				Controls.mouseButton0 = 1;
				Controls.rawMouseYWhenStartedDrag = Controls.rawMouseY;
				Controls.rawMouseXWhenStartedDrag = Controls.rawMouseX;
			}
		});
		document.body.addEventListener('mouseup', event=>{
			if(event.button==0){
				Controls.mouseButton0 = 0;
			}
		});
		document.body.addEventListener('wheel', function(event) {
			event.preventDefault(); // Prevents the default scrolling behavior
			const scrollAmount = event.deltaY; // Gets the vertical scroll amount
			game.onMouseWheelChange(scrollAmount); // Calls your function with the scroll amount
		}, {passive: false}); // Setting passive to false allows you to call preventDefault
		//canv.dom.style.cursor = "none"; //hide mouse cursor cuz its slightly out of sync with the player's blob and is annoying
	}
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	game.nextState(dt);
	doGraphicsDtAgeByterect(dt, age, canv.byteRect);
	canv.afterPaint();
	afterAfterPaint(canv); //must be after canv.afterPaint(), like in dagball its called afterAfterPaint. renaming this from doOverlays to afterAfterPaint.
	//setTimeout(doGraphicsDtAgeByterectAndMore, 1); //FIXME do requestAnimationFrame instead, for lower lag? or does waiting 1 more millisecond give it time to do other UI things?
	if(Controls.pause){
		console.log('Pause');
	}else{
		requestAnimationFrame(doGraphicsDtAgeByterectAndMore); //was this way 2025-2-5 and earlier for a long time
		//setTimeout(doGraphicsDtAgeByterectAndMore, 1); //2025-2-6 trying to fix "input type=range" and label events
	}
};

//moving this up, to replace other INF const: const INF = 1<<29;
//const distSqArrays = []; //sideBits -> Int32Array(1<<(sideBits<<1)). reuse.


//given 6 uint10s, 3 of them in each int i j, returns 3 uint10s in an int.
const triMin = (i,j)=>{
	let iLow = i&mask10;
	let jLow = j&mask10;
	let iMid = (i>>>10)&mask10;
	let jMid = (j>>>10)&mask10;
	let iHigh = (i>>>20)&mask10;
	let jHigh = (j>>>20)&mask10;
	let low = iLow<jLow ? iLow : jLow;
	let mid = iMid<jMid ? iMid : jMid;
	let high = iHigh<jHigh ? iHigh : jHigh;
	return (high<<20)|(mid<<10)|low;
};

//updates this.rps.tridist based on the team at each voxel. FIXME should i make game.rps.team as a Uint8Array or maybe a packed 1 bit per pixel int array?
//Game.prototype.updateTridist = function(yFrom, yTo, xFrom, xTo){
Game.prototype.updateTridist = function(smallYFrom, smallYTo, smallXFrom, smallXTo, optionalBorder){
	const rpsTeam = this.rps.team;
	//const rpsTridist = this.rps.tridist;
	const rpsTridistSmall = this.rps.tridistSmall;
	const endSize = Size*4;
	//let border = 50; //FIXME dont hardcode this
	let border = optionalBorder || 32;
	let innerSmallYFrom = smallYFrom+border;
	let innerSmallYTo = smallYTo-border;
	let innerSmallXFrom = smallXFrom+border;
	let innerSmallXTo = smallXTo-border;
	
	for(let smallY=smallYFrom; smallY<smallYTo; smallY++){
		let smallYIsInner = innerSmallYFrom <= smallY && smallY < innerSmallYTo;
		for(let smallX=smallXFrom; smallX<smallXTo; smallX++){
			let smallI = (smallY<<SmallSizeBits)|smallX;
			let teams = 0;
			let topLeftI = toBig(smallI); //top left of the 4x4, where 16 indexs in the big arrays aligns to 1 index in small array.
			for(let dyAdd=0; dyAdd<endSize; dyAdd+=Size){ //MagnifyShift==2 meaning 4x4 aka (1<<2)**2
				for(let dx=0; dx<4; dx++){
					let i = (topLeftI+dyAdd)|dx;
					teams |= rpsTeam[i]; //get all teams in the 4x4
				}
			}
			
			//TODO rename game.rps.team to game.rps.teams cuz it can have a powerset of all 3 teams?
			//let teams = rpsTeam[i]; //can be REDTEAM, BLUETEAM, GREENTEAM, or any 2 or 3 of those. Each next team that is added there xors a mask bit.
			//&7 soonly 3 teams in 8 possible combos (powerset), meaning is there an even vs odd number of that team at that voxel. its reversible. addVox remVox.
			//3 uint10s that are max (1023) if it needs to be recomputed, or is 0 to mean that team is here so distance from it is 0.
			//rpsTridist[i] = teamsToTridistInt[teams&7];
			
			let isInner = smallYIsInner && (innerSmallXFrom <= smallX && smallX < innerSmallXTo);
			if(isInner){
				//rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
				rpsTridistSmall[smallI] = teamsToTridistInt[teams&7];
			}else{
				rpsTridistSmall[smallI] = triMin(rpsTridistSmall[smallI],teamsToTridistInt[teams&7]);
				//throw new Error('TODO dont overwrite distances but take minimum 3 times');
			}
			
			
			//rpsTridistSmall[toSmall(i)] = teamsToTridistInt[teams&7];
			//rpsTridist[i] = teams==REDTEAM ? 0 : 1023;
			//rpsTridist[i] = randInt(1024);
			//rpsTridist &= mask10; //FIXME remove this. its all red, the low 10 bits.
		}
	}
	//computeUint10Distances(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	//computeUint10Distances(rpsTridistSmall, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
	computeUint10Distances(rpsTridistSmall, SmallSizeBits, smallYFrom, smallYTo, smallXFrom, smallXTo); //modifies rpsTridist
	//broken and made it twice as slow so not pursuing this for now: computeUint10Distances2x2Magnify(rpsTridist, SizeBits, yFrom, yTo, xFrom, xTo); //modifies rpsTridist
};

//color is a uint6. distanceSquaredArray is 1 of game.rps.boardR or game.rps.boardG or game.rps.boardB.
//OLD: colorChannel is RED or GREEN or BLUE as in "const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;".
//Only does the top left 1024x1024, not the whole 8192x8192 but that is planned to do sparsely later.
//Gotta get it working in basic way first, to play rock paper scissors per voxel.
Game.prototype.updateDistanceCacheOLD = function(distanceSquaredArray, color){
	const sideBits = 10; //1024x1024
	const side = 1<<sideBits;
	const fromY = 0, fromX = 0; //make sure it doesnt hang off the end of the 8192x8192
	const board = this.board;
	let countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				countVoxelsOfThatColor++;
			}
		}
	}
	let voxelsY = new Int16Array(countVoxelsOfThatColor);
	let voxelsX = new Int16Array(countVoxelsOfThatColor);
	countVoxelsOfThatColor = 0;
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			let voxel = board[offset+movedX];
			let colorUint6 = voxel&63;
			//if(colorUint6 == color){
			if(colorUint6 != 0){ //anything except black, for testing
				voxelsY[countVoxelsOfThatColor] = y;
				voxelsX[countVoxelsOfThatColor++] = x;
			}
		}
	}
	let distanceSquareds = computeSquaredDistances(sideBits, voxelsY, voxelsX); //1024x1024 if sideBits is 10
	for(let y=0; y<side; y++){
		const movedY = fromY+y;
		const offset = movedY<<SizeBits;
		for(let x=0; x<side; x++){
			let movedX = fromX+x;
			//let voxel = board[offset+movedX];
			//distanceSquared may be approximate or exact, depending on computeSquaredDistances has at least 2 implementations.
			let distanceSquared = distanceSquareds[(y<<sideBits)|x];
			distanceSquaredArray[(movedY<<SizeBits)|movedX] = distanceSquared;
		}
	}
};

/*const computeSquaredDistances = (sideBits, voxelYs, voxelXs)=>{
	//return computeSquaredDistances_exactButSlow(sideBits, voxelYs, voxelXs);
	//return computeSquaredDistances_approximateAndHexagonsAndFast(sideBits, voxelYs, voxelXs);
	return computeBalancedDistances(sideBits, voxelYs, voxelXs);
	
	//TODO make something like computeSquaredDistances_approximateAndHexagonsAndFast
	//but find a way to make it exact like computeSquaredDistances_exactButSlow and still fast.
	//The main difference is computeSquaredDistances_exactButSlow works by intersection of 2 parabolas in the 2 vertical steps.
};*/

// Lambda functions for extracting and setting distances
const mask10 = 0x3FF; //10 bit mask
const getDistance1 = (val) => (val & mask10); //approx distance (scaled by 3 or 4 depending on angle) to nearest REDTEAM voxel, given a tridist int.
const getDistance2 = (val) => ((val >> 10) & mask10); //GREENTEAM. See teamShift int array.
const getDistance3 = (val) => ((val >> 20) & mask10); //BLUETEAM. FIXME is this right? did i mix up teams and order of bits here?
const setDistances = (d1, d2, d3) => ((d1 & mask10) | ((d2 & mask10) << 10) | ((d3 & mask10) << 20)); //makes an int for game.rps.tridist



//size->Int32Array(size)
const reusableIntArrays = {};
const reusableIntArray = size=>(reusableIntArrays[size] || (reusableIntArrays[size] = new Int32Array(size)));

//given 2 ints that each contain 3 uint10s, return 3 averages as an int, rounding down for each.
//This works 2024-11-12 but computeUint10Distances2x2Magnify does not, and since computeUint10Distances2x2Magnify is slow im trying something different,
//gonna make game.rps.tridist half size. or... maybe i should just reduce to 512x512 resolution and magnify the canvas. try that for now.
const tridistAve = (trintA,trintB)=>{
	let low10 = ((trintA&1023)+(trintB&1023))>>1;
	//let mid10 = ((trintA&0b11111111110000000000)+(trintB&0b11111111110000000000))>>1;
	let mid10 = ((trintA>>10)+(trintB>>10))<<9;
	//wait, is this gonna be the same as just (trintA+trintB)>>1? Try it...
	//return (trintA+trintB)>>1;
	let high10 = ((trintA>>>20)+(trintB>>20))<<19;
	return high10|mid10|low10;
};


//const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo)=>{
//If you use use a half (2x2) size 2d array, you'd use orthogonal 6 (default 3) and diagonal 8 (default 4),
//then interpolate between after it returns, or 1/4 size (4x4) would use orthogonal 12 diagonal 16, then interpolate.
//If you use bigger orthogonal andOr diagonal than those defaults, you might want to reduce maxDist (default 1019)
//so 1 more hop past that does not overflow uint10,
//and maybe a little less than that so 1023 (the max uint10) can mean havent processed this pixel.
const computeUint10Distances = (tridist, shift, yFrom, yTo, xFrom, xTo, orthogonalDist, diagonalDist, optionalMaxDist)=>{
	const orthogonal = orthogonalDist || 3;
	const diagonal = diagonalDist || 4;
	const maxDistance = optionalMaxDist || 1019;
	const mask10 = 0x3FF;
	const offset = 1 << shift;

	// Precompute bit masks
	const mask1 = mask10;
	const mask2 = mask10 << 10;
	const mask3 = mask10 << 20;

	// First pass: Top-left to bottom-right
	for (let y = yFrom; y < yTo; y++) {
		for (let x = xFrom; x < xTo; x++) {
			//let i = (y << shift) | x;
			let wrappedY = y&SmallSizeMask;
			let wrappedX = x&SmallSizeMask;
			let i = (wrappedY << shift) | wrappedX;

			// Current distances
			let val = tridist[i];
			let dist1 = val & mask1;
			let dist2 = (val >>> 10) & mask10;
			let dist3 = (val >>> 20) & mask10;

			// Neighbor indices
			let i_nw = i - offset - 1;
			let i_n = i - offset;
			let i_w = i - 1;
			let i_ne = i - offset + 1;
			/*
			//wrap around SmallSize X SmallSize aka the 2048 X 2048 that fits 4x4 magnified in the 8192 X 8192 Size X Size
			// Neighbor indices
			let i_nw = (i - offset - 1)&SmallSizeMask;
			let i_n = (i - offset)&SmallSizeMask;
			let i_w = (i - 1)&SmallSizeMask;
			let i_ne = (i - offset + 1)&SmallSizeMask;
			*/
			

			// Ensure indices are within bounds
			// (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
			// Otherwise, add boundary checks here.

			// Distances from neighbors
			let d1_nw = (tridist[i_nw] & mask1) + diagonal;
			let d1_n = (tridist[i_n] & mask1) + orthogonal;
			let d1_w = (tridist[i_w] & mask1) + orthogonal;
			let d1_ne = (tridist[i_ne] & mask1) + diagonal;

			let newDist1 = dist1;
			if (d1_nw < newDist1) newDist1 = d1_nw;
			if (d1_n < newDist1) newDist1 = d1_n;
			if (d1_w < newDist1) newDist1 = d1_w;
			if (d1_ne < newDist1) newDist1 = d1_ne;
			if (newDist1 > maxDistance) newDist1 = maxDistance;

			// Repeat for dist2
			let d2_nw = ((tridist[i_nw] >>> 10) & mask10) + diagonal;
			let d2_n = ((tridist[i_n] >>> 10) & mask10) + orthogonal;
			let d2_w = ((tridist[i_w] >>> 10) & mask10) + orthogonal;
			let d2_ne = ((tridist[i_ne] >>> 10) & mask10) + diagonal;

			let newDist2 = dist2;
			if (d2_nw < newDist2) newDist2 = d2_nw;
			if (d2_n < newDist2) newDist2 = d2_n;
			if (d2_w < newDist2) newDist2 = d2_w;
			if (d2_ne < newDist2) newDist2 = d2_ne;
			if (newDist2 > maxDistance) newDist2 = maxDistance;

			// Repeat for dist3
			let d3_nw = ((tridist[i_nw] >>> 20) & mask10) + diagonal;
			let d3_n = ((tridist[i_n] >>> 20) & mask10) + orthogonal;
			let d3_w = ((tridist[i_w] >>> 20) & mask10) + orthogonal;
			let d3_ne = ((tridist[i_ne] >>> 20) & mask10) + diagonal;

			let newDist3 = dist3;
			if (d3_nw < newDist3) newDist3 = d3_nw;
			if (d3_n < newDist3) newDist3 = d3_n;
			if (d3_w < newDist3) newDist3 = d3_w;
			if (d3_ne < newDist3) newDist3 = d3_ne;
			if (newDist3 > maxDistance) newDist3 = maxDistance;

			// Combine distances back into a single integer
			tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
		}
	}

	// Second pass: Bottom-right to top-left
	for (let y = yTo - 1; y >= yFrom; y--) {
		for (let x = xTo - 1; x >= xFrom; x--) {
			//let i = (y << shift) | x;
			let wrappedY = y&SmallSizeMask;
			let wrappedX = x&SmallSizeMask;
			let i = (wrappedY << shift) | wrappedX;

			// Current distances
			let val = tridist[i];
			let dist1 = val & mask1;
			let dist2 = (val >>> 10) & mask10;
			let dist3 = (val >>> 20) & mask10;

			// Neighbor indices
			let i_se = i + offset + 1;
			let i_s = i + offset;
			let i_e = i + 1;
			let i_sw = i + offset - 1;
			/*//wrap around SmallSize X SmallSize aka the 2048 X 2048 that fits 4x4 magnified in the 8192 X 8192 Size X Size
			// Neighbor indices
			let i_se = (i + offset + 1)&SmallSizeMask;
			let i_s = (i + offset)&SmallSizeMask;
			let i_e = (i + 1)&SmallSizeMask;
			let i_sw = (i + offset - 1)&SmallSizeMask;
			*/
			

			// Ensure indices are within bounds
			// (Assuming yFrom and xFrom are 0 and yTo and xTo are less than the grid size)
			// Otherwise, add boundary checks here.

			// Distances from neighbors
			let d1_se = (tridist[i_se] & mask1) + diagonal;
			let d1_s = (tridist[i_s] & mask1) + orthogonal;
			let d1_e = (tridist[i_e] & mask1) + orthogonal;
			let d1_sw = (tridist[i_sw] & mask1) + diagonal;

			let newDist1 = dist1;
			if (d1_se < newDist1) newDist1 = d1_se;
			if (d1_s < newDist1) newDist1 = d1_s;
			if (d1_e < newDist1) newDist1 = d1_e;
			if (d1_sw < newDist1) newDist1 = d1_sw;
			if (newDist1 > maxDistance) newDist1 = maxDistance;

			// Repeat for dist2
			let d2_se = ((tridist[i_se] >>> 10) & mask10) + diagonal;
			let d2_s = ((tridist[i_s] >>> 10) & mask10) + orthogonal;
			let d2_e = ((tridist[i_e] >>> 10) & mask10) + orthogonal;
			let d2_sw = ((tridist[i_sw] >>> 10) & mask10) + diagonal;

			let newDist2 = dist2;
			if (d2_se < newDist2) newDist2 = d2_se;
			if (d2_s < newDist2) newDist2 = d2_s;
			if (d2_e < newDist2) newDist2 = d2_e;
			if (d2_sw < newDist2) newDist2 = d2_sw;
			if (newDist2 > maxDistance) newDist2 = maxDistance;

			// Repeat for dist3
			let d3_se = ((tridist[i_se] >>> 20) & mask10) + diagonal;
			let d3_s = ((tridist[i_s] >>> 20) & mask10) + orthogonal;
			let d3_e = ((tridist[i_e] >>> 20) & mask10) + orthogonal;
			let d3_sw = ((tridist[i_sw] >>> 20) & mask10) + diagonal;

			let newDist3 = dist3;
			if (d3_se < newDist3) newDist3 = d3_se;
			if (d3_s < newDist3) newDist3 = d3_s;
			if (d3_e < newDist3) newDist3 = d3_e;
			if (d3_sw < newDist3) newDist3 = d3_sw;
			if (newDist3 > maxDistance) newDist3 = maxDistance;

			// Combine distances back into a single integer
			tridist[i] = (newDist3 << 20) | (newDist2 << 10) | newDist1;
		}
	}
};


//this is actually just an approximation of distance, and the angles matter its not exact. not distance squared.
const computeSquaredDistances_approximateAndHexagonsAndFast = (sideBits, voxelYs, voxelXs)=>{
	const side = 1 << sideBits;
	const sideMask = side - 1;
	const size = side * side;
	distSq = distSqArrays[sideBits] || (distSqArrays[sideBits] = new Int32Array(1<<(sideBits<<1))); //reuse
	//const distSq = new Int32Array(size).fill(Infinity);
	distSq.fill(INF);
	
	// Initialize distSq for voxels
	for(let v = 0; v < voxelYs.length; v++){
		const y = voxelYs[v] & sideMask;
		const x = voxelXs[v] & sideMask;
		distSq[(y << sideBits) | x] = 0;
	}
	
	// First Pass: Top-Left to Bottom-Right
	for(let y = 0; y < side; y++){
		for(let x = 0; x < side; x++){
			let i = (y << sideBits) | x;
			if(distSq[i] === 0) continue; // Voxel
			
			// Check top-left
			if(y > 0 && x > 0){
				let j = ((y -1) << sideBits) | (x -1);
				let distance = distSq[j] + 2; // Diagonal distance squared = 2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check top
			if(y > 0){
				let j = ((y -1) << sideBits) | x;
				let distance = distSq[j] + 1; // Vertical distance squared =1
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check top-right
			if(y >0 && x < side -1){
				let j = ((y -1) << sideBits) | (x +1);
				let distance = distSq[j] + 2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
		}
	}
	
	// Second Pass: Bottom-Right to Top-Left
	for(let y = side -1; y >=0; y--){
		for(let x = side -1; x >=0; x--){
			let i = (y << sideBits) | x;
			if(distSq[i] ===0) continue; // Voxel
			
			// Check bottom-right
			if(y < side -1 && x < side -1){
				let j = ((y +1) << sideBits) | (x +1);
				let distance = distSq[j] + 2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check bottom
			if(y < side -1){
				let j = ((y +1) << sideBits) | x;
				let distance = distSq[j] +1; // Vertical distance squared =1
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
			// Check bottom-left
			if(y < side -1 && x >0){
				let j = ((y +1) << sideBits) | (x -1);
				let distance = distSq[j] +2; // Diagonal distance squared =2
				if(distance < distSq[i]){
					distSq[i] = distance;
				}
			}
		}
	}
	
	return distSq; // distance squared from each pixel to nearest voxel.
};

//Opensource MIT licensed by Ben F Rayfield, that returns int array, 1 int per pixel,
//of distance squared to nearest voxel, of sparse voxels, in average constant time per pixel.
//https://github.com/benrayfield/jsutils/blob/master/src/ComputeSquaredDistancesForConstantCostPerPixel.js (that may be an old version as i modify it here)
const computeSquaredDistances_exactButSlow = (sideBits, voxelYs, voxelXs)=>{
  // Ensure sideBits does not exceed 15 to prevent integer overflow in squared distances
  if (sideBits > 15) throw new Error('sideBits must be <= 15');

  const side = 1 << sideBits;		   // Compute side length (e.g., 512 for sideBits=9)
  const size = side * side;			 // Total number of pixels in the grid

  // Initialize presence array: 1 where voxel exists, else 0
  const presence = new Uint8Array(size);
  for (let i = 0; i < voxelYs.length; i++) {
	const y = voxelYs[i];
	const x = voxelXs[i];
	if (y >= 0 && y < side && x >= 0 && x < side) {
	  presence[(y << sideBits) | x] = 1; // Bitwise indexing for faster computation
	}
  }

  const INF = 0x7FFFFFFF;				// Representation of infinity for distances
  const distRow = new Int32Array(size);   // Intermediate distance array after row-wise transform
  const finalDist = new Int32Array(size); // Final distance array after column-wise transform

  // Initialize distRow: 0 for voxels, INF otherwise
  for (let i = 0; i < size; i++) {
	distRow[i] = presence[i] ? 0 : INF;
  }

  /**
   * Row-wise Distance Transform (Two Passes: Forward and Backward)
   * Optimized for cache locality by accessing memory sequentially.
   */
  for (let y = 0; y < side; y++) {
	const rowOffset = y << sideBits; // Compute row offset using bitwise shift (y * side)

	// Forward Pass: Left to Right
	let lastVoxelX = -INF;
	for (let x = 0; x < side; x++) {
	  const idx = rowOffset | x; // Bitwise OR for faster index computation
	  if (presence[idx] === 1) {
		lastVoxelX = x;
		distRow[idx] = 0; // Distance to itself is 0
	  } else if (lastVoxelX !== -INF) {
		const dx = x - lastVoxelX;
		const dxSq = Math.imul(dx, dx); // Accurate computation of dx²
		if (dxSq < distRow[idx]) {
		  distRow[idx] = dxSq; // Update distance if smaller
		}
	  }
	}

	// Backward Pass: Right to Left
	lastVoxelX = -INF;
	for (let x = side - 1; x >= 0; x--) {
	  const idx = rowOffset | x;
	  if (presence[idx] === 1) {
		lastVoxelX = x;
		distRow[idx] = 0;
	  } else if (lastVoxelX !== -INF) {
		const dx = lastVoxelX - x;
		const dxSq = Math.imul(dx, dx);
		if (dxSq < distRow[idx]) {
		  distRow[idx] = dxSq;
		}
	  }
	}
  }

  // Initialize finalDist as a copy of distRow
  for (let i = 0; i < size; i++) {
	finalDist[i] = distRow[i];
  }

  /**
   * Column-wise Distance Transform (Two Passes: Forward and Backward)
   * Implements the Felzenszwalb and Huttenlocher 1D Distance Transform for each column.
   * This ensures accurate computation of squared Euclidean distances.
   */

  /**
   * Helper function to compute the 1D squared distance transform.
   * Implements the algorithm by Felzenszwalb and Huttenlocher (2004).
   * @param {Int32Array} f - The input array representing squared horizontal distances.
   * @param {number} n - The length of the input array.
   * @returns {Int32Array} - The output array representing squared Euclidean distances.
   */
  const distanceTransform1D = (f, n) => {
	const d = new Int32Array(n);
	const v = new Int32Array(n);
	const z = new Float32Array(n + 1);
	let k = 0;
	v[0] = 0;
	z[0] = -Infinity;
	z[1] = +Infinity;

	for (let q = 1; q < n; q++) {
	  let s;
	  do {
		const i = v[k];
		// Compute the intersection point between the parabola at i and q
		s = ((f[q] + Math.imul(q, q)) - (f[i] + Math.imul(i, i))) / (2 * q - 2 * i);
		if (s <= z[k]) {
		  k--;
		} else {
		  break;
		}
	  } while (k >= 0);

	  k++;
	  v[k] = q;
	  z[k] = s;
	  z[k + 1] = +Infinity;
	}

	k = 0;
	for (let q = 0; q < n; q++) {
	  while (z[k + 1] < q) {
		k++;
	  }
	  const i = v[k];
	  d[q] = Math.imul(q - i, q - i) + f[i];
	}

	return d;
  };

  // Perform column-wise distance transform using the 1D distance transform
  for (let x = 0; x < side; x++) {
	// Extract the column's row-wise distances
	const f = new Int32Array(side);
	for (let y = 0; y < side; y++) {
	  const idx = (y << sideBits) | x;
	  f[y] = distRow[idx];
	}

	// Compute the 1D distance transform for the column
	const dt = distanceTransform1D(f, side);

	// Update the finalDist array with the computed distances
	for (let y = 0; y < side; y++) {
	  const idx = (y << sideBits) | x;
	  finalDist[idx] = dt[y];
	}
  }

  return finalDist; // Return the final squared distance array
};

var createPaintControls = ()=>{
	let html = '';
	let color6 = game.paintColor.p;
	color6 = randInt(Colors)
	let c = IColorStr(color6);
	let foregroundColor = randInt(Colors);
	for(let color=Colors-1; color>=0; color--){
		html += '<input type=button style="background-color:'+IColorStr(color)+'" onclick="NS.game.getOb().setPaintColor('+color+');"></input>';
		if(color==48) html += ' <input type=button id=topBrushPrototype style="background-color:'+c+';color:'+IColorStr(foregroundColor)+'" value="?" onclick="NS.game.getOb().setPaintColor(randInt(Colors));"></input>';
		//if(color==32) html += '<br>'; //32 colors per row
		if(color==16 || color==32 || color==48) html += '<br>'; //16 colors per row
	}
	//html += ' <input type=button id=topBrushPrototype style="background-color:'+c+';color:'+IColorStr(foregroundColor)+'" value="RAND" onclick="NS.game.getOb().setPaintColor(randInt(Colors));"></input>';
	document.getElementById('paintControlsDiv').innerHTML = html;
	updatePaintControls();
};

var updatePaintControls = ()=>{
	//just change the displayed paint color, size, etc, as its gotta display
	//what color and paintbrush size you'd use, if any is selected?
	let dom = document.getElementById('topBrushPrototype');
	let c = IColorStr(game.paintColor.p);
	let foregroundColor = IColorStr(randInt(Colors));
	dom.innerHTML = c;
	dom.style['background-color'] = c;
	dom.style['color'] = foregroundColor;
	let paintControlsDiv = document.getElementById('paintControlsDiv');
	paintControlsDiv.style.color = c;
	paintControlsDiv.style['background-color'] = c;
	//let topFewRowsOfControls = document.getElementById('topFewRowsOfControls');
	//topFewRowsOfControls.style['background-color'] = c;
};

window.onload = ()=>{
	createPaintControls();
	game.onTextareaResize(); //change varPathTxt width to mainTextarea width the first time
	timeStarted = time();
	doGraphicsDtAgeByterectAndMore();
	console.log('TODO add test cases to game.qvox add qvoxels in different orders to make sure total poten (qvox returns change in poten) and array contents are the same regardless of order. Its a very tight constraint cuz theres factorial number of possible orders so i can just pick at random and theyll have to come to the same game state, so if any tiny thing is wrong it will likely come up in that. Remember to use zThickness as multiple of 6<<qlev as the funcs bilinearPotentialEnergy and bilinearMult always return an integer when their params are all (not too big) multiples of 6.');
};

Controls.mouseY = game.Y.p; //so game.sparseUpdate() doesnt remove objects in view when mouse starts at (0,0) in 16million**2 space.
Controls.mouseX = game.X.p;
console.log('game.gobs.length=='+game.gobs.length);

</script>
</head>
<body>
<div id=leftControls style="z-index:10;opacity:.7">
	<label style="color:white"><b>
		<div id=topFewRowsOfControls>
			
			<table style="float:left"><tr><td>
				<label style="float:left;background-color:black">MENU:&nbsp;</label>
				<input type=button value="restart game" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
				<input type=button value="restart level editor" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
				<input type=button value="play online" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
				<input type=button value="About" onclick="alert('Ben F Rayfield offers Blob Monsters Game to everyone under opensource MIT license. As of 2025-2 you can get some versions (its just a html file) at https://github.com/benrayfield/jsutils/tree/master/src/blobMonstersGame and play it at https://humanai.net/experiments/blobMonstersGame.html aka https://tinyurl.com/blobmonster . Its incomplete, but... The New empty universe button doesnt just start playing a new game. It starts building a game like programming and content creation. And at the same time it plays the game. If you just want to play some game, thats the restart last minigame button. TODO alot of thats not working yet or is not hooked into this code but is somewhere else todo. Quicksave and Quickload are in the game of making possible games and playing them, of this limited kind where you divide it into small javascript functions of vector to list of int voxels.');" style="float:left">
				<input type=button value="Delete Cookies" onclick="alert('TODO');" style="float:left">
				<input type=button style="float:left"></input>
				<input type=button style="float:left"></input>
				<input type=button style="float:left"></input>
				<input type=button style="float:left"></input>
				<input type=button style="float:left"></input>
			</td></tr><tr><td>
				<label style="float:left;background-color:black">OPEN:&nbsp;&nbsp;</label>
				<input type=button value="QuickLoad (cookie) 1" onclick="alert('TODO');" style="float:left">
				<input type=button value="2" onclick="alert('TODO');" style="float:left">
				<input type=button value="3" onclick="alert('TODO');" style="float:left">
				<input type=button value="4" onclick="alert('TODO');" style="float:left">
				<input type=button value="5" onclick="alert('TODO');" style="float:left">
				<input type=button value="6" onclick="alert('TODO');" style="float:left">
				<input type=button value="7" onclick="alert('TODO');" style="float:left">
				<input type=button value="8" onclick="alert('TODO');" style="float:left">
				<input type=button value="9" onclick="alert('TODO');" style="float:left">
				<input type=button value="from (text box)" onclick="alert('TODO');" style="float:left">
				<input type=button value="Open (file)" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
			</td></tr><tr><td>
				<label style="float:left;background-color:black">SAVE:&nbsp;&nbsp;&nbsp;</label>
				<input type=button value="QuickSave (cookie) 1" onclick="alert('TODO');" style="float:left">
				<input type=button value="2" onclick="alert('TODO');" style="float:left">
				<input type=button value="3" onclick="alert('TODO');" style="float:left">
				<input type=button value="4" onclick="alert('TODO');" style="float:left">
				<input type=button value="5" onclick="alert('TODO');" style="float:left">
				<input type=button value="6" onclick="alert('TODO');" style="float:left">
				<input type=button value="7" onclick="alert('TODO');" style="float:left">
				<input type=button value="8" onclick="alert('TODO');" style="float:left">
				<input type=button value="9" onclick="alert('TODO');" style="float:left">
				<input type=button value="  to   (text box)" onclick="setVarPathTxt(''); document.getElementById('mainTextarea').value = State();" style="float:left">
				<input type=button value="Save (file)" onclick="alert('this doesnt work yet. See V tree such as V.testnet.toMap()');" style="float:left">
			</td></tr><tr><td>
				<label style="float:left;background-color:black">TOOL:&nbsp;&nbsp;&nbsp;</label>
				<div id=paintControlsDiv style="padding:2px;float:left"></div>
			</td></tr><tr><td>
				<label style="float:left;background-color:black">CODE:&nbsp;</label>
				<input type=text id=varPathTxt style="background-color:black;color:white"></input><br>
			</td></tr><tr><td>
				<textarea id=mainTextarea onmouseenter="game.onTextareaResize();" onmouseleave="game.onTextareaResize();" onInput="game.onTextareaInput(this.value);" style="float:left;background-color:black;color:white;position:static" rows=50 cols=70>testing</textarea><br>
			</td></tr></table>
			
		</div>
		<br><br>
		<div id=selectedGobVarsDiv style="position:absolute;right:0;bottom:0"></div>
	</b></label>
</div>
</body>
</html>

